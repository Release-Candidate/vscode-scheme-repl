/*
 * SPDX-FileCopyrightText:  Copyright 2023 Roland Csaszar
 * SPDX-License-Identifier: MIT
 *
 * Project:  vscode-scheme-repl
 * File:     functionDocumentation.ts
 * Date:     23.5.2023
 *
 * ==============================================================================
 * Autogenerated by the script `../generate_function_documentation.ts`, from
 * https://cisco.github.io/ChezScheme/csug9.5/summary.html
 * DO NOT EDIT!
 */

/* eslint-disable max-lines */

/**
 * The type of a identifier.
 */
export type IdentifierType =
    | "syntax"
    | "module"
    | "procedure"
    | "thread parameter"
    | "global parameter"
    | "Error: unknown";

/**
 * The object to save the data of a function documentation to.
 */
export type FunctionDoc = {
    name: string;
    endParen: boolean;
    params: string[];
    type: IdentifierType;
    url: URL;
    description: string;
};

export const functionDocs: FunctionDoc[] = [
    {
        name: "'",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s2"),
        description: `**syntax**: \`(quote \`*obj*\`)\`
**syntax**: \`'\`*obj*
**returns: ***obj*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`'\`*obj* is equivalent to \`(quote \`*obj*\`)\`. The abbreviated form is converted into the longer form by the Scheme reader (see \`read\`).
`
    },
    {
        name: "`",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s5"),
        description: `**syntax**: \`(quasiquote \`*obj*\` ...)\`
**syntax**: \`\`\`*obj*
**syntax**: \`(unquote \`*obj*\` ...)\`
**syntax**: \`,\`*obj*
**syntax**: \`(unquote-splicing \`*obj*\` ...)\`
**syntax**: \`,@\`*obj*
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`\`\`*obj* is equivalent to \`(quasiquote \`*obj*\`)\`, \`,\`*obj* is equivalent to \`(unquote \`*obj*\`)\`, and \`,@\`*obj* is equivalent to \`(unquote-splicing \`*obj*\`)\`. The abbreviated forms are converted into the longer forms by the Scheme reader (see \`read\`).

\`quasiquote\` is similar to \`quote\`, but it allows parts of the quoted text to be "unquoted." Within a \`quasiquote\` expression, \`unquote\` and \`unquote-splicing\` subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each \`unquote\` subform is inserted into the output in place of the \`unquote\` form, while the value of each \`unquote-splicing\` subform is spliced into the surrounding list or vector structure. \`unquote\` and \`unquote-splicing\` are valid only within \`quasiquote\` expressions.

\`quasiquote\` expressions may be nested, with each \`quasiquote\` introducing a new level of quotation and each \`unquote\` or \`unquote-splicing\` taking away a level of quotation. An expression nested within \`quasiquote\` expressions must be within \`unquote\` or \`unquote-splicing\` expressions to be evaluated.

\`\`(+ 2 3) \`=>\` (+ 2 3) \`
\` \`
\` \`(+ 2 ,(* 3 4)) \`=>\` (+ 2 12)\`
\` \`(a b (,(+ 2 3) c) d) \`=>\` (a b (5 c) d)\`
\` \`(a b ,(reverse '(c d e)) f g) \`=>\` (a b (e d c) f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a . ,b)) \`=>\` (1 . 2) \`
\` \`
\` \`(+ ,@(cdr '(* 2 3))) \`=>\` (+ 2 3)\`
\` \`(a b ,@(reverse '(c d e)) f g) \`=>\` (a b e d c f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a ,@b)) \`=>\` (1 . 2)\`
\` \`#(,@(list 1 2 3)) \`=>\` #(1 2 3) \`
\` \`
\` '\`,(cons 'a 'b) \`=>\` \`,(cons 'a 'b)\`
\` \`',(cons 'a 'b) \`=>\` '(a . b)\`

\`unquote\` and \`unquote-splicing\` forms with zero or more than one subform are valid only in splicing (list or vector) contexts. \`(unquote \`*obj*\` ...)\` is equivalent to \`(unquote \`*obj*\`) ...\`, and \`(unquote-splicing \`*obj*\` ...)\` is equivalent to \`(unquote-splicing \`*obj*\`) ...\`. These forms are primarily useful as intermediate forms in the output of the \`quasiquote\` expander. They support certain useful nested quasiquotation idioms [], such as \`,@,@\`, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated \`quasiquote\` expression.

\`\`(a (unquote) b) \`=>\` (a b)\`
\` \`(a (unquote (+ 3 3)) b) \`=>\` (a 6 b)\`
\` \`(a (unquote (+ 3 3) (* 3 3)) b) \`=>\` (a 6 9 b) \`
\` \`
\` (let ([x '(m n)]) \`\`(a ,@,@x f)) \`=>\` \`(a (unquote-splicing m n) f)\`
\` (let ([x '(m n)])\`
\`   (eval \`(let ([m '(b c)] [n '(d e)]) \`(a ,@,@x f))\`
\`         (environment '(rnrs)))) \`=>\` (a b c d e f)\`

\`unquote\` and \`unquote-splicing\` are auxiliary keywords for \`quasiquote\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: ",",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s5"),
        description: `**syntax**: \`(quasiquote \`*obj*\` ...)\`
**syntax**: \`\`\`*obj*
**syntax**: \`(unquote \`*obj*\` ...)\`
**syntax**: \`,\`*obj*
**syntax**: \`(unquote-splicing \`*obj*\` ...)\`
**syntax**: \`,@\`*obj*
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`\`\`*obj* is equivalent to \`(quasiquote \`*obj*\`)\`, \`,\`*obj* is equivalent to \`(unquote \`*obj*\`)\`, and \`,@\`*obj* is equivalent to \`(unquote-splicing \`*obj*\`)\`. The abbreviated forms are converted into the longer forms by the Scheme reader (see \`read\`).

\`quasiquote\` is similar to \`quote\`, but it allows parts of the quoted text to be "unquoted." Within a \`quasiquote\` expression, \`unquote\` and \`unquote-splicing\` subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each \`unquote\` subform is inserted into the output in place of the \`unquote\` form, while the value of each \`unquote-splicing\` subform is spliced into the surrounding list or vector structure. \`unquote\` and \`unquote-splicing\` are valid only within \`quasiquote\` expressions.

\`quasiquote\` expressions may be nested, with each \`quasiquote\` introducing a new level of quotation and each \`unquote\` or \`unquote-splicing\` taking away a level of quotation. An expression nested within \`quasiquote\` expressions must be within \`unquote\` or \`unquote-splicing\` expressions to be evaluated.

\`\`(+ 2 3) \`=>\` (+ 2 3) \`
\` \`
\` \`(+ 2 ,(* 3 4)) \`=>\` (+ 2 12)\`
\` \`(a b (,(+ 2 3) c) d) \`=>\` (a b (5 c) d)\`
\` \`(a b ,(reverse '(c d e)) f g) \`=>\` (a b (e d c) f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a . ,b)) \`=>\` (1 . 2) \`
\` \`
\` \`(+ ,@(cdr '(* 2 3))) \`=>\` (+ 2 3)\`
\` \`(a b ,@(reverse '(c d e)) f g) \`=>\` (a b e d c f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a ,@b)) \`=>\` (1 . 2)\`
\` \`#(,@(list 1 2 3)) \`=>\` #(1 2 3) \`
\` \`
\` '\`,(cons 'a 'b) \`=>\` \`,(cons 'a 'b)\`
\` \`',(cons 'a 'b) \`=>\` '(a . b)\`

\`unquote\` and \`unquote-splicing\` forms with zero or more than one subform are valid only in splicing (list or vector) contexts. \`(unquote \`*obj*\` ...)\` is equivalent to \`(unquote \`*obj*\`) ...\`, and \`(unquote-splicing \`*obj*\` ...)\` is equivalent to \`(unquote-splicing \`*obj*\`) ...\`. These forms are primarily useful as intermediate forms in the output of the \`quasiquote\` expander. They support certain useful nested quasiquotation idioms [], such as \`,@,@\`, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated \`quasiquote\` expression.

\`\`(a (unquote) b) \`=>\` (a b)\`
\` \`(a (unquote (+ 3 3)) b) \`=>\` (a 6 b)\`
\` \`(a (unquote (+ 3 3) (* 3 3)) b) \`=>\` (a 6 9 b) \`
\` \`
\` (let ([x '(m n)]) \`\`(a ,@,@x f)) \`=>\` \`(a (unquote-splicing m n) f)\`
\` (let ([x '(m n)])\`
\`   (eval \`(let ([m '(b c)] [n '(d e)]) \`(a ,@,@x f))\`
\`         (environment '(rnrs)))) \`=>\` (a b c d e f)\`

\`unquote\` and \`unquote-splicing\` are auxiliary keywords for \`quasiquote\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: ",@",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s5"),
        description: `**syntax**: \`(quasiquote \`*obj*\` ...)\`
**syntax**: \`\`\`*obj*
**syntax**: \`(unquote \`*obj*\` ...)\`
**syntax**: \`,\`*obj*
**syntax**: \`(unquote-splicing \`*obj*\` ...)\`
**syntax**: \`,@\`*obj*
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`\`\`*obj* is equivalent to \`(quasiquote \`*obj*\`)\`, \`,\`*obj* is equivalent to \`(unquote \`*obj*\`)\`, and \`,@\`*obj* is equivalent to \`(unquote-splicing \`*obj*\`)\`. The abbreviated forms are converted into the longer forms by the Scheme reader (see \`read\`).

\`quasiquote\` is similar to \`quote\`, but it allows parts of the quoted text to be "unquoted." Within a \`quasiquote\` expression, \`unquote\` and \`unquote-splicing\` subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each \`unquote\` subform is inserted into the output in place of the \`unquote\` form, while the value of each \`unquote-splicing\` subform is spliced into the surrounding list or vector structure. \`unquote\` and \`unquote-splicing\` are valid only within \`quasiquote\` expressions.

\`quasiquote\` expressions may be nested, with each \`quasiquote\` introducing a new level of quotation and each \`unquote\` or \`unquote-splicing\` taking away a level of quotation. An expression nested within \`quasiquote\` expressions must be within \`unquote\` or \`unquote-splicing\` expressions to be evaluated.

\`\`(+ 2 3) \`=>\` (+ 2 3) \`
\` \`
\` \`(+ 2 ,(* 3 4)) \`=>\` (+ 2 12)\`
\` \`(a b (,(+ 2 3) c) d) \`=>\` (a b (5 c) d)\`
\` \`(a b ,(reverse '(c d e)) f g) \`=>\` (a b (e d c) f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a . ,b)) \`=>\` (1 . 2) \`
\` \`
\` \`(+ ,@(cdr '(* 2 3))) \`=>\` (+ 2 3)\`
\` \`(a b ,@(reverse '(c d e)) f g) \`=>\` (a b e d c f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a ,@b)) \`=>\` (1 . 2)\`
\` \`#(,@(list 1 2 3)) \`=>\` #(1 2 3) \`
\` \`
\` '\`,(cons 'a 'b) \`=>\` \`,(cons 'a 'b)\`
\` \`',(cons 'a 'b) \`=>\` '(a . b)\`

\`unquote\` and \`unquote-splicing\` forms with zero or more than one subform are valid only in splicing (list or vector) contexts. \`(unquote \`*obj*\` ...)\` is equivalent to \`(unquote \`*obj*\`) ...\`, and \`(unquote-splicing \`*obj*\` ...)\` is equivalent to \`(unquote-splicing \`*obj*\`) ...\`. These forms are primarily useful as intermediate forms in the output of the \`quasiquote\` expander. They support certain useful nested quasiquotation idioms [], such as \`,@,@\`, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated \`quasiquote\` expression.

\`\`(a (unquote) b) \`=>\` (a b)\`
\` \`(a (unquote (+ 3 3)) b) \`=>\` (a 6 b)\`
\` \`(a (unquote (+ 3 3) (* 3 3)) b) \`=>\` (a 6 9 b) \`
\` \`
\` (let ([x '(m n)]) \`\`(a ,@,@x f)) \`=>\` \`(a (unquote-splicing m n) f)\`
\` (let ([x '(m n)])\`
\`   (eval \`(let ([m '(b c)] [n '(d e)]) \`(a ,@,@x f))\`
\`         (environment '(rnrs)))) \`=>\` (a b c d e f)\`

\`unquote\` and \`unquote-splicing\` are auxiliary keywords for \`quasiquote\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "=>",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s16"),
        description: `**syntax**: \`else\`
**syntax**: \`=>\`
**libraries: **\`(rnrs base)\`, \`(rnrs exceptions)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`cond\`. Both also serve as auxiliary keywords for \`guard\`, and \`else\` also serves as an auxiliary keyword for \`case\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "_",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s26"),
        description: `**syntax**: \`_\`
**syntax**: \`...\`
**libraries: **\`(rnrs base)\`, \`(rnrs syntax-case)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`syntax-rules\`, \`identifier-syntax\`, and \`syntax-case\`. The second ( \`...\` ) is also an auxiliary keyword for \`syntax\` and \`quasisyntax\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "...",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s26"),
        description: `**syntax**: \`_\`
**syntax**: \`...\`
**libraries: **\`(rnrs base)\`, \`(rnrs syntax-case)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`syntax-rules\`, \`identifier-syntax\`, and \`syntax-case\`. The second ( \`...\` ) is also an auxiliary keyword for \`syntax\` and \`quasisyntax\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "#'",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s33"),
        description: `**syntax**: \`(syntax \`*template*\`)\`
**syntax**: \`#'\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#'\`*template* is equivalent to \`(syntax \`*template*\`)\`. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.

A \`syntax\` expression is like a \`quote\` expression except that the values of pattern variables appearing within *template* are inserted into *template*, and contextual information associated both with the input and with the template is retained in the output to support lexical scoping. A \`syntax\` *template* is identical to a \`syntax-rules\` *template* and is treated similarly.

List and vector structures within the template become true lists or vectors (suitable for direct application of list or vector operations, like \`map\` or \`vector-ref\`) to the extent that the list or vector structures must be copied to insert the values of pattern variables, and empty lists are never wrapped. For example, \`#'(x ...)\`, \`#'(a b c)\`, \`#'()\` are all lists if \`x\`, \`a\`, \`b\`, and \`c\` are pattern variables.

The definition of \`or\` below is equivalent to the one given in Section  except that it employs \`syntax-case\` and \`syntax\` in place of \`syntax-rules\`.

\`(define-syntax or\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(_) #'#f]\`
\`       [(_ e) #'e]\`
\`       [(_ e1 e2 e3 ...)\`
\`        #'(let ([t e1]) (if t t (or e2 e3 ...)))])))\`
`
    },
    {
        name: "#`",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s40"),
        description: `**syntax**: \`(quasisyntax \`*template*\` ...)\`
**syntax**: \`#\`\`*template*
**syntax**: \`(unsyntax \`*template*\` ...)\`
**syntax**: \`#,\`*template*
**syntax**: \`(unsyntax-splicing \`*template*\` ...)\`
**syntax**: \`#,@\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#\`\`*template* is equivalent to \`(quasisyntax \`*template*\`)\`, while \`#,\`*template* is equivalent to \`(unsyntax \`*template*\`)\`, and \`#,@\`*template* to \`(unsyntax-splicing \`*template*\`)\`. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.

\`quasisyntax\` is similar to \`syntax\`, but it allows parts of the quoted text to be evaluated, in a manner similar to \`quasiquote\` (Section ).

Within a \`quasisyntax\` *template*, subforms of \`unsyntax\` and \`unsyntax-splicing\` forms are evaluated, and everything else is treated as ordinary template material, as with \`syntax\`. The value of each \`unsyntax\` subform is inserted into the output in place of the \`unsyntax\` form, while the value of each \`unsyntax-splicing\` subform is spliced into the surrounding list or vector structure. \`unsyntax\` and \`unsyntax-splicing\` are valid only within \`quasisyntax\` expressions.

\`quasisyntax\` expressions may be nested, with each \`quasisyntax\` introducing a new level of syntax quotation and each \`unsyntax\` or \`unsyntax-splicing\` taking away a level of quotation. An expression nested within \`quasisyntax\` expressions must be within \`unsyntax\` or \`unsyntax-splicing\` expressions to be evaluated.
`
    },
    {
        name: "#,",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s40"),
        description: `**syntax**: \`(quasisyntax \`*template*\` ...)\`
**syntax**: \`#\`\`*template*
**syntax**: \`(unsyntax \`*template*\` ...)\`
**syntax**: \`#,\`*template*
**syntax**: \`(unsyntax-splicing \`*template*\` ...)\`
**syntax**: \`#,@\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#\`\`*template* is equivalent to \`(quasisyntax \`*template*\`)\`, while \`#,\`*template* is equivalent to \`(unsyntax \`*template*\`)\`, and \`#,@\`*template* to \`(unsyntax-splicing \`*template*\`)\`. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.

\`quasisyntax\` is similar to \`syntax\`, but it allows parts of the quoted text to be evaluated, in a manner similar to \`quasiquote\` (Section ).

Within a \`quasisyntax\` *template*, subforms of \`unsyntax\` and \`unsyntax-splicing\` forms are evaluated, and everything else is treated as ordinary template material, as with \`syntax\`. The value of each \`unsyntax\` subform is inserted into the output in place of the \`unsyntax\` form, while the value of each \`unsyntax-splicing\` subform is spliced into the surrounding list or vector structure. \`unsyntax\` and \`unsyntax-splicing\` are valid only within \`quasisyntax\` expressions.

\`quasisyntax\` expressions may be nested, with each \`quasisyntax\` introducing a new level of syntax quotation and each \`unsyntax\` or \`unsyntax-splicing\` taking away a level of quotation. An expression nested within \`quasisyntax\` expressions must be within \`unsyntax\` or \`unsyntax-splicing\` expressions to be evaluated.
`
    },
    {
        name: "#,@",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s40"),
        description: `**syntax**: \`(quasisyntax \`*template*\` ...)\`
**syntax**: \`#\`\`*template*
**syntax**: \`(unsyntax \`*template*\` ...)\`
**syntax**: \`#,\`*template*
**syntax**: \`(unsyntax-splicing \`*template*\` ...)\`
**syntax**: \`#,@\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#\`\`*template* is equivalent to \`(quasisyntax \`*template*\`)\`, while \`#,\`*template* is equivalent to \`(unsyntax \`*template*\`)\`, and \`#,@\`*template* to \`(unsyntax-splicing \`*template*\`)\`. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.

\`quasisyntax\` is similar to \`syntax\`, but it allows parts of the quoted text to be evaluated, in a manner similar to \`quasiquote\` (Section ).

Within a \`quasisyntax\` *template*, subforms of \`unsyntax\` and \`unsyntax-splicing\` forms are evaluated, and everything else is treated as ordinary template material, as with \`syntax\`. The value of each \`unsyntax\` subform is inserted into the output in place of the \`unsyntax\` form, while the value of each \`unsyntax-splicing\` subform is spliced into the surrounding list or vector structure. \`unsyntax\` and \`unsyntax-splicing\` are valid only within \`quasisyntax\` expressions.

\`quasisyntax\` expressions may be nested, with each \`quasisyntax\` introducing a new level of syntax quotation and each \`unsyntax\` or \`unsyntax-splicing\` taking away a level of quotation. An expression nested within \`quasisyntax\` expressions must be within \`unsyntax\` or \`unsyntax-splicing\` expressions to be evaluated.
`
    },
    {
        name: "#%",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s109"),
        description: `**syntax**: \`($primitive \`*variable*\`)\`
**syntax**: \`#%\`*variable*
**syntax**: \`($primitive 2 \`*variable*\`)\`
**syntax**: \`#2%\`*variable*
**syntax**: \`($primitive 3 \`*variable*\`)\`
**syntax**: \`#3%\`*variable*
**returns: **the primitive value for *variable*
**libraries: **\`(chezscheme)\`

*variable* must name a primitive procedure. The \`$primitive\` syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive.

The expression \`($primitive \`*variable*\`)\` may be abbreviated as \`#%\`*variable*. The reader expands \`#%\` followed by an object into a \`$primitive\` expression, much as it expands \`'\`*object* into a \`quote\` expression.

If a \`2\` or \`3\` appears in the form or between the \`#\` and \`%\` in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the \`optimize-level\` parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application.

\`(#%car '(a b c)) \`=>\` a\`
\` (let ([car cdr]) (car '(a b c))) \`=>\` (b c)\`
\` (let ([car cdr]) (#%car '(a b c))) \`=>\` a\`
\` (begin (set! car cdr) (#%car '(a b c))) \`=>\` a\`
`
    },
    {
        name: "#2%",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s109"),
        description: `**syntax**: \`($primitive \`*variable*\`)\`
**syntax**: \`#%\`*variable*
**syntax**: \`($primitive 2 \`*variable*\`)\`
**syntax**: \`#2%\`*variable*
**syntax**: \`($primitive 3 \`*variable*\`)\`
**syntax**: \`#3%\`*variable*
**returns: **the primitive value for *variable*
**libraries: **\`(chezscheme)\`

*variable* must name a primitive procedure. The \`$primitive\` syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive.

The expression \`($primitive \`*variable*\`)\` may be abbreviated as \`#%\`*variable*. The reader expands \`#%\` followed by an object into a \`$primitive\` expression, much as it expands \`'\`*object* into a \`quote\` expression.

If a \`2\` or \`3\` appears in the form or between the \`#\` and \`%\` in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the \`optimize-level\` parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application.

\`(#%car '(a b c)) \`=>\` a\`
\` (let ([car cdr]) (car '(a b c))) \`=>\` (b c)\`
\` (let ([car cdr]) (#%car '(a b c))) \`=>\` a\`
\` (begin (set! car cdr) (#%car '(a b c))) \`=>\` a\`
`
    },
    {
        name: "#3%",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s109"),
        description: `**syntax**: \`($primitive \`*variable*\`)\`
**syntax**: \`#%\`*variable*
**syntax**: \`($primitive 2 \`*variable*\`)\`
**syntax**: \`#2%\`*variable*
**syntax**: \`($primitive 3 \`*variable*\`)\`
**syntax**: \`#3%\`*variable*
**returns: **the primitive value for *variable*
**libraries: **\`(chezscheme)\`

*variable* must name a primitive procedure. The \`$primitive\` syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive.

The expression \`($primitive \`*variable*\`)\` may be abbreviated as \`#%\`*variable*. The reader expands \`#%\` followed by an object into a \`$primitive\` expression, much as it expands \`'\`*object* into a \`quote\` expression.

If a \`2\` or \`3\` appears in the form or between the \`#\` and \`%\` in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the \`optimize-level\` parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application.

\`(#%car '(a b c)) \`=>\` a\`
\` (let ([car cdr]) (car '(a b c))) \`=>\` (b c)\`
\` (let ([car cdr]) (#%car '(a b c))) \`=>\` a\`
\` (begin (set! car cdr) (#%car '(a b c))) \`=>\` a\`
`
    },
    {
        name: "($primitive ",
        endParen: true,
        params: ["variable"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s109"),
        description: `**syntax**: \`($primitive \`*variable*\`)\`
**syntax**: \`#%\`*variable*
**syntax**: \`($primitive 2 \`*variable*\`)\`
**syntax**: \`#2%\`*variable*
**syntax**: \`($primitive 3 \`*variable*\`)\`
**syntax**: \`#3%\`*variable*
**returns: **the primitive value for *variable*
**libraries: **\`(chezscheme)\`

*variable* must name a primitive procedure. The \`$primitive\` syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive.

The expression \`($primitive \`*variable*\`)\` may be abbreviated as \`#%\`*variable*. The reader expands \`#%\` followed by an object into a \`$primitive\` expression, much as it expands \`'\`*object* into a \`quote\` expression.

If a \`2\` or \`3\` appears in the form or between the \`#\` and \`%\` in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the \`optimize-level\` parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application.

\`(#%car '(a b c)) \`=>\` a\`
\` (let ([car cdr]) (car '(a b c))) \`=>\` (b c)\`
\` (let ([car cdr]) (#%car '(a b c))) \`=>\` a\`
\` (begin (set! car cdr) (#%car '(a b c))) \`=>\` a\`
`
    },
    {
        name: "($primitive 2 ",
        endParen: true,
        params: ["variable"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s109"),
        description: `**syntax**: \`($primitive \`*variable*\`)\`
**syntax**: \`#%\`*variable*
**syntax**: \`($primitive 2 \`*variable*\`)\`
**syntax**: \`#2%\`*variable*
**syntax**: \`($primitive 3 \`*variable*\`)\`
**syntax**: \`#3%\`*variable*
**returns: **the primitive value for *variable*
**libraries: **\`(chezscheme)\`

*variable* must name a primitive procedure. The \`$primitive\` syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive.

The expression \`($primitive \`*variable*\`)\` may be abbreviated as \`#%\`*variable*. The reader expands \`#%\` followed by an object into a \`$primitive\` expression, much as it expands \`'\`*object* into a \`quote\` expression.

If a \`2\` or \`3\` appears in the form or between the \`#\` and \`%\` in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the \`optimize-level\` parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application.

\`(#%car '(a b c)) \`=>\` a\`
\` (let ([car cdr]) (car '(a b c))) \`=>\` (b c)\`
\` (let ([car cdr]) (#%car '(a b c))) \`=>\` a\`
\` (begin (set! car cdr) (#%car '(a b c))) \`=>\` a\`
`
    },
    {
        name: "($primitive 3 ",
        endParen: true,
        params: ["variable"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s109"),
        description: `**syntax**: \`($primitive \`*variable*\`)\`
**syntax**: \`#%\`*variable*
**syntax**: \`($primitive 2 \`*variable*\`)\`
**syntax**: \`#2%\`*variable*
**syntax**: \`($primitive 3 \`*variable*\`)\`
**syntax**: \`#3%\`*variable*
**returns: **the primitive value for *variable*
**libraries: **\`(chezscheme)\`

*variable* must name a primitive procedure. The \`$primitive\` syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive.

The expression \`($primitive \`*variable*\`)\` may be abbreviated as \`#%\`*variable*. The reader expands \`#%\` followed by an object into a \`$primitive\` expression, much as it expands \`'\`*object* into a \`quote\` expression.

If a \`2\` or \`3\` appears in the form or between the \`#\` and \`%\` in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the \`optimize-level\` parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application.

\`(#%car '(a b c)) \`=>\` a\`
\` (let ([car cdr]) (car '(a b c))) \`=>\` (b c)\`
\` (let ([car cdr]) (#%car '(a b c))) \`=>\` a\`
\` (begin (set! car cdr) (#%car '(a b c))) \`=>\` a\`
`
    },
    {
        name: "$system",
        endParen: false,
        params: [""],
        type: "module",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s35"),
        description: `**module**: \`$system\`
**libraries: **\`(chezscheme)\`

\`$system\` contains all user-visible top-level bindings built into along with various undocumented system bindings.
`
    },
    {
        name: "&assertion",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s21"),
        description: `**syntax**: \`&assertion\`
**procedure**: \`(make-assertion-violation)\`
**returns: **a condition of type \`&assertion\`
**procedure**: \`(assertion-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&assertion\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

This condition type indicates a specific violation in which the program has passed the wrong number or types of arguments to a procedure. This condition type might be defined as follows.

\`(define-condition-type &assertion &violation\`
\`   make-assertion-violation assertion-violation?)\`
`
    },
    {
        name: "&condition",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s13"),
        description: `**syntax**: \`&condition\`
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

\`&condition\` is a record-type name (Chapter ) and the root of the condition-type hierarchy. All simple condition types are extensions of this type, and all conditions, whether simple or compound, are considered instances of this type.
`
    },
    {
        name: "&continuation",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s6"),
        description: `**syntax**: \`&continuation\`
**procedure**: \`(make-continuation-condition \`*continuation*\`)\`
**returns: **a condition of type \`&continuation\`
**procedure**: \`(continuation-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&continuation\`, \`#f\` otherwise
**procedure**: \`(condition-continuation \`*condition*\`)\`
**returns: **the contents of *condition*'s \`continuation\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition to indicate the current continuation at the point where the exception described by the condition occurred. The continuation of a failed \`assert\` or a call to \`assertion-violation\`, \`assertion-violationf\`, \`error\`, \`errorf\`, or \`syntax-error\` is now included via this condition type in the conditions passed to \`raise\`. The \`continuation\` argument should be a continuation. This condition type might be defined as follows.

\`(define-condition-type &continuation &condition\`
\`   make-continuation-condition continuation-condition?\`
\`   (continuation condition-continuation))\`
`
    },
    {
        name: "&error",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s22"),
        description: `**syntax**: \`&error\`
**procedure**: \`(make-error)\`
**returns: **a condition of type \`&error\`
**procedure**: \`(error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&error\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that an error has occurred with the program's interaction with its operating environment, such as the failure of an attempt to open a file. It is not used to describe situations in which an error in the program has been detected. This condition type might be defined as follows.

\`(define-condition-type &error &serious\`
\`   make-error error?)\`
`
    },
    {
        name: "&format",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s4"),
        description: `**syntax**: \`&format\`
**procedure**: \`(make-format-condition)\`
**returns: **a condition of type \`&format\`
**procedure**: \`(format-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&format\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Presence of this condition type within a compound condition indicates that the string provided by the \`&message\` condition, if present, is a \`format\` string and the list of objects provided by the \`&irritants\` condition, if present, should be treated as additional \`format\` arguments. This condition type might be defined as follows.

\`(define-condition-type &format &condition\`
\`   make-format-condition format-condition?)\`
`
    },
    {
        name: "&i/o",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s32"),
        description: `**syntax**: \`&i/o\`
**procedure**: \`(make-i/o-error)\`
**returns: **a condition of type \`&i/o\`
**procedure**: \`(i/o-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of type \`&i/o\` indicates that an input/output error of some sort has occurred. Conditions of this type typically occur as one of the more specific subtypes described below. This condition type might be defined as follows.

\`(define-condition-type &i/o &error\`
\`   make-i/o-error i/o-error?)\`
`
    },
    {
        name: "&i/o-decoding",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s42"),
        description: `**syntax**: \`&i/o-decoding\`
**procedure**: \`(make-i/o-decoding-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-decoding\`
**procedure**: \`(i/o-decoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-decoding\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that a decoding error has occurred during the transcoding of bytes to characters. The *pobj* argument to the constructor should be the port involved, if any. The port should be positioned past the invalid encoding. This condition type might be defined as follows.

\`(define-condition-type &i/o-decoding &i/o-port\`
\`   make-i/o-decoding-error i/o-decoding-error?)\`
`
    },
    {
        name: "&i/o-encoding",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s43"),
        description: `**syntax**: \`&i/o-encoding\`
**procedure**: \`(make-i/o-encoding-error \`*pobj*\` \`*cobj*\`)\`
**returns: **a condition of type \`&i/o-encoding\`
**procedure**: \`(i/o-encoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-encoding\`, \`#f\` otherwise
**procedure**: \`(i/o-encoding-error-char \`*condition*\`)\`
**returns: **the contents of *condition*'s \`cobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that an encoding error has occurred during the transcoding of characters to bytes. The *pobj* argument to the constructor should be the port involved, if any, and the *cobj* argument should be the character for which the encoding failed. This condition type might be defined as follows.

\`(define-condition-type &i/o-encoding &i/o-port\`
\`   make-i/o-encoding-error i/o-encoding-error?\`
\`   (cobj i/o-encoding-error-char))\`

The final two condition types describe conditions that occur when implementations are required to produce a NaN or infinity but have no representations for these values.
`
    },
    {
        name: "&i/o-file-already-exists",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s39"),
        description: `**syntax**: \`&i/o-file-already-exists\`
**procedure**: \`(make-i/o-file-already-exists-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-already-exists\`
**procedure**: \`(i/o-file-already-exists-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-already-exists\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates a situation in which an operation on a file failed because the file already exists, e.g., an attempt is made to open an existing file for output without the \`no-fail\` file option. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-already-exists &i/o-filename\`
\`   make-i/o-file-already-exists-error\`
\`   i/o-file-already-exists-error?)\`
`
    },
    {
        name: "&i/o-file-does-not-exist",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s40"),
        description: `**syntax**: \`&i/o-file-does-not-exist\`
**procedure**: \`(make-i/o-file-does-not-exist-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-does-not-exist\`
**procedure**: \`(i/o-file-does-not-exist-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-does-not-exist\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates a situation in which an operation on a file failed because the file does not exist, e.g., an attempt is made to open a nonexistent file for input only. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-does-not-exist &i/o-filename\`
\`   make-i/o-file-does-not-exist-error\`
\`   i/o-file-does-not-exist-error?)\`
`
    },
    {
        name: "&i/o-file-is-read-only",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s38"),
        description: `**syntax**: \`&i/o-file-is-read-only\`
**procedure**: \`(make-i/o-file-is-read-only-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-is-read-only\`
**procedure**: \`(i/o-file-is-read-only-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-is-read-only\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates an attempt to treat as writeable a read-only file. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-is-read-only &i/o-file-protection\`
\`   make-i/o-file-is-read-only-error\`
\`   i/o-file-is-read-only-error?)\`
`
    },
    {
        name: "&i/o-file-protection",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s37"),
        description: `**syntax**: \`&i/o-file-protection\`
**procedure**: \`(make-i/o-file-protection-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-protection\`
**procedure**: \`(i/o-file-protection-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-protection\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates that an attempt has been made to perform some input/output operation on a file for which the program does not have the proper permission. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-protection &i/o-filename\`
\`   make-i/o-file-protection-error\`
\`   i/o-file-protection-error?)\`
`
    },
    {
        name: "&i/o-filename",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s36"),
        description: `**syntax**: \`&i/o-filename\`
**procedure**: \`(make-i/o-filename-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-filename\`
**procedure**: \`(i/o-filename-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-filename\`, \`#f\` otherwise
**procedure**: \`(i/o-error-filename \`*condition*\`)\`
**returns: **the contents of *condition*'s \`filename\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an input/output error that occurred while operating on a file. The *filename* argument to the constructor should be the name of the file. This condition type might be defined as follows.

\`(define-condition-type &i/o-filename &i/o\`
\`   make-i/o-filename-error i/o-filename-error?\`
\`   (filename i/o-error-filename))\`
`
    },
    {
        name: "&i/o-invalid-position",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s35"),
        description: `**syntax**: \`&i/o-invalid-position\`
**procedure**: \`(make-i/o-invalid-position-error \`*position*\`)\`
**returns: **a condition of type \`&i/o-invalid-position\`
**procedure**: \`(i/o-invalid-position-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-invalid-position\`, \`#f\` otherwise
**procedure**: \`(i/o-error-position \`*condition*\`)\`
**returns: **the contents of *condition*'s \`position\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an attempt to set a port's position to a position that is out of range for the underlying file or other object. The *position* argument to the constructor should be the invalid position. This condition type might be defined as follows.

\`(define-condition-type &i/o-invalid-position &i/o\`
\`   make-i/o-invalid-position-error\`
\`   i/o-invalid-position-error?\`
\`   (position i/o-error-position))\`
`
    },
    {
        name: "&i/o-port",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s41"),
        description: `**syntax**: \`&i/o-port\`
**procedure**: \`(make-i/o-port-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-port\`
**procedure**: \`(i/o-port-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-port\`, \`#f\` otherwise
**procedure**: \`(i/o-error-port \`*condition*\`)\`
**returns: **the contents of *condition*'s \`pobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type is usually included with a condition of one of the other \`&i/o\` subtypes to indicate the port involved in the exceptional situation, if a port is involved. The *pobj* argument to the constructor should be the port. This condition type might be defined as follows.

\`(define-condition-type &i/o-port &i/o\`
\`   make-i/o-port-error i/o-port-error?\`
\`   (pobj i/o-error-port))\`
`
    },
    {
        name: "&i/o-read",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s33"),
        description: `**syntax**: \`&i/o-read\`
**procedure**: \`(make-i/o-read-error)\`
**returns: **a condition of type \`&i/o-read\`
**procedure**: \`(i/o-read-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-read\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates that an error has occurred while reading from a port. This condition type might be defined as follows.

\`(define-condition-type &i/o-read &i/o\`
\`   make-i/o-read-error i/o-read-error?)\`
`
    },
    {
        name: "&i/o-write",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s34"),
        description: `**syntax**: \`&i/o-write\`
**procedure**: \`(make-i/o-write-error)\`
**returns: **a condition of type \`&i/o-write\`
**procedure**: \`(i/o-write-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-write\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates that an error has occurred while writing to a port. This condition type might be defined as follows.

\`(define-condition-type &i/o-write &i/o\`
\`   make-i/o-write-error i/o-write-error?)\`
`
    },
    {
        name: "&implementation-restriction",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s28"),
        description: `**syntax**: \`&implementation-restriction\`
**procedure**: \`(make-implementation-restriction-violation)\`
**returns: **a condition of type \`&implementation-restriction\`
**procedure**: \`(implementation-restriction-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&implementation-restriction\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

An implementation-restriction condition indicates that the program has attempted to exceed some limitation in the implementation, such as when the value of a fixnum addition operation would result in a number that exceeds the implementation's fixnum range. It does not normally indicate a deficiency in the implementation but rather a mismatch between what the program is attempting to do and what the implementation can support. In many cases, implementation restrictions are dictated by the underlying hardware. This condition type might be defined as follows.

\`(define-condition-type &implementation-restriction &violation\`
\`   make-implementation-restriction-violation\`
\`   implementation-restriction-violation?)\`
`
    },
    {
        name: "&irritants",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s25"),
        description: `**syntax**: \`&irritants\`
**procedure**: \`(make-irritants-condition \`*irritants*\`)\`
**returns: **a condition of type \`&irritants\`
**procedure**: \`(irritants-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&irritants\`, \`#f\` otherwise
**procedure**: \`(condition-irritants \`*condition*\`)\`
**returns: **the contents of *condition*'s \`irritants\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&message\` condition to provide information about Scheme values that may have caused or been materially involved in the exceptional situation. For example, if a procedure receives the wrong type of argument, it may raise an exception with a compound condition consisting of an assertion condition, a who condition naming the procedure, a message condition stating that the wrong type of argument was received, and an irritants condition listing the argument. The *irritants* argument to the constructor should be a list. This condition type might be defined as follows.

\`(define-condition-type &irritants &condition\`
\`   make-irritants-condition irritants-condition?\`
\`   (irritants condition-irritants))\`
`
    },
    {
        name: "&lexical",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s29"),
        description: `**syntax**: \`&lexical\`
**procedure**: \`(make-lexical-violation)\`
**returns: **a condition of type \`&lexical\`
**procedure**: \`(lexical-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&lexical\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a lexical error has occurred in the parsing of a Scheme program or datum, such as mismatched parentheses or an invalid character appearing within a numeric constant. This condition type might be defined as follows.

\`(define-condition-type &lexical &violation\`
\`   make-lexical-violation lexical-violation?)\`
`
    },
    {
        name: "&message",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s24"),
        description: `**syntax**: \`&message\`
**procedure**: \`(make-message-condition \`*message*\`)\`
**returns: **a condition of type \`&message\`
**procedure**: \`(message-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&message\`, \`#f\` otherwise
**procedure**: \`(condition-message \`*condition*\`)\`
**returns: **the contents of *condition*'s \`message\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&warning\` condition or one of the \`&serious\` condition subtypes to provide a more specific description of the exceptional situation. The *message* argument to the constructor may be any Scheme value but is typically a string. This condition type might be defined as follows.

\`(define-condition-type &message &condition\`
\`   make-message-condition message-condition?\`
\`   (message condition-message))\`
`
    },
    {
        name: "&no-infinities",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s44"),
        description: `**syntax**: \`&no-infinities\`
**procedure**: \`(make-no-infinities-violation)\`
**returns: **a condition of type \`&no-infinities\`
**procedure**: \`(no-infinities-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&no-infinities\`, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

This condition indicates that the implementation has no representation for infinity. This condition type might be defined as follows.

\`(define-condition-type &no-infinities &implementation-restriction\`
\`   make-no-infinities-violation\`
\`   no-infinities-violation?)\`
`
    },
    {
        name: "&no-nans",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s45"),
        description: `**syntax**: \`&no-nans\`
**procedure**: \`(make-no-nans-violation)\`
**returns: **a condition of type \`&no-nans\`
**procedure**: \`(no-nans-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&no-nans\`, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

This condition indicates that the implementation has no representation for NaN. This condition type might be defined as follows.

\`(define-condition-type &no-nans &implementation-restriction\`
\`   make-no-nans-violation no-nans-violation?)\`

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "&non-continuable",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s27"),
        description: `**syntax**: \`&non-continuable\`
**procedure**: \`(make-non-continuable-violation)\`
**returns: **a condition of type \`&non-continuable\`
**procedure**: \`(non-continuable-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&non-continuable\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a non-continuable violation has occurred. \`raise\` raises an exception with this type if the current exception handler returns. This condition type might be defined as follows.

\`(define-condition-type &non-continuable &violation\`
\`   make-non-continuable-violation\`
\`   non-continuable-violation?)\`
`
    },
    {
        name: "&serious",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s19"),
        description: `**syntax**: \`&serious\`
**procedure**: \`(make-serious-condition)\`
**returns: **a condition of type \`&serious\`
**procedure**: \`(serious-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&serious\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate situations of a serious nature that, if uncaught, generally result in termination of the program's execution. Conditions of this type typically occur as one of the more specific subtypes \`&error\` or \`&violation\`. This condition type might be defined as follows.

\`(define-condition-type &serious &condition\`
\`   make-serious-condition serious-condition?)\`
`
    },
    {
        name: "&source",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s5"),
        description: `**syntax**: \`&source\`
**procedure**: \`(make-source-condition \`*form*\`)\`
**returns: **a condition of type \`&source\`
**procedure**: \`(source-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&source\`, \`#f\` otherwise
**procedure**: \`(source-condition-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition when a source expression can be identified in situations in which a \`&syntax\` condition would be inappropriate, such as when a run-time assertion violation is detected. The \`form\` argument should be an s-expression or syntax object representing the source expression. This condition type might be defined as follows.

\`(define-condition-type &source &condition\`
\`   make-source-condition source-condition?\`
\`   (form source-condition-form))\`
`
    },
    {
        name: "&syntax",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s30"),
        description: `**syntax**: \`&syntax\`
**procedure**: \`(make-syntax-violation \`*form*\` \`*subform*\`)\`
**returns: **a condition of type \`&syntax\`
**procedure**: \`(syntax-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&syntax\`, \`#f\` otherwise
**procedure**: \`(syntax-violation-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**procedure**: \`(syntax-violation-subform \`*condition*\`)\`
**returns: **the contents of *condition*'s \`subform\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the *form* and *subform* arguments to \`make-syntax-violation\` should be a syntax object (Section ) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter. If there is no need to identify a subform, *subform* should be \`#f\`. This condition type might be defined as follows.

\`(define-condition-type &syntax &violation\`
\`   make-syntax-violation syntax-violation?\`
\`   (form syntax-violation-form)\`
\`   (subform syntax-violation-subform))\`
`
    },
    {
        name: "&undefined",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s31"),
        description: `**syntax**: \`&undefined\`
**procedure**: \`(make-undefined-violation)\`
**returns: **a condition of type \`&undefined\`
**procedure**: \`(undefined-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&undefined\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

An undefined condition indicates an attempt to reference an unbound variable. This condition type might be defined as follows.

\`(define-condition-type &undefined &violation\`
\`   make-undefined-violation undefined-violation?)\`

The next several condition types describe conditions that occur when input or output operations fail in some manner.
`
    },
    {
        name: "&violation",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s20"),
        description: `**syntax**: \`&violation\`
**procedure**: \`(make-violation)\`
**returns: **a condition of type \`&violation\`
**procedure**: \`(violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&violation\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that the program has violated some requirement, usually due to a bug in the program. This condition type might be defined as follows.

\`(define-condition-type &violation &serious\`
\`   make-violation violation?)\`
`
    },
    {
        name: "&warning",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s23"),
        description: `**syntax**: \`&warning\`
**procedure**: \`(make-warning)\`
**returns: **a condition of type \`&warning\`
**procedure**: \`(warning? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&warning\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Warning conditions indicate situations that do not prevent the program from continuing its execution but, in some cases, might result in a more serious problem at some later point. For example, a compiler might use a condition of this type to indicate that it has processed a call to a standard procedure with the wrong number of arguments; this will not become a serious problem unless the call is actually evaluated at some later point. This condition type might be defined as follows.

\`(define-condition-type &warning &condition\`
\`   make-warning warning?)\`
`
    },
    {
        name: "&who",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s26"),
        description: `**syntax**: \`&who\`
**procedure**: \`(make-who-condition \`*who*\`)\`
**returns: **a condition of type \`&who\`
**procedure**: \`(who-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&who\`, \`#f\` otherwise
**procedure**: \`(condition-who \`*condition*\`)\`
**returns: **the contents of *condition*'s \`who\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are often included with a \`&message\` condition to identify the syntactic form or procedure that detected the error. The *who* argument to the constructor should be a symbol or string. This condition type might be defined as follows.

\`(define-condition-type &who &condition\`
\`   make-who-condition who-condition?\`
\`   (who condition-who))\`
`
    },
    {
        name: "(* ",
        endParen: true,
        params: ["num", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s91"),
        description: `**procedure**: \`(* \`*num*\` ...)\`
**returns: **the product of the arguments *num*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

When called with no arguments, \`*\` returns 1.

\`(*) \`=>\` 1\`
\` (* 3.4) \`=>\` 3.4\`
\` (* 1 1/2) \`=>\` 1/2\`
\` (* 3 4 5.5) \`=>\` 66.0\`
\` (* 1+2i 3+4i) \`=>\` -5+10i\`
\` (apply * '(1 2 3 4 5)) \`=>\` 120\`
`
    },
    {
        name: "(+ ",
        endParen: true,
        params: ["num", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s89"),
        description: `**procedure**: \`(+ \`*num*\` ...)\`
**returns: **the sum of the arguments *num*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

When called with no arguments, \`+\` returns 0.

\`(+) \`=>\` 0\`
\` (+ 1 2) \`=>\` 3\`
\` (+ 1/2 2/3) \`=>\` 7/6\`
\` (+ 3 4 5) \`=>\` 12\`
\` (+ 3.0 4) \`=>\` 7.0\`
\` (+ 3+4i 4+3i) \`=>\` 7+7i\`
\` (apply + '(1 2 3 4 5)) \`=>\` 15\`
`
    },
    {
        name: "(- ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s90"),
        description: `**procedure**: \`(- \`*num*\`)\`
**returns: **the additive inverse of *num*
**procedure**: \`(- \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**returns: **the difference between *num1* and the sum of *num2*\` \`*num3*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`(- 3) \`=>\` -3\`
\` (- -2/3) \`=>\` 2/3\`
\` (- 4 3.0) \`=>\` 1.0\`
\` (- 3.25+4.25i 1/4+1/4i) \`=>\` 3.0+4.0i\`
\` (- 4 3 2 1) \`=>\` -2\`
`
    },
    {
        name: "(- ",
        endParen: true,
        params: ["num1", "num2", "num3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s90"),
        description: `**procedure**: \`(- \`*num*\`)\`
**returns: **the additive inverse of *num*
**procedure**: \`(- \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**returns: **the difference between *num1* and the sum of *num2*\` \`*num3*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`(- 3) \`=>\` -3\`
\` (- -2/3) \`=>\` 2/3\`
\` (- 4 3.0) \`=>\` 1.0\`
\` (- 3.25+4.25i 1/4+1/4i) \`=>\` 3.0+4.0i\`
\` (- 4 3 2 1) \`=>\` -2\`
`
    },
    {
        name: "(-1+ ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s68"),
        description: `**procedure**: \`(1+ \`*num*\`)\`
**procedure**: \`(add1 \`*num*\`)\`
**procedure**: \`(1- \`*num*\`)\`
**procedure**: \`(-1+ \`*num*\`)\`
**procedure**: \`(sub1 \`*num*\`)\`
**returns: ***num* plus 1 or *num* minus 1
**libraries: **\`(chezscheme)\`

\`1+\` and \`add1\` are equivalent to \`(lambda (x) (+ x 1))\`; \`1-\`, \`-1+\`, and \`sub1\` are equivalent to \`(lambda (x) (- x 1))\`.

\`(define plus\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x y)\`
\`     (if (zero? x)\`
\`         y\`
\`         (plus (1- x) (1+ y))))) \`
\` \`
\` (plus 7 8) \`=>\` 15 \`
\` \`
\` (define double\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x)\`
\`     (if (zero? x)\`
\`         0\`
\`         (add1 (add1 (double (sub1 x))))))) \`
\` \`
\` (double 7) \`=>\` 14\`
`
    },
    {
        name: "(/ ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s92"),
        description: `**procedure**: \`(/ \`*num*\`)\`
**returns: **the multiplicative inverse of *num*
**procedure**: \`(/ \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**returns: **the result of dividing *num1* by the product of *num2*\` \`*num3*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (/ -17) \`=>\` -1/17\`
\` (/ 1/2) \`=>\` 2\`
\` (/ .5) \`=>\` 2.0\`
\` (/ 3 4) \`=>\` 3/4\`
\` (/ 3.0 4) \`=>\` .75\`
\` (/ -5+10i 3+4i) \`=>\` 1+2i\`
\` (/ 60 5 4 3 2) \`=>\` 1/2\`
`
    },
    {
        name: "(/ ",
        endParen: true,
        params: ["num1", "num2", "num3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s92"),
        description: `**procedure**: \`(/ \`*num*\`)\`
**returns: **the multiplicative inverse of *num*
**procedure**: \`(/ \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**returns: **the result of dividing *num1* by the product of *num2*\` \`*num3*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (/ -17) \`=>\` -1/17\`
\` (/ 1/2) \`=>\` 2\`
\` (/ .5) \`=>\` 2.0\`
\` (/ 3 4) \`=>\` 3/4\`
\` (/ 3.0 4) \`=>\` .75\`
\` (/ -5+10i 3+4i) \`=>\` 1+2i\`
\` (/ 60 5 4 3 2) \`=>\` 1/2\`
`
    },
    {
        name: "(1+ ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s68"),
        description: `**procedure**: \`(1+ \`*num*\`)\`
**procedure**: \`(add1 \`*num*\`)\`
**procedure**: \`(1- \`*num*\`)\`
**procedure**: \`(-1+ \`*num*\`)\`
**procedure**: \`(sub1 \`*num*\`)\`
**returns: ***num* plus 1 or *num* minus 1
**libraries: **\`(chezscheme)\`

\`1+\` and \`add1\` are equivalent to \`(lambda (x) (+ x 1))\`; \`1-\`, \`-1+\`, and \`sub1\` are equivalent to \`(lambda (x) (- x 1))\`.

\`(define plus\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x y)\`
\`     (if (zero? x)\`
\`         y\`
\`         (plus (1- x) (1+ y))))) \`
\` \`
\` (plus 7 8) \`=>\` 15 \`
\` \`
\` (define double\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x)\`
\`     (if (zero? x)\`
\`         0\`
\`         (add1 (add1 (double (sub1 x))))))) \`
\` \`
\` (double 7) \`=>\` 14\`
`
    },
    {
        name: "(1- ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s68"),
        description: `**procedure**: \`(1+ \`*num*\`)\`
**procedure**: \`(add1 \`*num*\`)\`
**procedure**: \`(1- \`*num*\`)\`
**procedure**: \`(-1+ \`*num*\`)\`
**procedure**: \`(sub1 \`*num*\`)\`
**returns: ***num* plus 1 or *num* minus 1
**libraries: **\`(chezscheme)\`

\`1+\` and \`add1\` are equivalent to \`(lambda (x) (+ x 1))\`; \`1-\`, \`-1+\`, and \`sub1\` are equivalent to \`(lambda (x) (- x 1))\`.

\`(define plus\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x y)\`
\`     (if (zero? x)\`
\`         y\`
\`         (plus (1- x) (1+ y))))) \`
\` \`
\` (plus 7 8) \`=>\` 15 \`
\` \`
\` (define double\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x)\`
\`     (if (zero? x)\`
\`         0\`
\`         (add1 (add1 (double (sub1 x))))))) \`
\` \`
\` (double 7) \`=>\` 14\`
`
    },
    {
        name: "(< ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s67"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(> 3/4) \`=>\` #t\`
\` (< 3/4) \`=>\` #t\`
\` (= 3/4) \`=>\` #t\`
`
    },
    {
        name: "(< ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s88"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The predicate \`=\` returns \`#t\` if its arguments are equal. The predicate \`<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`>=\` returns \`#t\` if its arguments are monotonically nonincreasing.

As implied by the names of the arguments, \`=\` is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return \`#f\`.

\`(= 7 7) \`=>\` #t\`
\` (= 7 9) \`=>\` #f \`
\` \`
\` (< 2e3 3e2) \`=>\` #f\`
\` (<= 1 2 3 3 4 5) \`=>\` #t\`
\` (<= 1 2 3 4 5) \`=>\` #t \`
\` \`
\` (> 1 2 2 3 3 4) \`=>\` #f\`
\` (>= 1 2 2 3 3 4) \`=>\` #f \`
\` \`
\` (= -1/2 -0.5) \`=>\` #t\`
\` (= 2/3 .667) \`=>\` #f\`
\` (= 7.2+0i 7.2) \`=>\` #t\`
\` (= 7.2-3i 7) \`=>\` #f \`
\` \`
\` (< 1/2 2/3 3/4) \`=>\` #t\`
\` (> 8 4.102 2/3 -5) \`=>\` #t \`
\` \`
\` (let ([x 0.218723452])\`
\`   (< 0.210 x 0.220)) \`=>\` #t \`
\` \`
\` (let ([i 1] [v (vector 'a 'b 'c)])\`
\`   (< -1 i (vector-length v))) \`=>\` #t \`
\` \`
\` (apply < '(1 2 3 4)) \`=>\` #t\`
\` (apply > '(4 3 3 2)) \`=>\` #f \`
\` \`
\` (= +nan.0 +nan.0) \`=>\` #f\`
\` (< +nan.0 +nan.0) \`=>\` #f\`
\` (> +nan.0 +nan.0) \`=>\` #f\`
\` (>= +inf.0 +nan.0) \`=>\` #f\`
\` (>= +nan.0 -inf.0) \`=>\` #f\`
\` (> +nan.0 0.0) \`=>\` #f\`
`
    },
    {
        name: "(<= ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s67"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(> 3/4) \`=>\` #t\`
\` (< 3/4) \`=>\` #t\`
\` (= 3/4) \`=>\` #t\`
`
    },
    {
        name: "(<= ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s88"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The predicate \`=\` returns \`#t\` if its arguments are equal. The predicate \`<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`>=\` returns \`#t\` if its arguments are monotonically nonincreasing.

As implied by the names of the arguments, \`=\` is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return \`#f\`.

\`(= 7 7) \`=>\` #t\`
\` (= 7 9) \`=>\` #f \`
\` \`
\` (< 2e3 3e2) \`=>\` #f\`
\` (<= 1 2 3 3 4 5) \`=>\` #t\`
\` (<= 1 2 3 4 5) \`=>\` #t \`
\` \`
\` (> 1 2 2 3 3 4) \`=>\` #f\`
\` (>= 1 2 2 3 3 4) \`=>\` #f \`
\` \`
\` (= -1/2 -0.5) \`=>\` #t\`
\` (= 2/3 .667) \`=>\` #f\`
\` (= 7.2+0i 7.2) \`=>\` #t\`
\` (= 7.2-3i 7) \`=>\` #f \`
\` \`
\` (< 1/2 2/3 3/4) \`=>\` #t\`
\` (> 8 4.102 2/3 -5) \`=>\` #t \`
\` \`
\` (let ([x 0.218723452])\`
\`   (< 0.210 x 0.220)) \`=>\` #t \`
\` \`
\` (let ([i 1] [v (vector 'a 'b 'c)])\`
\`   (< -1 i (vector-length v))) \`=>\` #t \`
\` \`
\` (apply < '(1 2 3 4)) \`=>\` #t\`
\` (apply > '(4 3 3 2)) \`=>\` #f \`
\` \`
\` (= +nan.0 +nan.0) \`=>\` #f\`
\` (< +nan.0 +nan.0) \`=>\` #f\`
\` (> +nan.0 +nan.0) \`=>\` #f\`
\` (>= +inf.0 +nan.0) \`=>\` #f\`
\` (>= +nan.0 -inf.0) \`=>\` #f\`
\` (> +nan.0 0.0) \`=>\` #f\`
`
    },
    {
        name: "(= ",
        endParen: true,
        params: ["num1", "num2", "num3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s67"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(> 3/4) \`=>\` #t\`
\` (< 3/4) \`=>\` #t\`
\` (= 3/4) \`=>\` #t\`
`
    },
    {
        name: "(= ",
        endParen: true,
        params: ["num1", "num2", "num3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s88"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The predicate \`=\` returns \`#t\` if its arguments are equal. The predicate \`<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`>=\` returns \`#t\` if its arguments are monotonically nonincreasing.

As implied by the names of the arguments, \`=\` is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return \`#f\`.

\`(= 7 7) \`=>\` #t\`
\` (= 7 9) \`=>\` #f \`
\` \`
\` (< 2e3 3e2) \`=>\` #f\`
\` (<= 1 2 3 3 4 5) \`=>\` #t\`
\` (<= 1 2 3 4 5) \`=>\` #t \`
\` \`
\` (> 1 2 2 3 3 4) \`=>\` #f\`
\` (>= 1 2 2 3 3 4) \`=>\` #f \`
\` \`
\` (= -1/2 -0.5) \`=>\` #t\`
\` (= 2/3 .667) \`=>\` #f\`
\` (= 7.2+0i 7.2) \`=>\` #t\`
\` (= 7.2-3i 7) \`=>\` #f \`
\` \`
\` (< 1/2 2/3 3/4) \`=>\` #t\`
\` (> 8 4.102 2/3 -5) \`=>\` #t \`
\` \`
\` (let ([x 0.218723452])\`
\`   (< 0.210 x 0.220)) \`=>\` #t \`
\` \`
\` (let ([i 1] [v (vector 'a 'b 'c)])\`
\`   (< -1 i (vector-length v))) \`=>\` #t \`
\` \`
\` (apply < '(1 2 3 4)) \`=>\` #t\`
\` (apply > '(4 3 3 2)) \`=>\` #f \`
\` \`
\` (= +nan.0 +nan.0) \`=>\` #f\`
\` (< +nan.0 +nan.0) \`=>\` #f\`
\` (> +nan.0 +nan.0) \`=>\` #f\`
\` (>= +inf.0 +nan.0) \`=>\` #f\`
\` (>= +nan.0 -inf.0) \`=>\` #f\`
\` (> +nan.0 0.0) \`=>\` #f\`
`
    },
    {
        name: "(> ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s67"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(> 3/4) \`=>\` #t\`
\` (< 3/4) \`=>\` #t\`
\` (= 3/4) \`=>\` #t\`
`
    },
    {
        name: "(> ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s88"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The predicate \`=\` returns \`#t\` if its arguments are equal. The predicate \`<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`>=\` returns \`#t\` if its arguments are monotonically nonincreasing.

As implied by the names of the arguments, \`=\` is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return \`#f\`.

\`(= 7 7) \`=>\` #t\`
\` (= 7 9) \`=>\` #f \`
\` \`
\` (< 2e3 3e2) \`=>\` #f\`
\` (<= 1 2 3 3 4 5) \`=>\` #t\`
\` (<= 1 2 3 4 5) \`=>\` #t \`
\` \`
\` (> 1 2 2 3 3 4) \`=>\` #f\`
\` (>= 1 2 2 3 3 4) \`=>\` #f \`
\` \`
\` (= -1/2 -0.5) \`=>\` #t\`
\` (= 2/3 .667) \`=>\` #f\`
\` (= 7.2+0i 7.2) \`=>\` #t\`
\` (= 7.2-3i 7) \`=>\` #f \`
\` \`
\` (< 1/2 2/3 3/4) \`=>\` #t\`
\` (> 8 4.102 2/3 -5) \`=>\` #t \`
\` \`
\` (let ([x 0.218723452])\`
\`   (< 0.210 x 0.220)) \`=>\` #t \`
\` \`
\` (let ([i 1] [v (vector 'a 'b 'c)])\`
\`   (< -1 i (vector-length v))) \`=>\` #t \`
\` \`
\` (apply < '(1 2 3 4)) \`=>\` #t\`
\` (apply > '(4 3 3 2)) \`=>\` #f \`
\` \`
\` (= +nan.0 +nan.0) \`=>\` #f\`
\` (< +nan.0 +nan.0) \`=>\` #f\`
\` (> +nan.0 +nan.0) \`=>\` #f\`
\` (>= +inf.0 +nan.0) \`=>\` #f\`
\` (>= +nan.0 -inf.0) \`=>\` #f\`
\` (> +nan.0 0.0) \`=>\` #f\`
`
    },
    {
        name: "(>= ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s67"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(> 3/4) \`=>\` #t\`
\` (< 3/4) \`=>\` #t\`
\` (= 3/4) \`=>\` #t\`
`
    },
    {
        name: "(>= ",
        endParen: true,
        params: ["real1", "real2", "real3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s88"),
        description: `**procedure**: \`(= \`*num1*\` \`*num2*\` \`*num3*\` ...)\`
**procedure**: \`(< \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(> \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(<= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**procedure**: \`(>= \`*real1*\` \`*real2*\` \`*real3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The predicate \`=\` returns \`#t\` if its arguments are equal. The predicate \`<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`>=\` returns \`#t\` if its arguments are monotonically nonincreasing.

As implied by the names of the arguments, \`=\` is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return \`#f\`.

\`(= 7 7) \`=>\` #t\`
\` (= 7 9) \`=>\` #f \`
\` \`
\` (< 2e3 3e2) \`=>\` #f\`
\` (<= 1 2 3 3 4 5) \`=>\` #t\`
\` (<= 1 2 3 4 5) \`=>\` #t \`
\` \`
\` (> 1 2 2 3 3 4) \`=>\` #f\`
\` (>= 1 2 2 3 3 4) \`=>\` #f \`
\` \`
\` (= -1/2 -0.5) \`=>\` #t\`
\` (= 2/3 .667) \`=>\` #f\`
\` (= 7.2+0i 7.2) \`=>\` #t\`
\` (= 7.2-3i 7) \`=>\` #f \`
\` \`
\` (< 1/2 2/3 3/4) \`=>\` #t\`
\` (> 8 4.102 2/3 -5) \`=>\` #t \`
\` \`
\` (let ([x 0.218723452])\`
\`   (< 0.210 x 0.220)) \`=>\` #t \`
\` \`
\` (let ([i 1] [v (vector 'a 'b 'c)])\`
\`   (< -1 i (vector-length v))) \`=>\` #t \`
\` \`
\` (apply < '(1 2 3 4)) \`=>\` #t\`
\` (apply > '(4 3 3 2)) \`=>\` #f \`
\` \`
\` (= +nan.0 +nan.0) \`=>\` #f\`
\` (< +nan.0 +nan.0) \`=>\` #f\`
\` (> +nan.0 +nan.0) \`=>\` #f\`
\` (>= +inf.0 +nan.0) \`=>\` #f\`
\` (>= +nan.0 -inf.0) \`=>\` #f\`
\` (> +nan.0 0.0) \`=>\` #f\`
`
    },
    {
        name: "(abort)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s182"),
        description: `**procedure**: \`(abort)\`
**procedure**: \`(abort \`*obj*\`)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

\`abort\` invokes the current abort handler (see \`abort-handler\`), passing along its argument, if any.
`
    },
    {
        name: "(abort ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s182"),
        description: `**procedure**: \`(abort)\`
**procedure**: \`(abort \`*obj*\`)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

\`abort\` invokes the current abort handler (see \`abort-handler\`), passing along its argument, if any.
`
    },
    {
        name: "abort-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s183"),
        description: `**thread parameter**: \`abort-handler\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a procedure and should accept either zero arguments or one argument. The current abort handler is called by \`abort\`.

The default abort handler exits the Scheme process. The exit code for the Scheme process is -1 if no arguments were supplied, 0 if the first argument is void, the value of the first argument if it is a 32-bit exact integer, and -1 otherwise.
`
    },
    {
        name: "(abs ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s105"),
        description: `**procedure**: \`(abs \`*real*\`)\`
**returns: **the absolute value of *real*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(acos ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s132"),
        description: `**procedure**: \`(asin \`*num*\`)\`
**procedure**: \`(acos \`*num*\`)\`
**returns: **the arc sine or the arc cosine of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The result is in radians. The arc sine and arc cosine of a complex number are defined as follows.

\`(define pi (* (asin 1) 2))\`
\` (= (* (acos 0) 2) pi) \`=>\` #t\`
`
    },
    {
        name: "(acosh ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s77"),
        description: `**procedure**: \`(asinh \`*num*\`)\`
**procedure**: \`(acosh \`*num*\`)\`
**procedure**: \`(atanh \`*num*\`)\`
**returns: **the hyperbolic arc sine, arc cosine, or arc tangent of *num*
**libraries: **\`(chezscheme)\`

\`(acosh 0.0) \`=>\` 0.0+1.5707963267948966i\`
\` (acosh 1.0) \`=>\` 0.0\`
\` (atanh -1.0) \`=>\` -inf.0\`
`
    },
    {
        name: "(add-duration ",
        endParen: true,
        params: ["time", "timed"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s209"),
        description: `**procedure**: \`(time-difference \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(time-difference! \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(add-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(add-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(subtract-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**procedure**: \`(subtract-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**libraries: **\`(chezscheme)\`

For \`time-difference\`, *time1* and *time2* must have the same time type, and the result is a time object with time type \`time-duration\`. For \`add-duration\`, \`add-duration!\`, \`subtract-duration\`, and \`subtract-duration!\`, *timed* must have time type \`time-duration\`, and the result is a time object with the same time type as *time*. \`time-difference!\`, \`add-duration!\`, and \`subtract-duration!\` are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object.

\`(let ([delay (make-time 'time-duration 0 1)])\`
\`   (let ([t1 (current-time 'time-monotonic)])\`
\`     (sleep delay)\`
\`     (let ([t2 (current-time 'time-monotonic)])\`
\`       (let ([t3 (time-difference t2 t1)])\`
\`         (and\`
\`           (eq? (time-type t3) 'time-duration)\`
\`           (time>=? t3 delay)\`
\`           (time=? (add-duration t1 t3) t2)\`
\`           (time=? (subtract-duration t2 t3) t1)))))) \`=>\` #t\`
`
    },
    {
        name: "(add-duration! ",
        endParen: true,
        params: ["time", "timed"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s209"),
        description: `**procedure**: \`(time-difference \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(time-difference! \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(add-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(add-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(subtract-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**procedure**: \`(subtract-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**libraries: **\`(chezscheme)\`

For \`time-difference\`, *time1* and *time2* must have the same time type, and the result is a time object with time type \`time-duration\`. For \`add-duration\`, \`add-duration!\`, \`subtract-duration\`, and \`subtract-duration!\`, *timed* must have time type \`time-duration\`, and the result is a time object with the same time type as *time*. \`time-difference!\`, \`add-duration!\`, and \`subtract-duration!\` are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object.

\`(let ([delay (make-time 'time-duration 0 1)])\`
\`   (let ([t1 (current-time 'time-monotonic)])\`
\`     (sleep delay)\`
\`     (let ([t2 (current-time 'time-monotonic)])\`
\`       (let ([t3 (time-difference t2 t1)])\`
\`         (and\`
\`           (eq? (time-type t3) 'time-duration)\`
\`           (time>=? t3 delay)\`
\`           (time=? (add-duration t1 t3) t2)\`
\`           (time=? (subtract-duration t2 t3) t1)))))) \`=>\` #t\`
`
    },
    {
        name: "add-prefix",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s22"),
        description: `**syntax**: \`only\`
**syntax**: \`except\`
**syntax**: \`add-prefix\`
**syntax**: \`drop-prefix\`
**syntax**: \`rename\`
**syntax**: \`alias\`
**libraries: **\`(chezscheme)\`

These identifiers are auxiliary keywords for \`import\` and \`import-only\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(add1 ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s68"),
        description: `**procedure**: \`(1+ \`*num*\`)\`
**procedure**: \`(add1 \`*num*\`)\`
**procedure**: \`(1- \`*num*\`)\`
**procedure**: \`(-1+ \`*num*\`)\`
**procedure**: \`(sub1 \`*num*\`)\`
**returns: ***num* plus 1 or *num* minus 1
**libraries: **\`(chezscheme)\`

\`1+\` and \`add1\` are equivalent to \`(lambda (x) (+ x 1))\`; \`1-\`, \`-1+\`, and \`sub1\` are equivalent to \`(lambda (x) (- x 1))\`.

\`(define plus\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x y)\`
\`     (if (zero? x)\`
\`         y\`
\`         (plus (1- x) (1+ y))))) \`
\` \`
\` (plus 7 8) \`=>\` 15 \`
\` \`
\` (define double\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x)\`
\`     (if (zero? x)\`
\`         0\`
\`         (add1 (add1 (double (sub1 x))))))) \`
\` \`
\` (double 7) \`=>\` 14\`
`
    },
    {
        name: "alias",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s22"),
        description: `**syntax**: \`only\`
**syntax**: \`except\`
**syntax**: \`add-prefix\`
**syntax**: \`drop-prefix\`
**syntax**: \`rename\`
**syntax**: \`alias\`
**libraries: **\`(chezscheme)\`

These identifiers are auxiliary keywords for \`import\` and \`import-only\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(alias ",
        endParen: true,
        params: ["id1", "id2"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s38"),
        description: `**syntax**: \`(alias \`*id1*\` \`*id2*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`alias\` is a definition and can appear anywhere other definitions can appear. It is used to transfer the binding from one identifier to another.

\`(let ([x 3]) (alias y x) (set! y 4) (list x y)) \`=>\` (4 4) \`
\` \`
\` (module lisp (if)\`
\`   (module (scheme:if)\`
\`     (import scheme)\`
\`     (alias scheme:if if))\`
\`   (define-syntax if\`
\`     (syntax-rules ()\`
\`       [(_ e_1 e_2 e_3)\`
\`        (scheme:if (not (memq e_1 '(#f ()))) e_2 e_3)])))\`
\` (define (length ls)\`
\`   (import lisp)\`
\`   (if ls (+ (length (cdr ls)) 1) 0))\`
\` (length '(a b c)) \`=>\` 3\`

Because of left-to-right expansion order, aliases should appear after the definition of the right-hand-side identifier, e.g.:

\`(let ()\`
\`   (import-only (chezscheme))\`
\`   (define y 3)\`
\`   (alias x y)\`
\`   x) \`=>\` 3\`

rather than:

\`(let ()\`
\`   (import-only (chezscheme))\`
\`   (alias x y)\`
\`   (define y 3)\`
\`   x) \`=>\` \`*exception: unbound identifier*
`
    },
    {
        name: "(and ",
        endParen: true,
        params: ["expr", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s11"),
        description: `**syntax**: \`(and \`*expr*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If no subexpressions are present, the \`and\` form evaluates to \`#t\`. Otherwise, \`and\` evaluates each subexpression in sequence from left to right until only one subexpression remains or a subexpression returns \`#f\`. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns \`#f\`, \`and\` returns \`#f\` without evaluating the remaining subexpressions. A syntax definition of \`and\` appears on page .

\`(let ([x 3])\`
\`   (and (> x 2) (< x 4))) \`=>\` #t \`
\` \`
\` (let ([x 5])\`
\`   (and (> x 2) (< x 4))) \`=>\` #f \`
\` \`
\` (and #f '(a b) '(c d)) \`=>\` #f\`
\` (and '(a b) '(c d) '(e f)) \`=>\` (e f)\`
`
    },
    {
        name: "(andmap ",
        endParen: true,
        params: ["procedure", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s8"),
        description: `**procedure**: \`(andmap \`*procedure*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`

\`andmap\` is identical to the Revised Report \`for-all\`.
`
    },
    {
        name: "(angle ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s124"),
        description: `**procedure**: \`(angle \`*num*\`)\`
**returns: **the angle part of the polar representation of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The range of the result is (exclusive) to (inclusive).

\`(angle 7.3@1.5708) \`=>\` 1.5708\`
\` (angle 5.2) \`=>\` 0.0\`
`
    },
    {
        name: "(annotation-expression ",
        endParen: true,
        params: ["annotation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s51"),
        description: `**procedure**: \`(annotation-expression \`*annotation*\`)\`
**returns: **the expression component of *annotation*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(annotation-option-set ",
        endParen: true,
        params: ["symbol", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s68"),
        description: `**syntax**: \`(annotation-option-set \`*symbol*\` ...)\`
**returns: **an annotation-options enumeration set
**libraries: **\`(chezscheme)\`

Annotation-options enumeration sets may be passed to \`make-annotation\` to control whether the annotation is used for debugging, profiling, both, or neither. Accordingly, each *symbol* must be either *debug* or \`profile\`.
`
    },
    {
        name: "(annotation-options ",
        endParen: true,
        params: ["annotation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s54"),
        description: `**procedure**: \`(annotation-options \`*annotation*\`)\`
**returns: **the options enumeration set of *annotation*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(annotation-source ",
        endParen: true,
        params: ["annotation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s52"),
        description: `**procedure**: \`(annotation-source \`*annotation*\`)\`
**returns: **the source-object component of *annotation*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(annotation-stripped ",
        endParen: true,
        params: ["annotation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s53"),
        description: `**procedure**: \`(annotation-stripped \`*annotation*\`)\`
**returns: **the stripped component of *annotation*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(annotation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s50"),
        description: `**procedure**: \`(annotation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an annotation, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(append)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s49"),
        description: `**procedure**: \`(append)\`
**procedure**: \`(append \`*list*\` ... \`*obj*\`)\`
**returns: **the concatenation of the input lists
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`append\` returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. The new list is made from new pairs for all arguments but the last; the last (which need not be a list) is merely placed at the end of the new structure. \`append\` may be defined without error checks as follows.

\`(define append\`
\`   (lambda args\`
\`     (let f ([ls '()] [args args])\`
\`       (if (null? args)\`
\`           ls\`
\`           (let g ([ls ls])\`
\`             (if (null? ls)\`
\`                 (f (car args) (cdr args))\`
\`                 (cons (car ls) (g (cdr ls))))))))) \`
\` \`
\` (append '(a b c) '()) \`=>\` (a b c)\`
\` (append '() '(a b c)) \`=>\` (a b c)\`
\` (append '(a b) '(c d)) \`=>\` (a b c d)\`
\` (append '(a b) 'c) \`=>\` (a b . c)\`
\` (let ([x (list 'b)])\`
\`   (eq? x (cdr (append '(a) x)))) \`=>\` #t\`
`
    },
    {
        name: "(append ",
        endParen: true,
        params: ["list", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s49"),
        description: `**procedure**: \`(append)\`
**procedure**: \`(append \`*list*\` ... \`*obj*\`)\`
**returns: **the concatenation of the input lists
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`append\` returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. The new list is made from new pairs for all arguments but the last; the last (which need not be a list) is merely placed at the end of the new structure. \`append\` may be defined without error checks as follows.

\`(define append\`
\`   (lambda args\`
\`     (let f ([ls '()] [args args])\`
\`       (if (null? args)\`
\`           ls\`
\`           (let g ([ls ls])\`
\`             (if (null? ls)\`
\`                 (f (car args) (cdr args))\`
\`                 (cons (car ls) (g (cdr ls))))))))) \`
\` \`
\` (append '(a b c) '()) \`=>\` (a b c)\`
\` (append '() '(a b c)) \`=>\` (a b c)\`
\` (append '(a b) '(c d)) \`=>\` (a b c d)\`
\` (append '(a b) 'c) \`=>\` (a b . c)\`
\` (let ([x (list 'b)])\`
\`   (eq? x (cdr (append '(a) x)))) \`=>\` #t\`
`
    },
    {
        name: "(append! ",
        endParen: true,
        params: ["list", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s13"),
        description: `**procedure**: \`(append! \`*list*\` ...)\`
**returns: **the concatenation of the input lists
**libraries: **\`(chezscheme)\`

Like \`append\`, \`append!\` returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. Unlike \`append\`, \`append!\` reuses the pairs in all of the arguments in forming the new list. That is, the last cdr of each list argument but the last is changed to point to the next list argument. If any argument but the last is the empty list, it is essentially ignored. The final argument (which need not be a list) is not altered.

\`append!\` performs less allocation than \`append\` but is not necessarily faster. Its use can easily lead to confusing or incorrect results if used indiscriminately.

\`(append! '(a b) '(c d)) \`=>\` (a b c d) \`
\` \`
\` (let ([x '(a b)])\`
\`     (append! x '(c d))\`
\`     x) \`=>\` (a b c d)\`
`
    },
    {
        name: "(apply ",
        endParen: true,
        params: ["procedure", "obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s3"),
        description: `**procedure**: \`(apply \`*procedure*\` \`*obj*\` ... \`*list*\`)\`
**returns: **the values of applying *procedure* to *obj*\` ...\` and the elements of *list*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`apply\` invokes *procedure*, passing the first *obj* as the first argument, the second *obj* as the second argument, and so on for each object in *obj*\` ...\`, and passing the elements of *list* in order as the remaining arguments. Thus, *procedure* is called with as many arguments as there are *objs* plus elements of *list*.

\`apply\` is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.

\`(apply + '(4 5)) \`=>\` 9 \`
\` \`
\` (apply min '(6 8 3 2 5)) \`=>\` 2 \`
\` \`
\` (apply min  5 1 3 '(6 8 3 2 5)) \`=>\` 1 \`
\` \`
\` (apply vector 'a 'b '(c d e)) \`=>\` #(a b c d e) \`
\` \`
\` (define first\`
\`   (lambda (ls)\`
\`     (apply (lambda (x . y) x) ls)))\`
\` (define rest\`
\`   (lambda (ls)\`
\`     (apply (lambda (x . y) y) ls)))\`
\` (first '(a b c d)) \`=>\` a\`
\` (rest '(a b c d)) \`=>\` (b c d) \`
\` \`
\` (apply append\`
\`   '(1 2 3)\`
\`   '((a b) (c d e) (f))) \`=>\` (1 2 3 a b c d e f)\`
`
    },
    {
        name: "(apropos ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s37"),
        description: `**procedure**: \`(apropos \`*s*\`)\`
**procedure**: \`(apropos \`*s*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`apropos\` is like \`apropos-list\` except the information is displayed to the current output port, as shown in the following transcript.

\`> (library (a) (export a-vector-sortof) (import (rnrs))\`
\`     (define a-vector-sortof '(vector 1 2 3)))\`
\` > (apropos 'vector-sort)\`
\` interaction environment:\`
\`   vector-sort, vector-sort!\`
\` (a):\`
\`   a-vector-sortof\`
\` (chezscheme):\`
\`   vector-sort, vector-sort!\`
\` (rnrs):\`
\`   vector-sort, vector-sort!\`
\` (rnrs sorting):\`
\`   vector-sort, vector-sort!\`
\` (scheme):\`
\`   vector-sort, vector-sort!\`
`
    },
    {
        name: "(apropos ",
        endParen: true,
        params: ["s", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s37"),
        description: `**procedure**: \`(apropos \`*s*\`)\`
**procedure**: \`(apropos \`*s*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`apropos\` is like \`apropos-list\` except the information is displayed to the current output port, as shown in the following transcript.

\`> (library (a) (export a-vector-sortof) (import (rnrs))\`
\`     (define a-vector-sortof '(vector 1 2 3)))\`
\` > (apropos 'vector-sort)\`
\` interaction environment:\`
\`   vector-sort, vector-sort!\`
\` (a):\`
\`   a-vector-sortof\`
\` (chezscheme):\`
\`   vector-sort, vector-sort!\`
\` (rnrs):\`
\`   vector-sort, vector-sort!\`
\` (rnrs sorting):\`
\`   vector-sort, vector-sort!\`
\` (scheme):\`
\`   vector-sort, vector-sort!\`
`
    },
    {
        name: "(apropos-list ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s36"),
        description: `**procedure**: \`(apropos-list \`*s*\`)\`
**procedure**: \`(apropos-list \`*s*\` \`*env*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

This procedure returns a selected list of symbols and pairs. Each symbol in the list represents an identifier bound in *env*. Each pair represents a set of identifiers exported by a predefined library or a library previously defined or loaded into the system. The car of the pair is the library name, and the cdr is a list of symbols. If *s* is a string, only entries whose names have *s* as a substring are included, and if *s* is a symbol, only those whose names have the name of *s* as a substring are selected. If no environment is provided, it defaults to the value of \`interaction-environment\`.

\`(library (a) (export a-vector-sortof) (import (rnrs))\`
\`   (define a-vector-sortof '(vector 1 2 3)))\`
\` (apropos-list 'vector-sort) \`=>
\`   (vector-sort vector-sort!\`
\`    ((a) a-vector-sortof)\`
\`    ((chezscheme) vector-sort vector-sort!)\`
\`    ((rnrs) vector-sort vector-sort!)\`
\`    ((rnrs sorting) vector-sort vector-sort!)\`
\`    ((scheme) vector-sort vector-sort!))\`
`
    },
    {
        name: "(apropos-list ",
        endParen: true,
        params: ["s", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s36"),
        description: `**procedure**: \`(apropos-list \`*s*\`)\`
**procedure**: \`(apropos-list \`*s*\` \`*env*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

This procedure returns a selected list of symbols and pairs. Each symbol in the list represents an identifier bound in *env*. Each pair represents a set of identifiers exported by a predefined library or a library previously defined or loaded into the system. The car of the pair is the library name, and the cdr is a list of symbols. If *s* is a string, only entries whose names have *s* as a substring are included, and if *s* is a symbol, only those whose names have the name of *s* as a substring are selected. If no environment is provided, it defaults to the value of \`interaction-environment\`.

\`(library (a) (export a-vector-sortof) (import (rnrs))\`
\`   (define a-vector-sortof '(vector 1 2 3)))\`
\` (apropos-list 'vector-sort) \`=>
\`   (vector-sort vector-sort!\`
\`    ((a) a-vector-sortof)\`
\`    ((chezscheme) vector-sort vector-sort!)\`
\`    ((rnrs) vector-sort vector-sort!)\`
\`    ((rnrs sorting) vector-sort vector-sort!)\`
\`    ((scheme) vector-sort vector-sort!))\`
`
    },
    {
        name: "(ash ",
        endParen: true,
        params: ["int", "count"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s52"),
        description: `**procedure**: \`(ash \`*int*\` \`*count*\`)\`
**returns: ***int* shifted left arithmetically by *count*.
**libraries: **\`(chezscheme)\`

Both arguments must be exact integers. The first argument is treated as a two's complement integer, regardless of the underlying representation. If *count* is negative, *int* is shifted right by -*count* bits.

\`(ash 8 0) \`=>\` 8\`
\` (ash 8 2) \`=>\` 32\`
\` (ash 8 -2) \`=>\` 2\`
\` (ash -1 2) \`=>\` -4\`
\` (ash -1 -2) \`=>\` -1\`
`
    },
    {
        name: "(asin ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s132"),
        description: `**procedure**: \`(asin \`*num*\`)\`
**procedure**: \`(acos \`*num*\`)\`
**returns: **the arc sine or the arc cosine of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The result is in radians. The arc sine and arc cosine of a complex number are defined as follows.

\`(define pi (* (asin 1) 2))\`
\` (= (* (acos 0) 2) pi) \`=>\` #t\`
`
    },
    {
        name: "(asinh ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s77"),
        description: `**procedure**: \`(asinh \`*num*\`)\`
**procedure**: \`(acosh \`*num*\`)\`
**procedure**: \`(atanh \`*num*\`)\`
**returns: **the hyperbolic arc sine, arc cosine, or arc tangent of *num*
**libraries: **\`(chezscheme)\`

\`(acosh 0.0) \`=>\` 0.0+1.5707963267948966i\`
\` (acosh 1.0) \`=>\` 0.0\`
\` (atanh -1.0) \`=>\` -inf.0\`
`
    },
    {
        name: "(assert ",
        endParen: true,
        params: ["expression"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s5"),
        description: `**syntax**: \`(assert \`*expression*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`assert\` evaluates *expression* and returns the value of *expression* if the value is not \`#f\`. If the value of *expression* is \`#f\`, \`assert\` raises a non-continuable exception with condition types \`&assertion\` and \`&message\`, with an implementation-dependent value in its message field. Implementations are encouraged to provide information about the location of the \`assert\` call within the condition whenever possible.
`
    },
    {
        name: "(assertion-violation ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s4"),
        description: `**procedure**: \`(error \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**procedure**: \`(assertion-violation \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`error\` raises a non-continuable exception with condition type \`&error\` and should be used to describe situations for which the \`&error\` condition type is appropriate, typically a situation involving the program's interaction with something outside of the program. \`assertion-violation\` raises a non-continuable exception with condition type \`&assertion\` and should be used to describe situations for which the \`&assertion\` condition type is appropriate, typically an invalid argument to a procedure or invalid value of a subexpression of a syntactic form.

The continuation object with which the exception is raised also includes a \`&who\` condition whose who field is *who* if *who* is not \`#f\`, a \`&message\` condition whose message field is *msg*, and an \`&irritants\` condition whose irritants field is \`(\`*irritant*\` ...)\`.

*who* must be a string, a symbol, or \`#f\` identifying the procedure or syntactic form reporting the error upon whose behalf the error is being reported. It is usually best to identify a procedure the programmer has called rather than some other procedure the programmer may not be aware is involved in carrying out the operation. *msg* must be a string and should describe the exceptional situation. The irritants may be any Scheme objects and should include values that may have caused or been materially involved in the exceptional situation.
`
    },
    {
        name: "(assertion-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s21"),
        description: `**syntax**: \`&assertion\`
**procedure**: \`(make-assertion-violation)\`
**returns: **a condition of type \`&assertion\`
**procedure**: \`(assertion-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&assertion\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

This condition type indicates a specific violation in which the program has passed the wrong number or types of arguments to a procedure. This condition type might be defined as follows.

\`(define-condition-type &assertion &violation\`
\`   make-assertion-violation assertion-violation?)\`
`
    },
    {
        name: "(assertion-violationf ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s2"),
        description: `**procedure**: \`(assertion-violationf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **does not return
**procedure**: \`(errorf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **does not return
**procedure**: \`(warningf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(assoc ",
        endParen: true,
        params: ["obj", "alist"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s58"),
        description: `**procedure**: \`(assq \`*obj*\` \`*alist*\`)\`
**procedure**: \`(assv \`*obj*\` \`*alist*\`)\`
**procedure**: \`(assoc \`*obj*\` \`*alist*\`)\`
**returns: **first element of *alist* whose car is equivalent to *obj*, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`
`
    },
    {
        name: "(assp ",
        endParen: true,
        params: ["procedure", "alist"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s60"),
        description: `**procedure**: \`(assp \`*procedure*\` \`*alist*\`)\`
**returns: **first element of *alist* for whose car *procedure* returns true, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`
`
    },
    {
        name: "(assq ",
        endParen: true,
        params: ["obj", "alist"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s58"),
        description: `**procedure**: \`(assq \`*obj*\` \`*alist*\`)\`
**procedure**: \`(assv \`*obj*\` \`*alist*\`)\`
**procedure**: \`(assoc \`*obj*\` \`*alist*\`)\`
**returns: **first element of *alist* whose car is equivalent to *obj*, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`
`
    },
    {
        name: "(assv ",
        endParen: true,
        params: ["obj", "alist"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s58"),
        description: `**procedure**: \`(assq \`*obj*\` \`*alist*\`)\`
**procedure**: \`(assv \`*obj*\` \`*alist*\`)\`
**procedure**: \`(assoc \`*obj*\` \`*alist*\`)\`
**returns: **first element of *alist* whose car is equivalent to *obj*, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`
`
    },
    {
        name: "(atan ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s133"),
        description: `**procedure**: \`(atan \`*num*\`)\`
**procedure**: \`(atan \`*real1*\` \`*real2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

When passed a single complex argument *num* (the first form), \`atan\` returns the arc tangent of *num*. The arc tangent of a complex number is defined as follows.

When passed two real arguments (the second form), \`atan\` is equivalent to \`(lambda (y x) (angle (make-rectangular x y)))\`.

\`(define pi (* (atan 1) 4))\`
\` (= (* (atan 1.0 0.0) 2) pi) \`=>\` #t\`
`
    },
    {
        name: "(atan ",
        endParen: true,
        params: ["real1", "real2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s133"),
        description: `**procedure**: \`(atan \`*num*\`)\`
**procedure**: \`(atan \`*real1*\` \`*real2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

When passed a single complex argument *num* (the first form), \`atan\` returns the arc tangent of *num*. The arc tangent of a complex number is defined as follows.

When passed two real arguments (the second form), \`atan\` is equivalent to \`(lambda (y x) (angle (make-rectangular x y)))\`.

\`(define pi (* (atan 1) 4))\`
\` (= (* (atan 1.0 0.0) 2) pi) \`=>\` #t\`
`
    },
    {
        name: "(atanh ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s77"),
        description: `**procedure**: \`(asinh \`*num*\`)\`
**procedure**: \`(acosh \`*num*\`)\`
**procedure**: \`(atanh \`*num*\`)\`
**returns: **the hyperbolic arc sine, arc cosine, or arc tangent of *num*
**libraries: **\`(chezscheme)\`

\`(acosh 0.0) \`=>\` 0.0+1.5707963267948966i\`
\` (acosh 1.0) \`=>\` 0.0\`
\` (atanh -1.0) \`=>\` -inf.0\`
`
    },
    {
        name: "(atom? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s2"),
        description: `**procedure**: \`(atom? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is not a pair, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`atom?\` is equivalent to \`(lambda (x) (not (pair? x)))\`.

\`(atom? '(a b c)) \`=>\` #f\`
\` (atom? '(3 . 4)) \`=>\` #f\`
\` (atom? '()) \`=>\` #t\`
\` (atom? 3) \`=>\` #t\`
`
    },
    {
        name: "base-exception-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s12"),
        description: `**thread parameter**: \`base-exception-handler\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a procedure, and the procedure should accept one argument. The default value of \`base-exception-handler\` is the procedure \`default-exception-handler\`.

The value of this parameter is invoked whenever no exception handler established by a program has chosen to handle an exception.
`
    },
    {
        name: "(begin ",
        endParen: true,
        params: ["expr1", "expr2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s4"),
        description: `**syntax**: \`(begin \`*expr1*\` \`*expr2*\` ...)\`
**returns: **the values of the last subexpression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(bignum? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s11"),
        description: `**procedure**: \`(bignum? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a bignum, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\` (bignum? 0) \`=>\` #f\`
\` (bignum? (most-positive-fixnum)) \`=>\` #f\`
\` (bignum? (most-negative-fixnum)) \`=>\` #f\`
\` (bignum? (* (most-positive-fixnum) 2)) \`=>\` #t\`
\` (bignum? 3/4) \`=>\` #f\`
\` (bignum? 'a) \`=>\` #f\`
`
    },
    {
        name: "(binary-port-input-buffer ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(binary-port-input-count ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s18"),
        description: `**procedure**: \`(port-input-count \`*input-port*\`)\`
**procedure**: \`(textual-port-input-count \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-count \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return an exact integer representing the number of characters or bytes left to be read from the port's input buffer, i.e., the difference between the buffer size and index.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart.
`
    },
    {
        name: "(binary-port-input-index ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(binary-port-input-size ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(binary-port-output-buffer ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(binary-port-output-count ",
        endParen: true,
        params: ["binary-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s22"),
        description: `**procedure**: \`(port-output-count \`*output-port*\`)\`
**procedure**: \`(textual-port-output-count \`*textual-output-port*\`)\`
**procedure**: \`(binary-port-output-count \`*binary-output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return an exact integer representing the amount of space in characters or bytes available to be written in the port's output buffer, i.e., the difference between the buffer size and index.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart.
`
    },
    {
        name: "(binary-port-output-index ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(binary-port-output-size ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(binary-port? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s45"),
        description: `**procedure**: \`(binary-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a binary port, \`#f\` otherwise
**procedure**: \`(textual-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a textual port, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(bitwise-and ",
        endParen: true,
        params: ["exint", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s134"),
        description: `**procedure**: \`(bitwise-not \`*exint*\`)\`
**returns: **the bitwise not of *exint*
**procedure**: \`(bitwise-and \`*exint*\` ...)\`
**returns: **the bitwise and of *exint*\` ...\`
**procedure**: \`(bitwise-ior \`*exint*\` ...)\`
**returns: **the bitwise inclusive or of *exint*\` ...\`
**procedure**: \`(bitwise-xor \`*exint*\` ...)\`
**returns: **the bitwise exclusive or of *exint*\` ...\`
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

\`(bitwise-not 0) \`=>\` -1\`
\` (bitwise-not 3) \`=>\` -4 \`
\` \`
\` (bitwise-and #b01101 #b00111) \`=>\` #b00101\`
\` (bitwise-ior #b01101 #b00111) \`=>\` #b01111\`
\` (bitwise-xor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(bitwise-arithmetic-shift ",
        endParen: true,
        params: ["exint1", "exint2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s144"),
        description: `**procedure**: \`(bitwise-arithmetic-shift \`*exint1*\` \`*exint2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

If *exint2* is negative, \`bitwise-arithmetic-shift\` returns the result of arithmetically shifting *exint1* right by \`-\`*exint2* bits. Otherwise, \`bitwise-arithmetic-shift\` returns the result of shifting *exint1* left by *exint2* bits. *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-arithmetic-shift #b10000 -3) \`=>\` #b00010\`
\` (bitwise-arithmetic-shift -1 -1) \`=>\` -1\`
\` (bitwise-arithmetic-shift -64 -3) \`=>\` -8\`
\` (bitwise-arithmetic-shift #b00010 2) \`=>\` #b01000\`
\` (bitwise-arithmetic-shift -1 2) \`=>\` -4\`

Thus, \`bitwise-arithmetic-shift\` behaves as if defined as follows.

\`(define bitwise-arithmetic-shift\`
\`   (lambda (exint1 exint2)\`
\`     (if (< exint2 0)\`
\`         (bitwise-arithmetic-shift-right exint1 (- exint2))\`
\`         (bitwise-arithmetic-shift-left exint1 exint2))))\`
`
    },
    {
        name: "(bitwise-arithmetic-shift-left ",
        endParen: true,
        params: ["exint1", "exint2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s143"),
        description: `**procedure**: \`(bitwise-arithmetic-shift-right \`*exint1*\` \`*exint2*\`)\`
**returns: ***exint1* arithmetically shifted right by *exint2* bits
**procedure**: \`(bitwise-arithmetic-shift-left \`*exint1*\` \`*exint2*\`)\`
**returns: ***exint1* shifted left by *exint2* bits
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* must be nonnegative. *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-arithmetic-shift-right #b10000 3) \`=>\` #b00010\`
\` (bitwise-arithmetic-shift-right -1 1) \`=>\` -1\`
\` (bitwise-arithmetic-shift-right -64 3) \`=>\` -8 \`
\` \`
\` (bitwise-arithmetic-shift-left #b00010 2) \`=>\` #b01000\`
\` (bitwise-arithmetic-shift-left -1 2) \`=>\` -4\`
`
    },
    {
        name: "(bitwise-arithmetic-shift-right ",
        endParen: true,
        params: ["exint1", "exint2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s143"),
        description: `**procedure**: \`(bitwise-arithmetic-shift-right \`*exint1*\` \`*exint2*\`)\`
**returns: ***exint1* arithmetically shifted right by *exint2* bits
**procedure**: \`(bitwise-arithmetic-shift-left \`*exint1*\` \`*exint2*\`)\`
**returns: ***exint1* shifted left by *exint2* bits
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* must be nonnegative. *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-arithmetic-shift-right #b10000 3) \`=>\` #b00010\`
\` (bitwise-arithmetic-shift-right -1 1) \`=>\` -1\`
\` (bitwise-arithmetic-shift-right -64 3) \`=>\` -8 \`
\` \`
\` (bitwise-arithmetic-shift-left #b00010 2) \`=>\` #b01000\`
\` (bitwise-arithmetic-shift-left -1 2) \`=>\` -4\`
`
    },
    {
        name: "(bitwise-bit-count ",
        endParen: true,
        params: ["exint"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s136"),
        description: `**procedure**: \`(bitwise-bit-count \`*exint*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

For nonnegative inputs, \`bitwise-bit-count\` returns the number of bits set in the two's complement representation of *exint*. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in the two's complement representation of *exint*, which is equivalent to \`(bitwise-not (bitwise-bit-count (bitwise-not \`*exint*\`)))\`.

\`(bitwise-bit-count #b00000) \`=>\` 0\`
\` (bitwise-bit-count #b00001) \`=>\` 1\`
\` (bitwise-bit-count #b00100) \`=>\` 1\`
\` (bitwise-bit-count #b10101) \`=>\` 3 \`
\` \`
\` (bitwise-bit-count -1) \`=>\` -1\`
\` (bitwise-bit-count -2) \`=>\` -2\`
\` (bitwise-bit-count -4) \`=>\` -3\`
`
    },
    {
        name: "(bitwise-bit-field ",
        endParen: true,
        params: ["exint1", "exint2", "exint3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s141"),
        description: `**procedure**: \`(bitwise-bit-field \`*exint1*\` \`*exint2*\` \`*exint3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* and *exint3* must be nonnegative, and *exint2* must not be greater than *exint3*. This procedure returns the number represented by extracting from *exint1* the sequence of bits from *exint2* (inclusive) to *exint3* (exclusive). *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-bit-field #b10110 0 3) \`=>\` #b00110\`
\` (bitwise-bit-field #b10110 1 3) \`=>\` #b00011\`
\` (bitwise-bit-field #b10110 2 3) \`=>\` #b00001\`
\` (bitwise-bit-field #b10110 3 3) \`=>\` #b00000\`
`
    },
    {
        name: "(bitwise-bit-set? ",
        endParen: true,
        params: ["exint1", "exint2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s139"),
        description: `**procedure**: \`(bitwise-bit-set? \`*exint1*\` \`*exint2*\`)\`
**returns: **\`#t\` if bit *exint2* of *exint1* is set, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* is taken as a zero-based index for the bits in the two's complement representation of *exint1*. The two's complement representation of a nonnegative number conceptually extends to the left (toward more significant bits) with an infinite number of zero bits, and the two's complement representation of a negative number conceptually extends to the left with an infinite number of one bits. Thus, exact integers can be used to represent arbitrarily large sets, where 0 is the empty set, -1 is the universe, and \`bitwise-bit-set?\` is used to test for membership.

\`(bitwise-bit-set? #b01011 0) \`=>\` #t\`
\` (bitwise-bit-set? #b01011 2) \`=>\` #f \`
\` \`
\` (bitwise-bit-set? -1 0) \`=>\` #t\`
\` (bitwise-bit-set? -1 20) \`=>\` #t\`
\` (bitwise-bit-set? -3 1) \`=>\` #f \`
\` \`
\` (bitwise-bit-set? 0 5000) \`=>\` #f\`
\` (bitwise-bit-set? -1 5000) \`=>\` #t\`
`
    },
    {
        name: "(bitwise-copy-bit ",
        endParen: true,
        params: ["exint1", "exint2", "exint3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s140"),
        description: `**procedure**: \`(bitwise-copy-bit \`*exint1*\` \`*exint2*\` \`*exint3*\`)\`
**returns: ***exint1* with bit *exint2* replaced by *exint3*
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* is taken as a zero-based index for the bits in the two's complement representation of *exint1*. *exint3* must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of *exint3*. *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-copy-bit #b01110 0 1) \`=>\` #b01111\`
\` (bitwise-copy-bit #b01110 2 0) \`=>\` #b01010\`
`
    },
    {
        name: "(bitwise-copy-bit-field ",
        endParen: true,
        params: ["exint1", "exint2", "exint3", "exint4"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s142"),
        description: `**procedure**: \`(bitwise-copy-bit-field \`*exint1*\` \`*exint2*\` \`*exint3*\` \`*exint4*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* and *exint3* must be nonnegative, and *exint2* must not be greater than *exint3*. This procedure returns *exint1* with the *n* bits from *exint2* (inclusive) to *exint3* (exclusive) replaced by the low-order *n* bits of *exint4*. *exint1* and *exint4* are treated as if represented in two's complement, even if they are not represented that way internally.

\`(bitwise-copy-bit-field #b10000 0 3 #b10101) \`=>\` #b10101\`
\` (bitwise-copy-bit-field #b10000 1 3 #b10101) \`=>\` #b10010\`
\` (bitwise-copy-bit-field #b10000 2 3 #b10101) \`=>\` #b10100\`
\` (bitwise-copy-bit-field #b10000 3 3 #b10101) \`=>\` #b10000\`
`
    },
    {
        name: "(bitwise-first-bit-set ",
        endParen: true,
        params: ["exint"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s138"),
        description: `**procedure**: \`(bitwise-first-bit-set \`*exint*\`)\`
**returns: **the index of the least significant bit set in *exint*
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

The input is treated as if represented in two's complement, even if it is not represented that way internally.

If *exint* is 0, \`bitwise-first-bit-set\` returns -1.

\`(bitwise-first-bit-set #b00000) \`=>\` -1\`
\` (bitwise-first-bit-set #b00001) \`=>\` 0\`
\` (bitwise-first-bit-set #b01100) \`=>\` 2 \`
\` \`
\` (bitwise-first-bit-set -1) \`=>\` 0\`
\` (bitwise-first-bit-set -2) \`=>\` 1\`
\` (bitwise-first-bit-set -3) \`=>\` 0\`
`
    },
    {
        name: "(bitwise-if ",
        endParen: true,
        params: ["exint1", "exint2", "exint3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s135"),
        description: `**procedure**: \`(bitwise-if \`*exint1*\` \`*exint2*\` \`*exint3*\`)\`
**returns: **the bitwise "if" of its arguments
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

For each bit set in *exint1*, the corresponding bit of the result is taken from *exint2*, and for each bit not set in *exint1*, the corresponding bit of the result is taken from *x3*.

\`(bitwise-if #b101010 #b111000 #b001100) \`=>\` #b101100\`

\`bitwise-if\` might be defined as follows:

\`(define bitwise-if\`
\`   (lambda (exint1 exint2 exint3)\`
\`     (bitwise-ior\`
\`       (bitwise-and exint1 exint2)\`
\`       (bitwise-and (bitwise-not exint1) exint3))))\`
`
    },
    {
        name: "(bitwise-ior ",
        endParen: true,
        params: ["exint", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s134"),
        description: `**procedure**: \`(bitwise-not \`*exint*\`)\`
**returns: **the bitwise not of *exint*
**procedure**: \`(bitwise-and \`*exint*\` ...)\`
**returns: **the bitwise and of *exint*\` ...\`
**procedure**: \`(bitwise-ior \`*exint*\` ...)\`
**returns: **the bitwise inclusive or of *exint*\` ...\`
**procedure**: \`(bitwise-xor \`*exint*\` ...)\`
**returns: **the bitwise exclusive or of *exint*\` ...\`
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

\`(bitwise-not 0) \`=>\` -1\`
\` (bitwise-not 3) \`=>\` -4 \`
\` \`
\` (bitwise-and #b01101 #b00111) \`=>\` #b00101\`
\` (bitwise-ior #b01101 #b00111) \`=>\` #b01111\`
\` (bitwise-xor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(bitwise-length ",
        endParen: true,
        params: ["exint"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s137"),
        description: `**procedure**: \`(bitwise-length \`*exint*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

This procedure returns the number of bits of the smallest two's complement representation of *exint*, not including the sign bit for negative numbers. For 0 \`bitwise-length\` returns 0.

\`(bitwise-length #b00000) \`=>\` 0\`
\` (bitwise-length #b00001) \`=>\` 1\`
\` (bitwise-length #b00100) \`=>\` 3\`
\` (bitwise-length #b00110) \`=>\` 3 \`
\` \`
\` (bitwise-length -1) \`=>\` 0\`
\` (bitwise-length -6) \`=>\` 3\`
\` (bitwise-length -9) \`=>\` 4\`
`
    },
    {
        name: "(bitwise-not ",
        endParen: true,
        params: ["exint"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s134"),
        description: `**procedure**: \`(bitwise-not \`*exint*\`)\`
**returns: **the bitwise not of *exint*
**procedure**: \`(bitwise-and \`*exint*\` ...)\`
**returns: **the bitwise and of *exint*\` ...\`
**procedure**: \`(bitwise-ior \`*exint*\` ...)\`
**returns: **the bitwise inclusive or of *exint*\` ...\`
**procedure**: \`(bitwise-xor \`*exint*\` ...)\`
**returns: **the bitwise exclusive or of *exint*\` ...\`
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

\`(bitwise-not 0) \`=>\` -1\`
\` (bitwise-not 3) \`=>\` -4 \`
\` \`
\` (bitwise-and #b01101 #b00111) \`=>\` #b00101\`
\` (bitwise-ior #b01101 #b00111) \`=>\` #b01111\`
\` (bitwise-xor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(bitwise-reverse-bit-field ",
        endParen: true,
        params: ["exint1", "exint2", "exint3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s146"),
        description: `**procedure**: \`(bitwise-reverse-bit-field \`*exint1*\` \`*exint2*\` \`*exint3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2* and *exint3* must be nonnegative, and *exint2* must not be greater than *exint3*. This procedure returns the result of reversing the bits of *exint1* from bit *exint2* (inclusive) through bit *exint3* (exclusive). *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-reverse-bit-field #b00011010 0 5) \`=>\` #b00001011\`
\` (bitwise-reverse-bit-field #b01101011 2 7) \`=>\` #b00101111\`
`
    },
    {
        name: "(bitwise-rotate-bit-field ",
        endParen: true,
        params: ["exint1", "exint2", "exint3", "exint4"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s145"),
        description: `**procedure**: \`(bitwise-rotate-bit-field \`*exint1*\` \`*exint2*\` \`*exint3*\` \`*exint4*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

*exint2*, *exint3*, and *exint4* must be nonnegative, and *exint2* must not be greater than *exint3*. This procedure returns the result of shifting the bits of *exint1* from bit *exint2* (inclusive) through bit *exint3* (exclusive) left by \`(mod \`*exint4*\` (- \`*exint3*\` \`*exint2*\`))\` bits, with the bits shifted out of the range inserted at the bottom end of the range. *exint1* is treated as if represented in two's complement, even if it is not represented that way internally.

\`(bitwise-rotate-bit-field #b00011010 0 5 3) \`=>\` #b00010110\`
\` (bitwise-rotate-bit-field #b01101011 2 7 3) \`=>\` #b01011011\`
`
    },
    {
        name: "(bitwise-xor ",
        endParen: true,
        params: ["exint", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s134"),
        description: `**procedure**: \`(bitwise-not \`*exint*\`)\`
**returns: **the bitwise not of *exint*
**procedure**: \`(bitwise-and \`*exint*\` ...)\`
**returns: **the bitwise and of *exint*\` ...\`
**procedure**: \`(bitwise-ior \`*exint*\` ...)\`
**returns: **the bitwise inclusive or of *exint*\` ...\`
**procedure**: \`(bitwise-xor \`*exint*\` ...)\`
**returns: **the bitwise exclusive or of *exint*\` ...\`
**libraries: **\`(rnrs arithmetic bitwise)\`, \`(rnrs)\`

The inputs are treated as if represented in two's complement, even if they are not represented that way internally.

\`(bitwise-not 0) \`=>\` -1\`
\` (bitwise-not 3) \`=>\` -4 \`
\` \`
\` (bitwise-and #b01101 #b00111) \`=>\` #b00101\`
\` (bitwise-ior #b01101 #b00111) \`=>\` #b01111\`
\` (bitwise-xor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(block-read ",
        endParen: true,
        params: ["textual-input-port", "string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s69"),
        description: `**procedure**: \`(block-read \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(block-read \`*textual-input-port*\` \`*string*\` \`*count*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*count* must be a nonnegative fixnum less than or equal to the length of *string*. If not provided, it defaults to the length of *string*.

If *textual-input-port* is at end-of-file, an eof object is returned. Otherwise, *string* is filled with as many characters as are available for reading from *textual-input-port* up to *count*, and the number of characters placed in the string is returned.

If *textual-input-port* is buffered and the buffer is nonempty, the buffered input or a portion thereof is returned; otherwise \`block-read\` bypasses the buffer entirely.
`
    },
    {
        name: "(block-read ",
        endParen: true,
        params: ["textual-input-port", "string", "count"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s69"),
        description: `**procedure**: \`(block-read \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(block-read \`*textual-input-port*\` \`*string*\` \`*count*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*count* must be a nonnegative fixnum less than or equal to the length of *string*. If not provided, it defaults to the length of *string*.

If *textual-input-port* is at end-of-file, an eof object is returned. Otherwise, *string* is filled with as many characters as are available for reading from *textual-input-port* up to *count*, and the number of characters placed in the string is returned.

If *textual-input-port* is buffered and the buffer is nonempty, the buffered input or a portion thereof is returned; otherwise \`block-read\` bypasses the buffer entirely.
`
    },
    {
        name: "(block-write ",
        endParen: true,
        params: ["textual-output-port", "string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s86"),
        description: `**procedure**: \`(block-write \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(block-write \`*textual-output-port*\` \`*string*\` \`*count*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*count* must be a nonnegative fixnum less than or equal to the length of *string*. If not provided, it defaults to the length of *string*.

\`block-write\` writes the first *count* characters of *string* to *textual-output-port*. If the port is buffered and the buffer is nonempty, the buffer is flushed before the contents of *string* are written. In any case, the contents of *string* are written immediately, without passing through the buffer.
`
    },
    {
        name: "(block-write ",
        endParen: true,
        params: ["textual-output-port", "string", "count"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s86"),
        description: `**procedure**: \`(block-write \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(block-write \`*textual-output-port*\` \`*string*\` \`*count*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*count* must be a nonnegative fixnum less than or equal to the length of *string*. If not provided, it defaults to the length of *string*.

\`block-write\` writes the first *count* characters of *string* to *textual-output-port*. If the port is buffered and the buffer is nonempty, the buffer is flushed before the contents of *string* are written. In any case, the contents of *string* are written immediately, without passing through the buffer.
`
    },
    {
        name: "(boolean=? ",
        endParen: true,
        params: ["boolean1", "boolean2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s271"),
        description: `**procedure**: \`(boolean=? \`*boolean1*\` \`*boolean2*\`)\`
**returns: **\`#t\` if the two booleans are the same, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The boolean values \`#t\` and \`#f\` may also be compared with \`eq?\`, which is typically more efficient than \`boolean=?\`.

\`(boolean=? #t #t) \`=>\` #t\`
\` (boolean=? #t #f) \`=>\` #f\`
\` (boolean=? #t (< 3 4)) \`=>\` #t\`
`
    },
    {
        name: "(boolean? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s14"),
        description: `**procedure**: \`(boolean? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is either \`#t\` or \`#f\`, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`boolean?\` is equivalent to \`(lambda (x) (or (eq? x #t) (eq? x #f)))\`.

\`(boolean? #t) \`=>\` #t\`
\` (boolean? #f) \`=>\` #t\`
\` (or (boolean? 't) (boolean? '())) \`=>\` #f\`
`
    },
    {
        name: "(bound-identifier=? ",
        endParen: true,
        params: ["identifier1", "identifier2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s37"),
        description: `**procedure**: \`(free-identifier=? \`*identifier1*\` \`*identifier2*\`)\`
**procedure**: \`(bound-identifier=? \`*identifier1*\` \`*identifier2*\`)\`
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

Symbolic names alone do not distinguish identifiers unless the identifiers are to be used only as symbolic data. The predicates \`free-identifier=?\` and \`bound-identifier=?\` are used to compare identifiers according to their as free references or bound identifiers in a given context.

\`free-identifier=?\` is used to determine whether two identifiers would be equivalent if they were to appear as free identifiers in the output of a transformer. Because identifier references are lexically scoped, this means \`(free-identifier=? \`*id1*\` \`*id2*\`)\` is true if and only if the identifiers *id1* and *id2* refer to the same binding. (For this comparison, two like-named identifiers are assumed to have the same binding if neither is bound.) Literal identifiers (auxiliary keywords) appearing in \`syntax-case\` patterns (such as \`else\` in \`case\` and \`cond\`) are matched with \`free-identifier=?\`.

Similarly, \`bound-identifier=?\` is used to determine whether two identifiers would be equivalent if they were to appear as bound identifiers in the output of a transformer. In other words, if \`bound-identifier=?\` returns true for two identifiers, a binding for one will capture references to the other within its scope. In general, two identifiers are \`bound-identifier=?\` only if both are present in the original program or both are introduced by the same transformer application (perhaps implicitly---see \`datum->syntax\`). \`bound-identifier=?\` can be used for detecting duplicate identifiers in a binding construct or for other preprocessing of a binding construct that requires detecting instances of the bound identifiers.

The definition below is equivalent to the earlier definition of a simplified version of \`cond\` with \`syntax-rules\`, except that \`else\` is recognized via an explicit call to \`free-identifier?\` within a fender rather than via inclusion in the literals list.

\`(define-syntax cond\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(_ (e0 e1 e2 ...))\`
\`        (and (identifier? #'e0) (free-identifier=? #'e0 #'else))\`
\`        #'(begin e1 e2 ...)]\`
\`       [(_ (e0 e1 e2 ...)) #'(if e0 (begin e1 e2 ...))]\`
\`       [(_ (e0 e1 e2 ...) c1 c2 ...)\`
\`        #'(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))\`

With either definition of \`cond\`, \`else\` is not recognized as an auxiliary keyword if an enclosing lexical binding for \`else\` exists. For example,

\`(let ([else #f])\`
\`   (cond [else (write "oops")]))\`

does write \`"oops"\`, since \`else\` is bound lexically and is therefore not the same \`else\` that appears in the definition of \`cond\`.

The following definition of unnamed \`let\` uses \`bound-identifier=?\` to detect duplicate identifiers.

\`(define-syntax let\`
\`   (lambda (x)\`
\`     (define ids?\`
\`       (lambda (ls)\`
\`         (or (null? ls)\`
\`             (and (identifier? (car ls)) (ids? (cdr ls))))))\`
\`     (define unique-ids?\`
\`       (lambda (ls)\`
\`         (or (null? ls)\`
\`             (and (not (memp\`
\`                         (lambda (x) (bound-identifier=? x (car ls)))\`
\`                         (cdr ls)))\`
\`                  (unique-ids? (cdr ls))))))\`
\`     (syntax-case x ()\`
\`       [(_ ((i e) ...) b1 b2 ...)\`
\`        (and (ids? #'(i ...)) (unique-ids? #'(i ...)))\`
\`        #'((lambda (i ...) b1 b2 ...) e ...)])))\`

With the definition of \`let\` above, the expression

\`(let ([a 3] [a 4]) (+ a a))\`

is a syntax violation, whereas

\`(let ([a 0])\`
\`   (let-syntax ([dolet (lambda (x)\`
\`                         (syntax-case x ()\`
\`                           [(_ b)\`
\`                            #'(let ([a 3] [b 4]) (+ a b))]))])\`
\`     (dolet a)))\`

evaluates to \`7\` since the identifier \`a\` introduced by \`dolet\` and the identifier \`a\` extracted from the input form are not \`bound-identifier=?\`. Since both occurrences of \`a\`, however, if left as free references, would refer to the same binding for \`a\`, \`free-identifier=?\` would not distinguish them.

Two identifiers that are \`free-identifier=?\` may not be \`bound-identifier=?\`. An identifier introduced by a transformer may refer to the same enclosing binding as an identifier not introduced by the transformer, but an introduced binding for one will not capture references to the other. On the other hand, identifiers that are \`bound-identifier=?\` are \`free-identifier=?\`, as long as the identifiers have valid bindings in the context where they are compared.
`
    },
    {
        name: "(box ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s83"),
        description: `**procedure**: \`(box \`*obj*\`)\`
**returns: **a new box containing *obj*
**libraries: **\`(chezscheme)\`

\` (box 'a) \`=>\` #&a\`
\` (box (box '(a b c))) \`=>\` #&#&(a b c)\`
`
    },
    {
        name: "(box-cas! ",
        endParen: true,
        params: ["box", "old-obj", "new-obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s86"),
        description: `**procedure**: \`(box-cas! \`*box*\` \`*old-obj*\` \`*new-obj*\`)\`
**returns: **\`#t\` if *box* is changed, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*box* must be mutable. \`box-cas!\` atomically changes the content of *box* to *new-obj* if the replaced content is \`eq?\` to *old-obj*. If the content of *box* that would be replaced is not \`eq?\` to *old-obj*, then *box* is unchanged.

\`(define b (box 'old))\`
\` (box-cas! b 'old 'new) \`=>\` #t\`
\` (unbox b) \`=>\` 'new\`
\` (box-cas! b 'other 'wrong) \`=>\` #f\`
\` (unbox b) \`=>\` 'new\`
`
    },
    {
        name: "(box-immutable ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s88"),
        description: `**procedure**: \`(box-immutable \`*obj*\`)\`
**returns: **a new immutable box containing *obj*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(box? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s82"),
        description: `**procedure**: \`(box? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a box, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (box? '#&a) \`=>\` #t\`
\` (box? 'a) \`=>\` #f\`
\` (box? (box 3)) \`=>\` #t\`
`
    },
    {
        name: "(break ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s17"),
        description: `**procedure**: \`(break \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**procedure**: \`(break \`*who*\`)\`
**procedure**: \`(break)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(break ",
        endParen: true,
        params: ["who"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s17"),
        description: `**procedure**: \`(break \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**procedure**: \`(break \`*who*\`)\`
**procedure**: \`(break)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(break)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s17"),
        description: `**procedure**: \`(break \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**procedure**: \`(break \`*who*\`)\`
**procedure**: \`(break)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "break-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s19"),
        description: `**thread parameter**: \`break-handler\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a procedure. The current break handler is called by \`break\`, which passes along its arguments. See \`break\` for a description of the default break handler. The example below shows how to disable breaks.

\`(break-handler (lambda args (void)))\`
`
    },
    {
        name: "(buffer-mode ",
        endParen: true,
        params: ["symbol"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s27"),
        description: `**syntax**: \`(buffer-mode \`*symbol*\`)\`
**returns: ***symbol*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*symbol* must be one of the symbols \`block\`, \`line\`, or \`none\`. The expression \`(buffer-mode \`*symbol*\`)\` is equivalent to the expression \`(quote \`*symbol*\`)\` except that the former checks at expansion time that *symbol* is one of the buffer-mode symbols. The \`buffer-mode\` syntax provides useful documentation as well.

\`(buffer-mode block) \`=>\` block\`
\` (buffer-mode cushion) \`=>\` \`*syntax violation*
`
    },
    {
        name: "(buffer-mode? ",
        endParen: true,
        params: ["obj"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s28"),
        description: `**syntax**: \`(buffer-mode? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a valid buffer mode, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

\`(buffer-mode? 'block) \`=>\` #t\`
\` (buffer-mode? 'line) \`=>\` #t\`
\` (buffer-mode? 'none) \`=>\` #t\`
\` (buffer-mode? 'something-else) \`=>\` #f\`
`
    },
    {
        name: "(bwp-object? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s28"),
        description: `**procedure**: \`(bwp-object? \`*obj*\`)\`
**returns: **\`#t\` if obj is the broken weak-pair object, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(bwp-object? #!bwp) \`=>\` #t\`
\` (bwp-object? 'bwp) \`=>\` #f \`
\` \`
\` (define x (cons 'a 'b))\`
\` (define p (weak-cons x '()))\`
\` (set! x '*)\`
\` (collect (collect-maximum-generation))\`
\` (car p) \`=>\` #!bwp\`
\` (bwp-object? (car p)) \`=>\` #t\`
`
    },
    {
        name: "(bytes-allocated)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s223"),
        description: `**procedure**: \`(bytes-allocated)\`
**procedure**: \`(bytes-allocated \`*g*\`)\`
**returns: **the number of bytes currently allocated
**libraries: **\`(chezscheme)\`

If *g* is supplied, \`bytes-allocated\` returns the number of bytes currently allocated for Scheme objects in the specified generation. *g* must be a nonnegative exact integer no greater than the maximum nonstatic generation, i.e., the value returned by \`collect-maximum-generation\`, or the symbol \`static\`. If *g* is not supplied, \`bytes-allocated\` returns the total number of bytes allocated in all generations.
`
    },
    {
        name: "(bytes-allocated ",
        endParen: true,
        params: ["g"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s223"),
        description: `**procedure**: \`(bytes-allocated)\`
**procedure**: \`(bytes-allocated \`*g*\`)\`
**returns: **the number of bytes currently allocated
**libraries: **\`(chezscheme)\`

If *g* is supplied, \`bytes-allocated\` returns the number of bytes currently allocated for Scheme objects in the specified generation. *g* must be a nonnegative exact integer no greater than the maximum nonstatic generation, i.e., the value returned by \`collect-maximum-generation\`, or the symbol \`static\`. If *g* is not supplied, \`bytes-allocated\` returns the total number of bytes allocated in all generations.
`
    },
    {
        name: "(bytes-deallocated)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s225"),
        description: `**procedure**: \`(bytes-deallocated)\`
**returns: **the total number of bytes deallocated by the garbage collector
**libraries: **\`(chezscheme)\`

The total number of bytes allocated by the current process, whether still in use or not, can be obtained by summing \`(bytes-deallocated)\` and \`(bytes-allocated)\` and possibly subtracting \`(initial-bytes-allocated)\`.
`
    },
    {
        name: "(bytevector ",
        endParen: true,
        params: ["fill", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s60"),
        description: `**procedure**: \`(bytevector \`*fill*\` ...)\`
**returns: **a new bytevector containing *fill*\` ...\`
**libraries: **\`(chezscheme)\`

Each *fill* value must be an exact integer representing a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

\`(bytevector) \`=>\` #vu8()\`
\` (bytevector 1 3 5) \`=>\` #vu8(1 3 5)\`
\` (bytevector -1 -3 -5) \`=>\` #vu8(255 253 251)\`
`
    },
    {
        name: "(bytevector->immutable-bytevector ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s67"),
        description: `**procedure**: \`(bytevector->immutable-bytevector \`*bytevector*\`)\`
**returns: **an immutable bytevector equal to *bytevector*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(bytevector->s8-list ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s61"),
        description: `**procedure**: \`(bytevector->s8-list \`*bytevector*\`)\`
**returns: **a new list of the 8-bit signed elements of *bytevector*
**libraries: **\`(chezscheme)\`

The values in the returned list are exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. \`bytevector->s8-list\` is similar to the Revised Report \`bytevector->u8-list\` except the values in the returned list are signed rather than unsigned.

\`(bytevector->s8-list (make-bytevector 0)) \`=>\` ()\`
\` (bytevector->s8-list #vu8(1 127 128 255)) \`=>\` (1 127 -128 -1) \`
\` \`
\` (let ([v #vu8(1 2 3 255)])\`
\`   (apply * (bytevector->s8-list v))) \`=>\` -6\`
`
    },
    {
        name: "(bytevector->sint-list ",
        endParen: true,
        params: ["bytevector", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s260"),
        description: `**procedure**: \`(bytevector->uint-list \`*bytevector*\` \`*eness*\` \`*size*\`)\`
**returns: **a new list of the *size*-byte unsigned elements of *bytevector*
**procedure**: \`(bytevector->sint-list \`*bytevector*\` \`*eness*\` \`*size*\`)\`
**returns: **a new list of the *size*-byte signed elements of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*eness* must be a valid endianness symbol naming the endianness. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. It must be a value that evenly divides the length of *bytevector*.

\`(bytevector->uint-list (make-bytevector 0) 'little 3) \`=>\` () \`
\` \`
\` (let ([v #vu8(1 2 3 4 5 6)])\`
\`   (bytevector->uint-list v 'big 3)) \`=>\` (#x010203 #x040506) \`
\` \`
\` (let ([v (make-bytevector 80 -1)])\`
\`   (bytevector->sint-list v 'big 20)) \`=>\` (-1 -1 -1 -1)\`
`
    },
    {
        name: "(bytevector->string ",
        endParen: true,
        params: ["bytevector", "transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s91"),
        description: `**procedure**: \`(bytevector->string \`*bytevector*\` \`*transcoder*\`)\`
**returns: **a string containing the characters encoded in *bytevector*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This operation, at least in effect, creates a bytevector input port with the specified *transcoder* from which all of the available characters are read, as if by \`get-string-all\`, and placed into the output string.

\`(let ([tx (make-transcoder (utf-8-codec) (eol-style lf)\`
\`             (error-handling-mode replace))])\`
\`   (bytevector->string #vu8(97 98 99) tx)) \`=>\` "abc"\`
`
    },
    {
        name: "(bytevector->u8-list ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s252"),
        description: `**procedure**: \`(bytevector->u8-list \`*bytevector*\`)\`
**returns: **a list of the 8-bit unsigned elements of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

\`(bytevector->u8-list (make-bytevector 0)) \`=>\` ()\`
\` (bytevector->u8-list #vu8(1 127 128 255)) \`=>\` (1 127 128 255) \`
\` \`
\` (let ([v #vu8(1 2 3 255)])\`
\`   (apply * (bytevector->u8-list v))) \`=>\` 1530\`
`
    },
    {
        name: "(bytevector->uint-list ",
        endParen: true,
        params: ["bytevector", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s260"),
        description: `**procedure**: \`(bytevector->uint-list \`*bytevector*\` \`*eness*\` \`*size*\`)\`
**returns: **a new list of the *size*-byte unsigned elements of *bytevector*
**procedure**: \`(bytevector->sint-list \`*bytevector*\` \`*eness*\` \`*size*\`)\`
**returns: **a new list of the *size*-byte signed elements of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*eness* must be a valid endianness symbol naming the endianness. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. It must be a value that evenly divides the length of *bytevector*.

\`(bytevector->uint-list (make-bytevector 0) 'little 3) \`=>\` () \`
\` \`
\` (let ([v #vu8(1 2 3 4 5 6)])\`
\`   (bytevector->uint-list v 'big 3)) \`=>\` (#x010203 #x040506) \`
\` \`
\` (let ([v (make-bytevector 80 -1)])\`
\`   (bytevector->sint-list v 'big 20)) \`=>\` (-1 -1 -1 -1)\`
`
    },
    {
        name: "(bytevector-compress ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s70"),
        description: `**procedure**: \`(bytevector-compress \`*bytevector*\`)\`
**returns: **a new bytevector containing compressed content of *bytevector*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(bytevector-copy ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s246"),
        description: `**procedure**: \`(bytevector-copy \`*bytevector*\`)\`
**returns: **a new bytevector that is a copy of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

\`bytevector-copy\` creates a new bytevector with the same length and contents as *bytevector*.

\`(bytevector-copy #vu8(1 127 128 255)) \`=>\` #vu8(1 127 128 255) \`
\` \`
\` (let ([v #vu8(1 127 128 255)])\`
\`   (eq? v (bytevector-copy v))) \`=>\` #f\`
`
    },
    {
        name: "(bytevector-copy! ",
        endParen: true,
        params: ["src", "src-start", "dst", "dst-start", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s247"),
        description: `**procedure**: \`(bytevector-copy! \`*src*\` \`*src-start*\` \`*dst*\` \`*dst-start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*src* and *dst* must be bytevectors. *src-start*, *dst-start*, and *n* must be exact nonnegative integers. The sum of *src-start* and *n* must not exceed the length of *src*, and the sum of *dst-start* and *n* must not exceed the length of *dst*.

\`bytevector-copy!\` overwrites the *n* bytes of *dst* starting at *dst-start* with the *n* bytes of *src* starting at *src-start*. This works even if *dst* is the same bytevector as *src* and the source and destination locations overlap. That is, the destination is filled with the bytes that appeared at the source before the operation began.

\`(define v1 #vu8(31 63 95 127 159 191 223 255))\`
\` (define v2 (make-bytevector 10 0)) \`
\` \`
\` (bytevector-copy! v1 2 v2 1 4)\`
\` v2 \`=>\` #vu8(0 95 127 159 191 0 0 0 0 0)\`
\`  \`
\` (bytevector-copy! v1 5 v2 7 3)\`
\` v2 \`=>\` #vu8(0 95 127 159 191 0 0 191 223 255)\`
\`  \`
\` (bytevector-copy! v2 3 v2 0 6)\`
\` v2 \`=>\` #vu8(159 191 0 0 191 223 0 191 223 255)\`
\`  \`
\` (bytevector-copy! v2 0 v2 1 9)\`
\` v2 \`=>\` #vu8(159 159 191 0 0 191 223 0 191 223)\`
`
    },
    {
        name: "(bytevector-fill! ",
        endParen: true,
        params: ["bytevector", "fill"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s245"),
        description: `**procedure**: \`(bytevector-fill! \`*bytevector*\` \`*fill*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

The *fill* value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

\`bytevector-fill!\` replaces each element of *bytevector* with *fill*.

\`(let ([v (make-bytevector 6)])\`
\`   (bytevector-fill! v 255)\`
\`   v) \`=>\` #vu8(255 255 255 255 255 255) \`
\` \`
\` (let ([v (make-bytevector 6)])\`
\`   (bytevector-fill! v -128)\`
\`   v) \`=>\` #vu8(128 128 128 128 128 128)\`
`
    },
    {
        name: "(bytevector-ieee-double-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s262"),
        description: `**procedure**: \`(bytevector-ieee-single-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the single floating-point value at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-ieee-double-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the double floating-point value at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an inexact real number. Examples appear after the mutation operators below.
`
    },
    {
        name: "(bytevector-ieee-double-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "x"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s263"),
        description: `**procedure**: \`(bytevector-ieee-single-native-set! \`*bytevector*\` \`*n*\` \`*x*\`)\`
**procedure**: \`(bytevector-ieee-double-native-set! \`*bytevector*\` \`*n*\` \`*x*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

These procedures store the given value as an IEEE-754 single or double floating-point value at index *n* (zero-based) of *bytevector*.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-ieee-single-native-set! v 0 .125)\`
\` (bytevector-ieee-single-native-set! v 4 -3/2)\`
\` (list\`
\`   (bytevector-ieee-single-native-ref v 0)\`
\`   (bytevector-ieee-single-native-ref v 4)) \`=>\` (0.125 -1.5) \`
\` \`
\` (bytevector-ieee-double-native-set! v 0 1e23)\`
\` (bytevector-ieee-double-native-ref v 0) \`=>\` 1e23\`
`
    },
    {
        name: "(bytevector-ieee-double-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s264"),
        description: `**procedure**: \`(bytevector-ieee-single-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the single floating-point value at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-ieee-double-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the double floating-point value at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an inexact real number. Examples appear after the mutation operators below.
`
    },
    {
        name: "(bytevector-ieee-double-set! ",
        endParen: true,
        params: ["bytevector", "n", "x", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s265"),
        description: `**procedure**: \`(bytevector-ieee-single-set! \`*bytevector*\` \`*n*\` \`*x*\` \`*eness*\`)\`
**procedure**: \`(bytevector-ieee-double-set! \`*bytevector*\` \`*n*\` \`*x*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value as an IEEE-754 single or double floating-point value at index *n* (zero-based) of *bytevector*.

\`(define v (make-bytevector 10 #xc7))\`
\` (bytevector-ieee-single-set! v 1 .125 'little)\`
\` (bytevector-ieee-single-set! v 6 -3/2 'big)\`
\` (list\`
\`   (bytevector-ieee-single-ref v 1 'little)\`
\`   (bytevector-ieee-single-ref v 6 'big)) \`=>\` (0.125 -1.5)\`
\` v \`=>\` #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0) \`
\` \`
\` (bytevector-ieee-double-set! v 1 1e23 'big)\`
\` (bytevector-ieee-double-ref v 1 'big) \`=>\` 1e23\`
`
    },
    {
        name: "(bytevector-ieee-single-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s262"),
        description: `**procedure**: \`(bytevector-ieee-single-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the single floating-point value at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-ieee-double-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the double floating-point value at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an inexact real number. Examples appear after the mutation operators below.
`
    },
    {
        name: "(bytevector-ieee-single-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "x"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s263"),
        description: `**procedure**: \`(bytevector-ieee-single-native-set! \`*bytevector*\` \`*n*\` \`*x*\`)\`
**procedure**: \`(bytevector-ieee-double-native-set! \`*bytevector*\` \`*n*\` \`*x*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

These procedures store the given value as an IEEE-754 single or double floating-point value at index *n* (zero-based) of *bytevector*.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-ieee-single-native-set! v 0 .125)\`
\` (bytevector-ieee-single-native-set! v 4 -3/2)\`
\` (list\`
\`   (bytevector-ieee-single-native-ref v 0)\`
\`   (bytevector-ieee-single-native-ref v 4)) \`=>\` (0.125 -1.5) \`
\` \`
\` (bytevector-ieee-double-native-set! v 0 1e23)\`
\` (bytevector-ieee-double-native-ref v 0) \`=>\` 1e23\`
`
    },
    {
        name: "(bytevector-ieee-single-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s264"),
        description: `**procedure**: \`(bytevector-ieee-single-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the single floating-point value at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-ieee-double-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the double floating-point value at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an inexact real number. Examples appear after the mutation operators below.
`
    },
    {
        name: "(bytevector-ieee-single-set! ",
        endParen: true,
        params: ["bytevector", "n", "x", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s265"),
        description: `**procedure**: \`(bytevector-ieee-single-set! \`*bytevector*\` \`*n*\` \`*x*\` \`*eness*\`)\`
**procedure**: \`(bytevector-ieee-double-set! \`*bytevector*\` \`*n*\` \`*x*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value as an IEEE-754 single or double floating-point value at index *n* (zero-based) of *bytevector*.

\`(define v (make-bytevector 10 #xc7))\`
\` (bytevector-ieee-single-set! v 1 .125 'little)\`
\` (bytevector-ieee-single-set! v 6 -3/2 'big)\`
\` (list\`
\`   (bytevector-ieee-single-ref v 1 'little)\`
\`   (bytevector-ieee-single-ref v 6 'big)) \`=>\` (0.125 -1.5)\`
\` v \`=>\` #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0) \`
\` \`
\` (bytevector-ieee-double-set! v 1 1e23 'big)\`
\` (bytevector-ieee-double-ref v 1 'big) \`=>\` 1e23\`
`
    },
    {
        name: "(bytevector-length ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s243"),
        description: `**procedure**: \`(bytevector-length \`*bytevector*\`)\`
**returns: **the length of *bytevector* in 8-bit bytes
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

\` (bytevector-length #vu8()) \`=>\` 0\`
\` (bytevector-length #vu8(1 2 3)) \`=>\` 3\`
\` (bytevector-length (make-bytevector 300)) \`=>\` 300\`
`
    },
    {
        name: "(bytevector-s16-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s254"),
        description: `**procedure**: \`(bytevector-u16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\`

If native endianness is big:

\`(bytevector-u16-native-ref v 2) \`=>\` #xfe56\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x-1aa\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x7898 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`

If native endianness is little:

\`(bytevector-u16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x-6788 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x-67874523a901cbee\`
`
    },
    {
        name: "(bytevector-s16-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "s16"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s255"),
        description: `**procedure**: \`(bytevector-u16-native-set! \`*bytevector*\` \`*n*\` \`*u16*\`)\`
**procedure**: \`(bytevector-s16-native-set! \`*bytevector*\` \`*n*\` \`*s16*\`)\`
**procedure**: \`(bytevector-u32-native-set! \`*bytevector*\` \`*n*\` \`*u32*\`)\`
**procedure**: \`(bytevector-s32-native-set! \`*bytevector*\` \`*n*\` \`*s32*\`)\`
**procedure**: \`(bytevector-u64-native-set! \`*bytevector*\` \`*n*\` \`*u64*\`)\`
**procedure**: \`(bytevector-s64-native-set! \`*bytevector*\` \`*n*\` \`*s64*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length *bytevector*. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-native-set! v 0 #xfe56)\`
\` (bytevector-s16-native-set! v 2 #x-1aa)\`
\` (bytevector-s16-native-set! v 4 #x7898)\`

If native endianness is big:

\`v \`=>\` #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\`

\`(define v (make-bytevector 16 0))\`
\` (bytevector-u32-native-set! v 0 #x1234fe56)\`
\` (bytevector-s32-native-set! v 4 #x1234fe56)\`
\` (bytevector-s32-native-set! v 8 #x-23458768)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\`
\`   \`\`      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\`

\`(define v (make-bytevector 24 0))\`
\` (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 16 #x-67874523a901cbee)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\`

If native endianness is little:

\`v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\`
`
    },
    {
        name: "(bytevector-s16-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s256"),
        description: `**procedure**: \`(bytevector-u16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\`
\` (bytevector-u16-ref v 0 (endianness big)) \`=>\` #x1234\`
\` (bytevector-s16-ref v 1 (endianness big)) \`=>\` #x34fe\`
\` (bytevector-s16-ref v 5 (endianness big)) \`=>\` #x-4588 \`
\` \`
\` (bytevector-u32-ref v 2 'big) \`=>\` #xfe56dcba\`
\` (bytevector-s32-ref v 3 'big) \`=>\` #x56dcba78\`
\` (bytevector-s32-ref v 4 'big) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-ref v 0 'big) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-ref v 1 'big) \`=>\` #x34fe56dcba78989a \`
\` \`
\` (bytevector-u16-ref v 0 (endianness little)) \`=>\` #x3412\`
\` (bytevector-s16-ref v 1 (endianness little)) \`=>\` #x-1cc\`
\` (bytevector-s16-ref v 5 (endianness little)) \`=>\` #x78ba \`
\` \`
\` (bytevector-u32-ref v 2 'little) \`=>\` #xbadc56fe\`
\` (bytevector-s32-ref v 3 'little) \`=>\` #x78badc56\`
\` (bytevector-s32-ref v 4 'little) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-ref v 0 'little) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-ref v 1 'little) \`=>\` #x-6567874523a901cc\`
`
    },
    {
        name: "(bytevector-s16-set! ",
        endParen: true,
        params: ["bytevector", "n", "s16", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s257"),
        description: `**procedure**: \`(bytevector-u16-set! \`*bytevector*\` \`*n*\` \`*u16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s16-set! \`*bytevector*\` \`*n*\` \`*s16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u32-set! \`*bytevector*\` \`*n*\` \`*u32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s32-set! \`*bytevector*\` \`*n*\` \`*s32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u64-set! \`*bytevector*\` \`*n*\` \`*u64*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s64-set! \`*bytevector*\` \`*n*\` \`*s64*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-set! v 0 #xfe56 (endianness big))\`
\` (bytevector-s16-set! v 3 #x-1aa (endianness little))\`
\` (bytevector-s16-set! v 5 #x7898 (endianness big))\`
\` v \`=>\` #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \`
\` \`
\` (define v (make-bytevector 16 0))\`
\` (bytevector-u32-set! v 0 #x1234fe56 'little)\`
\` (bytevector-s32-set! v 6 #x1234fe56 'big)\`
\` (bytevector-s32-set! v 11 #x-23458768 'little)\`
\` v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x0) \`
\` \`
\` (define v (make-bytevector 28 0))\`
\` (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\`
\` (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\`
\` (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\`
\` v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\`
`
    },
    {
        name: "(bytevector-s24-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-s24-set! ",
        endParen: true,
        params: ["bytevector", "n", "s24", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-s32-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s254"),
        description: `**procedure**: \`(bytevector-u16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\`

If native endianness is big:

\`(bytevector-u16-native-ref v 2) \`=>\` #xfe56\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x-1aa\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x7898 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`

If native endianness is little:

\`(bytevector-u16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x-6788 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x-67874523a901cbee\`
`
    },
    {
        name: "(bytevector-s32-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "s32"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s255"),
        description: `**procedure**: \`(bytevector-u16-native-set! \`*bytevector*\` \`*n*\` \`*u16*\`)\`
**procedure**: \`(bytevector-s16-native-set! \`*bytevector*\` \`*n*\` \`*s16*\`)\`
**procedure**: \`(bytevector-u32-native-set! \`*bytevector*\` \`*n*\` \`*u32*\`)\`
**procedure**: \`(bytevector-s32-native-set! \`*bytevector*\` \`*n*\` \`*s32*\`)\`
**procedure**: \`(bytevector-u64-native-set! \`*bytevector*\` \`*n*\` \`*u64*\`)\`
**procedure**: \`(bytevector-s64-native-set! \`*bytevector*\` \`*n*\` \`*s64*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length *bytevector*. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-native-set! v 0 #xfe56)\`
\` (bytevector-s16-native-set! v 2 #x-1aa)\`
\` (bytevector-s16-native-set! v 4 #x7898)\`

If native endianness is big:

\`v \`=>\` #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\`

\`(define v (make-bytevector 16 0))\`
\` (bytevector-u32-native-set! v 0 #x1234fe56)\`
\` (bytevector-s32-native-set! v 4 #x1234fe56)\`
\` (bytevector-s32-native-set! v 8 #x-23458768)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\`
\`   \`\`      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\`

\`(define v (make-bytevector 24 0))\`
\` (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 16 #x-67874523a901cbee)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\`

If native endianness is little:

\`v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\`
`
    },
    {
        name: "(bytevector-s32-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s256"),
        description: `**procedure**: \`(bytevector-u16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\`
\` (bytevector-u16-ref v 0 (endianness big)) \`=>\` #x1234\`
\` (bytevector-s16-ref v 1 (endianness big)) \`=>\` #x34fe\`
\` (bytevector-s16-ref v 5 (endianness big)) \`=>\` #x-4588 \`
\` \`
\` (bytevector-u32-ref v 2 'big) \`=>\` #xfe56dcba\`
\` (bytevector-s32-ref v 3 'big) \`=>\` #x56dcba78\`
\` (bytevector-s32-ref v 4 'big) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-ref v 0 'big) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-ref v 1 'big) \`=>\` #x34fe56dcba78989a \`
\` \`
\` (bytevector-u16-ref v 0 (endianness little)) \`=>\` #x3412\`
\` (bytevector-s16-ref v 1 (endianness little)) \`=>\` #x-1cc\`
\` (bytevector-s16-ref v 5 (endianness little)) \`=>\` #x78ba \`
\` \`
\` (bytevector-u32-ref v 2 'little) \`=>\` #xbadc56fe\`
\` (bytevector-s32-ref v 3 'little) \`=>\` #x78badc56\`
\` (bytevector-s32-ref v 4 'little) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-ref v 0 'little) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-ref v 1 'little) \`=>\` #x-6567874523a901cc\`
`
    },
    {
        name: "(bytevector-s32-set! ",
        endParen: true,
        params: ["bytevector", "n", "s32", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s257"),
        description: `**procedure**: \`(bytevector-u16-set! \`*bytevector*\` \`*n*\` \`*u16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s16-set! \`*bytevector*\` \`*n*\` \`*s16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u32-set! \`*bytevector*\` \`*n*\` \`*u32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s32-set! \`*bytevector*\` \`*n*\` \`*s32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u64-set! \`*bytevector*\` \`*n*\` \`*u64*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s64-set! \`*bytevector*\` \`*n*\` \`*s64*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-set! v 0 #xfe56 (endianness big))\`
\` (bytevector-s16-set! v 3 #x-1aa (endianness little))\`
\` (bytevector-s16-set! v 5 #x7898 (endianness big))\`
\` v \`=>\` #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \`
\` \`
\` (define v (make-bytevector 16 0))\`
\` (bytevector-u32-set! v 0 #x1234fe56 'little)\`
\` (bytevector-s32-set! v 6 #x1234fe56 'big)\`
\` (bytevector-s32-set! v 11 #x-23458768 'little)\`
\` v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x0) \`
\` \`
\` (define v (make-bytevector 28 0))\`
\` (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\`
\` (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\`
\` (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\`
\` v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\`
`
    },
    {
        name: "(bytevector-s40-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-s40-set! ",
        endParen: true,
        params: ["bytevector", "n", "s40", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-s48-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-s48-set! ",
        endParen: true,
        params: ["bytevector", "n", "s48", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-s56-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-s56-set! ",
        endParen: true,
        params: ["bytevector", "n", "s56", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-s64-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s254"),
        description: `**procedure**: \`(bytevector-u16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\`

If native endianness is big:

\`(bytevector-u16-native-ref v 2) \`=>\` #xfe56\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x-1aa\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x7898 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`

If native endianness is little:

\`(bytevector-u16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x-6788 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x-67874523a901cbee\`
`
    },
    {
        name: "(bytevector-s64-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "s64"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s255"),
        description: `**procedure**: \`(bytevector-u16-native-set! \`*bytevector*\` \`*n*\` \`*u16*\`)\`
**procedure**: \`(bytevector-s16-native-set! \`*bytevector*\` \`*n*\` \`*s16*\`)\`
**procedure**: \`(bytevector-u32-native-set! \`*bytevector*\` \`*n*\` \`*u32*\`)\`
**procedure**: \`(bytevector-s32-native-set! \`*bytevector*\` \`*n*\` \`*s32*\`)\`
**procedure**: \`(bytevector-u64-native-set! \`*bytevector*\` \`*n*\` \`*u64*\`)\`
**procedure**: \`(bytevector-s64-native-set! \`*bytevector*\` \`*n*\` \`*s64*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length *bytevector*. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-native-set! v 0 #xfe56)\`
\` (bytevector-s16-native-set! v 2 #x-1aa)\`
\` (bytevector-s16-native-set! v 4 #x7898)\`

If native endianness is big:

\`v \`=>\` #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\`

\`(define v (make-bytevector 16 0))\`
\` (bytevector-u32-native-set! v 0 #x1234fe56)\`
\` (bytevector-s32-native-set! v 4 #x1234fe56)\`
\` (bytevector-s32-native-set! v 8 #x-23458768)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\`
\`   \`\`      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\`

\`(define v (make-bytevector 24 0))\`
\` (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 16 #x-67874523a901cbee)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\`

If native endianness is little:

\`v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\`
`
    },
    {
        name: "(bytevector-s64-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s256"),
        description: `**procedure**: \`(bytevector-u16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\`
\` (bytevector-u16-ref v 0 (endianness big)) \`=>\` #x1234\`
\` (bytevector-s16-ref v 1 (endianness big)) \`=>\` #x34fe\`
\` (bytevector-s16-ref v 5 (endianness big)) \`=>\` #x-4588 \`
\` \`
\` (bytevector-u32-ref v 2 'big) \`=>\` #xfe56dcba\`
\` (bytevector-s32-ref v 3 'big) \`=>\` #x56dcba78\`
\` (bytevector-s32-ref v 4 'big) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-ref v 0 'big) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-ref v 1 'big) \`=>\` #x34fe56dcba78989a \`
\` \`
\` (bytevector-u16-ref v 0 (endianness little)) \`=>\` #x3412\`
\` (bytevector-s16-ref v 1 (endianness little)) \`=>\` #x-1cc\`
\` (bytevector-s16-ref v 5 (endianness little)) \`=>\` #x78ba \`
\` \`
\` (bytevector-u32-ref v 2 'little) \`=>\` #xbadc56fe\`
\` (bytevector-s32-ref v 3 'little) \`=>\` #x78badc56\`
\` (bytevector-s32-ref v 4 'little) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-ref v 0 'little) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-ref v 1 'little) \`=>\` #x-6567874523a901cc\`
`
    },
    {
        name: "(bytevector-s64-set! ",
        endParen: true,
        params: ["bytevector", "n", "s64", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s257"),
        description: `**procedure**: \`(bytevector-u16-set! \`*bytevector*\` \`*n*\` \`*u16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s16-set! \`*bytevector*\` \`*n*\` \`*s16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u32-set! \`*bytevector*\` \`*n*\` \`*u32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s32-set! \`*bytevector*\` \`*n*\` \`*s32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u64-set! \`*bytevector*\` \`*n*\` \`*u64*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s64-set! \`*bytevector*\` \`*n*\` \`*s64*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-set! v 0 #xfe56 (endianness big))\`
\` (bytevector-s16-set! v 3 #x-1aa (endianness little))\`
\` (bytevector-s16-set! v 5 #x7898 (endianness big))\`
\` v \`=>\` #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \`
\` \`
\` (define v (make-bytevector 16 0))\`
\` (bytevector-u32-set! v 0 #x1234fe56 'little)\`
\` (bytevector-s32-set! v 6 #x1234fe56 'big)\`
\` (bytevector-s32-set! v 11 #x-23458768 'little)\`
\` v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x0) \`
\` \`
\` (define v (make-bytevector 28 0))\`
\` (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\`
\` (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\`
\` (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\`
\` v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\`
`
    },
    {
        name: "(bytevector-s8-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s249"),
        description: `**procedure**: \`(bytevector-s8-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 8-bit signed byte at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *bytevector*.

The value returned is an exact 8-bit signed integer, i.e., a value in the range -128 to 127 inclusive, and is the equivalent of the stored value treated as a two's complement value.

\`(bytevector-s8-ref #vu8(1 127 128 255) 0) \`=>\` 1\`
\` (bytevector-s8-ref #vu8(1 127 128 255) 1) \`=>\` 127\`
\` (bytevector-s8-ref #vu8(1 127 128 255) 2) \`=>\` -128\`
\` (bytevector-s8-ref #vu8(1 127 128 255) 3) \`=>\` -1\`
`
    },
    {
        name: "(bytevector-s8-set! ",
        endParen: true,
        params: ["bytevector", "n", "s8"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s251"),
        description: `**procedure**: \`(bytevector-s8-set! \`*bytevector*\` \`*n*\` \`*s8*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *bytevector*. *s8* must be an 8-bit signed value, i.e., a value in the range -128 to 127 inclusive.

\`bytevector-s8-set!\` changes the 8-bit value at index *n* (zero-based) of *bytevector* to the two's complement equivalent of *s8*.

\`(let ([v (make-bytevector 4 0)])\`
\`   (bytevector-s8-set! v 1 100)\`
\`   (bytevector-s8-set! v 2 -100)\`
\`   v) \`=>\` #vu8(0 100 156 0)\`
`
    },
    {
        name: "(bytevector-sint-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s258"),
        description: `**procedure**: \`(bytevector-uint-ref \`*bytevector*\` \`*n*\` \`*eness*\` \`*size*\`)\`
**returns: **the *size*-byte unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-sint-ref \`*bytevector*\` \`*n*\` \`*eness*\` \`*size*\`)\`
**returns: **the *size*-byte signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of *n* and *size* must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76)) \`
\` \`
\` (bytevector-uint-ref v 0 'big 1) \`=>\` #x12\`
\` (bytevector-uint-ref v 0 'little 1) \`=>\` #x12\`
\` (bytevector-uint-ref v 1 'big 3) \`=>\` #x34fe56\`
\` (bytevector-uint-ref v 2 'little 7) \`=>\` #x9a9878badc56fe \`
\` \`
\` (bytevector-sint-ref v 2 'big 1) \`=>\` #x-02\`
\` (bytevector-sint-ref v 1 'little 6) \`=>\` #x78badc56fe34\`
\` (bytevector-sint-ref v 2 'little 7) \`=>\` #x-6567874523a902 \`
\` \`
\` (bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) \`=>\` -1\`
`
    },
    {
        name: "(bytevector-sint-set! ",
        endParen: true,
        params: ["bytevector", "n", "sint", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s259"),
        description: `**procedure**: \`(bytevector-uint-set! \`*bytevector*\` \`*n*\` \`*uint*\` \`*eness*\` \`*size*\`)\`
**procedure**: \`(bytevector-sint-set! \`*bytevector*\` \`*n*\` \`*sint*\` \`*eness*\` \`*size*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of *n* and *size* must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *uint* must be an exact integer in the range 0 to 2 - 1 inclusive. *sint* must be an exact integer in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the *size* bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 5 0))\`
\` (bytevector-uint-set! v 1 #x123456 (endianness big) 3)\`
\` v \`=>\` #vu8(0 #x12 #x34 #x56 0) \`
\` \`
\` (define v (make-bytevector 7 -1))\`
\` (bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)\`
\` v \`=>\` #vu8(#xff 0 0 0 0 #x80 #xff)\`
`
    },
    {
        name: "(bytevector-truncate! ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s63"),
        description: `**procedure**: \`(bytevector-truncate! \`*bytevector*\` \`*n*\`)\`
**returns: ***bytevector* or the empty bytevector
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative fixnum not greater than the length of *bytevector*. If *n* is zero, \`bytevector-truncate!\` returns the empty bytevector. Otherwise, *bytevector-truncate!* destructively truncates *bytevector* to its first *n* bytes and returns *bytevector*.

\`(define bv (make-bytevector 7 19))\`
\` (bytevector-truncate! bv 0) \`=>\` #vu8()\`
\` bv \`=>\` #vu8(19 19 19 19 19 19 19)\`
\` (bytevector-truncate! bv 3) \`=>\` #vu8(19 19 19)\`
\` bv \`=>\` #vu8(19 19 19)\`
`
    },
    {
        name: "(bytevector-u16-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s254"),
        description: `**procedure**: \`(bytevector-u16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\`

If native endianness is big:

\`(bytevector-u16-native-ref v 2) \`=>\` #xfe56\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x-1aa\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x7898 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`

If native endianness is little:

\`(bytevector-u16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x-6788 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x-67874523a901cbee\`
`
    },
    {
        name: "(bytevector-u16-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "u16"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s255"),
        description: `**procedure**: \`(bytevector-u16-native-set! \`*bytevector*\` \`*n*\` \`*u16*\`)\`
**procedure**: \`(bytevector-s16-native-set! \`*bytevector*\` \`*n*\` \`*s16*\`)\`
**procedure**: \`(bytevector-u32-native-set! \`*bytevector*\` \`*n*\` \`*u32*\`)\`
**procedure**: \`(bytevector-s32-native-set! \`*bytevector*\` \`*n*\` \`*s32*\`)\`
**procedure**: \`(bytevector-u64-native-set! \`*bytevector*\` \`*n*\` \`*u64*\`)\`
**procedure**: \`(bytevector-s64-native-set! \`*bytevector*\` \`*n*\` \`*s64*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length *bytevector*. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-native-set! v 0 #xfe56)\`
\` (bytevector-s16-native-set! v 2 #x-1aa)\`
\` (bytevector-s16-native-set! v 4 #x7898)\`

If native endianness is big:

\`v \`=>\` #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\`

\`(define v (make-bytevector 16 0))\`
\` (bytevector-u32-native-set! v 0 #x1234fe56)\`
\` (bytevector-s32-native-set! v 4 #x1234fe56)\`
\` (bytevector-s32-native-set! v 8 #x-23458768)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\`
\`   \`\`      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\`

\`(define v (make-bytevector 24 0))\`
\` (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 16 #x-67874523a901cbee)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\`

If native endianness is little:

\`v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\`
`
    },
    {
        name: "(bytevector-u16-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s256"),
        description: `**procedure**: \`(bytevector-u16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\`
\` (bytevector-u16-ref v 0 (endianness big)) \`=>\` #x1234\`
\` (bytevector-s16-ref v 1 (endianness big)) \`=>\` #x34fe\`
\` (bytevector-s16-ref v 5 (endianness big)) \`=>\` #x-4588 \`
\` \`
\` (bytevector-u32-ref v 2 'big) \`=>\` #xfe56dcba\`
\` (bytevector-s32-ref v 3 'big) \`=>\` #x56dcba78\`
\` (bytevector-s32-ref v 4 'big) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-ref v 0 'big) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-ref v 1 'big) \`=>\` #x34fe56dcba78989a \`
\` \`
\` (bytevector-u16-ref v 0 (endianness little)) \`=>\` #x3412\`
\` (bytevector-s16-ref v 1 (endianness little)) \`=>\` #x-1cc\`
\` (bytevector-s16-ref v 5 (endianness little)) \`=>\` #x78ba \`
\` \`
\` (bytevector-u32-ref v 2 'little) \`=>\` #xbadc56fe\`
\` (bytevector-s32-ref v 3 'little) \`=>\` #x78badc56\`
\` (bytevector-s32-ref v 4 'little) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-ref v 0 'little) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-ref v 1 'little) \`=>\` #x-6567874523a901cc\`
`
    },
    {
        name: "(bytevector-u16-set! ",
        endParen: true,
        params: ["bytevector", "n", "u16", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s257"),
        description: `**procedure**: \`(bytevector-u16-set! \`*bytevector*\` \`*n*\` \`*u16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s16-set! \`*bytevector*\` \`*n*\` \`*s16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u32-set! \`*bytevector*\` \`*n*\` \`*u32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s32-set! \`*bytevector*\` \`*n*\` \`*s32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u64-set! \`*bytevector*\` \`*n*\` \`*u64*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s64-set! \`*bytevector*\` \`*n*\` \`*s64*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-set! v 0 #xfe56 (endianness big))\`
\` (bytevector-s16-set! v 3 #x-1aa (endianness little))\`
\` (bytevector-s16-set! v 5 #x7898 (endianness big))\`
\` v \`=>\` #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \`
\` \`
\` (define v (make-bytevector 16 0))\`
\` (bytevector-u32-set! v 0 #x1234fe56 'little)\`
\` (bytevector-s32-set! v 6 #x1234fe56 'big)\`
\` (bytevector-s32-set! v 11 #x-23458768 'little)\`
\` v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x0) \`
\` \`
\` (define v (make-bytevector 28 0))\`
\` (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\`
\` (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\`
\` (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\`
\` v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\`
`
    },
    {
        name: "(bytevector-u24-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-u24-set! ",
        endParen: true,
        params: ["bytevector", "n", "u24", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-u32-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s254"),
        description: `**procedure**: \`(bytevector-u16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\`

If native endianness is big:

\`(bytevector-u16-native-ref v 2) \`=>\` #xfe56\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x-1aa\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x7898 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`

If native endianness is little:

\`(bytevector-u16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x-6788 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x-67874523a901cbee\`
`
    },
    {
        name: "(bytevector-u32-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "u32"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s255"),
        description: `**procedure**: \`(bytevector-u16-native-set! \`*bytevector*\` \`*n*\` \`*u16*\`)\`
**procedure**: \`(bytevector-s16-native-set! \`*bytevector*\` \`*n*\` \`*s16*\`)\`
**procedure**: \`(bytevector-u32-native-set! \`*bytevector*\` \`*n*\` \`*u32*\`)\`
**procedure**: \`(bytevector-s32-native-set! \`*bytevector*\` \`*n*\` \`*s32*\`)\`
**procedure**: \`(bytevector-u64-native-set! \`*bytevector*\` \`*n*\` \`*u64*\`)\`
**procedure**: \`(bytevector-s64-native-set! \`*bytevector*\` \`*n*\` \`*s64*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length *bytevector*. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-native-set! v 0 #xfe56)\`
\` (bytevector-s16-native-set! v 2 #x-1aa)\`
\` (bytevector-s16-native-set! v 4 #x7898)\`

If native endianness is big:

\`v \`=>\` #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\`

\`(define v (make-bytevector 16 0))\`
\` (bytevector-u32-native-set! v 0 #x1234fe56)\`
\` (bytevector-s32-native-set! v 4 #x1234fe56)\`
\` (bytevector-s32-native-set! v 8 #x-23458768)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\`
\`   \`\`      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\`

\`(define v (make-bytevector 24 0))\`
\` (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 16 #x-67874523a901cbee)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\`

If native endianness is little:

\`v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\`
`
    },
    {
        name: "(bytevector-u32-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s256"),
        description: `**procedure**: \`(bytevector-u16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\`
\` (bytevector-u16-ref v 0 (endianness big)) \`=>\` #x1234\`
\` (bytevector-s16-ref v 1 (endianness big)) \`=>\` #x34fe\`
\` (bytevector-s16-ref v 5 (endianness big)) \`=>\` #x-4588 \`
\` \`
\` (bytevector-u32-ref v 2 'big) \`=>\` #xfe56dcba\`
\` (bytevector-s32-ref v 3 'big) \`=>\` #x56dcba78\`
\` (bytevector-s32-ref v 4 'big) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-ref v 0 'big) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-ref v 1 'big) \`=>\` #x34fe56dcba78989a \`
\` \`
\` (bytevector-u16-ref v 0 (endianness little)) \`=>\` #x3412\`
\` (bytevector-s16-ref v 1 (endianness little)) \`=>\` #x-1cc\`
\` (bytevector-s16-ref v 5 (endianness little)) \`=>\` #x78ba \`
\` \`
\` (bytevector-u32-ref v 2 'little) \`=>\` #xbadc56fe\`
\` (bytevector-s32-ref v 3 'little) \`=>\` #x78badc56\`
\` (bytevector-s32-ref v 4 'little) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-ref v 0 'little) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-ref v 1 'little) \`=>\` #x-6567874523a901cc\`
`
    },
    {
        name: "(bytevector-u32-set! ",
        endParen: true,
        params: ["bytevector", "n", "u32", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s257"),
        description: `**procedure**: \`(bytevector-u16-set! \`*bytevector*\` \`*n*\` \`*u16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s16-set! \`*bytevector*\` \`*n*\` \`*s16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u32-set! \`*bytevector*\` \`*n*\` \`*u32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s32-set! \`*bytevector*\` \`*n*\` \`*s32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u64-set! \`*bytevector*\` \`*n*\` \`*u64*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s64-set! \`*bytevector*\` \`*n*\` \`*s64*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-set! v 0 #xfe56 (endianness big))\`
\` (bytevector-s16-set! v 3 #x-1aa (endianness little))\`
\` (bytevector-s16-set! v 5 #x7898 (endianness big))\`
\` v \`=>\` #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \`
\` \`
\` (define v (make-bytevector 16 0))\`
\` (bytevector-u32-set! v 0 #x1234fe56 'little)\`
\` (bytevector-s32-set! v 6 #x1234fe56 'big)\`
\` (bytevector-s32-set! v 11 #x-23458768 'little)\`
\` v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x0) \`
\` \`
\` (define v (make-bytevector 28 0))\`
\` (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\`
\` (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\`
\` (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\`
\` v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\`
`
    },
    {
        name: "(bytevector-u40-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-u40-set! ",
        endParen: true,
        params: ["bytevector", "n", "u40", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-u48-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-u48-set! ",
        endParen: true,
        params: ["bytevector", "n", "u48", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-u56-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s64"),
        description: `**procedure**: \`(bytevector-u24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s24-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 24-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s40-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 40-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s48-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 48-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s56-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 56-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of *bytevector*. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.
`
    },
    {
        name: "(bytevector-u56-set! ",
        endParen: true,
        params: ["bytevector", "n", "u56", "eness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s65"),
        description: `**procedure**: \`(bytevector-u24-set! \`*bytevector*\` \`*n*\` \`*u24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s24-set! \`*bytevector*\` \`*n*\` \`*s24*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u40-set! \`*bytevector*\` \`*n*\` \`*u40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s40-set! \`*bytevector*\` \`*n*\` \`*s40*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u48-set! \`*bytevector*\` \`*n*\` \`*u48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s48-set! \`*bytevector*\` \`*n*\` \`*s48*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u56-set! \`*bytevector*\` \`*n*\` \`*u56*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s56-set! \`*bytevector*\` \`*n*\` \`*s56*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*bytevector* must be mutable. *n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *u24* must be a 24-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s24* must be a 24-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u40* must be a 40-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s40* must be a 40-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u48* must be a 48-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s48* must be a 48-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u56* must be a 56-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s56* must be a 56-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.
`
    },
    {
        name: "(bytevector-u64-native-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s254"),
        description: `**procedure**: \`(bytevector-u16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-native-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. The native endianness is assumed.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\`

If native endianness is big:

\`(bytevector-u16-native-ref v 2) \`=>\` #xfe56\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x-1aa\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x7898 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x1234fe56\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x1234fe56dcba7898\`

If native endianness is little:

\`(bytevector-u16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 2) \`=>\` #x56fe\`
\` (bytevector-s16-native-ref v 6) \`=>\` #x-6788 \`
\` \`
\` (bytevector-u32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 0) \`=>\` #x56fe3412\`
\` (bytevector-s32-native-ref v 4) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-native-ref v 0) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-native-ref v 0) \`=>\` #x-67874523a901cbee\`
`
    },
    {
        name: "(bytevector-u64-native-set! ",
        endParen: true,
        params: ["bytevector", "n", "u64"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s255"),
        description: `**procedure**: \`(bytevector-u16-native-set! \`*bytevector*\` \`*n*\` \`*u16*\`)\`
**procedure**: \`(bytevector-s16-native-set! \`*bytevector*\` \`*n*\` \`*s16*\`)\`
**procedure**: \`(bytevector-u32-native-set! \`*bytevector*\` \`*n*\` \`*u32*\`)\`
**procedure**: \`(bytevector-s32-native-set! \`*bytevector*\` \`*n*\` \`*s32*\`)\`
**procedure**: \`(bytevector-u64-native-set! \`*bytevector*\` \`*n*\` \`*u64*\`)\`
**procedure**: \`(bytevector-s64-native-set! \`*bytevector*\` \`*n*\` \`*s64*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of *n* and the number of bytes occupied by the value must not exceed the length *bytevector*. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. The native endianness is assumed.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-native-set! v 0 #xfe56)\`
\` (bytevector-s16-native-set! v 2 #x-1aa)\`
\` (bytevector-s16-native-set! v 4 #x7898)\`

If native endianness is big:

\`v \`=>\` #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\`

\`(define v (make-bytevector 16 0))\`
\` (bytevector-u32-native-set! v 0 #x1234fe56)\`
\` (bytevector-s32-native-set! v 4 #x1234fe56)\`
\` (bytevector-s32-native-set! v 8 #x-23458768)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\`
\`   \`\`      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\`

If native endianness is little:

\`v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\`

\`(define v (make-bytevector 24 0))\`
\` (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\`
\` (bytevector-s64-native-set! v 16 #x-67874523a901cbee)\`

If native endianness is big:

\`v \`=>\` #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\`

If native endianness is little:

\`v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\`
`
    },
    {
        name: "(bytevector-u64-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s256"),
        description: `**procedure**: \`(bytevector-u16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s16-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 16-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s32-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 32-bit signed integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-u64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-s64-ref \`*bytevector*\` \`*n*\` \`*eness*\`)\`
**returns: **the 64-bit signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\`
\` (bytevector-u16-ref v 0 (endianness big)) \`=>\` #x1234\`
\` (bytevector-s16-ref v 1 (endianness big)) \`=>\` #x34fe\`
\` (bytevector-s16-ref v 5 (endianness big)) \`=>\` #x-4588 \`
\` \`
\` (bytevector-u32-ref v 2 'big) \`=>\` #xfe56dcba\`
\` (bytevector-s32-ref v 3 'big) \`=>\` #x56dcba78\`
\` (bytevector-s32-ref v 4 'big) \`=>\` #x-23458768 \`
\` \`
\` (bytevector-u64-ref v 0 'big) \`=>\` #x1234fe56dcba7898\`
\` (bytevector-s64-ref v 1 'big) \`=>\` #x34fe56dcba78989a \`
\` \`
\` (bytevector-u16-ref v 0 (endianness little)) \`=>\` #x3412\`
\` (bytevector-s16-ref v 1 (endianness little)) \`=>\` #x-1cc\`
\` (bytevector-s16-ref v 5 (endianness little)) \`=>\` #x78ba \`
\` \`
\` (bytevector-u32-ref v 2 'little) \`=>\` #xbadc56fe\`
\` (bytevector-s32-ref v 3 'little) \`=>\` #x78badc56\`
\` (bytevector-s32-ref v 4 'little) \`=>\` #x-67874524 \`
\` \`
\` (bytevector-u64-ref v 0 'little) \`=>\` #x9878badc56fe3412\`
\` (bytevector-s64-ref v 1 'little) \`=>\` #x-6567874523a901cc\`
`
    },
    {
        name: "(bytevector-u64-set! ",
        endParen: true,
        params: ["bytevector", "n", "u64", "eness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s257"),
        description: `**procedure**: \`(bytevector-u16-set! \`*bytevector*\` \`*n*\` \`*u16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s16-set! \`*bytevector*\` \`*n*\` \`*s16*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u32-set! \`*bytevector*\` \`*n*\` \`*u32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s32-set! \`*bytevector*\` \`*n*\` \`*s32*\` \`*eness*\`)\`
**procedure**: \`(bytevector-u64-set! \`*bytevector*\` \`*n*\` \`*u64*\` \`*eness*\`)\`
**procedure**: \`(bytevector-s64-set! \`*bytevector*\` \`*n*\` \`*s64*\` \`*eness*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. The sum of *n* and the number of bytes occupied by the value must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *u16* must be a 16-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s16* must be a 16-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u32* must be a 32-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; *s32* must be a 32-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive; *u64* must be a 64-bit unsigned value, i.e., a value in the range 0 to 2 - 1 inclusive; and *s64* must be a 64-bit signed value, i.e., a value in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 2, 4, or 8 bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 8 0))\`
\` (bytevector-u16-set! v 0 #xfe56 (endianness big))\`
\` (bytevector-s16-set! v 3 #x-1aa (endianness little))\`
\` (bytevector-s16-set! v 5 #x7898 (endianness big))\`
\` v \`=>\` #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \`
\` \`
\` (define v (make-bytevector 16 0))\`
\` (bytevector-u32-set! v 0 #x1234fe56 'little)\`
\` (bytevector-s32-set! v 6 #x1234fe56 'big)\`
\` (bytevector-s32-set! v 11 #x-23458768 'little)\`
\` v \`=>\` #vu8(#x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x0) \`
\` \`
\` (define v (make-bytevector 28 0))\`
\` (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\`
\` (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\`
\` (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\`
\` v \`=>\` #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\`
\`   \`\`      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\`
\`   \`\`      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\`
`
    },
    {
        name: "(bytevector-u8-ref ",
        endParen: true,
        params: ["bytevector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s248"),
        description: `**procedure**: \`(bytevector-u8-ref \`*bytevector*\` \`*n*\`)\`
**returns: **the 8-bit unsigned byte at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *bytevector*.

The value is returned as an exact 8-bit unsigned integer, i.e., a value in the range 0 to 255 inclusive.

\`(bytevector-u8-ref #vu8(1 127 128 255) 0) \`=>\` 1\`
\` (bytevector-u8-ref #vu8(1 127 128 255) 2) \`=>\` 128\`
\` (bytevector-u8-ref #vu8(1 127 128 255) 3) \`=>\` 255\`
`
    },
    {
        name: "(bytevector-u8-set! ",
        endParen: true,
        params: ["bytevector", "n", "u8"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s250"),
        description: `**procedure**: \`(bytevector-u8-set! \`*bytevector*\` \`*n*\` \`*u8*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *bytevector*. *u8* must be an 8-bit unsigned value, i.e., a value in the range 0 to 255 inclusive.

\`bytevector-u8-set!\` changes the 8-bit value at index *n* (zero-based) of *bytevector* to *u8*.

\`(let ([v (make-bytevector 5 -1)])\`
\`   (bytevector-u8-set! v 2 128)\`
\`   v) \`=>\` #vu8(255 255 128 255 255)\`
`
    },
    {
        name: "(bytevector-uint-ref ",
        endParen: true,
        params: ["bytevector", "n", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s258"),
        description: `**procedure**: \`(bytevector-uint-ref \`*bytevector*\` \`*n*\` \`*eness*\` \`*size*\`)\`
**returns: **the *size*-byte unsigned integer at index *n* (zero-based) of *bytevector*
**procedure**: \`(bytevector-sint-ref \`*bytevector*\` \`*n*\` \`*eness*\` \`*size*\`)\`
**returns: **the *size*-byte signed integer at index *n* (zero-based) of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of *n* and *size* must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *eness* must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

\`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76)) \`
\` \`
\` (bytevector-uint-ref v 0 'big 1) \`=>\` #x12\`
\` (bytevector-uint-ref v 0 'little 1) \`=>\` #x12\`
\` (bytevector-uint-ref v 1 'big 3) \`=>\` #x34fe56\`
\` (bytevector-uint-ref v 2 'little 7) \`=>\` #x9a9878badc56fe \`
\` \`
\` (bytevector-sint-ref v 2 'big 1) \`=>\` #x-02\`
\` (bytevector-sint-ref v 1 'little 6) \`=>\` #x78badc56fe34\`
\` (bytevector-sint-ref v 2 'little 7) \`=>\` #x-6567874523a902 \`
\` \`
\` (bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) \`=>\` -1\`
`
    },
    {
        name: "(bytevector-uint-set! ",
        endParen: true,
        params: ["bytevector", "n", "uint", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s259"),
        description: `**procedure**: \`(bytevector-uint-set! \`*bytevector*\` \`*n*\` \`*uint*\` \`*eness*\` \`*size*\`)\`
**procedure**: \`(bytevector-sint-set! \`*bytevector*\` \`*n*\` \`*sint*\` \`*eness*\` \`*size*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer and indexes the starting byte of the value. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of *n* and *size* must not exceed the length of *bytevector*. *n* need be a multiple of the number of bytes occupied by the value. *uint* must be an exact integer in the range 0 to 2 - 1 inclusive. *sint* must be an exact integer in the range -2 to 2 - 1 inclusive. *eness* must be a valid endianness symbol naming the endianness.

These procedures store the given value in the *size* bytes starting at index *n* (zero-based) of *bytevector*. Negative values are stored as their two's complement equivalent.

\`(define v (make-bytevector 5 0))\`
\` (bytevector-uint-set! v 1 #x123456 (endianness big) 3)\`
\` v \`=>\` #vu8(0 #x12 #x34 #x56 0) \`
\` \`
\` (define v (make-bytevector 7 -1))\`
\` (bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)\`
\` v \`=>\` #vu8(#xff 0 0 0 0 #x80 #xff)\`
`
    },
    {
        name: "(bytevector-uncompress ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s73"),
        description: `**procedure**: \`(bytevector-uncompress \`*bytevector*\`)\`
**returns: **a bytevector containing uncompressed content of *bytevector*
**libraries: **\`(chezscheme)\`

Uncompresses a *bytevector* produced by \`bytevector-compress\` to a new bytevector with the same content as the original given to \`bytevector-compress\`.
`
    },
    {
        name: "(bytevector=? ",
        endParen: true,
        params: ["bytevector1", "bytevector2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s244"),
        description: `**procedure**: \`(bytevector=? \`*bytevector1*\` \`*bytevector2*\`)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

Two bytevectors are equal by \`bytevector=?\` if and only if they have the same length and same contents.

\`(bytevector=? #vu8() #vu8()) \`=>\` #t\`
\` (bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) \`=>\` #t\`
\` (bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) \`=>\` #f\`
\` (bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) \`=>\` #f\`
`
    },
    {
        name: "(bytevector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s24"),
        description: `**procedure**: \`(bytevector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a bytevector, \`#f\` otherwise
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

\` (bytevector? #vu8()) \`=>\` #t\`
\` (bytevector? '#()) \`=>\` #f\`
\` (bytevector? "abc") \`=>\` #f\`
`
    },
    {
        name: "(caaaar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caaadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caaar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caadar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caaddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cadaar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cadadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cadar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caddar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cadddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(caddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(call-with-bytevector-output-port ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s38"),
        description: `**procedure**: \`(call-with-bytevector-output-port \`*procedure*\`)\`
**procedure**: \`(call-with-bytevector-output-port \`*procedure*\` \`*?transcoder*\`)\`
**returns: **a bytevector containing the accumulated bytes
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and *procedure* is called with a textual bytevector output port whose transcoder is *?transcoder*. Otherwise, *procedure* is called with a binary bytevector output port. If *procedure* returns, a bytevector containing the bytes accumulated in the port is created, the accumulated bytes are cleared from the port, the port's position is reset to zero, and the bytevector is returned from \`call-with-bytevector-output-port\`. These actions occur each time *procedure* returns, if it returns multiple times due to the invocation of a continuation created while *procedure* is active.

\`(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)\`
\`             (error-handling-mode replace))])\`
\`   (call-with-bytevector-output-port\`
\`     (lambda (p) (put-string p "abc"))\`
\`     tx)) \`=>\` #vu8(97 98 99)\`
`
    },
    {
        name: "(call-with-bytevector-output-port ",
        endParen: true,
        params: ["procedure", "?transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s38"),
        description: `**procedure**: \`(call-with-bytevector-output-port \`*procedure*\`)\`
**procedure**: \`(call-with-bytevector-output-port \`*procedure*\` \`*?transcoder*\`)\`
**returns: **a bytevector containing the accumulated bytes
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and *procedure* is called with a textual bytevector output port whose transcoder is *?transcoder*. Otherwise, *procedure* is called with a binary bytevector output port. If *procedure* returns, a bytevector containing the bytes accumulated in the port is created, the accumulated bytes are cleared from the port, the port's position is reset to zero, and the bytevector is returned from \`call-with-bytevector-output-port\`. These actions occur each time *procedure* returns, if it returns multiple times due to the invocation of a continuation created while *procedure* is active.

\`(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)\`
\`             (error-handling-mode replace))])\`
\`   (call-with-bytevector-output-port\`
\`     (lambda (p) (put-string p "abc"))\`
\`     tx)) \`=>\` #vu8(97 98 99)\`
`
    },
    {
        name: "(call-with-current-continuation ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s54"),
        description: `**procedure**: \`(call/cc \`*procedure*\`)\`
**procedure**: \`(call-with-current-continuation \`*procedure*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are the same. The shorter name is often used for the obvious reason that it requires fewer keystrokes to type.

\`call/cc\` obtains its continuation and passes it to *procedure*, which should accept one argument. The continuation itself is represented by a procedure. Each time this procedure is applied to zero or more values, it returns the values to the continuation of the \`call/cc\` application. That is, when the continuation procedure is called, it returns its arguments as the values of the application of \`call/cc\`.

If *procedure* returns normally when passed the continuation procedure, the values returned by \`call/cc\` are the values returned by *procedure*.
`
    },
    {
        name: "(call-with-input-file ",
        endParen: true,
        params: ["path", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s58"),
        description: `**procedure**: \`(call-with-input-file \`*path*\` \`*procedure*\`)\`
**procedure**: \`(call-with-input-file \`*path*\` \`*procedure*\` \`*options*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(chezscheme)\`

*path* must be a string. *procedure* should accept one argument.

\`call-with-input-file\` creates a new input port for the file named by *path*, as if with \`open-input-file\`, and passes this port to *procedure*. If *procedure* returns normally, \`call-with-input-file\` closes the input port and returns the values returned by *procedure*.

\`call-with-input-file\` does not automatically close the input port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in Section  of , \`dynamic-wind\` may be used to ensure that the port is closed if a continuation created outside of *procedure* is invoked.

See \`open-input-file\` above for a description of the optional *options* argument.

The Revised Report version of \`call-with-input-file\` does not support the optional *input* argument.
`
    },
    {
        name: "(call-with-input-file ",
        endParen: true,
        params: ["path", "procedure", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s58"),
        description: `**procedure**: \`(call-with-input-file \`*path*\` \`*procedure*\`)\`
**procedure**: \`(call-with-input-file \`*path*\` \`*procedure*\` \`*options*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(chezscheme)\`

*path* must be a string. *procedure* should accept one argument.

\`call-with-input-file\` creates a new input port for the file named by *path*, as if with \`open-input-file\`, and passes this port to *procedure*. If *procedure* returns normally, \`call-with-input-file\` closes the input port and returns the values returned by *procedure*.

\`call-with-input-file\` does not automatically close the input port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in Section  of , \`dynamic-wind\` may be used to ensure that the port is closed if a continuation created outside of *procedure* is invoked.

See \`open-input-file\` above for a description of the optional *options* argument.

The Revised Report version of \`call-with-input-file\` does not support the optional *input* argument.
`
    },
    {
        name: "(call-with-input-file ",
        endParen: true,
        params: ["path", "procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s77"),
        description: `**procedure**: \`(call-with-input-file \`*path*\` \`*procedure*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. *procedure* should accept one argument.

\`call-with-input-file\` creates a new input port for the file named by *path*, as if with \`open-input-file\`, and passes this port to *procedure*. If *procedure* returns, \`call-with-input-file\` closes the input port and returns the values returned by *procedure*.

\`call-with-input-file\` does not automatically close the input port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in Section , \`dynamic-wind\` may be used to ensure that the port is closed if a continuation created outside of *procedure* is invoked.

The following example shows the use of \`call-with-input-file\` in an expression that gathers a list of objects from the file named by "myfile.ss." It is functionally equivalent to the example given for \`open-input-file\` above.

\`(call-with-input-file "myfile.ss"\`
\`   (lambda (p)\`
\`     (let f ([x (read p)])\`
\`       (if (eof-object? x)\`
\`           '()\`
\`           (cons x (f (read p)))))))\`

\`call-with-input-file\` might be defined without error checking as follows.

\`(define call-with-input-file\`
\`   (lambda (filename proc)\`
\`     (let ([p (open-input-file filename)])\`
\`       (let-values ([v* (proc p)])\`
\`         (close-port p)\`
\`         (apply values v*)))))\`
`
    },
    {
        name: "(call-with-output-file ",
        endParen: true,
        params: ["path", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s78"),
        description: `**procedure**: \`(call-with-output-file \`*path*\` \`*procedure*\`)\`
**procedure**: \`(call-with-output-file \`*path*\` \`*procedure*\` \`*options*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(chezscheme)\`

*path* must be a string. *procedure* should accept one argument.

\`call-with-output-file\` creates a new output port for the file named by *path*, as if with \`open-output-file\`, and passes this port to *procedure*. If *procedure* returns, \`call-with-output-file\` closes the output port and returns the values returned by *procedure*.

\`call-with-output-file\` does not automatically close the output port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in Section  of , \`dynamic-wind\` may be used to ensure that the port is closed if a continuation created outside of *procedure* is invoked.

See \`open-output-file\` above for a description of the optional *options* argument.

The Revised Report version of \`call-with-output-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(call-with-output-file ",
        endParen: true,
        params: ["path", "procedure", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s78"),
        description: `**procedure**: \`(call-with-output-file \`*path*\` \`*procedure*\`)\`
**procedure**: \`(call-with-output-file \`*path*\` \`*procedure*\` \`*options*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(chezscheme)\`

*path* must be a string. *procedure* should accept one argument.

\`call-with-output-file\` creates a new output port for the file named by *path*, as if with \`open-output-file\`, and passes this port to *procedure*. If *procedure* returns, \`call-with-output-file\` closes the output port and returns the values returned by *procedure*.

\`call-with-output-file\` does not automatically close the output port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in Section  of , \`dynamic-wind\` may be used to ensure that the port is closed if a continuation created outside of *procedure* is invoked.

See \`open-output-file\` above for a description of the optional *options* argument.

The Revised Report version of \`call-with-output-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(call-with-output-file ",
        endParen: true,
        params: ["path", "procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s78"),
        description: `**procedure**: \`(call-with-output-file \`*path*\` \`*procedure*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. *procedure* should accept one argument.

\`call-with-output-file\` creates a new output port for the file named by *path*, as if with \`open-output-file\`, and passes this port to *procedure*. If *procedure* returns, \`call-with-output-file\` closes the output port and returns the values returned by *procedure*.

\`call-with-output-file\` does not automatically close the output port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in Section , \`dynamic-wind\` may be used to ensure that the port is closed if a continuation created outside of *procedure* is invoked.

The following shows the use of \`call-with-output-file\` to write a list of objects (the value of \`list-to-be-printed\`), separated by newlines, to the file named by "myfile.ss." It is functionally equivalent to the example given for \`open-output-file\` above.

\`(call-with-output-file "myfile.ss"\`
\`   (lambda (p)\`
\`     (let f ([ls list-to-be-printed])\`
\`       (unless (null? ls)\`
\`         (write (car ls) p)\`
\`         (newline p)\`
\`         (f (cdr ls))))))\`

\`call-with-output-file\` might be defined without error checking as follows.

\`(define call-with-output-file\`
\`   (lambda (filename proc)\`
\`     (let ([p (open-output-file filename)])\`
\`       (let-values ([v* (proc p)])\`
\`         (close-port p)\`
\`         (apply values v*)))))\`
`
    },
    {
        name: "(call-with-port ",
        endParen: true,
        params: ["port", "procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s51"),
        description: `**procedure**: \`(call-with-port \`*port*\` \`*procedure*\`)\`
**returns: **the values returned by *procedure*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

\`call-with-port\` calls *procedure* with *port* as the only argument. If *procedure* returns, \`call-with-port\` closes the port and returns the values returned by *procedure*.

\`call-with-port\` does not automatically close the port if a continuation created outside of *procedure* is invoked, since it is possible that another continuation created inside of *procedure* will be invoked at a later time, returning control to *procedure*. If *procedure* does not return, an implementation is free to close the port only if it can prove that the output port is no longer accessible.

The example below copies the contents of infile to outfile, overwriting outfile if it exists. Unless an error occurs, the ports are closed after the copy has been completed.

\`(call-with-port (open-file-input-port "infile" (file-options)\`
\`                   (buffer-mode block) (native-transcoder))\`
\`   (lambda (ip)\`
\`     (call-with-port (open-file-output-port "outfile"\`
\`                       (file-options no-fail)\`
\`                       (buffer-mode block)\`
\`                       (native-transcoder)) \`
\`       (lambda (op)\`
\`         (do ([c (get-char ip) (get-char ip)])\`
\`             ((eof-object? c))\`
\`           (put-char op c))))))\`

A definition of \`call-with-port\` is given on page .
`
    },
    {
        name: "(call-with-string-output-port ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s39"),
        description: `**procedure**: \`(call-with-string-output-port \`*procedure*\`)\`
**returns: **a string containing the accumulated characters
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*procedure* is called with one argument, a string output port. If *procedure* returns, a string containing the characters accumulated in the port is created, the accumulated characters are cleared from the port, the port's position is reset to zero, and the string is returned from \`call-with-string-output-port\`. These actions occur each time *procedure* returns, if it returns multiple times due to the invocation of a continuation created while *procedure* is active.
`
    },
    {
        name: "(call-with-values ",
        endParen: true,
        params: ["producer", "consumer"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s71"),
        description: `**procedure**: \`(call-with-values \`*producer*\` \`*consumer*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*producer* and *consumer* must be procedures. \`call-with-values\` applies *consumer* to the values returned by invoking *producer* without arguments.

\`(call-with-values\`
\`   (lambda () (values 'bond 'james))\`
\`   (lambda (x y) (cons y x))) \`=>\` (james . bond) \`
\` \`
\` (call-with-values values list) \`=>\` '()\`

In the second example, \`values\` itself serves as the producer. It receives no arguments and thus returns no values. \`list\` is thus applied to no arguments and so returns the empty list.
`
    },
    {
        name: "(call/1cc ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s9"),
        description: `**procedure**: \`(call/1cc \`*procedure*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`call/1cc\` obtains its continuation and passes it to *procedure*, which should accept one argument. The continuation itself is represented by a procedure. This procedure normally takes one argument but may take an arbitrary number of arguments depending upon whether the context of the call to \`call/1cc\` expects multiple return values or not. When this procedure is applied to a value or values, it returns the values to the continuation of the \`call/1cc\` application.
`
    },
    {
        name: "(call/cc ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s54"),
        description: `**procedure**: \`(call/cc \`*procedure*\`)\`
**procedure**: \`(call-with-current-continuation \`*procedure*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are the same. The shorter name is often used for the obvious reason that it requires fewer keystrokes to type.

\`call/cc\` obtains its continuation and passes it to *procedure*, which should accept one argument. The continuation itself is represented by a procedure. Each time this procedure is applied to zero or more values, it returns the values to the continuation of the \`call/cc\` application. That is, when the continuation procedure is called, it returns its arguments as the values of the application of \`call/cc\`.

If *procedure* returns normally when passed the continuation procedure, the values returned by \`call/cc\` are the values returned by *procedure*.
`
    },
    {
        name: "(car ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s38"),
        description: `**procedure**: \`(car \`*pair*\`)\`
**returns: **the car of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The empty list is not a pair, so the argument must not be the empty list.

\`(car '(a)) \`=>\` a\`
\` (car '(a b c)) \`=>\` a\`
\` (car (cons 3 4)) \`=>\` 3\`
`
    },
    {
        name: "(case ",
        endParen: true,
        params: ["expr0", "clause1", "clause2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s1"),
        description: `**syntax**: \`(case \`*expr0*\` \`*clause1*\` \`*clause2*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

Each clause but the last must take one of the forms:

\`((\`*key*\` ...) \`*expr1*\` \`*expr2*\` ...)\`
\` (\`*key*\` \`*expr1*\` \`*expr2*\` ...)\`
`
    },
    {
        name: "(case ",
        endParen: true,
        params: ["expr0", "clause1", "clause2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s18"),
        description: `**syntax**: \`(case \`*expr0*\` \`*clause1*\` \`*clause2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

Each clause but the last must take the form

\`((\`*key*\` ...) \`*expr1*\` \`*expr2*\` ...)\`
`
    },
    {
        name: "(case-lambda ",
        endParen: true,
        params: ["clause", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s13"),
        description: `**syntax**: \`(case-lambda \`*clause*\` ...)\`
**returns: **a procedure
**libraries: **\`(rnrs control)\`, \`(rnrs)\`

A \`case-lambda\` expression consists of a set of clauses, each resembling a \`lambda\` expression. Each *clause* has the form below.

\`[\`*formals*\` \`*body1*\` \`*body2*\` ...]\`

The formal parameters of a clause are defined by *formals* in the same manner as for a \`lambda\` expression. The number of arguments accepted by the procedure value of a \`case-lambda\` expression is determined by the numbers of arguments accepted by the individual clauses.

When a procedure created with \`case-lambda\` is invoked, the clauses are considered in order. The first clause that accepts the given number of actual parameters is selected, the formal parameters defined by its *formals* are bound to the corresponding actual parameters, and the body is evaluated as described for \`lambda\` above. If *formals* in a clause is a proper list of identifiers, then the clause accepts exactly as many actual parameters as there are formal parameters (identifiers) in *formals*. As with a \`lambda\` *formals*, a \`case-lambda\` clause *formals* may be a single identifier, in which case the clause accepts any number of arguments, or an improper list of identifiers terminated by an identifier, in which case the clause accepts any number of arguments greater than or equal to the number of formal parameters excluding the terminating identifier. If no clause accepts the number of actual parameters supplied, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "case-sensitive",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s109"),
        description: `**thread parameter**: \`case-sensitive\`
**libraries: **\`(chezscheme)\`

The \`case-sensitive\` parameter determines whether the reader is case-sensitive with respect to symbol and character names. When set to true (the default, as required by the Revised Report) the case of alphabetic characters within symbol names is significant. When set to \`#f\`, case is insignificant. More precisely, when set to \`#f\`, symbol and character names are folded (as if by \`string-foldcase\`); otherwise, they are left as they appear in the input.

The value of the \`case-sensitive\` matters only if neither \`#!fold-case\` nor \`#!no-fold-case\` has appeared previously in the same input stream. That is, symbol and character name are folded if \`#!fold-case\` has been seen. They are not folded if \`#!no-fold-case\` has been seen. If neither has been seen, they are folded if and only if \`(case-sensitive)\` is \`#f\`.

\`(case-sensitive) \`=>\` #t\`
\` (eq? 'abc 'ABC) \`=>\` #f\`
\` 'ABC \`=>\` ABC\`
\` (case-sensitive #f)\`
\` 'ABC \`=>\` abc\`
\` (eq? 'abc 'ABC) \`=>\` #t\`
`
    },
    {
        name: "cd",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s139"),
        description: `**global parameter**: \`current-directory\`
**global parameter**: \`cd\`
**libraries: **\`(chezscheme)\`

When invoked without arguments, \`current-directory\` returns a string representing the current working directory. Otherwise, the current working directory is changed to the directory specified by the argument, which must be a string representing a valid directory pathname.

\`cd\` is bound to the same parameter.
`
    },
    {
        name: "(cdaaar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdaadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdaar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdadar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdaddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cddaar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cddadr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cddar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdddar ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cddddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cddr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s42"),
        description: `**procedure**: \`(caar \`*pair*\`)\`
**procedure**: \`(cadr \`*pair*\`)\`
**procedure**: \`(cddddr \`*pair*\`)\`
**returns: **the caar, cadr, ..., or cddddr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These procedures are defined as the composition of up to four \`car\`s and \`cdr\`s. The \`a\`'s and \`d\`'s between the \`c\` and \`r\` represent the application of \`car\` or \`cdr\` in order from right to left. For example, the procedure \`cadr\` applied to a pair yields the \`car\` of the \`cdr\` of the pair and is equivalent to \`(lambda (x) (car (cdr x)))\`.

\`(caar '((a))) \`=>\` a\`
\` (cadr '(a b c)) \`=>\` b\`
\` (cdddr '(a b c d)) \`=>\` (d)\`
\` (cadadr '(a (b c))) \`=>\` c\`
`
    },
    {
        name: "(cdr ",
        endParen: true,
        params: ["pair"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s39"),
        description: `**procedure**: \`(cdr \`*pair*\`)\`
**returns: **the cdr of *pair*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The empty list is not a pair, so the argument must not be the empty list.

\`(cdr '(a)) \`=>\` ()\`
\` (cdr '(a b c)) \`=>\` (b c)\`
\` (cdr (cons 3 4)) \`=>\` 4\`
`
    },
    {
        name: "(ceiling ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s103"),
        description: `**procedure**: \`(ceiling \`*real*\`)\`
**returns: **the integer closest to *real* toward
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *real* is an infinity or NaN, \`ceiling\` returns *real*.

\`(ceiling 19) \`=>\` 19\`
\` (ceiling 2/3) \`=>\` 1\`
\` (ceiling -2/3) \`=>\` 0\`
\` (ceiling 17.3) \`=>\` 18.0\`
\` (ceiling -17/2) \`=>\` -8\`
`
    },
    {
        name: "(cfl* ",
        endParen: true,
        params: ["cflonum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s38"),
        description: `**procedure**: \`(cfl+ \`*cflonum*\` ...)\`
**procedure**: \`(cfl* \`*cflonum*\` ...)\`
**procedure**: \`(cfl- \`*cflonum1*\` \`*cflonum2*\` ...)\`
**procedure**: \`(cfl/ \`*cflonum1*\` \`*cflonum2*\` ...)\`
**returns: **a cflonum
**libraries: **\`(chezscheme)\`

These procedures compute the sum, difference, product, or quotient of inexact complex quantities, whether these quantities are represented by flonums or inexact complexnums. For example, if \`cfl+\` receives two flonum arguments and , it returns the sum + ; in this case, it behaves the same as \`fl+\`. With two inexact complexnum arguments + and + , it returns the sum ( + ) + ( + ). If one argument is a flonum and the other an inexact complexnum + , \`cfl+\` returns ( + ) + .

When passed zero arguments, \`cfl+\` returns 0.0 and \`cfl*\` returns 1.0. When passed one argument, \`cfl-\` returns the additive inverse of the argument, and \`cfl/\` returns the multiplicative inverse of the argument. When passed three or more arguments, \`cfl-\` returns the difference between its first and the sum of its remaining arguments, and \`cfl/\` returns the quotient of its first and the product of its remaining arguments.

\`(cfl+) \`=>\` 0.0\`
\` (cfl*) \`=>\` 1.0\`
\` (cfl- 5.0+1.0i) \`=>\` -5.0-1.0i\`
\` (cfl/ 2.0+2.0i) \`=>\` 0.25-0.25i \`
\` \`
\` (cfl+ 1.0+2.2i -3.7+5.3i) \`=>\` -2.7+7.5i\`
\` (cfl+ 1.0 -5.3) \`=>\` -4.3\`
\` (cfl+ 1.0 2.0 -5.3i) \`=>\` 3.0-5.3i\`
\` (cfl- 1.0+2.5i -3.7) \`=>\` 4.7+2.5i\`
\` (cfl* 1.0+2.0i 3.0+4.0i) \`=>\` -5.0+10.0i\`
\` (cfl/ -5.0+10.0i 1.0+2.0i 2.0) \`=>\` 1.5+2.0i\`
`
    },
    {
        name: "(cfl+ ",
        endParen: true,
        params: ["cflonum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s38"),
        description: `**procedure**: \`(cfl+ \`*cflonum*\` ...)\`
**procedure**: \`(cfl* \`*cflonum*\` ...)\`
**procedure**: \`(cfl- \`*cflonum1*\` \`*cflonum2*\` ...)\`
**procedure**: \`(cfl/ \`*cflonum1*\` \`*cflonum2*\` ...)\`
**returns: **a cflonum
**libraries: **\`(chezscheme)\`

These procedures compute the sum, difference, product, or quotient of inexact complex quantities, whether these quantities are represented by flonums or inexact complexnums. For example, if \`cfl+\` receives two flonum arguments and , it returns the sum + ; in this case, it behaves the same as \`fl+\`. With two inexact complexnum arguments + and + , it returns the sum ( + ) + ( + ). If one argument is a flonum and the other an inexact complexnum + , \`cfl+\` returns ( + ) + .

When passed zero arguments, \`cfl+\` returns 0.0 and \`cfl*\` returns 1.0. When passed one argument, \`cfl-\` returns the additive inverse of the argument, and \`cfl/\` returns the multiplicative inverse of the argument. When passed three or more arguments, \`cfl-\` returns the difference between its first and the sum of its remaining arguments, and \`cfl/\` returns the quotient of its first and the product of its remaining arguments.

\`(cfl+) \`=>\` 0.0\`
\` (cfl*) \`=>\` 1.0\`
\` (cfl- 5.0+1.0i) \`=>\` -5.0-1.0i\`
\` (cfl/ 2.0+2.0i) \`=>\` 0.25-0.25i \`
\` \`
\` (cfl+ 1.0+2.2i -3.7+5.3i) \`=>\` -2.7+7.5i\`
\` (cfl+ 1.0 -5.3) \`=>\` -4.3\`
\` (cfl+ 1.0 2.0 -5.3i) \`=>\` 3.0-5.3i\`
\` (cfl- 1.0+2.5i -3.7) \`=>\` 4.7+2.5i\`
\` (cfl* 1.0+2.0i 3.0+4.0i) \`=>\` -5.0+10.0i\`
\` (cfl/ -5.0+10.0i 1.0+2.0i 2.0) \`=>\` 1.5+2.0i\`
`
    },
    {
        name: "(cfl- ",
        endParen: true,
        params: ["cflonum1", "cflonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s38"),
        description: `**procedure**: \`(cfl+ \`*cflonum*\` ...)\`
**procedure**: \`(cfl* \`*cflonum*\` ...)\`
**procedure**: \`(cfl- \`*cflonum1*\` \`*cflonum2*\` ...)\`
**procedure**: \`(cfl/ \`*cflonum1*\` \`*cflonum2*\` ...)\`
**returns: **a cflonum
**libraries: **\`(chezscheme)\`

These procedures compute the sum, difference, product, or quotient of inexact complex quantities, whether these quantities are represented by flonums or inexact complexnums. For example, if \`cfl+\` receives two flonum arguments and , it returns the sum + ; in this case, it behaves the same as \`fl+\`. With two inexact complexnum arguments + and + , it returns the sum ( + ) + ( + ). If one argument is a flonum and the other an inexact complexnum + , \`cfl+\` returns ( + ) + .

When passed zero arguments, \`cfl+\` returns 0.0 and \`cfl*\` returns 1.0. When passed one argument, \`cfl-\` returns the additive inverse of the argument, and \`cfl/\` returns the multiplicative inverse of the argument. When passed three or more arguments, \`cfl-\` returns the difference between its first and the sum of its remaining arguments, and \`cfl/\` returns the quotient of its first and the product of its remaining arguments.

\`(cfl+) \`=>\` 0.0\`
\` (cfl*) \`=>\` 1.0\`
\` (cfl- 5.0+1.0i) \`=>\` -5.0-1.0i\`
\` (cfl/ 2.0+2.0i) \`=>\` 0.25-0.25i \`
\` \`
\` (cfl+ 1.0+2.2i -3.7+5.3i) \`=>\` -2.7+7.5i\`
\` (cfl+ 1.0 -5.3) \`=>\` -4.3\`
\` (cfl+ 1.0 2.0 -5.3i) \`=>\` 3.0-5.3i\`
\` (cfl- 1.0+2.5i -3.7) \`=>\` 4.7+2.5i\`
\` (cfl* 1.0+2.0i 3.0+4.0i) \`=>\` -5.0+10.0i\`
\` (cfl/ -5.0+10.0i 1.0+2.0i 2.0) \`=>\` 1.5+2.0i\`
`
    },
    {
        name: "(cfl-conjugate ",
        endParen: true,
        params: ["cflonum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s39"),
        description: `**procedure**: \`(cfl-conjugate \`*cflonum*\`)\`
**returns: **complex conjugate of *cflonum*
**libraries: **\`(chezscheme)\`

The procedure \`cfl-conjugate\`, when passed an inexact complex argument + , returns its complex conjugate + (-).
`
    },
    {
        name: "(cfl-imag-part ",
        endParen: true,
        params: ["cflonum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s36"),
        description: `**procedure**: \`(cfl-real-part \`*cflonum*\`)\`
**returns: **the real part of *cflonum*
**procedure**: \`(cfl-imag-part \`*cflonum*\`)\`
**returns: **the imaginary part of *cflonum*
**libraries: **\`(chezscheme)\`

\`(cfl-real-part 2.0-3.0i) \`=>\` 2.0\`
\` (cfl-imag-part 2.0-3.0i) \`=>\` -3.0\`
\` (cfl-imag-part 2.0-0.0i) \`=>\` -0.0\`
\` (cfl-imag-part 2.0-inf.0i) \`=>\` -inf.0\`
`
    },
    {
        name: "(cfl-magnitude-squared ",
        endParen: true,
        params: ["cflonum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s41"),
        description: `**procedure**: \`(cfl-magnitude-squared \`*cflonum*\`)\`
**returns: **magnitude of *cflonum* squared
**libraries: **\`(chezscheme)\`

The procedure \`cfl-magnitude-squared\`, when passed an inexact complex argument + returns a flonum representing the magnitude of the argument squared, i.e., + .
`
    },
    {
        name: "(cfl-real-part ",
        endParen: true,
        params: ["cflonum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s36"),
        description: `**procedure**: \`(cfl-real-part \`*cflonum*\`)\`
**returns: **the real part of *cflonum*
**procedure**: \`(cfl-imag-part \`*cflonum*\`)\`
**returns: **the imaginary part of *cflonum*
**libraries: **\`(chezscheme)\`

\`(cfl-real-part 2.0-3.0i) \`=>\` 2.0\`
\` (cfl-imag-part 2.0-3.0i) \`=>\` -3.0\`
\` (cfl-imag-part 2.0-0.0i) \`=>\` -0.0\`
\` (cfl-imag-part 2.0-inf.0i) \`=>\` -inf.0\`
`
    },
    {
        name: "(cfl/ ",
        endParen: true,
        params: ["cflonum1", "cflonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s38"),
        description: `**procedure**: \`(cfl+ \`*cflonum*\` ...)\`
**procedure**: \`(cfl* \`*cflonum*\` ...)\`
**procedure**: \`(cfl- \`*cflonum1*\` \`*cflonum2*\` ...)\`
**procedure**: \`(cfl/ \`*cflonum1*\` \`*cflonum2*\` ...)\`
**returns: **a cflonum
**libraries: **\`(chezscheme)\`

These procedures compute the sum, difference, product, or quotient of inexact complex quantities, whether these quantities are represented by flonums or inexact complexnums. For example, if \`cfl+\` receives two flonum arguments and , it returns the sum + ; in this case, it behaves the same as \`fl+\`. With two inexact complexnum arguments + and + , it returns the sum ( + ) + ( + ). If one argument is a flonum and the other an inexact complexnum + , \`cfl+\` returns ( + ) + .

When passed zero arguments, \`cfl+\` returns 0.0 and \`cfl*\` returns 1.0. When passed one argument, \`cfl-\` returns the additive inverse of the argument, and \`cfl/\` returns the multiplicative inverse of the argument. When passed three or more arguments, \`cfl-\` returns the difference between its first and the sum of its remaining arguments, and \`cfl/\` returns the quotient of its first and the product of its remaining arguments.

\`(cfl+) \`=>\` 0.0\`
\` (cfl*) \`=>\` 1.0\`
\` (cfl- 5.0+1.0i) \`=>\` -5.0-1.0i\`
\` (cfl/ 2.0+2.0i) \`=>\` 0.25-0.25i \`
\` \`
\` (cfl+ 1.0+2.2i -3.7+5.3i) \`=>\` -2.7+7.5i\`
\` (cfl+ 1.0 -5.3) \`=>\` -4.3\`
\` (cfl+ 1.0 2.0 -5.3i) \`=>\` 3.0-5.3i\`
\` (cfl- 1.0+2.5i -3.7) \`=>\` 4.7+2.5i\`
\` (cfl* 1.0+2.0i 3.0+4.0i) \`=>\` -5.0+10.0i\`
\` (cfl/ -5.0+10.0i 1.0+2.0i 2.0) \`=>\` 1.5+2.0i\`
`
    },
    {
        name: "(cfl= ",
        endParen: true,
        params: ["cflonum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s37"),
        description: `**procedure**: \`(cfl= \`*cflonum*\` ...)\`
**returns: **\`#t\` if its arguments are equal, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (cfl= 7.0+0.0i 7.0) \`=>\` #t\`
\` (cfl= 1.0+2.0i 1.0+2.0i) \`=>\` #t\`
\` (cfl= 1.0+2.0i 1.0-2.0i) \`=>\` #f\`
`
    },
    {
        name: "(cflonum? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s13"),
        description: `**procedure**: \`(cflonum? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an inexact complexnum or flonum, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\` (cflonum? 0) \`=>\` #f\`
\` (cflonum? 0.0) \`=>\` #t\`
\` (cflonum? 3+4i) \`=>\` #f\`
\` (cflonum? 3.0+4i) \`=>\` #t\`
\` (cflonum? +i) \`=>\` #f\`
\` (cflonum? +1.0i) \`=>\` #t\`
`
    },
    {
        name: "(char- ",
        endParen: true,
        params: ["char1", "char2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s16"),
        description: `**procedure**: \`(char- \`*char1*\` \`*char2*\`)\`
**returns: **the integer difference between *char1* and *char2*
**libraries: **\`(chezscheme)\`

\`char-\` subtracts the integer value of *char2* from the integer value of *char1* and returns the difference. The following examples assume that the integer representation is the ASCII code for the character.

\`(char- #\\f #\\e) \`=>\` 1 \`
\` \`
\` (define digit-value\`
\`  ; returns the digit value of the base-r digit c, or #f if c\`
\`  ; is not a valid digit\`
\`   (lambda (c r)\`
\`     (let ([v (cond\`
\`                [(char<=? #\\0 c #\\9) (char- c #\\0)]\`
\`                [(char<=? #\\A c #\\Z) (char- c #\\7)]\`
\`                [(char<=? #\\a c #\\z) (char- c #\\W)]\`
\`                [else 36])])\`
\`       (and (fx< v r) v))))\`
\` (digit-value #\\8 10) \`=>\` 8\`
\` (digit-value #\\z 10) \`=>\` #f\`
\` (digit-value #\\z 36) \`=>\` 35\`

\`char-\` might be defined as follows.

\`(define char-\`
\`   (lambda (c1 c2)\`
\`     (- (char->integer c1) (char->integer c2))))\`
`
    },
    {
        name: "(char->integer ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s210"),
        description: `**procedure**: \`(char->integer \`*char*\`)\`
**returns: **the Unicode scalar value of *char* as an exact integer
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`(char->integer #\\newline) \`=>\` 10\`
\` (char->integer #\\space) \`=>\` 32\`
\` (- (char->integer #\\Z) (char->integer #\\A)) \`=>\` 25\`
`
    },
    {
        name: "(char-alphabetic? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s203"),
        description: `**procedure**: \`(char-alphabetic? \`*char*\`)\`
**returns: **\`#t\` if *char* is a letter, \`#f\` otherwise
**procedure**: \`(char-numeric? \`*char*\`)\`
**returns: **\`#t\` if *char* is a digit, \`#f\` otherwise
**procedure**: \`(char-whitespace? \`*char*\`)\`
**returns: **\`#t\` if *char* is whitespace, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

A character is alphabetic if it has the Unicode "Alphabetic" property, numeric if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space" property.

\`(char-alphabetic? #\\a) \`=>\` #t\`
\` (char-alphabetic? #\\T) \`=>\` #t\`
\` (char-alphabetic? #\\8) \`=>\` #f\`
\` (char-alphabetic? #\\$) \`=>\` #f \`
\` \`
\` (char-numeric? #\\7) \`=>\` #t\`
\` (char-numeric? #\\2) \`=>\` #t\`
\` (char-numeric? #\\X) \`=>\` #f\`
\` (char-numeric? #\\space) \`=>\` #f \`
\` \`
\` (char-whitespace? #\\space) \`=>\` #t\`
\` (char-whitespace? #\\newline) \`=>\` #t\`
\` (char-whitespace? #\\Z) \`=>\` #f\`
`
    },
    {
        name: "(char-ci<=? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char-ci<=? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s202"),
        description: `**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to the predicates \`char=?\`, \`char<?\`, \`char>?\`, \`char<=?\`, and \`char>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, \`char=?\` considers \`#\\a\` and \`#\\A\` to be distinct values; \`char-ci=?\` does not.

\`(char-ci<? #\\a #\\B) \`=>\` #t\`
\` (char-ci=? #\\W #\\w) \`=>\` #t\`
\` (char-ci=? #\\= #\\+) \`=>\` #f\`
\` (let ([c #\\R])\`
\`   (list (char<=? #\\a c #\\z)\`
\`         (char-ci<=? #\\a c #\\z))) \`=>\` (#f #t)\`
`
    },
    {
        name: "(char-ci<? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char-ci<? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s202"),
        description: `**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to the predicates \`char=?\`, \`char<?\`, \`char>?\`, \`char<=?\`, and \`char>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, \`char=?\` considers \`#\\a\` and \`#\\A\` to be distinct values; \`char-ci=?\` does not.

\`(char-ci<? #\\a #\\B) \`=>\` #t\`
\` (char-ci=? #\\W #\\w) \`=>\` #t\`
\` (char-ci=? #\\= #\\+) \`=>\` #f\`
\` (let ([c #\\R])\`
\`   (list (char<=? #\\a c #\\z)\`
\`         (char-ci<=? #\\a c #\\z))) \`=>\` (#f #t)\`
`
    },
    {
        name: "(char-ci=? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char-ci=? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s202"),
        description: `**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to the predicates \`char=?\`, \`char<?\`, \`char>?\`, \`char<=?\`, and \`char>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, \`char=?\` considers \`#\\a\` and \`#\\A\` to be distinct values; \`char-ci=?\` does not.

\`(char-ci<? #\\a #\\B) \`=>\` #t\`
\` (char-ci=? #\\W #\\w) \`=>\` #t\`
\` (char-ci=? #\\= #\\+) \`=>\` #f\`
\` (let ([c #\\R])\`
\`   (list (char<=? #\\a c #\\z)\`
\`         (char-ci<=? #\\a c #\\z))) \`=>\` (#f #t)\`
`
    },
    {
        name: "(char-ci>=? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char-ci>=? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s202"),
        description: `**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to the predicates \`char=?\`, \`char<?\`, \`char>?\`, \`char<=?\`, and \`char>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, \`char=?\` considers \`#\\a\` and \`#\\A\` to be distinct values; \`char-ci=?\` does not.

\`(char-ci<? #\\a #\\B) \`=>\` #t\`
\` (char-ci=? #\\W #\\w) \`=>\` #t\`
\` (char-ci=? #\\= #\\+) \`=>\` #f\`
\` (let ([c #\\R])\`
\`   (list (char<=? #\\a c #\\z)\`
\`         (char-ci<=? #\\a c #\\z))) \`=>\` (#f #t)\`
`
    },
    {
        name: "(char-ci>? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char-ci>? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s202"),
        description: `**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to the predicates \`char=?\`, \`char<?\`, \`char>?\`, \`char<=?\`, and \`char>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, \`char=?\` considers \`#\\a\` and \`#\\A\` to be distinct values; \`char-ci=?\` does not.

\`(char-ci<? #\\a #\\B) \`=>\` #t\`
\` (char-ci=? #\\W #\\w) \`=>\` #t\`
\` (char-ci=? #\\= #\\+) \`=>\` #f\`
\` (let ([c #\\R])\`
\`   (list (char<=? #\\a c #\\z)\`
\`         (char-ci<=? #\\a c #\\z))) \`=>\` (#f #t)\`
`
    },
    {
        name: "(char-downcase ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s207"),
        description: `**procedure**: \`(char-downcase \`*char*\`)\`
**returns: **the lower-case character equivalent of *char*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If *char* is an upper- or title-case character and has a single lower-case counterpart, \`char-downcase\` returns the lower-case counterpart. Otherwise \`char-downcase\` returns *char*.

\`(char-downcase #\\g) \`=>\` #\\g\`
\` (char-downcase #\\G) \`=>\` #\\g\`
\` (char-downcase #\\7) \`=>\` #\\7\`
\` (char-downcase #\\\`=>\`) \`=>\` #\\\`=>
`
    },
    {
        name: "(char-foldcase ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s209"),
        description: `**procedure**: \`(char-foldcase \`*char*\`)\`
**returns: **the case-folded character equivalent of *char*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If *char* has a case-folded counterpart, \`char-foldcase\` returns the case-folded counterpart. Otherwise, \`char-foldcase\` returns *char*. For most characters, \`(char-foldcase \`*char*\`)\` is equivalent to \`(char-downcase (char-upcase \`*char*\`))\`, but for Turkic İ and ı, \`char-foldcase\` acts as the identity.

\`(char-foldcase #\\g) \`=>\` #\\g\`
\` (char-foldcase #\\G) \`=>\` #\\g\`
\` (char-foldcase #\\7) \`=>\` #\\7\`
\` (char-foldcase #\\\`=>\`) \`=>\` #\\\`
`
    },
    {
        name: "(char-general-category ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s205"),
        description: `**procedure**: \`(char-general-category \`*char*\`)\`
**returns: **a symbol representing the Unicode general category of *char*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

The return value is one of the symbols \`Lu\`, \`Ll\`, \`Lt\`, \`Lm\`, \`Lo\`, \`Mn\`, \`Mc\`, \`Me\`, \`Nd\`, \`Nl\`, \`No\`, \`Ps\`, \`Pe\`, \`Pi\`, \`Pf\`, \`Pd\`, \`Pc\`, \`Po\`, \`Sc\`, \`Sm\`, \`Sk\`, \`So\`, \`Zs\`, \`Zp\`, \`Zl\`, \`Cc\`, \`Cf\`, \`Cs\`, \`Co\`, or \`Cn\`.

\`(char-general-category #\\a) \`=>\` Ll\`
\` (char-general-category #\\space) \`=>\` Zs\`
\` (char-general-category #\\x10FFFF) \`=>\` Cn  \`
`
    },
    {
        name: "(char-lower-case? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s204"),
        description: `**procedure**: \`(char-lower-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is lower case, \`#f\` otherwise
**procedure**: \`(char-upper-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is upper case, \`#f\` otherwise
**procedure**: \`(char-title-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is title case, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

A character is upper-case if it has the Unicode "Uppercase" property, lower-case if it has the "Lowercase" property, and title-case if it is in the Lt general category.

\`(char-lower-case? #\\r) \`=>\` #t\`
\` (char-lower-case? #\\R) \`=>\` #f \`
\` \`
\` (char-upper-case? #\\r) \`=>\` #f\`
\` (char-upper-case? #\\R) \`=>\` #t \`
\` \`
\` (char-title-case? #\\I) \`=>\` #f\`
\` (char-title-case? #\\x01C5) \`=>\` #t\`
`
    },
    {
        name: "(char-name ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s107"),
        description: `**procedure**: \`(char-name \`*obj*\`)\`
**returns: **see below
**procedure**: \`(char-name \`*name*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`char-name\` is used to associate names (symbols) with characters or to retrieve the most recently associated name or character for a given character or name. A name can map to only one character, but more than one name can map to the same character. The name most recently associated with a character determines how that character prints, and each name associated with a character may be used after the \`#\\\` character prefix to name that character on input.

Character associations created by \`char-name\` are ignored by the printer unless the parameter \`print-char-name\` is set to a true value. The reader recognizes character names established by \`char-name\` except after \`#!r6rs\`, which is implied within a library or R6RS top-level program.

In the one-argument form, *obj* must be a symbol or character. If it is a symbol and a character is associated with the symbol, \`char-name\` returns that character. If it is a symbol and no character is associated with the symbol, \`char-name\` returns \`#f\`. Similarly, if *obj* is a character, \`char-name\` returns the most recently associated symbol for the character or \`#f\` if no name is associated with the character. For example, with the default set of character names:

\`(char-name #\\space) \`=>\` space\`
\` (char-name 'space) \`=>\` #\\space\`
\` (char-name 'nochar) \`=>\` #f\`
\` (char-name #\\a) \`=>\` #f\`

When passed two arguments, *name* is added to the set of names associated with *char*, and any other association for *name* is dropped. *char* may be \`#f\`, in which case any other association for *name* is dropped and no new association is formed. In either case, any other names associated with *char* remain associated with *char*.

The following interactive session demonstrates the use of \`char-name\` to establish and remove associations between characters and names, including the association of more than one name with a character.

\`(print-char-name #t)\`
\` (char-name 'etx) \`=>\` #f\`
\` (char-name 'etx #\\x3)\`
\` (char-name 'etx) \`=>\` #\\etx\`
\` (char-name #\\x3) \`=>\` etx\`
\` #\\etx \`=>\` #\\etx\`
\` (eq? #\\etx #\\x3) \`=>\` #t\`
\` #!r6rs #\\etx \`=>\` \`*exception: invalid character name etx*
\` #!chezscheme #\\etx \`=>\` #\\etx\`
\` (char-name 'etx #\\space)\`
\` (char-name #\\x3) \`=>\` #f\`
\` (char-name 'etx) \`=>\` #\\etx\`
\` #\\space \`=>\` #\\etx\`
\` (char-name 'etx #f)\`
\` #\\etx \`=>\` \`*exception: invalid character name etx*
\` #\\space \`=>\` #\\space\`

(When using the expression editor, it is necessary to type Control-J to force the editor to read the erroneous \`#\\etx\` input on the two inputs above that result in read errors, since typing Enter causes the expression editor to read the input only if the input is well-formed.)

The reader does not recognize hex scalar value escapes in character names, as it does in symbols, so \`#\\new\\x6c;ine\` is not equivalent to \`#\\newline\`. In general, programmers should avoid the use of character name symbols that cannot be entered without the use of hex scalar value escapes or other symbol-name escape mechanisms, since such character names will not be readable.
`
    },
    {
        name: "(char-name ",
        endParen: true,
        params: ["name", "char"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s107"),
        description: `**procedure**: \`(char-name \`*obj*\`)\`
**returns: **see below
**procedure**: \`(char-name \`*name*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`char-name\` is used to associate names (symbols) with characters or to retrieve the most recently associated name or character for a given character or name. A name can map to only one character, but more than one name can map to the same character. The name most recently associated with a character determines how that character prints, and each name associated with a character may be used after the \`#\\\` character prefix to name that character on input.

Character associations created by \`char-name\` are ignored by the printer unless the parameter \`print-char-name\` is set to a true value. The reader recognizes character names established by \`char-name\` except after \`#!r6rs\`, which is implied within a library or R6RS top-level program.

In the one-argument form, *obj* must be a symbol or character. If it is a symbol and a character is associated with the symbol, \`char-name\` returns that character. If it is a symbol and no character is associated with the symbol, \`char-name\` returns \`#f\`. Similarly, if *obj* is a character, \`char-name\` returns the most recently associated symbol for the character or \`#f\` if no name is associated with the character. For example, with the default set of character names:

\`(char-name #\\space) \`=>\` space\`
\` (char-name 'space) \`=>\` #\\space\`
\` (char-name 'nochar) \`=>\` #f\`
\` (char-name #\\a) \`=>\` #f\`

When passed two arguments, *name* is added to the set of names associated with *char*, and any other association for *name* is dropped. *char* may be \`#f\`, in which case any other association for *name* is dropped and no new association is formed. In either case, any other names associated with *char* remain associated with *char*.

The following interactive session demonstrates the use of \`char-name\` to establish and remove associations between characters and names, including the association of more than one name with a character.

\`(print-char-name #t)\`
\` (char-name 'etx) \`=>\` #f\`
\` (char-name 'etx #\\x3)\`
\` (char-name 'etx) \`=>\` #\\etx\`
\` (char-name #\\x3) \`=>\` etx\`
\` #\\etx \`=>\` #\\etx\`
\` (eq? #\\etx #\\x3) \`=>\` #t\`
\` #!r6rs #\\etx \`=>\` \`*exception: invalid character name etx*
\` #!chezscheme #\\etx \`=>\` #\\etx\`
\` (char-name 'etx #\\space)\`
\` (char-name #\\x3) \`=>\` #f\`
\` (char-name 'etx) \`=>\` #\\etx\`
\` #\\space \`=>\` #\\etx\`
\` (char-name 'etx #f)\`
\` #\\etx \`=>\` \`*exception: invalid character name etx*
\` #\\space \`=>\` #\\space\`

(When using the expression editor, it is necessary to type Control-J to force the editor to read the erroneous \`#\\etx\` input on the two inputs above that result in read errors, since typing Enter causes the expression editor to read the input only if the input is well-formed.)

The reader does not recognize hex scalar value escapes in character names, as it does in symbols, so \`#\\new\\x6c;ine\` is not equivalent to \`#\\newline\`. In general, programmers should avoid the use of character name symbols that cannot be entered without the use of hex scalar value escapes or other symbol-name escape mechanisms, since such character names will not be readable.
`
    },
    {
        name: "(char-numeric? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s203"),
        description: `**procedure**: \`(char-alphabetic? \`*char*\`)\`
**returns: **\`#t\` if *char* is a letter, \`#f\` otherwise
**procedure**: \`(char-numeric? \`*char*\`)\`
**returns: **\`#t\` if *char* is a digit, \`#f\` otherwise
**procedure**: \`(char-whitespace? \`*char*\`)\`
**returns: **\`#t\` if *char* is whitespace, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

A character is alphabetic if it has the Unicode "Alphabetic" property, numeric if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space" property.

\`(char-alphabetic? #\\a) \`=>\` #t\`
\` (char-alphabetic? #\\T) \`=>\` #t\`
\` (char-alphabetic? #\\8) \`=>\` #f\`
\` (char-alphabetic? #\\$) \`=>\` #f \`
\` \`
\` (char-numeric? #\\7) \`=>\` #t\`
\` (char-numeric? #\\2) \`=>\` #t\`
\` (char-numeric? #\\X) \`=>\` #f\`
\` (char-numeric? #\\space) \`=>\` #f \`
\` \`
\` (char-whitespace? #\\space) \`=>\` #t\`
\` (char-whitespace? #\\newline) \`=>\` #t\`
\` (char-whitespace? #\\Z) \`=>\` #f\`
`
    },
    {
        name: "(char-ready?)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s68"),
        description: `**procedure**: \`(char-ready?)\`
**procedure**: \`(char-ready? \`*textual-input-port*\`)\`
**returns: **\`#t\` if a character is available on *textual-input-port*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *textual-input-port* is not supplied, it defaults to the current input port. \`char-ready?\` is like \`input-port-ready?\` except it is restricted to textual input ports.
`
    },
    {
        name: "(char-ready? ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s68"),
        description: `**procedure**: \`(char-ready?)\`
**procedure**: \`(char-ready? \`*textual-input-port*\`)\`
**returns: **\`#t\` if a character is available on *textual-input-port*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *textual-input-port* is not supplied, it defaults to the current input port. \`char-ready?\` is like \`input-port-ready?\` except it is restricted to textual input ports.
`
    },
    {
        name: "(char-title-case? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s204"),
        description: `**procedure**: \`(char-lower-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is lower case, \`#f\` otherwise
**procedure**: \`(char-upper-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is upper case, \`#f\` otherwise
**procedure**: \`(char-title-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is title case, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

A character is upper-case if it has the Unicode "Uppercase" property, lower-case if it has the "Lowercase" property, and title-case if it is in the Lt general category.

\`(char-lower-case? #\\r) \`=>\` #t\`
\` (char-lower-case? #\\R) \`=>\` #f \`
\` \`
\` (char-upper-case? #\\r) \`=>\` #f\`
\` (char-upper-case? #\\R) \`=>\` #t \`
\` \`
\` (char-title-case? #\\I) \`=>\` #f\`
\` (char-title-case? #\\x01C5) \`=>\` #t\`
`
    },
    {
        name: "(char-titlecase ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s208"),
        description: `**procedure**: \`(char-titlecase \`*char*\`)\`
**returns: **the title-case character equivalent of *char*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If *char* is an upper- or lower-case character and has a single title-case counterpart, \`char-titlecase\` returns the title-case counterpart. Otherwise, if it is not a title-case character, has no single title-case counterpart, but does have a single upper-case counterpart, \`char-titlecase\` returns the upper-case counterpart. Otherwise \`char-titlecase\` returns *char*.

\`(char-titlecase #\\g) \`=>\` #\\G\`
\` (char-titlecase #\\G) \`=>\` #\\G\`
\` (char-titlecase #\\7) \`=>\` #\\7\`
\` (char-titlecase #\\\`=>\`) \`=>\` #\\\`
`
    },
    {
        name: "(char-upcase ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s206"),
        description: `**procedure**: \`(char-upcase \`*char*\`)\`
**returns: **the upper-case character counterpart of *char*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If *char* is a lower- or title-case character and has a single upper-case counterpart, \`char-upcase\` returns the upper-case counterpart. Otherwise \`char-upcase\` returns *char*.

\`(char-upcase #\\g) \`=>\` #\\G\`
\` (char-upcase #\\G) \`=>\` #\\G\`
\` (char-upcase #\\7) \`=>\` #\\7\`
\` (char-upcase #\\\`=>\`) \`=>\` #\\\`
`
    },
    {
        name: "(char-upper-case? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s204"),
        description: `**procedure**: \`(char-lower-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is lower case, \`#f\` otherwise
**procedure**: \`(char-upper-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is upper case, \`#f\` otherwise
**procedure**: \`(char-title-case? \`*char*\`)\`
**returns: **\`#t\` if *char* is title case, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

A character is upper-case if it has the Unicode "Uppercase" property, lower-case if it has the "Lowercase" property, and title-case if it is in the Lt general category.

\`(char-lower-case? #\\r) \`=>\` #t\`
\` (char-lower-case? #\\R) \`=>\` #f \`
\` \`
\` (char-upper-case? #\\r) \`=>\` #f\`
\` (char-upper-case? #\\R) \`=>\` #t \`
\` \`
\` (char-title-case? #\\I) \`=>\` #f\`
\` (char-title-case? #\\x01C5) \`=>\` #t\`
`
    },
    {
        name: "(char-whitespace? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s203"),
        description: `**procedure**: \`(char-alphabetic? \`*char*\`)\`
**returns: **\`#t\` if *char* is a letter, \`#f\` otherwise
**procedure**: \`(char-numeric? \`*char*\`)\`
**returns: **\`#t\` if *char* is a digit, \`#f\` otherwise
**procedure**: \`(char-whitespace? \`*char*\`)\`
**returns: **\`#t\` if *char* is whitespace, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

A character is alphabetic if it has the Unicode "Alphabetic" property, numeric if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space" property.

\`(char-alphabetic? #\\a) \`=>\` #t\`
\` (char-alphabetic? #\\T) \`=>\` #t\`
\` (char-alphabetic? #\\8) \`=>\` #f\`
\` (char-alphabetic? #\\$) \`=>\` #f \`
\` \`
\` (char-numeric? #\\7) \`=>\` #t\`
\` (char-numeric? #\\2) \`=>\` #t\`
\` (char-numeric? #\\X) \`=>\` #f\`
\` (char-numeric? #\\space) \`=>\` #f \`
\` \`
\` (char-whitespace? #\\space) \`=>\` #t\`
\` (char-whitespace? #\\newline) \`=>\` #t\`
\` (char-whitespace? #\\Z) \`=>\` #f\`
`
    },
    {
        name: "(char<=? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char<=? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s201"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates behave in a similar manner to the numeric predicates \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`. For example, \`char=?\` returns \`#t\` when its arguments are equivalent characters, and \`char<?\` returns \`#t\` when its arguments are monotonically increasing character (Unicode scalar) values.

\`(char>? #\\a #\\b) \`=>\` #f\`
\` (char<? #\\a #\\b) \`=>\` #t\`
\` (char<? #\\a #\\b #\\c) \`=>\` #t\`
\` (let ([c #\\r])\`
\`   (char<=? #\\a c #\\z)) \`=>\` #t\`
\` (char<=? #\\Z #\\W) \`=>\` #f\`
\` (char=? #\\+ #\\+) \`=>\` #t\`
`
    },
    {
        name: "(char<? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char<? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s201"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates behave in a similar manner to the numeric predicates \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`. For example, \`char=?\` returns \`#t\` when its arguments are equivalent characters, and \`char<?\` returns \`#t\` when its arguments are monotonically increasing character (Unicode scalar) values.

\`(char>? #\\a #\\b) \`=>\` #f\`
\` (char<? #\\a #\\b) \`=>\` #t\`
\` (char<? #\\a #\\b #\\c) \`=>\` #t\`
\` (let ([c #\\r])\`
\`   (char<=? #\\a c #\\z)) \`=>\` #t\`
\` (char<=? #\\Z #\\W) \`=>\` #f\`
\` (char=? #\\+ #\\+) \`=>\` #t\`
`
    },
    {
        name: "(char=? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char=? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s201"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates behave in a similar manner to the numeric predicates \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`. For example, \`char=?\` returns \`#t\` when its arguments are equivalent characters, and \`char<?\` returns \`#t\` when its arguments are monotonically increasing character (Unicode scalar) values.

\`(char>? #\\a #\\b) \`=>\` #f\`
\` (char<? #\\a #\\b) \`=>\` #t\`
\` (char<? #\\a #\\b #\\c) \`=>\` #t\`
\` (let ([c #\\r])\`
\`   (char<=? #\\a c #\\z)) \`=>\` #t\`
\` (char<=? #\\Z #\\W) \`=>\` #f\`
\` (char=? #\\+ #\\+) \`=>\` #t\`
`
    },
    {
        name: "(char>=? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char>=? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s201"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates behave in a similar manner to the numeric predicates \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`. For example, \`char=?\` returns \`#t\` when its arguments are equivalent characters, and \`char<?\` returns \`#t\` when its arguments are monotonically increasing character (Unicode scalar) values.

\`(char>? #\\a #\\b) \`=>\` #f\`
\` (char<? #\\a #\\b) \`=>\` #t\`
\` (char<? #\\a #\\b #\\c) \`=>\` #t\`
\` (let ([c #\\r])\`
\`   (char<=? #\\a c #\\z)) \`=>\` #t\`
\` (char<=? #\\Z #\\W) \`=>\` #f\`
\` (char=? #\\+ #\\+) \`=>\` #t\`
`
    },
    {
        name: "(char>? ",
        endParen: true,
        params: ["char1", "char2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s15"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci<=? \`*char1*\` \`*char2*\` ...)\`
**procedure**: \`(char-ci>=? \`*char1*\` \`*char2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(char>? #\\a) \`=>\` #t\`
\` (char<? #\\a) \`=>\` #t\`
\` (char-ci=? #\\a) \`=>\` #t\`
`
    },
    {
        name: "(char>? ",
        endParen: true,
        params: ["char1", "char2", "char3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s201"),
        description: `**procedure**: \`(char=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char<=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**procedure**: \`(char>=? \`*char1*\` \`*char2*\` \`*char3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates behave in a similar manner to the numeric predicates \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`. For example, \`char=?\` returns \`#t\` when its arguments are equivalent characters, and \`char<?\` returns \`#t\` when its arguments are monotonically increasing character (Unicode scalar) values.

\`(char>? #\\a #\\b) \`=>\` #f\`
\` (char<? #\\a #\\b) \`=>\` #t\`
\` (char<? #\\a #\\b #\\c) \`=>\` #t\`
\` (let ([c #\\r])\`
\`   (char<=? #\\a c #\\z)) \`=>\` #t\`
\` (char<=? #\\Z #\\W) \`=>\` #f\`
\` (char=? #\\+ #\\+) \`=>\` #t\`
`
    },
    {
        name: "(char? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s19"),
        description: `**procedure**: \`(char? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a character, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (char? 'a) \`=>\` #f\`
\` (char? 97) \`=>\` #f\`
\` (char? #\\a) \`=>\` #t\`
\` (char? "a") \`=>\` #f\`
\` (char? (string-ref (make-string 1) 0)) \`=>\` #t\`
`
    },
    {
        name: "(chmod ",
        endParen: true,
        params: ["path", "mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s150"),
        description: `**procedure**: \`(chmod \`*path*\` \`*mode*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. *mode* must be a fixnum.

\`chmod\` sets the permissions on the file named by *path* to *mode*. Bits 0, 1, and 2 of *mode* are the execute, write, and read permission bits for users other than the file's owner who are not in the file's group. Bits 3-5 are the execute, write, and read permission bits for users other than the file's owner but in the file's group. Bits 6-8 are the execute, write, and read permission bits for the file's owner. Bits 7-9 are the Unix sticky, set-group-id, and set-user-id bits. Under Windows, all but the user "write" bit are ignored. If the file does not exist or the permissions cannot be changed, an exception is raised with condition type \`&i/o-filename\`.
`
    },
    {
        name: "(clear-input-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s36"),
        description: `**procedure**: \`(clear-input-port)\`
**procedure**: \`(clear-input-port \`*input-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *input-port* is not supplied, it defaults to the current input port. This procedure discards any data in the buffer associated with *input-port*. This may be necessary, for example, to clear any type-ahead from the keyboard in preparation for an urgent query.
`
    },
    {
        name: "(clear-input-port ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s36"),
        description: `**procedure**: \`(clear-input-port)\`
**procedure**: \`(clear-input-port \`*input-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *input-port* is not supplied, it defaults to the current input port. This procedure discards any data in the buffer associated with *input-port*. This may be necessary, for example, to clear any type-ahead from the keyboard in preparation for an urgent query.
`
    },
    {
        name: "(clear-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s37"),
        description: `**procedure**: \`(clear-output-port)\`
**procedure**: \`(clear-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *output-port* is not supplied, it defaults to the current output port. This procedure discards any data in the buffer associated with *output-port*. This may be necessary, for example, to clear any pending output on an interactive port in preparation for an urgent message.
`
    },
    {
        name: "(clear-output-port ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s37"),
        description: `**procedure**: \`(clear-output-port)\`
**procedure**: \`(clear-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *output-port* is not supplied, it defaults to the current output port. This procedure discards any data in the buffer associated with *output-port*. This may be necessary, for example, to clear any pending output on an interactive port in preparation for an urgent message.
`
    },
    {
        name: "(close-input-port ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s88"),
        description: `**procedure**: \`(close-input-port \`*input-port*\`)\`
**procedure**: \`(close-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

\`close-input-port\` closes an input port, and \`close-output-port\` closes an output port. These procedures are provided for backward compatibility with the Revised Report; they are not actually more convenient to use than \`close-port\`.
`
    },
    {
        name: "(close-output-port ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s88"),
        description: `**procedure**: \`(close-input-port \`*input-port*\`)\`
**procedure**: \`(close-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

\`close-input-port\` closes an input port, and \`close-output-port\` closes an output port. These procedures are provided for backward compatibility with the Revised Report; they are not actually more convenient to use than \`close-port\`.
`
    },
    {
        name: "(close-port ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s46"),
        description: `**procedure**: \`(close-port \`*port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *port* is not already closed, \`close-port\` closes it, first flushing any buffered bytes or characters to the underlying stream if the port is an output port. Once a port has been closed, no more input or output operations may be performed on the port. Because the operating system may place limits on the number of file ports open at one time or restrict access to an open file, it is good practice to close any file port that will no longer be used for input or output. If the port is an output port, closing the port explicitly also ensures that buffered data is written to the underlying stream. Some Scheme implementations close file ports automatically after they become inaccessible to the program or when the Scheme program exits, but it is best to close file ports explicitly whenever possible. Closing a port that has already been closed has no effect.
`
    },
    {
        name: "(collect)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s9"),
        description: `**procedure**: \`(collect)\`
**procedure**: \`(collect \`*cg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*max-tg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*min-tg*\` \`*max-tg*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure causes the storage manager to perform a garbage collection. \`collect\` is invoked periodically without arguments by the default collect-request handler, but it may also be called explicitly, e.g., from a custom collect-request handler, between phases of a computation when collection is most likely to be successful, or before timing a computation. In the threaded versions of , the thread that invokes \`collect\` must be the only active thread.

When called without arguments, the system determines automatically which generations to collect and the target generation for each collected generation as described in the lead-in to this section.

When called with arguments, the system collects all and only objects in generations less than or equal to *cg* (the maximum collected generation) into the target generation or generations determined by *min-tg* (the minimum target generation) and *max-tg* (the maximum target generation). Specifically, the target generation for any object in a collected generation *g* is , where \`static\` is taken to have the value one greater than the maximum nonstatic generation.

If present, *cg* must be a nonnegative fixnum no greater than the maximum nonstatic generation, i.e., the current value of the parameter \`collect-maximum-generation\`.

If present, *max-tg* must be a nonnegative fixnum or the symbol \`static\` and either equal to *cg* or one greater than *cg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. If *max-tg* is not present (but *cg* is), it defaults to *cg* if *cg* is equal to the maximum target generation and to one more than *cg* otherwise.

If present, *min-tg* must be a nonnegative fixnum or the symbol \`static\` and no greater than *max-tg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. Unless *max-cg* is the same as *cg*, *min-tg* must also be greater than *cg*. If *min-tg* is not present (but *cg* is), it defaults to the same value as *max-tg*.
`
    },
    {
        name: "(collect ",
        endParen: true,
        params: ["cg"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s9"),
        description: `**procedure**: \`(collect)\`
**procedure**: \`(collect \`*cg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*max-tg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*min-tg*\` \`*max-tg*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure causes the storage manager to perform a garbage collection. \`collect\` is invoked periodically without arguments by the default collect-request handler, but it may also be called explicitly, e.g., from a custom collect-request handler, between phases of a computation when collection is most likely to be successful, or before timing a computation. In the threaded versions of , the thread that invokes \`collect\` must be the only active thread.

When called without arguments, the system determines automatically which generations to collect and the target generation for each collected generation as described in the lead-in to this section.

When called with arguments, the system collects all and only objects in generations less than or equal to *cg* (the maximum collected generation) into the target generation or generations determined by *min-tg* (the minimum target generation) and *max-tg* (the maximum target generation). Specifically, the target generation for any object in a collected generation *g* is , where \`static\` is taken to have the value one greater than the maximum nonstatic generation.

If present, *cg* must be a nonnegative fixnum no greater than the maximum nonstatic generation, i.e., the current value of the parameter \`collect-maximum-generation\`.

If present, *max-tg* must be a nonnegative fixnum or the symbol \`static\` and either equal to *cg* or one greater than *cg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. If *max-tg* is not present (but *cg* is), it defaults to *cg* if *cg* is equal to the maximum target generation and to one more than *cg* otherwise.

If present, *min-tg* must be a nonnegative fixnum or the symbol \`static\` and no greater than *max-tg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. Unless *max-cg* is the same as *cg*, *min-tg* must also be greater than *cg*. If *min-tg* is not present (but *cg* is), it defaults to the same value as *max-tg*.
`
    },
    {
        name: "(collect ",
        endParen: true,
        params: ["cg", "max-tg"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s9"),
        description: `**procedure**: \`(collect)\`
**procedure**: \`(collect \`*cg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*max-tg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*min-tg*\` \`*max-tg*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure causes the storage manager to perform a garbage collection. \`collect\` is invoked periodically without arguments by the default collect-request handler, but it may also be called explicitly, e.g., from a custom collect-request handler, between phases of a computation when collection is most likely to be successful, or before timing a computation. In the threaded versions of , the thread that invokes \`collect\` must be the only active thread.

When called without arguments, the system determines automatically which generations to collect and the target generation for each collected generation as described in the lead-in to this section.

When called with arguments, the system collects all and only objects in generations less than or equal to *cg* (the maximum collected generation) into the target generation or generations determined by *min-tg* (the minimum target generation) and *max-tg* (the maximum target generation). Specifically, the target generation for any object in a collected generation *g* is , where \`static\` is taken to have the value one greater than the maximum nonstatic generation.

If present, *cg* must be a nonnegative fixnum no greater than the maximum nonstatic generation, i.e., the current value of the parameter \`collect-maximum-generation\`.

If present, *max-tg* must be a nonnegative fixnum or the symbol \`static\` and either equal to *cg* or one greater than *cg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. If *max-tg* is not present (but *cg* is), it defaults to *cg* if *cg* is equal to the maximum target generation and to one more than *cg* otherwise.

If present, *min-tg* must be a nonnegative fixnum or the symbol \`static\` and no greater than *max-tg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. Unless *max-cg* is the same as *cg*, *min-tg* must also be greater than *cg*. If *min-tg* is not present (but *cg* is), it defaults to the same value as *max-tg*.
`
    },
    {
        name: "(collect ",
        endParen: true,
        params: ["cg", "min-tg", "max-tg"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s9"),
        description: `**procedure**: \`(collect)\`
**procedure**: \`(collect \`*cg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*max-tg*\`)\`
**procedure**: \`(collect \`*cg*\` \`*min-tg*\` \`*max-tg*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure causes the storage manager to perform a garbage collection. \`collect\` is invoked periodically without arguments by the default collect-request handler, but it may also be called explicitly, e.g., from a custom collect-request handler, between phases of a computation when collection is most likely to be successful, or before timing a computation. In the threaded versions of , the thread that invokes \`collect\` must be the only active thread.

When called without arguments, the system determines automatically which generations to collect and the target generation for each collected generation as described in the lead-in to this section.

When called with arguments, the system collects all and only objects in generations less than or equal to *cg* (the maximum collected generation) into the target generation or generations determined by *min-tg* (the minimum target generation) and *max-tg* (the maximum target generation). Specifically, the target generation for any object in a collected generation *g* is , where \`static\` is taken to have the value one greater than the maximum nonstatic generation.

If present, *cg* must be a nonnegative fixnum no greater than the maximum nonstatic generation, i.e., the current value of the parameter \`collect-maximum-generation\`.

If present, *max-tg* must be a nonnegative fixnum or the symbol \`static\` and either equal to *cg* or one greater than *cg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. If *max-tg* is not present (but *cg* is), it defaults to *cg* if *cg* is equal to the maximum target generation and to one more than *cg* otherwise.

If present, *min-tg* must be a nonnegative fixnum or the symbol \`static\` and no greater than *max-tg*, again treating \`static\` as having the value one greater than the maximum nonstatic generation. Unless *max-cg* is the same as *cg*, *min-tg* must also be greater than *cg*. If *min-tg* is not present (but *cg* is), it defaults to the same value as *max-tg*.
`
    },
    {
        name: "collect-generation-radix",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s15"),
        description: `**global parameter**: \`collect-generation-radix\`
**libraries: **\`(chezscheme)\`

This parameter determines how often each generation is collected when \`collect\` is invoked without arguments, as by the default collect-request handler. Its value must be a positive fixnum. Generations are collected once every times a collection occurs, where is the value of \`collect-generation-radix\` and is the generation number.

Setting \`collect-generation-radix\` to one forces all generations to be collected each time a collection occurs. Setting \`collect-generation-radix\` to a very large number effectively delays collection of older generations indefinitely.
`
    },
    {
        name: "collect-maximum-generation",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s16"),
        description: `**global parameter**: \`collect-maximum-generation\`
**libraries: **\`(chezscheme)\`

This parameter determines the maximum nonstatic generation, hence the total number of generations, currently in use. Its value is an exact integer in the range 1 through 254. When set to 1, only two nonstatic generations are used; when set to 2, three nonstatic generations are used, and so on. When set to 254, 255 nonstatic generations are used, plus the single static generation for a total of 256 generations. Increasing the number of generations effectively decreases how often old objects are collected, potentially decreasing collection overhead but potentially increasing the number of inaccessible objects retained in the system and thus the total amount of memory required.
`
    },
    {
        name: "collect-notify",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s11"),
        description: `**global parameter**: \`collect-notify\`
**libraries: **\`(chezscheme)\`

If \`collect-notify\` is set to a true value, the collector prints a message whenever a collection is run. \`collect-notify\` is set to \`#f\` by default.
`
    },
    {
        name: "(collect-rendezvous)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s10"),
        description: `**procedure**: \`(collect-rendezvous)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Requests a garbage collection in the same way as when the system determines that a collection should occur. All running threads are coordinated so that one of them calls the collect-request handler, while the other threads pause until the handler returns.

Note that if the collect-request handler (see \`collect-request-handler\`) does not call \`collect\`, then \`collect-rendezvous\` does not actually perform a garbage collection.
`
    },
    {
        name: "collect-request-handler",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s17"),
        description: `**global parameter**: \`collect-request-handler\`
**libraries: **\`(chezscheme)\`

The value of \`collect-request-handler\` must be a procedure. The procedure is invoked without arguments whenever the system determines that a collection should occur, i.e., some time after an amount of storage determined by the parameter \`collect-trip-bytes\` has been allocated since the last collection.

By default, \`collect-request-handler\` simply invokes \`collect\` without arguments.

Automatic collection may be disabled by setting \`collect-request-handler\` to a procedure that does nothing, e.g.:

\`(collect-request-handler void)\`

Collection can also be temporarily disabled using \`critical-section\`, which prevents any interrupts from being handled.

In the threaded versions of , the collect-request handler is invoked by a single thread with all other threads temporarily suspended.
`
    },
    {
        name: "collect-trip-bytes",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s12"),
        description: `**global parameter**: \`collect-trip-bytes\`
**libraries: **\`(chezscheme)\`

This parameter determines the approximate amount of storage that is allowed to be allocated between garbage collections. Its value must be a positive fixnum.
`
    },
    {
        name: "(collections)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s229"),
        description: `**procedure**: \`(collections)\`
**returns: **the number garbage collections so far
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "command-line",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s193"),
        description: `**global parameter**: \`command-line\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(command-line)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/libraries.html#./libraries:s17"),
        description: `**procedure**: \`(command-line)\`
**returns: **a list of strings representing command-line arguments
**libraries: **\`(rnrs programs)\`, \`(rnrs)\`

This procedure may be used within a top-level program to obtain a list of the command-line arguments passed to the program.
`
    },
    {
        name: "command-line-arguments",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s195"),
        description: `**global parameter**: \`command-line-arguments\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "commonization-level",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s122"),
        description: `**thread parameter**: \`commonization-level\`
**libraries: **\`(chezscheme)\`

After running the main source optimization pass (cp0) for the last time, the compiler optionally runs a pass. The pass commonizes the code for lambda expressions that have identical structure by abstracting differences at certain leaves of the program, namely constants, references to unassigned variables, and references to primitives. The parameter \`commonization-level\` controls whether commonization is run and, if so, how aggressive it is. Its value must be a nonnegative exact integer ranging from 0 through 9. When the parameter is set to 0, the default, commonization is not run. Otherwise, higher values result in more commonization.

Commonization can undo some of the effects of cp0's inlining, can add run-time overhead, and can complicate debugging, particularly at higher commonization levels, which is why it is disabled by default. On the other hand, for macros or other meta programs that can generate large, mostly similar lambda expressions, enabling commonization can result in significant savings in object-code size and even reduce run-time overhead by making more efficient use of instruction caches.
`
    },
    {
        name: "(compile ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s43"),
        description: `**procedure**: \`(compile \`*obj*\`)\`
**procedure**: \`(compile \`*obj*\` \`*env*\`)\`
**returns: **value of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

*obj*, which can be an annotation (Section ) or unannotated value, is treated as a Scheme expression, expanded with the current expander (the value of \`current-expand\`) in the specified environment (or the interaction environment, if no environment is provided), compiled to machine code, and executed. \`compile\` is the default value of the \`current-eval\` parameter.
`
    },
    {
        name: "(compile ",
        endParen: true,
        params: ["obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s43"),
        description: `**procedure**: \`(compile \`*obj*\`)\`
**procedure**: \`(compile \`*obj*\` \`*env*\`)\`
**returns: **value of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

*obj*, which can be an annotation (Section ) or unannotated value, is treated as a Scheme expression, expanded with the current expander (the value of \`current-expand\`) in the specified environment (or the interaction environment, if no environment is provided), compiled to machine code, and executed. \`compile\` is the default value of the \`current-eval\` parameter.
`
    },
    {
        name: "(compile-file ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s63"),
        description: `**procedure**: \`(compile-file \`*input-filename*\`)\`
**procedure**: \`(compile-file \`*input-filename*\` \`*output-filename*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings. *input-filename* must name an existing, readable file. It must contain a sequence of zero or more source expressions; if this is not the case, \`compile-file\` raises an exception with condition type \`&syntax\`.
`
    },
    {
        name: "(compile-file ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s63"),
        description: `**procedure**: \`(compile-file \`*input-filename*\`)\`
**procedure**: \`(compile-file \`*input-filename*\` \`*output-filename*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings. *input-filename* must name an existing, readable file. It must contain a sequence of zero or more source expressions; if this is not the case, \`compile-file\` raises an exception with condition type \`&syntax\`.
`
    },
    {
        name: "compile-file-message",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s119"),
        description: `**thread parameter**: \`compile-file-message\`
**libraries: **\`(chezscheme)\`

When this parameter is set to true, the default, \`compile-file\`, \`compile-library\`, \`compile-program\`, and \`compile-script\` print a message of the form:

\`compiling \`*input-path*\` with output to \`*output-path*

When the parameter is set to \`#f\`, the message is not printed.
`
    },
    {
        name: "compile-imported-libraries",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s26"),
        description: `**thread parameter**: \`compile-imported-libraries\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "compile-interpret-simple",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s112"),
        description: `**thread parameter**: \`compile-interpret-simple\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(compile-library ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s68"),
        description: `**procedure**: \`(compile-library \`*input-filename*\`)\`
**procedure**: \`(compile-library \`*input-filename*\` \`*output-filename*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings.

\`compile-library\` is identical to \`compile-file\` except that it treats the input file as if it were prefixed by an implicit \`#!r6rs\`. This effectively disables any non-R6RS lexical syntax except where subsequently overridden by \`#!chezscheme\`.
`
    },
    {
        name: "(compile-library ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s68"),
        description: `**procedure**: \`(compile-library \`*input-filename*\`)\`
**procedure**: \`(compile-library \`*input-filename*\` \`*output-filename*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings.

\`compile-library\` is identical to \`compile-file\` except that it treats the input file as if it were prefixed by an implicit \`#!r6rs\`. This effectively disables any non-R6RS lexical syntax except where subsequently overridden by \`#!chezscheme\`.
`
    },
    {
        name: "compile-library-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s72"),
        description: `**thread parameter**: \`compile-library-handler\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(compile-port ",
        endParen: true,
        params: ["input-port", "output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s79"),
        description: `**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-port* must be a textual input port. *output-port* and, if present and non-false, *wpo-port* must be binary output ports. If present and non-false, *sfd* must be a source-file descriptor. If present and non-false, *covop* must be a textual output port.

\`compile-port\` is like \`compile-file\` except that it takes input from an arbitrary textual input port and sends output to an arbitrary binary output port. If *sfd* is supplied, it is passed to the reader so that source information can be associated with the expressions read from *input-port*. It is also used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is supplied, \`compile-port\` sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is supplied, \`compile-port\` sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are closed automatically after compilation under the assumption the program that opens the ports and invokes \`compile-port\` will take care of closing the ports.
`
    },
    {
        name: "(compile-port ",
        endParen: true,
        params: ["input-port", "output-port", "sfd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s79"),
        description: `**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-port* must be a textual input port. *output-port* and, if present and non-false, *wpo-port* must be binary output ports. If present and non-false, *sfd* must be a source-file descriptor. If present and non-false, *covop* must be a textual output port.

\`compile-port\` is like \`compile-file\` except that it takes input from an arbitrary textual input port and sends output to an arbitrary binary output port. If *sfd* is supplied, it is passed to the reader so that source information can be associated with the expressions read from *input-port*. It is also used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is supplied, \`compile-port\` sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is supplied, \`compile-port\` sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are closed automatically after compilation under the assumption the program that opens the ports and invokes \`compile-port\` will take care of closing the ports.
`
    },
    {
        name: "(compile-port ",
        endParen: true,
        params: ["input-port", "output-port", "sfd", "wpo-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s79"),
        description: `**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-port* must be a textual input port. *output-port* and, if present and non-false, *wpo-port* must be binary output ports. If present and non-false, *sfd* must be a source-file descriptor. If present and non-false, *covop* must be a textual output port.

\`compile-port\` is like \`compile-file\` except that it takes input from an arbitrary textual input port and sends output to an arbitrary binary output port. If *sfd* is supplied, it is passed to the reader so that source information can be associated with the expressions read from *input-port*. It is also used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is supplied, \`compile-port\` sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is supplied, \`compile-port\` sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are closed automatically after compilation under the assumption the program that opens the ports and invokes \`compile-port\` will take care of closing the ports.
`
    },
    {
        name: "(compile-port ",
        endParen: true,
        params: ["input-port", "output-port", "sfd", "wpo-port", "covop"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s79"),
        description: `**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-port \`*input-port*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-port* must be a textual input port. *output-port* and, if present and non-false, *wpo-port* must be binary output ports. If present and non-false, *sfd* must be a source-file descriptor. If present and non-false, *covop* must be a textual output port.

\`compile-port\` is like \`compile-file\` except that it takes input from an arbitrary textual input port and sends output to an arbitrary binary output port. If *sfd* is supplied, it is passed to the reader so that source information can be associated with the expressions read from *input-port*. It is also used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is supplied, \`compile-port\` sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is supplied, \`compile-port\` sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are closed automatically after compilation under the assumption the program that opens the ports and invokes \`compile-port\` will take care of closing the ports.
`
    },
    {
        name: "compile-profile",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s140"),
        description: `**thread parameter**: \`compile-profile\`
**libraries: **\`(chezscheme)\`

When this parameter is set to the symbol \`source\` or the boolean value \`#t\`, the compiler instruments the code it generates with instructions that count the number of times each section of source code is executed. When set to the symbol \`block\`, the compiler similarly instruments the code it generates with instructions that count the number of times each block of code is executed. When set to \`#f\` (the default), the compiler does not insert these instructions.

The general description of profiling above describes how the source and block profile information can be viewed or used for optimization.

The code generated when \`compile-profile\` is non-false is larger and less efficient, so this parameter should be set only when profile information is needed.
`
    },
    {
        name: "(compile-program ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s69"),
        description: `**procedure**: \`(compile-program \`*input-filename*\`)\`
**procedure**: \`(compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **a list of libraries invoked by the program
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings.

\`compile-program\` is like \`compile-script\` but differs in that it implements the semantics of RNRS top-level programs, while \`compile-script\` implements the semantics of the interactive top-level. The resulting compiled program will also run faster than if compiled via \`compile-file\` or \`compile-script\`.

\`compile-program\` returns a list of libraries directly invoked by the compiled top-level program, excluding built-in libraries like \`(rnrs)\` and \`(chezscheme)\`. The procedure \`library-requirements\` may be used to determine the indirect requirements, i.e., additional libraries required by the directly invoked libraries. When combined with \`library-object-filename\`, this information can be used to determine the set of files that must be distributed with the compiled program file.

A program invokes a library only if it references one or more variables exported from the library. The set of libraries invoked by a top-level program, and hence loaded when the program is loaded, might be smaller than the set imported by the program, and it might be larger than the set directly imported by the program.
`
    },
    {
        name: "(compile-program ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s69"),
        description: `**procedure**: \`(compile-program \`*input-filename*\`)\`
**procedure**: \`(compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **a list of libraries invoked by the program
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings.

\`compile-program\` is like \`compile-script\` but differs in that it implements the semantics of RNRS top-level programs, while \`compile-script\` implements the semantics of the interactive top-level. The resulting compiled program will also run faster than if compiled via \`compile-file\` or \`compile-script\`.

\`compile-program\` returns a list of libraries directly invoked by the compiled top-level program, excluding built-in libraries like \`(rnrs)\` and \`(chezscheme)\`. The procedure \`library-requirements\` may be used to determine the indirect requirements, i.e., additional libraries required by the directly invoked libraries. When combined with \`library-object-filename\`, this information can be used to determine the set of files that must be distributed with the compiled program file.

A program invokes a library only if it references one or more variables exported from the library. The set of libraries invoked by a top-level program, and hence loaded when the program is loaded, might be smaller than the set imported by the program, and it might be larger than the set directly imported by the program.
`
    },
    {
        name: "compile-program-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s74"),
        description: `**thread parameter**: \`compile-program-handler\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(compile-script ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s66"),
        description: `**procedure**: \`(compile-script \`*input-filename*\`)\`
**procedure**: \`(compile-script \`*input-filename*\` \`*output-filename*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings.

\`compile-script\` is like \`compile-file\` but differs in that it copies the leading \`#!\` line from the source-file script into the object file.
`
    },
    {
        name: "(compile-script ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s66"),
        description: `**procedure**: \`(compile-script \`*input-filename*\`)\`
**procedure**: \`(compile-script \`*input-filename*\` \`*output-filename*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-filename* and *output-filename* must be strings.

\`compile-script\` is like \`compile-file\` but differs in that it copies the leading \`#!\` line from the source-file script into the object file.
`
    },
    {
        name: "(compile-time-value-value ",
        endParen: true,
        params: ["ctv"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s17"),
        description: `**procedure**: \`(compile-time-value-value \`*ctv*\`)\`
**returns: **the value of a compile-time value
**libraries: **\`(chezscheme)\`

\`(define-syntax x (make-compile-time-value "eggs"))\`
\` (compile-time-value-value (top-level-syntax 'x)) \`=>\` "eggs"\`
`
    },
    {
        name: "(compile-time-value? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s16"),
        description: `**procedure**: \`(compile-time-value? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a compile-time value; \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(define-syntax x (make-compile-time-value "eggs"))\`
\` (compile-time-value? (top-level-syntax 'x)) \`=>\` #t\`
`
    },
    {
        name: "(compile-to-file ",
        endParen: true,
        params: ["obj-list", "output-file"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s81"),
        description: `**procedure**: \`(compile-to-file \`*obj-list*\` \`*output-file*\`)\`
**procedure**: \`(compile-to-file \`*obj-list*\` \`*output-file*\` \`*sfd*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*obj-list* must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section ). If any of the objects does not represent a syntactically valid expression, \`compile-to-file\` raises an exception with condition type \`&syntax\`. *output-file* must be a string. If present, *sfd* must be a source-file descriptor.

\`compile-to-file\` is like \`compile-file\` except that it takes input from a list of objects. *sfd* is used to associate block-profiling information with the input file name encapsulated within *sfd*.

When *obj-list* contains a single list-structured element whose first-element is the symbol \`top-level-program\`, \`compile-to-file\` returns a list of the libraries the top-level program requires at run time, as with \`compile-program\`. Otherwise, the return value is unspecified.
`
    },
    {
        name: "(compile-to-file ",
        endParen: true,
        params: ["obj-list", "output-file", "sfd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s81"),
        description: `**procedure**: \`(compile-to-file \`*obj-list*\` \`*output-file*\`)\`
**procedure**: \`(compile-to-file \`*obj-list*\` \`*output-file*\` \`*sfd*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*obj-list* must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section ). If any of the objects does not represent a syntactically valid expression, \`compile-to-file\` raises an exception with condition type \`&syntax\`. *output-file* must be a string. If present, *sfd* must be a source-file descriptor.

\`compile-to-file\` is like \`compile-file\` except that it takes input from a list of objects. *sfd* is used to associate block-profiling information with the input file name encapsulated within *sfd*.

When *obj-list* contains a single list-structured element whose first-element is the symbol \`top-level-program\`, \`compile-to-file\` returns a list of the libraries the top-level program requires at run time, as with \`compile-program\`. Otherwise, the return value is unspecified.
`
    },
    {
        name: "(compile-to-port ",
        endParen: true,
        params: ["obj-list", "output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s80"),
        description: `**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*obj-list* must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section ). If any of the objects does not represent a syntactically valid expression, \`compile-to-port\` raises an exception with condition type \`&syntax\`. *output-port* and, if present, *wpo-port* must be binary output ports. If present, *sfd* must be a source-file descriptor.

\`compile-to-port\` is like \`compile-file\` except that it takes input from a list of objects and sends output to an arbitrary binary output port. *sfd* is used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is present, *compile-to-port* sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is present, *compile-to-port* sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are not closed automatically after compilation under the assumption the program that opens the port and invokes \`compile-to-port\` will take care of closing the port.

When *obj-list* contains a single list-structured element whose first-element is the symbol \`top-level-program\`, \`compile-to-port\` returns a list of the libraries the top-level program requires at run time, as with \`compile-program\`. Otherwise, the return value is unspecified.
`
    },
    {
        name: "(compile-to-port ",
        endParen: true,
        params: ["obj-list", "output-port", "sfd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s80"),
        description: `**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*obj-list* must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section ). If any of the objects does not represent a syntactically valid expression, \`compile-to-port\` raises an exception with condition type \`&syntax\`. *output-port* and, if present, *wpo-port* must be binary output ports. If present, *sfd* must be a source-file descriptor.

\`compile-to-port\` is like \`compile-file\` except that it takes input from a list of objects and sends output to an arbitrary binary output port. *sfd* is used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is present, *compile-to-port* sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is present, *compile-to-port* sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are not closed automatically after compilation under the assumption the program that opens the port and invokes \`compile-to-port\` will take care of closing the port.

When *obj-list* contains a single list-structured element whose first-element is the symbol \`top-level-program\`, \`compile-to-port\` returns a list of the libraries the top-level program requires at run time, as with \`compile-program\`. Otherwise, the return value is unspecified.
`
    },
    {
        name: "(compile-to-port ",
        endParen: true,
        params: ["obj-list", "output-port", "sfd", "wpo-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s80"),
        description: `**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*obj-list* must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section ). If any of the objects does not represent a syntactically valid expression, \`compile-to-port\` raises an exception with condition type \`&syntax\`. *output-port* and, if present, *wpo-port* must be binary output ports. If present, *sfd* must be a source-file descriptor.

\`compile-to-port\` is like \`compile-file\` except that it takes input from a list of objects and sends output to an arbitrary binary output port. *sfd* is used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is present, *compile-to-port* sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is present, *compile-to-port* sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are not closed automatically after compilation under the assumption the program that opens the port and invokes \`compile-to-port\` will take care of closing the port.

When *obj-list* contains a single list-structured element whose first-element is the symbol \`top-level-program\`, \`compile-to-port\` returns a list of the libraries the top-level program requires at run time, as with \`compile-program\`. Otherwise, the return value is unspecified.
`
    },
    {
        name: "(compile-to-port ",
        endParen: true,
        params: ["obj-list", "output-port", "sfd", "wpo-port", "covop"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s80"),
        description: `**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\`)\`
**procedure**: \`(compile-to-port \`*obj-list*\` \`*output-port*\` \`*sfd*\` \`*wpo-port*\` \`*covop*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*obj-list* must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section ). If any of the objects does not represent a syntactically valid expression, \`compile-to-port\` raises an exception with condition type \`&syntax\`. *output-port* and, if present, *wpo-port* must be binary output ports. If present, *sfd* must be a source-file descriptor.

\`compile-to-port\` is like \`compile-file\` except that it takes input from a list of objects and sends output to an arbitrary binary output port. *sfd* is used to associate block-profiling information with the input file name encapsulated within *sfd*. If *wpo-port* is present, *compile-to-port* sends whole-program optimization information to *wpo-port* for use by \`compile-whole-program\`, as if (and regardless of whether) \`generate-wpo-files\` is set. If *covop* is present, *compile-to-port* sends coverage information to *covop*, as if (and regardless of whether) \`generate-covin-files\` is set.

The ports are not closed automatically after compilation under the assumption the program that opens the port and invokes \`compile-to-port\` will take care of closing the port.

When *obj-list* contains a single list-structured element whose first-element is the symbol \`top-level-program\`, \`compile-to-port\` returns a list of the libraries the top-level program requires at run time, as with \`compile-program\`. Otherwise, the return value is unspecified.
`
    },
    {
        name: "(compile-whole-library ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s78"),
        description: `**procedure**: \`(compile-whole-library \`*input-filename*\` \`*output-filename*\`)\`
**returns: **a list of libraries left to be loaded at run time
**libraries: **\`(chezscheme)\`

\`compile-whole-library\` is like \`compile-whole-program\`, except *input-filename* must specify a wpo file for a library, all libraries are automatically made visible, and a new wpo file is produced (when \`generate-wpo-files\` is \`#t\`) as well as an object file for the resulting combination of libraries.

The comment in the description of \`compile-whole-program\` about the effect of initialization-code linearization on dynamic dependencies applies to \`compile-whole-library\` as well.
`
    },
    {
        name: "(compile-whole-program ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s76"),
        description: `**procedure**: \`(compile-whole-program \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(compile-whole-program \`*input-filename*\` \`*output-filename*\` \`*libs-visible?*\`)\`
**returns: **a list of libraries left to be loaded at run time
**libraries: **\`(chezscheme)\`

\`compile-whole-program\` accepts as input a filename naming a "whole program optimization" (wpo) file for a top-level program and produces an object file incorporating the program and each library upon which it depends, provided that a wpo file for the library can be found.

If a wpo file for a required library cannot be found, but an object file for the library can, the library is not incorporated in the resulting object file. Such libraries are left to be loaded at run time. \`compile-whole-program\` returns a list of such libraries. If there are no such libraries, the resulting object file is self-contained and \`compile-whole-program\` returns the empty list.

The libraries incorporated into the resulting object file are visible (for use by \`environment\` and \`eval\`) if the *libs-visible?* argument is supplied and non-false. Any library incorporated into the resulting object file and required by an object file left to be loaded at run time is also visible, as are any libraries the object file depends upon, regardless of the value of *libs-visible?*.

\`compile-whole-program\` linearizes the initialization code for the set of incorporated libraries in a way that respects static dependencies among the libraries but not necessary dynamic dependencies deriving from initialization-time uses of \`environment\` or \`eval\`. Additional static dependencies can be added in most cases to force an ordering that allows the dynamic imports to succeed, though not in general since a different order might be required each time the program is run. Adding a static dependency of one library on a second requires adding an import of the second in the first as well as a run-time reference to one of the variables exported by the second in the body of the first.

*input-filename* and *output-filename* must be strings. *input-filename* must identify a wpo file, and a wpo or object file must also be present for each required library somewhere in the directories specified by the \`library-directories\` parameter.

To the extent possible given the specified set of visible libraries and requirements of libraries to be loaded at run time, \`compile-whole-program\` discards unused code and optimizes across program and library boundaries, potentially reducing program load time, run time, and memory requirements. Some optimization also occurs even across the boundaries of libraries that are not incorporated into the output, though this optimization is limited in nature.
`
    },
    {
        name: "(compile-whole-program ",
        endParen: true,
        params: ["input-filename", "output-filename", "libs-visible?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s76"),
        description: `**procedure**: \`(compile-whole-program \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(compile-whole-program \`*input-filename*\` \`*output-filename*\` \`*libs-visible?*\`)\`
**returns: **a list of libraries left to be loaded at run time
**libraries: **\`(chezscheme)\`

\`compile-whole-program\` accepts as input a filename naming a "whole program optimization" (wpo) file for a top-level program and produces an object file incorporating the program and each library upon which it depends, provided that a wpo file for the library can be found.

If a wpo file for a required library cannot be found, but an object file for the library can, the library is not incorporated in the resulting object file. Such libraries are left to be loaded at run time. \`compile-whole-program\` returns a list of such libraries. If there are no such libraries, the resulting object file is self-contained and \`compile-whole-program\` returns the empty list.

The libraries incorporated into the resulting object file are visible (for use by \`environment\` and \`eval\`) if the *libs-visible?* argument is supplied and non-false. Any library incorporated into the resulting object file and required by an object file left to be loaded at run time is also visible, as are any libraries the object file depends upon, regardless of the value of *libs-visible?*.

\`compile-whole-program\` linearizes the initialization code for the set of incorporated libraries in a way that respects static dependencies among the libraries but not necessary dynamic dependencies deriving from initialization-time uses of \`environment\` or \`eval\`. Additional static dependencies can be added in most cases to force an ordering that allows the dynamic imports to succeed, though not in general since a different order might be required each time the program is run. Adding a static dependency of one library on a second requires adding an import of the second in the first as well as a run-time reference to one of the variables exported by the second in the body of the first.

*input-filename* and *output-filename* must be strings. *input-filename* must identify a wpo file, and a wpo or object file must also be present for each required library somewhere in the directories specified by the \`library-directories\` parameter.

To the extent possible given the specified set of visible libraries and requirements of libraries to be loaded at run time, \`compile-whole-program\` discards unused code and optimizes across program and library boundaries, potentially reducing program load time, run time, and memory requirements. Some optimization also occurs even across the boundaries of libraries that are not incorporated into the output, though this optimization is limited in nature.
`
    },
    {
        name: "(complex? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s17"),
        description: `**procedure**: \`(number? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a number object, \`#f\` otherwise
**procedure**: \`(complex? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a complex number object, \`#f\` otherwise
**procedure**: \`(real? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number object, \`#f\` otherwise
**procedure**: \`(rational? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number object, \`#f\` otherwise
**procedure**: \`(integer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer object, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well.

The \`real?\`, \`rational?\`, and \`integer?\` predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts.

\`(integer? 1901) \`=>\` #t\`
\` (rational? 1901) \`=>\` #t\`
\` (real? 1901) \`=>\` #t\`
\` (complex? 1901) \`=>\` #t\`
\` (number? 1901) \`=>\` #t \`
\` \`
\` (integer? -3.0) \`=>\` #t\`
\` (rational? -3.0) \`=>\` #t\`
\` (real? -3.0) \`=>\` #t\`
\` (complex? -3.0) \`=>\` #t\`
\` (number? -3.0) \`=>\` #t \`
\` \`
\` (integer? 7+0i) \`=>\` #t\`
\` (rational? 7+0i) \`=>\` #t\`
\` (real? 7+0i) \`=>\` #t\`
\` (complex? 7+0i) \`=>\` #t\`
\` (number? 7+0i) \`=>\` #t \`
\` \`
\` (integer? -2/3) \`=>\` #f\`
\` (rational? -2/3) \`=>\` #t\`
\` (real? -2/3) \`=>\` #t\`
\` (complex? -2/3) \`=>\` #t\`
\` (number? -2/3) \`=>\` #t \`
\` \`
\` (integer? -2.345) \`=>\` #f\`
\` (rational? -2.345) \`=>\` #t\`
\` (real? -2.345) \`=>\` #t\`
\` (complex? -2.345) \`=>\` #t\`
\` (number? -2.345) \`=>\` #t \`
\` \`
\` (integer? 7.0+0.0i) \`=>\` #f\`
\` (rational? 7.0+0.0i) \`=>\` #f\`
\` (real? 7.0+0.0i) \`=>\` #f\`
\` (complex? 7.0+0.0i) \`=>\` #t\`
\` (number? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer? 3.2-2.01i) \`=>\` #f\`
\` (rational? 3.2-2.01i) \`=>\` #f\`
\` (real? 3.2-2.01i) \`=>\` #f\`
\` (complex? 3.2-2.01i) \`=>\` #t\`
\` (number? 3.2-2.01i) \`=>\` #t \`
\` \`
\` (integer? 'a) \`=>\` #f\`
\` (rational? '(a b c)) \`=>\` #f\`
\` (real? "3") \`=>\` #f\`
\` (complex? '#(1 2)) \`=>\` #f\`
\` (number? #\\a) \`=>\` #f\`
`
    },
    {
        name: "compress-format",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s42"),
        description: `**thread parameter**: \`compress-format\`
**libraries: **\`(chezscheme)\`

\`compress-format\` determines the compression algorithm and format used for output. Currently, the possible values of the parameter are the symbols \`lz4\` (the default) and \`gzip\`.

The \`lz4\` format uses the LZ4 compression library developed by Yann Collet. It is therefore compatible with the \`lz4\` program, which means that \`lz4\` may be used to uncompress files produced by and visa versa.

The \`gzip\` format uses the zlib compression library developed by Jean-loup Gailly and Mark Adler. It is therefore compatible with the \`gzip\` program, which means that \`gzip\` may be used to uncompress files produced by and visa versa.

Reading \`lz4\`-compressed data tends to be much faster than reading \`gzip\`-compressed data, while \`gzip\`-compressed data tends to be significantly smaller.
`
    },
    {
        name: "compress-level",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s43"),
        description: `**thread parameter**: \`compress-level\`
**libraries: **\`(chezscheme)\`

\`compress-level\` determines the amount of effort spent on compression and is thus relevant only for output. It can be set to one of the symbols \`minimum\`, \`low\`, \`medium\`, \`high\`, or \`maximum\`, which are listed in order from shortest to longest expected compression time and least to greatest expected effectiveness. Its default value is \`medium\`.
`
    },
    {
        name: "(compute-composition ",
        endParen: true,
        params: ["object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s31"),
        description: `**procedure**: \`(compute-composition \`*object*\`)\`
**procedure**: \`(compute-composition \`*object*\` \`*generation*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*object* can be any object. *generation* must be a fixnum between 0 and the value of \`collect-maximum-generation\`, inclusive, or the symbol \`static\`. If *generation* is not supplied, it defaults to the value of \`collect-maximum-generation\`.

\`compute-composition\` returns an association list representing the composition of *object*, including anything reachable from it in any generation less than or equal to *generation*. The association list has the following structure:

\`((\`*type*\` \`*count*\` . \`*bytes*\`) ...)\`

*type* is either the name of a primitive type, represented as a symbol, e.g., \`pair\`, or a record-type descriptor (rtd). *count* and *bytes* are nonnegative fixnums.

Immediate values such as fixnums, booleans, and characters are not included in the composition.

The following examples are valid for machines with 32-bit pointers.

\`(compute-composition 0) \`=>\` ()\`
\` (compute-composition (cons 0 0)) \`=>\` ((pair 1 . 8))\`
\` (compute-composition\`
\`   (cons (vector #t #f) 0)) \`=>\` ((pair 1 . 8) (vector 1 . 16)) \`
\` \`
\` (compute-composition\`
\`   (let ([x (cons 0 0)])\`
\`     (set-car! x x)\`
\`     (set-cdr! x x)\`
\`     x))                 \`=>\` ((pair 1 . 8) \`
\` \`
\` (define-record-type frob (fields x))\`
\` (collect 1 1) ; force rtd into generation 1\`
\` (compute-composition\`
\`   (let ([x (make-frob 0)])\`
\`     (cons x x))\`
\`   0)                       \`=>\` ((pair 1 . 8)\`
\`                                 (#<record type frob> 1 . 8))\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(compute-composition ",
        endParen: true,
        params: ["object", "generation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s31"),
        description: `**procedure**: \`(compute-composition \`*object*\`)\`
**procedure**: \`(compute-composition \`*object*\` \`*generation*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*object* can be any object. *generation* must be a fixnum between 0 and the value of \`collect-maximum-generation\`, inclusive, or the symbol \`static\`. If *generation* is not supplied, it defaults to the value of \`collect-maximum-generation\`.

\`compute-composition\` returns an association list representing the composition of *object*, including anything reachable from it in any generation less than or equal to *generation*. The association list has the following structure:

\`((\`*type*\` \`*count*\` . \`*bytes*\`) ...)\`

*type* is either the name of a primitive type, represented as a symbol, e.g., \`pair\`, or a record-type descriptor (rtd). *count* and *bytes* are nonnegative fixnums.

Immediate values such as fixnums, booleans, and characters are not included in the composition.

The following examples are valid for machines with 32-bit pointers.

\`(compute-composition 0) \`=>\` ()\`
\` (compute-composition (cons 0 0)) \`=>\` ((pair 1 . 8))\`
\` (compute-composition\`
\`   (cons (vector #t #f) 0)) \`=>\` ((pair 1 . 8) (vector 1 . 16)) \`
\` \`
\` (compute-composition\`
\`   (let ([x (cons 0 0)])\`
\`     (set-car! x x)\`
\`     (set-cdr! x x)\`
\`     x))                 \`=>\` ((pair 1 . 8) \`
\` \`
\` (define-record-type frob (fields x))\`
\` (collect 1 1) ; force rtd into generation 1\`
\` (compute-composition\`
\`   (let ([x (make-frob 0)])\`
\`     (cons x x))\`
\`   0)                       \`=>\` ((pair 1 . 8)\`
\`                                 (#<record type frob> 1 . 8))\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(compute-size ",
        endParen: true,
        params: ["object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s30"),
        description: `**procedure**: \`(compute-size \`*object*\`)\`
**procedure**: \`(compute-size \`*object*\` \`*generation*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*object* can be any object. *generation* must be a fixnum between 0 and the value of \`collect-maximum-generation\`, inclusive, or the symbol \`static\`. If *generation* is not supplied, it defaults to the value of \`collect-maximum-generation\`.

\`compute-size\` returns the amount of memory, in bytes, occupied by *object* and anything reachable from *object* in any generation less than or equal to *generation*. Immediate values such as fixnums, booleans, and characters have zero size.

The following examples are valid for machines with 32-bit pointers.

\`(compute-size 0) \`=>\` 0\`
\` (compute-size (cons 0 0)) \`=>\` 8\`
\` (compute-size (cons (vector #t #f) 0)) \`=>\` 24 \`
\` \`
\` (compute-size\`
\`   (let ([x (cons 0 0)])\`
\`     (set-car! x x)\`
\`     (set-cdr! x x)\`
\`     x))                  \`=>\` 8 \`
\` \`
\` (define-record-type frob (fields x))\`
\` (collect 1 1) ; force rtd into generation 1\`
\` (compute-size\`
\`   (let ([x (make-frob 0)])\`
\`     (cons x x))\`
\`   0)                       \`=>\` 16\`
`
    },
    {
        name: "(compute-size ",
        endParen: true,
        params: ["object", "generation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s30"),
        description: `**procedure**: \`(compute-size \`*object*\`)\`
**procedure**: \`(compute-size \`*object*\` \`*generation*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*object* can be any object. *generation* must be a fixnum between 0 and the value of \`collect-maximum-generation\`, inclusive, or the symbol \`static\`. If *generation* is not supplied, it defaults to the value of \`collect-maximum-generation\`.

\`compute-size\` returns the amount of memory, in bytes, occupied by *object* and anything reachable from *object* in any generation less than or equal to *generation*. Immediate values such as fixnums, booleans, and characters have zero size.

The following examples are valid for machines with 32-bit pointers.

\`(compute-size 0) \`=>\` 0\`
\` (compute-size (cons 0 0)) \`=>\` 8\`
\` (compute-size (cons (vector #t #f) 0)) \`=>\` 24 \`
\` \`
\` (compute-size\`
\`   (let ([x (cons 0 0)])\`
\`     (set-car! x x)\`
\`     (set-cdr! x x)\`
\`     x))                  \`=>\` 8 \`
\` \`
\` (define-record-type frob (fields x))\`
\` (collect 1 1) ; force rtd into generation 1\`
\` (compute-size\`
\`   (let ([x (make-frob 0)])\`
\`     (cons x x))\`
\`   0)                       \`=>\` 16\`
`
    },
    {
        name: "(concatenate-object-files ",
        endParen: true,
        params: ["out-file", "in-file1", "in-file2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s82"),
        description: `**procedure**: \`(concatenate-object-files \`*out-file*\` \`*in-file1*\` \`*in-file2*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*out-file* and each *in-file* must be strings.

\`concatenate-object-files\` combines the header information contained in the object files named by each *in-file*. It then writes the combined header information to the file named by *out-file*, followed by the remaining object code from each input file in turn.
`
    },
    {
        name: "(cond ",
        endParen: true,
        params: ["clause1", "clause2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s13"),
        description: `**syntax**: \`(cond \`*clause1*\` \`*clause2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(condition ",
        endParen: true,
        params: ["condition", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s15"),
        description: `**procedure**: \`(condition \`*condition*\` ...)\`
**returns: **a condition, possibly compound
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

\`condition\` is used to create condition objects that may consist of multiple simple conditions. Each argument *condition* may be simple or complex; if simple, it is treated as a compound condition with itself as its only simple condition. The simple conditions of the result condition are the simple conditions of the *condition* arguments, flattened into a single list and appearing in order, with the simple conditions of the first *condition* followed by the simple conditions of the second, and so on.

If the list has exactly one element, the result condition may be simple or compound; otherwise it is compound. The distinction between simple and compound conditions is not usually important but can be detected, if \`define-record-type\` rather than \`define-condition-type\` is used to extend an existing condition type, via the predicate defined by \`define-record-type\`.

\`(condition) \`=>\` #<condition>\`
\` (condition\`
\`   (make-error)\`
\`   (make-message-condition "oops")) \`=>\` #<condition> \`
\` \`
\` (define-record-type (&xcond make-xcond xcond?) (parent &condition))\`
\` (xcond? (make-xcond)) \`=>\` #t\`
\` (xcond? (condition (make-xcond))) \`=>\` #t \`*or*\` #f\`
\` (xcond? (condition)) \`=>\` #f\`
\` (xcond? (condition (make-error) (make-xcond))) \`=>\` #f\`
`
    },
    {
        name: "(condition-accessor ",
        endParen: true,
        params: ["rtd", "procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s18"),
        description: `**procedure**: \`(condition-predicate \`*rtd*\`)\`
**returns: **a condition predicate
**procedure**: \`(condition-accessor \`*rtd*\` \`*procedure*\`)\`
**returns: **a condition accessor
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

These procedures may be used to create the same kind of special predicates and accessors that are created by \`define-record-type\` from a record-type descriptor, *rtd*, of a simple condition type or other type derived from a simple condition type.

For both procedures, *rtd* must be a record-type descriptor of a subtype of \`&condition\`, and for \`condition-accessor\`, *procedure* should accept one argument.

The predicate returned by \`condition-predicate\` accepts one argument, which may be any Scheme value. The predicate returns \`#t\` if the value is a condition of the type described by *rtd*, i.e., an instance of the type described by *rtd* (or one of its subtypes) or a compound condition whose simple conditions include an instance of the type described by *rtd*. Otherwise, the predicate returns \`#f\`.

The accessor returned by \`condition-accessor\` accepts one argument, *c*, which must be a condition of the type described by *rtd*. The accessor applies *procedure* to a single argument, the first element of *c*'s simple condition list that is an instance of the type described by *rtd* (this is *c* itself if *c* is a simple condition), and returns the result of this application. In most situations, *procedure* is a record accessor for a field of the type described by *rtd*.

\`(define-record-type (&mistake make-mistake $mistake?)\`
\`   (parent &condition)\`
\`   (fields (immutable type $mistake-type))) \`
\` \`
\` ; define predicate and accessor as if we'd used define-condition-type\`
\` (define rtd (record-type-descriptor &mistake))\`
\` (define mistake? (condition-predicate rtd))\`
\` (define mistake-type (condition-accessor rtd $mistake-type)) \`
\` \`
\` (define c1 (make-mistake 'spelling))\`
\` (define c2 (condition c1 (make-irritants-condition '(eggregius))))\`
\` (list (mistake? c1) (mistake? c2)) \`=>\` (#t #t)\`
\` (list ($mistake? c1) ($mistake? c2)) \`=>\` (#t #f)\`
\` (mistake-type c1) \`=>\` spelling\`
\` ($mistake-type c1) \`=>\` spelling\`
\` (mistake-type c2) \`=>\` spelling\`
\` ($mistake-type c2) \`=>\` \`*violation*
`
    },
    {
        name: "(condition-broadcast ",
        endParen: true,
        params: ["cond"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s16"),
        description: `**procedure**: \`(condition-broadcast \`*cond*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*cond* must be a condition object.

\`condition-broadcast\` releases all of the threads waiting for the condition identified by *cond*.
`
    },
    {
        name: "(condition-continuation ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s6"),
        description: `**syntax**: \`&continuation\`
**procedure**: \`(make-continuation-condition \`*continuation*\`)\`
**returns: **a condition of type \`&continuation\`
**procedure**: \`(continuation-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&continuation\`, \`#f\` otherwise
**procedure**: \`(condition-continuation \`*condition*\`)\`
**returns: **the contents of *condition*'s \`continuation\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition to indicate the current continuation at the point where the exception described by the condition occurred. The continuation of a failed \`assert\` or a call to \`assertion-violation\`, \`assertion-violationf\`, \`error\`, \`errorf\`, or \`syntax-error\` is now included via this condition type in the conditions passed to \`raise\`. The \`continuation\` argument should be a continuation. This condition type might be defined as follows.

\`(define-condition-type &continuation &condition\`
\`   make-continuation-condition continuation-condition?\`
\`   (continuation condition-continuation))\`
`
    },
    {
        name: "(condition-irritants ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s25"),
        description: `**syntax**: \`&irritants\`
**procedure**: \`(make-irritants-condition \`*irritants*\`)\`
**returns: **a condition of type \`&irritants\`
**procedure**: \`(irritants-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&irritants\`, \`#f\` otherwise
**procedure**: \`(condition-irritants \`*condition*\`)\`
**returns: **the contents of *condition*'s \`irritants\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&message\` condition to provide information about Scheme values that may have caused or been materially involved in the exceptional situation. For example, if a procedure receives the wrong type of argument, it may raise an exception with a compound condition consisting of an assertion condition, a who condition naming the procedure, a message condition stating that the wrong type of argument was received, and an irritants condition listing the argument. The *irritants* argument to the constructor should be a list. This condition type might be defined as follows.

\`(define-condition-type &irritants &condition\`
\`   make-irritants-condition irritants-condition?\`
\`   (irritants condition-irritants))\`
`
    },
    {
        name: "(condition-message ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s24"),
        description: `**syntax**: \`&message\`
**procedure**: \`(make-message-condition \`*message*\`)\`
**returns: **a condition of type \`&message\`
**procedure**: \`(message-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&message\`, \`#f\` otherwise
**procedure**: \`(condition-message \`*condition*\`)\`
**returns: **the contents of *condition*'s \`message\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&warning\` condition or one of the \`&serious\` condition subtypes to provide a more specific description of the exceptional situation. The *message* argument to the constructor may be any Scheme value but is typically a string. This condition type might be defined as follows.

\`(define-condition-type &message &condition\`
\`   make-message-condition message-condition?\`
\`   (message condition-message))\`
`
    },
    {
        name: "(condition-name ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s17"),
        description: `**procedure**: \`(condition-name \`*condition*\`)\`
**returns: **the name associated with *condition*, if any; otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*condition* must be a condition.
`
    },
    {
        name: "(condition-predicate ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s18"),
        description: `**procedure**: \`(condition-predicate \`*rtd*\`)\`
**returns: **a condition predicate
**procedure**: \`(condition-accessor \`*rtd*\` \`*procedure*\`)\`
**returns: **a condition accessor
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

These procedures may be used to create the same kind of special predicates and accessors that are created by \`define-record-type\` from a record-type descriptor, *rtd*, of a simple condition type or other type derived from a simple condition type.

For both procedures, *rtd* must be a record-type descriptor of a subtype of \`&condition\`, and for \`condition-accessor\`, *procedure* should accept one argument.

The predicate returned by \`condition-predicate\` accepts one argument, which may be any Scheme value. The predicate returns \`#t\` if the value is a condition of the type described by *rtd*, i.e., an instance of the type described by *rtd* (or one of its subtypes) or a compound condition whose simple conditions include an instance of the type described by *rtd*. Otherwise, the predicate returns \`#f\`.

The accessor returned by \`condition-accessor\` accepts one argument, *c*, which must be a condition of the type described by *rtd*. The accessor applies *procedure* to a single argument, the first element of *c*'s simple condition list that is an instance of the type described by *rtd* (this is *c* itself if *c* is a simple condition), and returns the result of this application. In most situations, *procedure* is a record accessor for a field of the type described by *rtd*.

\`(define-record-type (&mistake make-mistake $mistake?)\`
\`   (parent &condition)\`
\`   (fields (immutable type $mistake-type))) \`
\` \`
\` ; define predicate and accessor as if we'd used define-condition-type\`
\` (define rtd (record-type-descriptor &mistake))\`
\` (define mistake? (condition-predicate rtd))\`
\` (define mistake-type (condition-accessor rtd $mistake-type)) \`
\` \`
\` (define c1 (make-mistake 'spelling))\`
\` (define c2 (condition c1 (make-irritants-condition '(eggregius))))\`
\` (list (mistake? c1) (mistake? c2)) \`=>\` (#t #t)\`
\` (list ($mistake? c1) ($mistake? c2)) \`=>\` (#t #f)\`
\` (mistake-type c1) \`=>\` spelling\`
\` ($mistake-type c1) \`=>\` spelling\`
\` (mistake-type c2) \`=>\` spelling\`
\` ($mistake-type c2) \`=>\` \`*violation*
`
    },
    {
        name: "(condition-signal ",
        endParen: true,
        params: ["cond"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s15"),
        description: `**procedure**: \`(condition-signal \`*cond*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*cond* must be a condition object.

\`condition-signal\` releases one of the threads waiting for the condition identified by *cond*.
`
    },
    {
        name: "(condition-wait ",
        endParen: true,
        params: ["cond", "mutex"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s14"),
        description: `**procedure**: \`(condition-wait \`*cond*\` \`*mutex*\`)\`
**procedure**: \`(condition-wait \`*cond*\` \`*mutex*\` \`*timeout*\`)\`
**returns: **\`#t\` if the calling thread was awakened by the condition, \`#f\` if the calling thread timed out waiting
**libraries: **\`(chezscheme)\`

*cond* must be a condition object, and *mutex* must be a mutex. The optional argument *timeout* is a time record of type \`time-duration\` or \`time-utc\`, or \`#f\` for no timeout. It defaults to \`#f\`.

\`condition-wait\` waits up to the specified *timeout* for the condition identified by the condition object *cond*. The calling thread must have acquired the mutex identified by the mutex *mutex* at the time \`condition-wait\` is called. *mutex* is released as a side effect of the call to \`condition-wait\`. When a thread is later released from the condition variable by one of the procedures described below or the timeout expires, *mutex* is reacquired and \`condition-wait\` returns.
`
    },
    {
        name: "(condition-wait ",
        endParen: true,
        params: ["cond", "mutex", "timeout"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s14"),
        description: `**procedure**: \`(condition-wait \`*cond*\` \`*mutex*\`)\`
**procedure**: \`(condition-wait \`*cond*\` \`*mutex*\` \`*timeout*\`)\`
**returns: **\`#t\` if the calling thread was awakened by the condition, \`#f\` if the calling thread timed out waiting
**libraries: **\`(chezscheme)\`

*cond* must be a condition object, and *mutex* must be a mutex. The optional argument *timeout* is a time record of type \`time-duration\` or \`time-utc\`, or \`#f\` for no timeout. It defaults to \`#f\`.

\`condition-wait\` waits up to the specified *timeout* for the condition identified by the condition object *cond*. The calling thread must have acquired the mutex identified by the mutex *mutex* at the time \`condition-wait\` is called. *mutex* is released as a side effect of the call to \`condition-wait\`. When a thread is later released from the condition variable by one of the procedures described below or the timeout expires, *mutex* is reacquired and \`condition-wait\` returns.
`
    },
    {
        name: "(condition-who ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s26"),
        description: `**syntax**: \`&who\`
**procedure**: \`(make-who-condition \`*who*\`)\`
**returns: **a condition of type \`&who\`
**procedure**: \`(who-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&who\`, \`#f\` otherwise
**procedure**: \`(condition-who \`*condition*\`)\`
**returns: **the contents of *condition*'s \`who\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are often included with a \`&message\` condition to identify the syntactic form or procedure that detected the error. The *who* argument to the constructor should be a symbol or string. This condition type might be defined as follows.

\`(define-condition-type &who &condition\`
\`   make-who-condition who-condition?\`
\`   (who condition-who))\`
`
    },
    {
        name: "(condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s14"),
        description: `**procedure**: \`(condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition object, otherwise \`#f\`
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

A condition object is an instance of a subtype of \`&condition\` or a compound condition, possibly created by user code with \`condition\`.

\`(condition? 'stable) \`=>\` #f\`
\` (condition? (make-error)) \`=>\` #t\`
\` (condition? (make-message-condition "oops")) \`=>\` #t\`
\` (condition?\`
\`   (condition\`
\`     (make-error)\`
\`     (make-message-condition "no such element"))) \`=>\` #t\`
`
    },
    {
        name: "(conjugate ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s74"),
        description: `**procedure**: \`(conjugate \`*num*\`)\`
**returns: **complex conjugate of *num*
**libraries: **\`(chezscheme)\`

The procedure \`conjugate\`, when passed a complex argument + , returns its complex conjugate + (-).

\`(conjugate 3.0+4.0i) \`=>\` 3.0-4.0i\`
\` (conjugate 1e-20-2e-30i) \`=>\` 1e-20+2e-30i\`
\` (conjugate 3) \`=>\` 3\`
`
    },
    {
        name: "(cons ",
        endParen: true,
        params: ["obj1", "obj2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s37"),
        description: `**procedure**: \`(cons \`*obj1*\` \`*obj2*\`)\`
**returns: **a new pair whose car and cdr are *obj1* and *obj2*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`cons\` is the pair constructor procedure. *obj1* becomes the car and *obj2* becomes the cdr of the new pair.

\`(cons 'a '()) \`=>\` (a)\`
\` (cons 'a '(b c)) \`=>\` (a b c)\`
\` (cons 3 4) \`=>\` (3 . 4)\`
`
    },
    {
        name: "(cons* ",
        endParen: true,
        params: ["obj", "final-obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s44"),
        description: `**procedure**: \`(cons* \`*obj*\` ... \`*final-obj*\`)\`
**returns: **a list of *obj*\` ...\` terminated by *final-obj*
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

If the objects *obj*\` ...\` are omitted, the result is simply *final-obj*. Otherwise, a list of *obj*\` ...\` is constructed, as with \`list\`, except that the final cdr field is *final-obj* instead of \`()\`. If *final-obj* is not a list, the result is an improper list.

\`(cons* '()) \`=>\` ()\`
\` (cons* '(a b)) \`=>\` (a b)\`
\` (cons* 'a 'b 'c) \`=>\` (a b . c)\`
\` (cons* 'a 'b '(c d)) \`=>\` (a b c d)\`
`
    },
    {
        name: "console-error-port",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s73"),
        description: `**thread parameter**: \`console-error-port\`
**libraries: **\`(chezscheme)\`

\`console-error-port\` is a parameter that can be used to set or obtain the console error port, which determines the port to which conditions and other messages are printed by the default exception handler. When called with no arguments, \`console-error-port\` returns the console error port. When called with one argument, which must be a textual output port, it changes the value of the console error port.

If the system determines that the standard output (stdout) and standard error (stderr) streams refer to the same file, socket, pipe, virtual terminal, device, etc., this parameter is initially set to the same value as the parameter \`console-output-port\`. Otherwise, this parameter is initially set to a different port tied to the standard error (stderr) stream of the Scheme process.
`
    },
    {
        name: "console-input-port",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s55"),
        description: `**global parameter**: \`console-input-port\`
**libraries: **\`(chezscheme)\`

\`console-input-port\` is a parameter that determines the input port used by the waiter and interactive debugger. When called with no arguments, it returns the console input port. When called with one argument, which must be a textual input port, it changes the value of the console input port. The initial value of this parameter is a port tied to the standard input (stdin) stream of the Scheme process.
`
    },
    {
        name: "console-output-port",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s71"),
        description: `**global parameter**: \`console-output-port\`
**libraries: **\`(chezscheme)\`

\`console-output-port\` is a parameter that determines the output port used by the waiter and interactive debugger. When called with no arguments, it returns the console output port. When called with one argument, which must be a textual output port, it changes the value of the console output port. The initial value of this parameter is a port tied to the standard output (stdout) stream of the Scheme process.
`
    },
    {
        name: "constant",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s1"),
        description: `**syntax**: *constant*
**returns: ***constant*

*constant* is any self-evaluating constant, i.e., a number, boolean, character, string, or bytevector. Constants are immutable; see the note in the description of \`quote\` below.

\`3.2 \`=>\` 3.2\`
\` #f \`=>\` #f\`
\` #\\c \`=>\` #\\c\`
\` "hi" \`=>\` "hi"\`
\` #vu8(3 4 5) \`=>\` #vu8(3 4 5)\`
`
    },
    {
        name: "constructor",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s177"),
        description: `**syntax**: \`predicate\`
**syntax**: \`prefix\`
**syntax**: \`constructor\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(continuation-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s6"),
        description: `**syntax**: \`&continuation\`
**procedure**: \`(make-continuation-condition \`*continuation*\`)\`
**returns: **a condition of type \`&continuation\`
**procedure**: \`(continuation-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&continuation\`, \`#f\` otherwise
**procedure**: \`(condition-continuation \`*condition*\`)\`
**returns: **the contents of *condition*'s \`continuation\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition to indicate the current continuation at the point where the exception described by the condition occurred. The continuation of a failed \`assert\` or a call to \`assertion-violation\`, \`assertion-violationf\`, \`error\`, \`errorf\`, or \`syntax-error\` is now included via this condition type in the conditions passed to \`raise\`. The \`continuation\` argument should be a continuation. This condition type might be defined as follows.

\`(define-condition-type &continuation &condition\`
\`   make-continuation-condition continuation-condition?\`
\`   (continuation condition-continuation))\`
`
    },
    {
        name: "(copy-environment ",
        endParen: true,
        params: ["env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s34"),
        description: `**procedure**: \`(copy-environment \`*env*\`)\`
**procedure**: \`(copy-environment \`*env*\` \`*mutable?*\`)\`
**procedure**: \`(copy-environment \`*env*\` \`*mutable?*\` \`*syms*\`)\`
**returns: **a new environment
**libraries: **\`(chezscheme)\`

\`copy-environment\` returns a copy of *env*, i.e., a new environment that contains the same bindings as *env*.

The environment is mutable if *mutable?* is omitted or true; if *mutable?* is false, the environment is immutable.

The set of bindings copied from *env* to the new environment is determined by *syms*, which defaults to the value of \`(environment-symbols \`*env*\`)\`. The binding, if any, for each element of *syms* is copied to the new environment, and no other bindings are present in the new environment.

In the current implementation, the storage space used by an environment is never collected, so repeated use of \`copy-environment\` will eventually cause the system to run out of memory.

\`(define e (copy-environment (scheme-environment)))\`
\` (eval '(define cons +) e)\`
\` (eval '(cons 3 4) e)                    \`=>\` 7\`
\` (eval '(cons 3 4) (scheme-environment)) \`=>\` (3 . 4)\`
`
    },
    {
        name: "(copy-environment ",
        endParen: true,
        params: ["env", "mutable?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s34"),
        description: `**procedure**: \`(copy-environment \`*env*\`)\`
**procedure**: \`(copy-environment \`*env*\` \`*mutable?*\`)\`
**procedure**: \`(copy-environment \`*env*\` \`*mutable?*\` \`*syms*\`)\`
**returns: **a new environment
**libraries: **\`(chezscheme)\`

\`copy-environment\` returns a copy of *env*, i.e., a new environment that contains the same bindings as *env*.

The environment is mutable if *mutable?* is omitted or true; if *mutable?* is false, the environment is immutable.

The set of bindings copied from *env* to the new environment is determined by *syms*, which defaults to the value of \`(environment-symbols \`*env*\`)\`. The binding, if any, for each element of *syms* is copied to the new environment, and no other bindings are present in the new environment.

In the current implementation, the storage space used by an environment is never collected, so repeated use of \`copy-environment\` will eventually cause the system to run out of memory.

\`(define e (copy-environment (scheme-environment)))\`
\` (eval '(define cons +) e)\`
\` (eval '(cons 3 4) e)                    \`=>\` 7\`
\` (eval '(cons 3 4) (scheme-environment)) \`=>\` (3 . 4)\`
`
    },
    {
        name: "(copy-environment ",
        endParen: true,
        params: ["env", "mutable?", "syms"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s34"),
        description: `**procedure**: \`(copy-environment \`*env*\`)\`
**procedure**: \`(copy-environment \`*env*\` \`*mutable?*\`)\`
**procedure**: \`(copy-environment \`*env*\` \`*mutable?*\` \`*syms*\`)\`
**returns: **a new environment
**libraries: **\`(chezscheme)\`

\`copy-environment\` returns a copy of *env*, i.e., a new environment that contains the same bindings as *env*.

The environment is mutable if *mutable?* is omitted or true; if *mutable?* is false, the environment is immutable.

The set of bindings copied from *env* to the new environment is determined by *syms*, which defaults to the value of \`(environment-symbols \`*env*\`)\`. The binding, if any, for each element of *syms* is copied to the new environment, and no other bindings are present in the new environment.

In the current implementation, the storage space used by an environment is never collected, so repeated use of \`copy-environment\` will eventually cause the system to run out of memory.

\`(define e (copy-environment (scheme-environment)))\`
\` (eval '(define cons +) e)\`
\` (eval '(cons 3 4) e)                    \`=>\` 7\`
\` (eval '(cons 3 4) (scheme-environment)) \`=>\` (3 . 4)\`
`
    },
    {
        name: "(copy-time ",
        endParen: true,
        params: ["time"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s208"),
        description: `**procedure**: \`(copy-time \`*time*\`)\`
**returns: **a copy of *time*
**libraries: **\`(chezscheme)\`

\`(define t1 (current-time))\`
\` (define t2 (copy-time t1))\`
\` (eq? t2 t1) \`=>\` #f\`
\` (eqv? (time-second t2) (time-second t1)) \`=>\` #t\`
\` (eqv? (time-nanosecond t2) (time-nanosecond t1)) \`=>\` #t\`
`
    },
    {
        name: "(cos ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s131"),
        description: `**procedure**: \`(sin \`*num*\`)\`
**procedure**: \`(cos \`*num*\`)\`
**procedure**: \`(tan \`*num*\`)\`
**returns: **the sine, cosine, or tangent of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The argument is specified in radians.

\`(sin 0.0) \`=>\` 0.0\`
\` (cos 0.0) \`=>\` 1.0\`
\` (tan 0.0) \`=>\` 0.0\`
`
    },
    {
        name: "(cosh ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s76"),
        description: `**procedure**: \`(sinh \`*num*\`)\`
**procedure**: \`(cosh \`*num*\`)\`
**procedure**: \`(tanh \`*num*\`)\`
**returns: **the hyperbolic sine, cosine, or tangent of *num*
**libraries: **\`(chezscheme)\`

\`(sinh 0.0) \`=>\` 0.0\`
\` (cosh 0.0) \`=>\` 1.0\`
\` (tanh -0.0) \`=>\` -0.0\`
`
    },
    {
        name: "(cost-center-allocation-count ",
        endParen: true,
        params: ["cost-center"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s245"),
        description: `**procedure**: \`(cost-center-allocation-count \`*cost-center*\`)\`
**returns: **the number of allocated bytes tracked by *cost-center*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(cost-center-instruction-count ",
        endParen: true,
        params: ["cost-center"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s244"),
        description: `**procedure**: \`(cost-center-instruction-count \`*cost-center*\`)\`
**returns: **the number of instructions tracked by *cost-center*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(cost-center-time ",
        endParen: true,
        params: ["cost-center"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s246"),
        description: `**procedure**: \`(cost-center-time \`*cost-center*\`)\`
**returns: **the cpu time tracked by *cost-center*
**libraries: **\`(chezscheme)\`

The cpu time is returned as a time object with time-type \`time-duration\`.
`
    },
    {
        name: "(cost-center? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s242"),
        description: `**procedure**: \`(cost-center? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a cost center, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "cp0-effort-limit",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s120"),
        description: `**thread parameter**: \`run-cp0\`
**thread parameter**: \`cp0-effort-limit\`
**thread parameter**: \`cp0-score-limit\`
**thread parameter**: \`cp0-outer-unroll-limit\`
**libraries: **\`(chezscheme)\`

These parameters control the operation of \`cp0\`, a source optimization pass that runs after macro expansion and prior to most other compiler passes. \`cp0\` performs procedure inlining, in which the code of one procedure is inlined at points where it is called by other procedures, as well as copy propagation, constant folding, useless code elimination, and several related optimizations. The algorithm used by the optimizer is described in detail in the paper "Fast and effective procedure inlining" [].

When \`cp0\` is enabled, the programmer can count on the compiler to fold constants, eliminate unnecessary \`let\` bindings, and eliminate unnecessary and inaccessible code. This is particularly useful when writing macros, since the programmer can usually handle only the general case and let the compiler simplify the code when possible. For example, the programmer can define \`case\` as follows:

\`(define-syntax case\`
\`   (syntax-rules ()\`
\`     [(_ e [(k ...) a1 a2 ...] ... [else b1 b2 ...])\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...\`
\`          [else b1 b2 ...]))]\`
\`     [(_ e [(k ...) a1 a2 ...] ...)\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...))]))\`

and count on the introduce \`let\` expression to be eliminated if \`e\` turns out to be an unassigned variable, and count on the entire \`case\` expression to be folded if \`e\` turns out to be a constant.
`
    },
    {
        name: "cp0-outer-unroll-limit",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s120"),
        description: `**thread parameter**: \`run-cp0\`
**thread parameter**: \`cp0-effort-limit\`
**thread parameter**: \`cp0-score-limit\`
**thread parameter**: \`cp0-outer-unroll-limit\`
**libraries: **\`(chezscheme)\`

These parameters control the operation of \`cp0\`, a source optimization pass that runs after macro expansion and prior to most other compiler passes. \`cp0\` performs procedure inlining, in which the code of one procedure is inlined at points where it is called by other procedures, as well as copy propagation, constant folding, useless code elimination, and several related optimizations. The algorithm used by the optimizer is described in detail in the paper "Fast and effective procedure inlining" [].

When \`cp0\` is enabled, the programmer can count on the compiler to fold constants, eliminate unnecessary \`let\` bindings, and eliminate unnecessary and inaccessible code. This is particularly useful when writing macros, since the programmer can usually handle only the general case and let the compiler simplify the code when possible. For example, the programmer can define \`case\` as follows:

\`(define-syntax case\`
\`   (syntax-rules ()\`
\`     [(_ e [(k ...) a1 a2 ...] ... [else b1 b2 ...])\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...\`
\`          [else b1 b2 ...]))]\`
\`     [(_ e [(k ...) a1 a2 ...] ...)\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...))]))\`

and count on the introduce \`let\` expression to be eliminated if \`e\` turns out to be an unassigned variable, and count on the entire \`case\` expression to be folded if \`e\` turns out to be a constant.
`
    },
    {
        name: "cp0-score-limit",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s120"),
        description: `**thread parameter**: \`run-cp0\`
**thread parameter**: \`cp0-effort-limit\`
**thread parameter**: \`cp0-score-limit\`
**thread parameter**: \`cp0-outer-unroll-limit\`
**libraries: **\`(chezscheme)\`

These parameters control the operation of \`cp0\`, a source optimization pass that runs after macro expansion and prior to most other compiler passes. \`cp0\` performs procedure inlining, in which the code of one procedure is inlined at points where it is called by other procedures, as well as copy propagation, constant folding, useless code elimination, and several related optimizations. The algorithm used by the optimizer is described in detail in the paper "Fast and effective procedure inlining" [].

When \`cp0\` is enabled, the programmer can count on the compiler to fold constants, eliminate unnecessary \`let\` bindings, and eliminate unnecessary and inaccessible code. This is particularly useful when writing macros, since the programmer can usually handle only the general case and let the compiler simplify the code when possible. For example, the programmer can define \`case\` as follows:

\`(define-syntax case\`
\`   (syntax-rules ()\`
\`     [(_ e [(k ...) a1 a2 ...] ... [else b1 b2 ...])\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...\`
\`          [else b1 b2 ...]))]\`
\`     [(_ e [(k ...) a1 a2 ...] ...)\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...))]))\`

and count on the introduce \`let\` expression to be eliminated if \`e\` turns out to be an unassigned variable, and count on the entire \`case\` expression to be folded if \`e\` turns out to be a constant.
`
    },
    {
        name: "(cpu-time)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s221"),
        description: `**procedure**: \`(cpu-time)\`
**returns: **the amount of cpu time consumed since system start-up
**libraries: **\`(chezscheme)\`

The amount is in milliseconds. The amount includes "system" as well as "user" time, i.e., time spent in the kernel on behalf of the process as well as time spent in the process itself.

See also \`current-time\`, which returns more precise information.
`
    },
    {
        name: "(create-exception-state)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s15"),
        description: `**procedure**: \`(create-exception-state)\`
**procedure**: \`(create-exception-state \`*procedure*\`)\`
**libraries: **\`(chezscheme)\`

\`create-exception-state\` creates an exception state whose stack of exception handlers is empty except for, in effect, an infinite number of occurrences of at its base. *handler* must be a procedure, and should accept one argument. If not provided, *handler* defaults to a procedure equivalent to the value of the following expression.

\`(lambda (x) ((base-exception-handler) x))\`
`
    },
    {
        name: "(create-exception-state ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s15"),
        description: `**procedure**: \`(create-exception-state)\`
**procedure**: \`(create-exception-state \`*procedure*\`)\`
**libraries: **\`(chezscheme)\`

\`create-exception-state\` creates an exception state whose stack of exception handlers is empty except for, in effect, an infinite number of occurrences of at its base. *handler* must be a procedure, and should accept one argument. If not provided, *handler* defaults to a procedure equivalent to the value of the following expression.

\`(lambda (x) ((base-exception-handler) x))\`
`
    },
    {
        name: "(critical-section ",
        endParen: true,
        params: ["body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s27"),
        description: `**syntax**: \`(with-interrupts-disabled \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(critical-section \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the body *body1*\` \`*body2*\` ...\`
**libraries: **\`(chezscheme)\`

\`with-interrupts-disabled\` evaluates the body *body1*\` \`*body2*\` ...\` with interrupts disabled. That is, upon entry, interrupts are disabled, and upon exit, interrupts are re-enabled. Thus, \`with-interrupts-disabled\` allows the implementation of indivisible operations in nonthreaded versions of or within a single thread in threaded versions of . \`critical-section\` is the same as \`with-interrupts-disabled\` and is provided for backward compatibility.

\`with-interrupts-disabled\` can be defined as follows.

\`(define-syntax with-interrupts-disabled\`
\`   (syntax-rules ()\`
\`     [(_ b1 b2 ...)\`
\`      (dynamic-wind\`
\`        disable-interrupts\`
\`        (lambda () b1 b2 ...)\`
\`        enable-interrupts)]))\`

The use of \`dynamic-wind\` ensures that interrupts are disabled whenever the body of the \`with-interrupts-disabled\` expression is active and re-enabled whenever it is not. Since calls to \`disable-interrupts\` are counted (see the discussion under \`disable-interrupts\` and \`enable-interrupts\` above), \`with-interrupts-disabled\` expressions may be nested with the desired effect.
`
    },
    {
        name: "(current-date)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s210"),
        description: `**procedure**: \`(current-date)\`
**procedure**: \`(current-date \`*offset*\`)\`
**returns: **a date object representing the current date
**libraries: **\`(chezscheme)\`

*offset* represents the time-zone offset in seconds east of UTC, as described above. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero.

If *offset* is not provided, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

The following examples assume the local time zone is EST.

\`(current-date) \`=>\` #<date Thu Dec 27 23:23:20 2007>\`
\` (current-date 0) \`=>\` #<date Fri Dec 28 04:23:20 2007> \`
\` \`
\` (date-zone-name (current-date)) \`=>\` "EST" \`*or other system-provided string*
\` (date-zone-name (current-date 0)) \`=>\` #f\`
`
    },
    {
        name: "(current-date ",
        endParen: true,
        params: ["offset"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s210"),
        description: `**procedure**: \`(current-date)\`
**procedure**: \`(current-date \`*offset*\`)\`
**returns: **a date object representing the current date
**libraries: **\`(chezscheme)\`

*offset* represents the time-zone offset in seconds east of UTC, as described above. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero.

If *offset* is not provided, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

The following examples assume the local time zone is EST.

\`(current-date) \`=>\` #<date Thu Dec 27 23:23:20 2007>\`
\` (current-date 0) \`=>\` #<date Fri Dec 28 04:23:20 2007> \`
\` \`
\` (date-zone-name (current-date)) \`=>\` "EST" \`*or other system-provided string*
\` (date-zone-name (current-date 0)) \`=>\` #f\`
`
    },
    {
        name: "current-directory",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s139"),
        description: `**global parameter**: \`current-directory\`
**global parameter**: \`cd\`
**libraries: **\`(chezscheme)\`

When invoked without arguments, \`current-directory\` returns a string representing the current working directory. Otherwise, the current working directory is changed to the directory specified by the argument, which must be a string representing a valid directory pathname.

\`cd\` is bound to the same parameter.
`
    },
    {
        name: "current-error-port",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s74"),
        description: `**thread parameter**: \`current-error-port\`
**libraries: **\`(chezscheme)\`

\`current-error-port\` is a parameter that can be used to set or obtain the current error port. When called with no arguments, \`current-error-port\` returns the current error port. When called with one argument, which must be a textual output port, it changes the value of the current error port. The Revised Report version of \`current-error-port\` accepts only zero arguments, i.e., it cannot be used to change the current error port. The initial value of this parameter is the same port as the initial value of \`console-error-port\`.
`
    },
    {
        name: "(current-error-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s32"),
        description: `**procedure**: \`(current-input-port)\`
**returns: **the current input port
**procedure**: \`(current-output-port)\`
**returns: **the current output port
**procedure**: \`(current-error-port)\`
**returns: **the current error port
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`

The current-input, current-output, and current-error ports return pre-built textual ports that are initially associated with a process's standard input, standard output, and standard error streams.

The values returned by \`current-input-port\` and \`current-output-port\` can be altered temporarily by the convenience I/O procedures \`with-input-from-file\` and \`with-output-to-file\` (Section ).
`
    },
    {
        name: "current-eval",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s39"),
        description: `**thread parameter**: \`current-eval\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "current-exception-state",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s14"),
        description: `**thread parameter**: \`current-exception-state\`
**libraries: **\`(chezscheme)\`

\`current-exception-state\` may be used to get or set the current exception state. When called without arguments, \`current-exception-state\` returns an comprising the current stack of handlers established by \`with-exception-handler\` and \`guard\`. When called with a single argument, which must be an exception state, \`current-exception-state\` sets the exception state.
`
    },
    {
        name: "current-expand",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s92"),
        description: `**thread parameter**: \`current-expand\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "current-input-port",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s56"),
        description: `**thread parameter**: \`current-input-port\`
**libraries: **\`(chezscheme)\`

\`current-input-port\` is a parameter that determines the default port argument for most input procedures, including \`read-char\`, \`peek-char\`, and \`read\`, When called with no arguments, \`current-input-port\` returns the current input port. When called with one argument, which must be a textual input port, it changes the value of the current input port. The Revised Report version of \`current-input-port\` accepts only zero arguments, i.e., it cannot be used to change the current input port. The initial value of this parameter is the same port as the initial value of \`console-input-port\`.
`
    },
    {
        name: "(current-input-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s32"),
        description: `**procedure**: \`(current-input-port)\`
**returns: **the current input port
**procedure**: \`(current-output-port)\`
**returns: **the current output port
**procedure**: \`(current-error-port)\`
**returns: **the current error port
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`

The current-input, current-output, and current-error ports return pre-built textual ports that are initially associated with a process's standard input, standard output, and standard error streams.

The values returned by \`current-input-port\` and \`current-output-port\` can be altered temporarily by the convenience I/O procedures \`with-input-from-file\` and \`with-output-to-file\` (Section ).
`
    },
    {
        name: "current-locate-source-object-source",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s74"),
        description: `**thread parameter**: \`current-locate-source-object-source\`
**libraries: **\`(chezscheme)\`

\`current-locate-source-object-source\` determines the source-location lookup function that is used by the system to report errors based on source objects. This parameter is initially bound to \`locate-source-object-object\`.

Adjust this parameter to control the way that source locations are extracted from source objects, possibly using recorded information, caches, and the filesystem in a way different from \`locate-source-object-object\`.
`
    },
    {
        name: "current-make-source-object",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s62"),
        description: `**thread parameter**: \`current-make-source-object\`
**libraries: **\`(chezscheme)\`

\`current-make-source-object\` is used by the reader to construct a source object for an annotation. \`current-make-source-object\` is initially bound to \`make-source-object\`, and the reader always calls the function bound to the paramater with three arguments.

Adjust this parameter to, for example, eagerly convert a position integer to a file-position object, instead of delaying the conversion to \`locate-source\`.
`
    },
    {
        name: "(current-memory-bytes)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s226"),
        description: `**procedure**: \`(current-memory-bytes)\`
**returns: **the total number of bytes currently allocated, including overhead
**libraries: **\`(chezscheme)\`

\`current-memory-bytes\` returns the total size of the heap in bytes, including not only the bytes occupied for Scheme objects but also various forms of overhead, including fragmentation and reserved but not currently occupied memory, and is thus an accurate measure of the amount of heap memory currently reserved from the operating system for the current process.
`
    },
    {
        name: "current-output-port",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s72"),
        description: `**thread parameter**: \`current-output-port\`
**libraries: **\`(chezscheme)\`

\`current-output-port\` is a parameter that determines the default port argument for most output procedures, including \`write-char\`, \`newline\`, \`write\`, \`display\`, and \`pretty-print\`. When called with no arguments, \`current-output-port\` returns the current output port. When called with one argument, which must be a textual output port, it changes the value of the current output port. The Revised Report version of \`current-output-port\` accepts only zero arguments, i.e., it cannot be used to change the current output port. The initial value of this parameter is the same port as the initial value of \`console-output-port\`.
`
    },
    {
        name: "(current-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s32"),
        description: `**procedure**: \`(current-input-port)\`
**returns: **the current input port
**procedure**: \`(current-output-port)\`
**returns: **the current output port
**procedure**: \`(current-error-port)\`
**returns: **the current error port
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`

The current-input, current-output, and current-error ports return pre-built textual ports that are initially associated with a process's standard input, standard output, and standard error streams.

The values returned by \`current-input-port\` and \`current-output-port\` can be altered temporarily by the convenience I/O procedures \`with-input-from-file\` and \`with-output-to-file\` (Section ).
`
    },
    {
        name: "(current-time)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s202"),
        description: `**procedure**: \`(current-time)\`
**procedure**: \`(current-time \`*time-type*\`)\`
**returns: **a time object representing the current time
**libraries: **\`(chezscheme)\`

*time-type* must be one of the time-type symbols listed above and defaults to \`time-utc\`.

\`(current-time) \`=>\` #<time-utc 1198815722.473668000>\`
\` (current-time 'time-process) \`=>\` #<time-process 0.120534264>\`
`
    },
    {
        name: "(current-time ",
        endParen: true,
        params: ["time-type"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s202"),
        description: `**procedure**: \`(current-time)\`
**procedure**: \`(current-time \`*time-type*\`)\`
**returns: **a time object representing the current time
**libraries: **\`(chezscheme)\`

*time-type* must be one of the time-type symbols listed above and defaults to \`time-utc\`.

\`(current-time) \`=>\` #<time-utc 1198815722.473668000>\`
\` (current-time 'time-process) \`=>\` #<time-process 0.120534264>\`
`
    },
    {
        name: "current-transcoder",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s11"),
        description: `**thread parameter**: \`current-transcoder\`
**libraries: **\`(chezscheme)\`

The transcoder value of the \`current-transcoder\` parameter is used whenever a textual file is opened with an implicit transcoder, e.g., by \`open-input-file\` and other convenience I/O procedures, \`compile-file\` \`include\`, \`load\`, and \`pretty-file\`. Its initial value is the value of the \`native-transcoder\` procedure.
`
    },
    {
        name: "custom-port-buffer-size",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s54"),
        description: `**thread parameter**: \`custom-port-buffer-size\`
**libraries: **\`(chezscheme)\`

\`custom-port-buffer-size\` is a parameter that determines the sizes of the buffers associated with newly created custom ports. When called with no arguments, the parameter returns the current buffer size. When called with a positive fixnum *k*, it sets the current buffer size to *k*.
`
    },
    {
        name: "(date->time-utc ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s216"),
        description: `**procedure**: \`(time-utc->date \`*time*\`)\`
**procedure**: \`(time-utc->date \`*time*\` \`*offset*\`)\`
**returns: **a date object corresponding to *time*
**procedure**: \`(date->time-utc \`*date*\`)\`
**returns: **a time object corresponding to *date*
**libraries: **\`(chezscheme)\`

These procedures are used to convert between time and date objects. The *time* argument to \`time-utc->date\` must have time-type \`utc\`, and \`date->time-utc\` always returns a time object with time-type \`utc\`.

For \`time-utc->date\`, *offset* represents the time-zone offset in seconds east of UTC, as described at the beginning of this section. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero.

If *offset* is not provided to \`time-utc->date\`, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date->time-utc d) \`=>\` #<time-utc 1190552850.000000000>\`
\` (define t (make-time 'time-utc 0 1190552850))\`
\` (time-utc->date t) \`=>\` #<date Sun Sep 23 09:07:30 2007>\`
\` (time-utc->date t 0) \`=>\` #<date Sun Sep 23 13:07:30 2007>\`
`
    },
    {
        name: "(date-and-time)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s217"),
        description: `**procedure**: \`(date-and-time)\`
**procedure**: \`(date-and-time \`*date*\`)\`
**returns: **a string giving the current date and time
**libraries: **\`(chezscheme)\`

The string is always in the format illustrated by the examples below and always has length 24.

\`(date-and-time) \`=>\` "Fri Jul 13 13:13:13 2001"\`
\` (define d (make-date 0 0 0 0 1 1 2007 0))\`
\` (date-and-time d) \`=>\` "Mon Jan 01 00:00:00 2007"\`
`
    },
    {
        name: "(date-and-time ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s217"),
        description: `**procedure**: \`(date-and-time)\`
**procedure**: \`(date-and-time \`*date*\`)\`
**returns: **a string giving the current date and time
**libraries: **\`(chezscheme)\`

The string is always in the format illustrated by the examples below and always has length 24.

\`(date-and-time) \`=>\` "Fri Jul 13 13:13:13 2001"\`
\` (define d (make-date 0 0 0 0 1 1 2007 0))\`
\` (date-and-time d) \`=>\` "Mon Jan 01 00:00:00 2007"\`
`
    },
    {
        name: "(date-day ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-dst? ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s215"),
        description: `**procedure**: \`(date-dst? \`*date*\`)\`
**returns: **whether *date* is in Daylight Saving Time
**procedure**: \`(date-zone-name \`*date*\`)\`
**returns: **\`#f\` or a string naming the time zone of *date*
**libraries: **\`(chezscheme)\`

These procedures report time-zone information for the date represented by *date* for a date object that is constructed without an explicit time-zone offset. When a date object is created instead with explicit time-zone offset, these procedures produce \`#f\`.

Daylight Saving Time status for the current time zone and a name string for the time zone are computed using platform-specific routines. In particular, the format of the zone name is platform-specific.

\`(define d (make-date 0 30 7 9 23 9 2007))\`
\` (date-zone-offset d) \`=>\` -14400 \`*assuming Eastern U.S. time zone*
\` (date-dst? d) \`=>\` #t\`
\` (date-zone-name d) \`=>\` "EDT" \`*or some system-provided string*
`
    },
    {
        name: "(date-hour ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-minute ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-month ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-nanosecond ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-second ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-week-day ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s214"),
        description: `**procedure**: \`(date-week-day \`*date*\`)\`
**returns: **the week-day of *date*
**procedure**: \`(date-year-day \`*date*\`)\`
**returns: **the year-day of *date*
**libraries: **\`(chezscheme)\`

These procedures allow the day-of-week or day-of-year to be determined for the date represented by *date*. A week-day is an exact nonnegative integer less than 7, where 0 represents Sunday, 1 represents Monday, and so on. A year-day is an exact nonnegative integer less than 367, where 0 represents the first day of the year (January 1), 1 the second day, 2 the third, and so on.

\`(define d1 (make-date 0 0 0 0 1 1 1970 -18000))\`
\` d1 \`=>\` #<date Thu Jan  1 00:00:00 1970>\`
\` (date-week-day d1) \`=>\` 4\`
\` (date-year-day d1) \`=>\` 0 \`
\` \`
\` (define d2 (make-date 0 30 7 9 23 9 2007 -14400))\`
\` d2 \`=>\` #<date Sun Sep 23 09:07:30 2007>\`
\` (date-week-day d2) \`=>\` 0\`
\` (date-year-day d2) \`=>\` 265\`
`
    },
    {
        name: "(date-year ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date-year-day ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s214"),
        description: `**procedure**: \`(date-week-day \`*date*\`)\`
**returns: **the week-day of *date*
**procedure**: \`(date-year-day \`*date*\`)\`
**returns: **the year-day of *date*
**libraries: **\`(chezscheme)\`

These procedures allow the day-of-week or day-of-year to be determined for the date represented by *date*. A week-day is an exact nonnegative integer less than 7, where 0 represents Sunday, 1 represents Monday, and so on. A year-day is an exact nonnegative integer less than 367, where 0 represents the first day of the year (January 1), 1 the second day, 2 the third, and so on.

\`(define d1 (make-date 0 0 0 0 1 1 1970 -18000))\`
\` d1 \`=>\` #<date Thu Jan  1 00:00:00 1970>\`
\` (date-week-day d1) \`=>\` 4\`
\` (date-year-day d1) \`=>\` 0 \`
\` \`
\` (define d2 (make-date 0 30 7 9 23 9 2007 -14400))\`
\` d2 \`=>\` #<date Sun Sep 23 09:07:30 2007>\`
\` (date-week-day d2) \`=>\` 0\`
\` (date-year-day d2) \`=>\` 265\`
`
    },
    {
        name: "(date-zone-name ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s215"),
        description: `**procedure**: \`(date-dst? \`*date*\`)\`
**returns: **whether *date* is in Daylight Saving Time
**procedure**: \`(date-zone-name \`*date*\`)\`
**returns: **\`#f\` or a string naming the time zone of *date*
**libraries: **\`(chezscheme)\`

These procedures report time-zone information for the date represented by *date* for a date object that is constructed without an explicit time-zone offset. When a date object is created instead with explicit time-zone offset, these procedures produce \`#f\`.

Daylight Saving Time status for the current time zone and a name string for the time zone are computed using platform-specific routines. In particular, the format of the zone name is platform-specific.

\`(define d (make-date 0 30 7 9 23 9 2007))\`
\` (date-zone-offset d) \`=>\` -14400 \`*assuming Eastern U.S. time zone*
\` (date-dst? d) \`=>\` #t\`
\` (date-zone-name d) \`=>\` "EDT" \`*or some system-provided string*
`
    },
    {
        name: "(date-zone-offset ",
        endParen: true,
        params: ["date"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s213"),
        description: `**procedure**: \`(date-nanosecond \`*date*\`)\`
**returns: **the nanosecond of *date*
**procedure**: \`(date-second \`*date*\`)\`
**returns: **the second of *date*
**procedure**: \`(date-minute \`*date*\`)\`
**returns: **the minute of *date*
**procedure**: \`(date-hour \`*date*\`)\`
**returns: **the hour of *date*
**procedure**: \`(date-day \`*date*\`)\`
**returns: **the day of *date*
**procedure**: \`(date-month \`*date*\`)\`
**returns: **the month of *date*
**procedure**: \`(date-year \`*date*\`)\`
**returns: **the year of *date*
**procedure**: \`(date-zone-offset \`*date*\`)\`
**returns: **the time-zone offset of *date*
**libraries: **\`(chezscheme)\`

*date* must be a date object.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date-nanosecond d) \`=>\` 0\`
\` (date-second d) \`=>\` 30\`
\` (date-minute d) \`=>\` 7\`
\` (date-hour d) \`=>\` 9\`
\` (date-day d) \`=>\` 23\`
\` (date-month d) \`=>\` 9\`
\` (date-year d) \`=>\` 2007\`
\` (date-zone-offset d) \`=>\` -14400\`
`
    },
    {
        name: "(date? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s212"),
        description: `**procedure**: \`(date? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a date object, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (date? (current-date))\`
\` (date? (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date? "Sun Sep 23 09:07:30 2007") \`=>\` #f\`
`
    },
    {
        name: "(datum ",
        endParen: true,
        params: ["template"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s9"),
        description: `**syntax**: \`(datum \`*template*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`(datum \`*template*\`)\` is a convenient shorthand syntax for

\`(syntax->datum (syntax \`*template*\`))\`

*datum* may be defined simply as follows.

\`(define-syntax datum\`
\`   (syntax-rules ()\`
\`     [(_ t) (syntax->datum #'t)])) \`
\` \`
\` (with-syntax ((a #'(a b c))) (datum a)) \`=>\` (a b c)\`
`
    },
    {
        name: "(datum->syntax ",
        endParen: true,
        params: ["template-identifier", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s45"),
        description: `**procedure**: \`(datum->syntax \`*template-identifier*\` \`*obj*\`)\`
**returns: **a syntax object
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`datum->syntax\` constructs a syntax object from *obj* that contains the same contextual information as *template-identifier*, with the effect that the syntax object behaves as if it were introduced into the code when *template-identifier* was introduced. The template identifier is often the keyword of an input form, extracted from the form, and the object is often a symbol naming an identifier to be constructed.
`
    },
    {
        name: "(datum->syntax-object ",
        endParen: true,
        params: ["template-identifier", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s10"),
        description: `**procedure**: \`(datum->syntax-object \`*template-identifier*\` \`*obj*\`)\`
**returns: **a syntax object
**libraries: **\`(chezscheme)\`

\`datum->syntax-object\` is identical to the Revised Report \`datum->syntax\`.
`
    },
    {
        name: "(debug)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s16"),
        description: `**procedure**: \`(debug)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

When the default exception handler receives a serious or non-warning condition, it displays the condition and resets to the current café. Before it resets, it saves the condition in the parameter \`debug-condition\`. The \`debug\` procedure may be used to inspect the condition. Whenever one of the built-in error-reporting mechanisms is used to raise an exception, the continuation at the point where the exception was raised can be inspected as well. More generally, \`debug\` allows the continuation contained within any continuation condition created by \`make-continuation-condition\` to be inspected.
`
    },
    {
        name: "debug-condition",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s13"),
        description: `**thread parameter**: \`debug-condition\`
**libraries: **\`(chezscheme)\`

This parameter is used by the default exception handler to hold the last serious or non-warning condition received by the handler, where it can be inspected via the \`debug\` procedure (Section ). It can also be invoked by user code to store or retrieve a condition.
`
    },
    {
        name: "debug-level",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s110"),
        description: `**thread parameter**: \`debug-level\`
**libraries: **\`(chezscheme)\`

This parameter can take on one of the four values 0, 1, 2, and 3. It is used to tell the compiler how important the preservation of debugging information is, with 0 being least important and 3 being most important. The default value is 1. As of Version 9.0, it is used solely to determine whether an error-causing call encountered in nontail position is treated as if it were in tail position (thus causing the caller's frame not to appear in a stack backtrace); this occurs at debug levels below 2.
`
    },
    {
        name: "debug-on-exception",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s10"),
        description: `**global parameter**: \`debug-on-exception\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(decode-float ",
        endParen: true,
        params: ["x"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s30"),
        description: `**procedure**: \`(decode-float \`*x*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*x* must be a flonum. \`decode-float\` returns a vector with three integer elements, *m*, *e*, and *s*, such that = 2. It is useful primarily in the printing of floating-point numbers.

\`(decode-float 1.0) \`=>\` #(4503599627370496 -52 1)\`
\` (decode-float -1.0) \`=>\` #(4503599627370496 -52 -1) \`
\` \`
\` (define slow-identity\`
\`   (lambda (x)\`
\`     (inexact\`
\`       (let ([v (decode-float x)])\`
\`         (let ([m (vector-ref v 0)]\`
\`               [e (vector-ref v 1)]\`
\`               [s (vector-ref v 2)])\`
\`           (* s m (expt 2 e))))))) \`
\` \`
\` (slow-identity 1.0) \`=>\` 1.0\`
\` (slow-identity -1e20) \`=>\` -1e20\`
`
    },
    {
        name: "(default-exception-handler ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s8"),
        description: `**procedure**: \`(default-exception-handler \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure is the default value of the \`base-exception-handler\` parameter called on a condition when no other exception handler has been defined or when all dynamically established exception handlers have chosen not to handle the condition. It first displays *obj*, as if with \`display-condition\`, to the console error port. For non-serious warning conditions, it returns immediately after displaying the condition.
`
    },
    {
        name: "(default-library-search-handler ",
        endParen: true,
        params: ["who", "library", "directories", "extensions"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s31"),
        description: `**procedure**: \`(default-library-search-handler \`*who*\` \`*library*\` \`*directories*\` \`*extensions*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

This procedure is the default value of the \`library-search-handler\`, which is called to locate the source or object code for a library during \`import\`, \`compile-whole-program\`, or \`compile-whole-library\`. *who* is a symbol that provides context in \`import-notify\` messages. *library* is the name of the desired library. *directories* is a list of source and object directory pairs in the form returned by \`library-directories\`. *extensions* is a list of source and object extension pairs in the form returned by \`library-extensions\`.

This procedure searches the specified directories until it finds a library source or object file with one of the specified extensions. If it finds the source file first, it constructs the corresponding object file path and checks whether the file exists. If it finds the object file first, the procedure looks for a corresponding source file with one of the given source extensions in a source directory paired with that object directory. The procedure returns three values: the file-system path of the library source file or \`#f\` if not found, the file-system path of the corresponding object file, which may be \`#f\`, and a boolean that is true if the object file exists.
`
    },
    {
        name: "(default-prompt-and-read ",
        endParen: true,
        params: ["level"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s176"),
        description: `**procedure**: \`(default-prompt-and-read \`*level*\`)\`
**libraries: **\`(chezscheme)\`

*level* must be a positive integer indicating the cafeé nesting level as described above.

This procedure is the default value of the \`waiter-prompt-and-read\` parameter whenever the expression editor (Section , Chapter ) is enabled. It might be defined as follows.

\`(define default-prompt-and-read\`
\`   (lambda (n)\`
\`     (unless (and (integer? n) (>= n 0))\`
\`        (assertion-violationf 'default-prompt-and-read\`
\`          "~s is not a nonnegative integer"\`
\`          n))\`
\`     (let ([prompt (waiter-prompt-string)])\`
\`       (unless (string=? prompt "")\`
\`         (do ([n n (- n 1)])\`
\`             ((= n 0)\`
\`              (write-char #\\space (console-output-port))\`
\`              (flush-output-port (console-output-port)))\`
\`             (display prompt (console-output-port))))\`
\`       (let ([x (read (console-input-port))])\`
\`          (when (and (eof-object? x) (not (string=? prompt "")))\`
\`             (newline (console-output-port))\`
\`             (flush-output-port (console-output-port)))\`
\`          x))))\`
`
    },
    {
        name: "default-record-equal-procedure",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s161"),
        description: `**thread parameter**: \`default-record-equal-procedure\`
**libraries: **\`(chezscheme)\`

This parameter determines how two record instances are compared by \`equal?\` if neither has a type-specific equality procedure. When the parameter has the value \`#f\` (the default), \`equal?\` compares the instances with \`eq?\`, i.e., there is no attempt at determining structural equivalence. Otherwise, the parameter's value must be a procedure, and \`equal?\` invokes that procedure to compare the instances, passing it three arguments: the two instances and a procedure that should be used to recursively compare arbitrary values within the instances.
`
    },
    {
        name: "default-record-hash-procedure",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s162"),
        description: `**thread parameter**: \`default-record-hash-procedure\`
**libraries: **\`(chezscheme)\`

This parameter determines the hash procedure used when \`equal-hash\` is called on a record instance and the instance does not have a type-specific hash procedure. When the parameter has the value \`#f\` (the default), \`equal-hash\` returns a value that is independent of the record type and contents of the instance. Otherwise, the parameter's value must be a procedure, and \`equal-hash\` invokes the procedure to compute the instance's hash value, passing it the record instance and a procedure to invoke to recursively compute hash values for arbitrary values contained within the record. The procedure should return a nonnegative exact integer, and the return value should be the same for any two instances the default equal procedure considers equivalent.
`
    },
    {
        name: "(define ",
        endParen: true,
        params: ["var", "expr"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s24"),
        description: `**syntax**: \`(define \`*var*\` \`*expr*\`)\`
**syntax**: \`(define \`*var*\`)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` \`*var2*\` ... . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

In the first form, \`define\` creates a new binding of *var* to the value of *expr*. The *expr* should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(define ",
        endParen: true,
        params: ["var"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s24"),
        description: `**syntax**: \`(define \`*var*\` \`*expr*\`)\`
**syntax**: \`(define \`*var*\`)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` \`*var2*\` ... . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

In the first form, \`define\` creates a new binding of *var* to the value of *expr*. The *expr* should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(define (",
        endParen: true,
        params: ["var0", "var1", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s24"),
        description: `**syntax**: \`(define \`*var*\` \`*expr*\`)\`
**syntax**: \`(define \`*var*\`)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` \`*var2*\` ... . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

In the first form, \`define\` creates a new binding of *var* to the value of *expr*. The *expr* should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(define (",
        endParen: true,
        params: ["var0", "varr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s24"),
        description: `**syntax**: \`(define \`*var*\` \`*expr*\`)\`
**syntax**: \`(define \`*var*\`)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` \`*var2*\` ... . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

In the first form, \`define\` creates a new binding of *var* to the value of *expr*. The *expr* should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(define (",
        endParen: true,
        params: ["var0", "var1", "var2", "varr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s24"),
        description: `**syntax**: \`(define \`*var*\` \`*expr*\`)\`
**syntax**: \`(define \`*var*\`)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(define (\`*var0*\` \`*var1*\` \`*var2*\` ... . \`*varr*\`) \`*body1*\` \`*body2*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

In the first form, \`define\` creates a new binding of *var* to the value of *expr*. The *expr* should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(define-condition-type ",
        endParen: true,
        params: ["name", "parent", "constructor", "pred", "field", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s17"),
        description: `**syntax**: \`(define-condition-type \`*name*\` \`*parent*\` \`*constructor*\` \`*pred*\` \`*field*\` ...)\`
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

A \`define-condition-type\` form is a definition and may appear anywhere other definitions may appear. It is used to define new simple condition types.

The subforms *name*, *parent*, *constructor*, and *pred* must be identifiers. Each *field* must be of the form \`(\`*field-name*\` \`*accessor-name*\`)\`, where *field-name* and *accessor-name* are identifiers.

\`define-condition-type\` defines *name* as a new record type whose parent record type is *parent*, whose constructor name is *constructor*, whose predicate name is *pred*, whose fields are *field-name*\` ...\`, and whose field accessors are named by *accessor-name*\` ...\`.

With the exception of the predicate and field accessors, \`define-condition-type\` is essentially an ordinary record definition equivalent to

\`(define-record-type (\`*name*\` \`*constructor*\` \`*pred*\`)\`
\`   (parent \`*parent*\`)\`
\`   (fields ((immutable \`*field-name*\` \`*accessor-name*\`) ...)))\`

The predicate differs from one that would be generated by a \`define-record-type\` form in that it returns \`#t\` not only for an instance of the new type but also for compound conditions whose simple conditions include an instance of the new type. Similarly, field accessors accept instances of the new type as well as compound conditions whose simple conditions include at least one instance of the new record type. If an accessor receives a compound condition whose simple conditions list includes one or more instances of the new type, the accessor operates on the first instance in the list.

\`(define-condition-type &mistake &condition make-mistake mistake?\`
\`   (type mistake-type)) \`
\` \`
\` (mistake? 'booboo) \`=>\` #f \`
\` \`
\` (define c1 (make-mistake 'spelling))\`
\` (mistake? c1) \`=>\` #t\`
\` (mistake-type c1) \`=>\` spelling \`
\` \`
\` (define c2 (condition c1 (make-irritants-condition '(eggregius))))\`
\` (mistake? c2) \`=>\` #t\`
\` (mistake-type c2) \`=>\` spelling\`
\` (irritants-condition? c2) \`=>\` #t\`
\` (condition-irritants c2) \`=>\` (eggregius)\`
`
    },
    {
        name: "(define-enumeration ",
        endParen: true,
        params: ["name", "symbol", "constructor"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s290"),
        description: `**syntax**: \`(define-enumeration \`*name*\` (\`*symbol*\` ...) \`*constructor*\`)\`
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

A \`define-enumeration\` form is a definition and can appear anywhere any other definition can appear.

The \`define-enumeration\` syntax creates a new enumeration set with the specified symbols in the specified order forming the enumeration's universe. It defines a new syntactic form named by *name* that may be used to verify that a symbol is in the universe. If *x* is in the universe, \`(\`*name x*\`)\` evaluates to *x*. It is a syntax violation if *x* is not in the universe.

\`define-enumeration\` also defines a new syntactic form named by *constructor* that may be used to create subsets of the enumeration type. If *x*\` ...\` are each in the universe, *(constructor x*\` ...)\` evaluates to an enumeration set containing *x*\` ...\`. Otherwise, it is a syntax violation. The same symbol may appear more than once in *x*\` ...\`, but the resulting set contains only one occurrence of the symbol.

\`(define-enumeration weather-element\`
\`   (hot warm cold sunny rainy snowy windy)\`
\`   weather) \`
\` \`
\` (weather-element hot) \`=>\` hot\`
\` (weather-element fun) \`=>\` \`*syntax violation*
\` (weather hot sunny windy) \`=>\` #<enum-set>\`
\` (enum-set->list (weather rainy cold rainy)) \`=>\` (cold rainy)\`
`
    },
    {
        name: "(define-ftype ",
        endParen: true,
        params: ["ftype-name", "ftype"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s137"),
        description: `**syntax**: \`(define-ftype \`*ftype-name*\` \`*ftype*\`)\`
**syntax**: \`(define-ftype (\`*ftype-name*\` \`*ftype*\`) ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(define-ftype (",
        endParen: true,
        params: ["ftype-name", "ftype", ") ..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s137"),
        description: `**syntax**: \`(define-ftype \`*ftype-name*\` \`*ftype*\`)\`
**syntax**: \`(define-ftype (\`*ftype-name*\` \`*ftype*\`) ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(define-property ",
        endParen: true,
        params: ["id", "key", "expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s18"),
        description: `**syntax**: \`(define-property \`*id*\` \`*key*\` \`*expr*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

A \`define-property\` form attaches a property to an existing identifier binding without disturbing the existing meaning of the identifier in the scope of that binding. It is typically used by one macro to record information about a binding for use by another macro. Both *id* and *key* must be identifiers. The expression *expr* is evaluated when the \`define-property\` form is expanded, and a new property associating *key* with the value of *expr* is attached to the existing binding of *id*, which must have a visible local or top-level binding.

\`define-property\` is a definition and can appear anywhere other definitions can appear. The scope of a property introduced by \`define-property\` is the entire body in which the \`define-property\` form appears or global if it appears at top level, except where it is replaced by a property for the same *id* and *key* or where the binding to which it is attached is shadowed. Any number of properties can be attached to the same binding with different keys. Attaching a new property with the same name as an property already attached to a binding shadows the existing property with the new property.

The following example defines a macro, \`get-info\`, that retrieves the \`info\` property of a binding, defines the variable \`x\`, attaches an \`info\` property to the binding of \`x\`, retrieves the property via \`get-info\`, references \`x\` to show that its normal binding is still intact, and uses \`get-info\` again within the scope of a different binding of \`x\` to show that the properties are shadowed as well as the outer binding of \`x\`.

\`(define info)\`
\` (define-syntax get-info\`
\`   (lambda (x)\`
\`     (lambda (lookup)\`
\`       (syntax-case x ()\`
\`         [(_ q)\`
\`          (let ([info-value (lookup #'q #'info)])\`
\`            #\`'#,(datum->syntax #'* info-value))]))))\`
\` (define x "x-value")\`
\` (define-property x info "x-info")\`
\` (get-info x) \`=>\` "x-info"\`
\` x \`=>\` "x-value"\`
\` (let ([x "inner-x-value"]) (get-info x)) \`=>\` #f\`
`
    },
    {
        name: "(define-record ",
        endParen: true,
        params: ["name", "fld1", "fld2", "init", "opt", "...)"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s173"),
        description: `**syntax**: \`(define-record \`*name*\` (\`*fld1*\` ...) ((\`*fld2*\` \`*init*\`) ...) (\`*opt*\` ...))\`
**syntax**: \`(define-record \`*name*\` \`*parent*\` (\`*fld1*\` ...) ((\`*fld2*\` \`*init*\`) ...) (\`*opt*\` ...))\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

A \`define-record\` form is a definition and may appear anywhere and only where other definitions may appear.

\`define-record\` creates a new record type containing a specified set of named fields and defines a set of procedures for creating and manipulating instances of the record type.

*name* must be an identifier. If *name* is a generated symbol (gensym), the record definition is , otherwise it is . (See the discussion of generativity earlier in this section.)

Each *fld* must be an identifier *field-name*, or it must take the form

\`(\`*class*\` \`*type*\` \`*field-name*\`)\`

where *class* and *type* are optional and *field-name* is an identifier. *class*, if present, must be the keyword \`immutable\` or the keyword \`mutable\`. If the \`immutable\` class specifier is present, the field is immutable; otherwise, the field is mutable. *type*, if present, specifies how the field is represented, as described below.
`
    },
    {
        name: "(define-record ",
        endParen: true,
        params: ["name", "parent", "fld1", "fld2", "init", "opt", "...)"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s173"),
        description: `**syntax**: \`(define-record \`*name*\` (\`*fld1*\` ...) ((\`*fld2*\` \`*init*\`) ...) (\`*opt*\` ...))\`
**syntax**: \`(define-record \`*name*\` \`*parent*\` (\`*fld1*\` ...) ((\`*fld2*\` \`*init*\`) ...) (\`*opt*\` ...))\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

A \`define-record\` form is a definition and may appear anywhere and only where other definitions may appear.

\`define-record\` creates a new record type containing a specified set of named fields and defines a set of procedures for creating and manipulating instances of the record type.

*name* must be an identifier. If *name* is a generated symbol (gensym), the record definition is , otherwise it is . (See the discussion of generativity earlier in this section.)

Each *fld* must be an identifier *field-name*, or it must take the form

\`(\`*class*\` \`*type*\` \`*field-name*\`)\`

where *class* and *type* are optional and *field-name* is an identifier. *class*, if present, must be the keyword \`immutable\` or the keyword \`mutable\`. If the \`immutable\` class specifier is present, the field is immutable; otherwise, the field is mutable. *type*, if present, specifies how the field is represented, as described below.
`
    },
    {
        name: "(define-record-type ",
        endParen: true,
        params: ["record-name", "clause", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s13"),
        description: `**syntax**: \`(define-record-type \`*record-name*\` \`*clause*\` ...)\`
**syntax**: \`(define-record-type (\`*record-name*\` \`*constructor*\` \`*pred*\`) \`*clause*\` ...)\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

A \`define-record-type\` form, or , is a definition and may appear anywhere other definitions may appear. It defines a record type identified by *record-name*, plus a predicate, constructor, accessors, and mutators for the record type. If the record definition takes the first form above, the names of the constructor and predicate are derived from *record-name*: \`make-\`*record-name* for the constructor and *record-name*\`?\` for the predicate. If the record definition takes the second form above, the name of the constructor is *constructor* and the name of the predicate is *pred*. All names defined by a record definition are scoped where the record definition appears.

The clauses *clause*\` ...\` of the record definition determine the fields of the record type and the names of their accessors and mutators; its parent type, if any; its construction protocol; whether it is nongenerative and, if so, whether its uid is specified; whether it is sealed; and whether it is opaque. The syntax and impact of each clause is described below.

None of the clauses is required; thus, the simplest record definition is

\`(define-record-type \`*record-name*\`)\`

which defines a new, generative, non-sealed, non-opaque record type with no parent and no fields, plus a constructor of no arguments and a predicate.

At most one of each kind of clause may be present in the set of clauses, and if a \`parent\` clause is present, a \`parent-rtd\` clause must not be present. The clauses that appear may appear in any order.

**Fields clause.**  A \`(fields \`*field-spec*\` ...)\` clause declares the fields of the record type. Each *field-spec* must take one of the following forms:

*field-name*
\` (immmutable \`*field-name*\`)\`
\` (mutable \`*field-name*\`)\`
\` (immmutable \`*field-name*\` \`*accessor-name*\`)\`
\` (mutable \`*field-name*\` \`*accessor-name*\` \`*mutator-name*\`)\`

where *field-name*, *accessor-name*, and *mutator-name* are identifiers. The first form, *field-name*, is equivalent to \`(immutable \`*field-name*\`)\`. The value of a field declared immutable may not be changed, and no mutator is created for it. With the first three forms, the name of the accessor is *rname*\`-\`*fname*, where *rname* is the record name and *fname* is the field name. With the third form, the name of the accessor is *rname*\`-\`*fname*\`-set!\`. The fourth and fifth forms explicitly declare the accessor and mutator names.

If no \`fields\` clause is present or the list *field-spec*\` ...\` is empty, the record type has no fields (other than parent fields, if any).

**Parent clause.**  A \`(parent \`*parent-name*\`)\` clause declares the parent record type; *parent-name* must be the name of a non-sealed record type previously defined via \`define-record-type\`. Instances of a record type are also considered instances of its parent record type and have all the fields of its parent record type in addition to those declared via the \`fields\` clause.

**Nongenerative clause.**  A \`nongenerative\` clause may take one of two forms:

\`(nongenerative)\`
\` (nongenerative \`*uid*\`)\`

where *uid* is a symbol. The first form is equivalent to the second, with a uid generated by the implementation at macro-expansion time. When a \`define-record-type\` form with a nongenerative clause is evaluated, a new type is created if and only if the uid is not the uid of an existing record type.

If it is the uid of an existing record type, the parent, field-names, sealed property, and opaque property must match as follows.

If these constraints are met, no new record type is created, and the other products of the record-type definition (constructor, predicate, accessors, and mutators) operate on records of the existing type. If these constraints are not met, the implementation may treat it as a syntax violation, or it may raise a run-time exception with condition type \`&assertion\`.

With the first form of \`nongenerative\` clause, the generated uid can be the uid of an existing record type only if the same definition is executed multiple times, e.g., if it appears in the body of a procedure that is invoked multiple times.

If *uid* is not the uid of an existing record type, or if no \`nongenerative\` clause is present, a new record type is created.

**Protocol clause.**  A \`(protocol \`*expression*\`)\` determines the protocol that the generated constructor uses to construct instances of the record type. It must evaluate to a procedure, and this procedure should be an appropriate protocol for the record type, as described on page .
`
    },
    {
        name: "(define-record-type (",
        endParen: true,
        params: ["record-name", "constructor", "pred", "clause", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s13"),
        description: `**syntax**: \`(define-record-type \`*record-name*\` \`*clause*\` ...)\`
**syntax**: \`(define-record-type (\`*record-name*\` \`*constructor*\` \`*pred*\`) \`*clause*\` ...)\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

A \`define-record-type\` form, or , is a definition and may appear anywhere other definitions may appear. It defines a record type identified by *record-name*, plus a predicate, constructor, accessors, and mutators for the record type. If the record definition takes the first form above, the names of the constructor and predicate are derived from *record-name*: \`make-\`*record-name* for the constructor and *record-name*\`?\` for the predicate. If the record definition takes the second form above, the name of the constructor is *constructor* and the name of the predicate is *pred*. All names defined by a record definition are scoped where the record definition appears.

The clauses *clause*\` ...\` of the record definition determine the fields of the record type and the names of their accessors and mutators; its parent type, if any; its construction protocol; whether it is nongenerative and, if so, whether its uid is specified; whether it is sealed; and whether it is opaque. The syntax and impact of each clause is described below.

None of the clauses is required; thus, the simplest record definition is

\`(define-record-type \`*record-name*\`)\`

which defines a new, generative, non-sealed, non-opaque record type with no parent and no fields, plus a constructor of no arguments and a predicate.

At most one of each kind of clause may be present in the set of clauses, and if a \`parent\` clause is present, a \`parent-rtd\` clause must not be present. The clauses that appear may appear in any order.

**Fields clause.**  A \`(fields \`*field-spec*\` ...)\` clause declares the fields of the record type. Each *field-spec* must take one of the following forms:

*field-name*
\` (immmutable \`*field-name*\`)\`
\` (mutable \`*field-name*\`)\`
\` (immmutable \`*field-name*\` \`*accessor-name*\`)\`
\` (mutable \`*field-name*\` \`*accessor-name*\` \`*mutator-name*\`)\`

where *field-name*, *accessor-name*, and *mutator-name* are identifiers. The first form, *field-name*, is equivalent to \`(immutable \`*field-name*\`)\`. The value of a field declared immutable may not be changed, and no mutator is created for it. With the first three forms, the name of the accessor is *rname*\`-\`*fname*, where *rname* is the record name and *fname* is the field name. With the third form, the name of the accessor is *rname*\`-\`*fname*\`-set!\`. The fourth and fifth forms explicitly declare the accessor and mutator names.

If no \`fields\` clause is present or the list *field-spec*\` ...\` is empty, the record type has no fields (other than parent fields, if any).

**Parent clause.**  A \`(parent \`*parent-name*\`)\` clause declares the parent record type; *parent-name* must be the name of a non-sealed record type previously defined via \`define-record-type\`. Instances of a record type are also considered instances of its parent record type and have all the fields of its parent record type in addition to those declared via the \`fields\` clause.

**Nongenerative clause.**  A \`nongenerative\` clause may take one of two forms:

\`(nongenerative)\`
\` (nongenerative \`*uid*\`)\`

where *uid* is a symbol. The first form is equivalent to the second, with a uid generated by the implementation at macro-expansion time. When a \`define-record-type\` form with a nongenerative clause is evaluated, a new type is created if and only if the uid is not the uid of an existing record type.

If it is the uid of an existing record type, the parent, field-names, sealed property, and opaque property must match as follows.

If these constraints are met, no new record type is created, and the other products of the record-type definition (constructor, predicate, accessors, and mutators) operate on records of the existing type. If these constraints are not met, the implementation may treat it as a syntax violation, or it may raise a run-time exception with condition type \`&assertion\`.

With the first form of \`nongenerative\` clause, the generated uid can be the uid of an existing record type only if the same definition is executed multiple times, e.g., if it appears in the body of a procedure that is invoked multiple times.

If *uid* is not the uid of an existing record type, or if no \`nongenerative\` clause is present, a new record type is created.

**Protocol clause.**  A \`(protocol \`*expression*\`)\` determines the protocol that the generated constructor uses to construct instances of the record type. It must evaluate to a procedure, and this procedure should be an appropriate protocol for the record type, as described on page .
`
    },
    {
        name: "(define-structure (",
        endParen: true,
        params: ["name", "id1", "id2", "expr", ") ...)"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s25"),
        description: `**syntax**: \`(define-structure (\`*name*\` \`*id1*\` ...) ((\`*id2*\` \`*expr*\`) ...))\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

A \`define-structure\` form is a definition and may appear anywhere and only where other definitions may appear.

\`define-structure\` defines a new data structure, *name*, and creates a set of procedures for creating and manipulating instances of the structure. The identifiers *id1*\` ...\` and *id2*\` ...\` name the fields of the data structure.

The following procedures are defined by \`define-structure\`:

The fields named by the identifiers *id1*\` ...\` are initialized by the arguments to the constructor procedure. The fields named by the identifiers *id2*\` ...\` are initialized explicitly to the values of the expressions *expr*\` ...\`. Each expression is evaluated within the scope of the identifiers *id1*\` ...\` (bound to the corresponding field values) and any of the identifiers *id2*\` ...\` (bound to the corresponding field values) appearing before it (as if within a \`let*\`).

To clarify, the constructor behaves as if defined as

\`(define make-\`*name*
\`   (lambda (\`*id1*\` ...)\`
\`     (let* ([\`*id2*\` \`*expr*\`] ...)\`
\`       \`*body*\`)))\`

where *body* builds the structure from the values of the identifiers *id1*\` ...\` and *id2*\` ...\`.

If no fields other than those initialized by the arguments to the constructor procedure are needed, the second subexpression, \`((\`*id2*\` \`*expr*\`) ...)\`, may be omitted.
`
    },
    {
        name: "(define-syntax ",
        endParen: true,
        params: ["keyword", "expr"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s12"),
        description: `**syntax**: \`(define-syntax \`*keyword*\` \`*expr*\`)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*expr* must evaluate to a transformer.

The following example defines \`let*\` as a syntactic extension, specifying the transformer with \`syntax-rules\` (see Section ).

\`(define-syntax let*\`
\`   (syntax-rules ()\`
\`     [(_ () b1 b2 ...) (let () b1 b2 ...)]\`
\`     [(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)\`
\`      (let ([i1 e1])\`
\`        (let* ([i2 e2] ...) b1 b2 ...))]))\`

All bindings established by a set of internal definitions, whether keyword or variable definitions, are visible everywhere within the immediately enclosing body, including within the definitions themselves. For example, the expression

\`(let ()\`
\`   (define even?\`
\`     (lambda (x)\`
\`       (or (= x 0) (odd? (- x 1)))))\`
\`   (define-syntax odd?\`
\`     (syntax-rules ()\`
\`       [(_ x) (not (even? x))]))\`
\`   (even? 10))\`

is valid and should evaluate to \`#t\`.
`
    },
    {
        name: "(define-top-level-syntax ",
        endParen: true,
        params: ["symbol", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s32"),
        description: `**procedure**: \`(define-top-level-syntax \`*symbol*\` \`*obj*\`)\`
**procedure**: \`(define-top-level-syntax \`*symbol*\` \`*obj*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`define-top-level-syntax\` is used to establish a top-level binding for the identifier named by *symbol* to the value of *obj* in the environment *env*. The value must be a procedure, the result of a call to \`make-variable-transformer\`, or the result of a call to \`top-level-syntax\`. If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

An exception is raised with condition type \`&assertion\` if *env* is not mutable.
`
    },
    {
        name: "(define-top-level-syntax ",
        endParen: true,
        params: ["symbol", "obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s32"),
        description: `**procedure**: \`(define-top-level-syntax \`*symbol*\` \`*obj*\`)\`
**procedure**: \`(define-top-level-syntax \`*symbol*\` \`*obj*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`define-top-level-syntax\` is used to establish a top-level binding for the identifier named by *symbol* to the value of *obj* in the environment *env*. The value must be a procedure, the result of a call to \`make-variable-transformer\`, or the result of a call to \`top-level-syntax\`. If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

An exception is raised with condition type \`&assertion\` if *env* is not mutable.
`
    },
    {
        name: "(define-top-level-value ",
        endParen: true,
        params: ["symbol", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s24"),
        description: `**procedure**: \`(define-top-level-value \`*symbol*\` \`*obj*\`)\`
**procedure**: \`(define-top-level-value \`*symbol*\` \`*obj*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`define-top-level-value\` is used to establish a binding for the variable named by *symbol* to the value *obj* in the environment *env*. If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

An exception is raised with condition type \`&assertion\` if *env* is not mutable.
`
    },
    {
        name: "(define-top-level-value ",
        endParen: true,
        params: ["symbol", "obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s24"),
        description: `**procedure**: \`(define-top-level-value \`*symbol*\` \`*obj*\`)\`
**procedure**: \`(define-top-level-value \`*symbol*\` \`*obj*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`define-top-level-value\` is used to establish a binding for the variable named by *symbol* to the value *obj* in the environment *env*. If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

An exception is raised with condition type \`&assertion\` if *env* is not mutable.
`
    },
    {
        name: "(define-values ",
        endParen: true,
        params: ["formals", "expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s16"),
        description: `**syntax**: \`(define-values \`*formals*\` \`*expr*\`)\`
**libraries: **\`(chezscheme)\`

A \`define-values\` form is a definition and can appear anywhere other definitions can appear. It is like a \`define\` form but permits an arbitrary formals list (like \`lambda\`) on the left-hand side. It evaluates *expr* and binds the variables appearing in *formals* to the resulting values, in the same manner as the formal parameters of a procedure are bound to its arguments.

\`(let ()\`
\`   (define-values (x y) (values 1 2))\`
\`   (list x y)) \`=>\` (1 2)\`
\` (let ()\`
\`   (define-values (x y . z) (values 1 2 3 4))\`
\`   (list x y z)) \`=>\` (1 2 (3 4))\`

A \`define-values\` form expands into a sequence of definitions, the first for a hidden temporary bound to a data structure holding the values returned by *expr* and the remainder binding each of the formals to the corresponding value or list of values, extracted from the data structure via a reference to the temporary. Because the temporary must be defined before the other variables are defined, this works for internal \`define-values\` forms only if \`internal-defines-as-letrec*\` is set to the default value \`#t\`.
`
    },
    {
        name: "(delay ",
        endParen: true,
        params: ["expr"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s65"),
        description: `**syntax**: \`(delay \`*expr*\`)\`
**returns: **a promise
**procedure**: \`(force \`*promise*\`)\`
**returns: **result of forcing *promise*
**libraries: **\`(rnrs r5rs)\`

The first time a promise created by \`delay\` is (with \`force\`), it evaluates *expr*, "remembering" the resulting value. Thereafter, each time the promise is forced, it returns the remembered value instead of reevaluating *expr*.

\`delay\` and \`force\` are typically used only in the absence of side effects, e.g., assignments, so that the order of evaluation is unimportant.
`
    },
    {
        name: "(delete-directory ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s148"),
        description: `**procedure**: \`(delete-directory \`*path*\`)\`
**procedure**: \`(delete-directory \`*path*\` \`*error?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*path* must be a string. \`delete-directory\` removes the directory named by *path*. If the optional *error?* argument is \`#f\` (the default), \`delete-directory\` returns a boolean value: \`#t\` if the operation is successful and \`#f\` if it is not. Otherwise, \`delete-directory\` returns an unspecified value if the operation is successful and raises an exception with condition type \`&i/o-filename\` if it is not. The behavior is unspecified if the directory is not empty, but on most systems the operations will not succeed.
`
    },
    {
        name: "(delete-directory ",
        endParen: true,
        params: ["path", "error?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s148"),
        description: `**procedure**: \`(delete-directory \`*path*\`)\`
**procedure**: \`(delete-directory \`*path*\` \`*error?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*path* must be a string. \`delete-directory\` removes the directory named by *path*. If the optional *error?* argument is \`#f\` (the default), \`delete-directory\` returns a boolean value: \`#t\` if the operation is successful and \`#f\` if it is not. Otherwise, \`delete-directory\` returns an unspecified value if the operation is successful and raises an exception with condition type \`&i/o-filename\` if it is not. The behavior is unspecified if the directory is not empty, but on most systems the operations will not succeed.
`
    },
    {
        name: "(delete-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s147"),
        description: `**procedure**: \`(delete-file \`*path*\`)\`
**procedure**: \`(delete-file \`*path*\` \`*error?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*path* must be a string. \`delete-file\` removes the file named by *path*. If the optional *error?* argument is \`#f\` (the default), \`delete-file\` returns a boolean value: \`#t\` if the operation is successful and \`#f\` if it is not. Otherwise, \`delete-file\` returns an unspecified value if the operation is successful and raises an exception with condition type \`&i/o-filename\` if it is not.

The Revised Report \`delete-file\` does not accept the optional *error?* argument but behaves as if *error?* is true.
`
    },
    {
        name: "(delete-file ",
        endParen: true,
        params: ["path", "error?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s147"),
        description: `**procedure**: \`(delete-file \`*path*\`)\`
**procedure**: \`(delete-file \`*path*\` \`*error?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*path* must be a string. \`delete-file\` removes the file named by *path*. If the optional *error?* argument is \`#f\` (the default), \`delete-file\` returns a boolean value: \`#t\` if the operation is successful and \`#f\` if it is not. Otherwise, \`delete-file\` returns an unspecified value if the operation is successful and raises an exception with condition type \`&i/o-filename\` if it is not.

The Revised Report \`delete-file\` does not accept the optional *error?* argument but behaves as if *error?* is true.
`
    },
    {
        name: "(delete-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s90"),
        description: `**procedure**: \`(delete-file \`*path*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs files)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. \`delete-file\` removes the file named by *path* if it exists and can be deleted, otherwise it raises an exception with condition type \`&i/o-filename\`. Whether \`delete-file\` follows symbolic links is unspecified.
`
    },
    {
        name: "(denominator ",
        endParen: true,
        params: ["rat"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s119"),
        description: `**procedure**: \`(denominator \`*rat*\`)\`
**returns: **the denominator of *rat*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *rat* is an integer, including zero, the denominator is one.

\`(denominator 9) \`=>\` 1\`
\` (denominator 9.0) \`=>\` 1.0\`
\` (denominator 0) \`=>\` 1\`
\` (denominator 0.0) \`=>\` 1.0\`
\` (denominator 2/3) \`=>\` 3\`
\` (denominator -9/4) \`=>\` 4\`
\` (denominator -2.25) \`=>\` 4.0\`
`
    },
    {
        name: "(directory-list ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s140"),
        description: `**procedure**: \`(directory-list \`*path*\`)\`
**returns: **a list of file names
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is a list of strings representing the names of files found in the directory named by *path*. \`directory-list\` raises an exception with condition type \`&i/o-filename\` if *path* does not name a directory or if the process cannot list the directory.
`
    },
    {
        name: "(directory-separator)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s153"),
        description: `**procedure**: \`(directory-separator)\`
**returns: **the preferred directory separator
**libraries: **\`(chezscheme)\`

The preferred directory separator is \`#\\\\\` for Windows and \`#\\/\` for other systems.
`
    },
    {
        name: "(directory-separator? ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s152"),
        description: `**procedure**: \`(directory-separator? \`*char*\`)\`
**returns: **\`#t\` if *char* is a directory separator, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The character \`#\\/\` is a directory separator on all current machine types, and \`#\\\\\` is a directory separator under Windows.
`
    },
    {
        name: "(disable-interrupts)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s26"),
        description: `**procedure**: \`(disable-interrupts)\`
**procedure**: \`(enable-interrupts)\`
**returns: **disable count
**libraries: **\`(chezscheme)\`

\`disable-interrupts\` disables the handling of interrupts, including timer, keyboard, and collect request interrupts. \`enable-interrupts\` re-enables these interrupts. The system maintains a disable count that starts at zero; when zero, interrupts are enabled. Each call to \`disable-interrupts\` increments the count, effectively disabling interrupts. Each call to \`enable-interrupts\` decrements the count, if not already zero, effectively enabling interrupts. For example, two calls to \`disable-interrupts\` followed by one call to \`enable-interrupts\` leaves interrupts disabled. Calls to \`enable-interrupts\` when the count is already zero (and interrupts are enabled) have no effect. The value returned by either procedure is the number of calls to \`enable-interrupts\` required to enable interrupts.

Great care should be exercised when using these procedures, since disabling interrupts inhibits the normal processing of keyboard interrupts, timer interrupts, and, perhaps most importantly, collect request interrupts. Since garbage collection does not happen automatically when interrupts are disabled, it is possible for the storage allocator to run out of space unnecessarily should interrupts be disabled for a long period of time.

The \`with-interrupts-disabled\` syntactic form should be used instead of these more primitive procedures whenever possible, since \`with-interrupts-disabled\` ensures that interrupts are re-enabled whenever a nonlocal exit occurs, such as when an exception is handled by the default exception handler.
`
    },
    {
        name: "(display ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s85"),
        description: `**procedure**: \`(display \`*obj*\`)\`
**procedure**: \`(display \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port.

\`display\` is similar to \`write\` or \`put-datum\` but prints strings and characters found within *obj* directly. Strings are printed without quotation marks or escapes for special characters, as if by \`put-string\`, and characters are printed without the \`#\\\` notation, as if by \`put-char\`. With \`display\`, the three-element list \`(a b c)\` and the two-element list \`("a b" c)\` both print as \`(a b c)\`. Because of this, \`display\` should not be used to print objects that are intended to be read with \`read\`. \`display\` is useful primarily for printing messages, with *obj* most often being a string. See Section  for an implementation of \`put-datum\`, \`write\`, and \`display\`.
`
    },
    {
        name: "(display ",
        endParen: true,
        params: ["obj", "textual-output-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s85"),
        description: `**procedure**: \`(display \`*obj*\`)\`
**procedure**: \`(display \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port.

\`display\` is similar to \`write\` or \`put-datum\` but prints strings and characters found within *obj* directly. Strings are printed without quotation marks or escapes for special characters, as if by \`put-string\`, and characters are printed without the \`#\\\` notation, as if by \`put-char\`. With \`display\`, the three-element list \`(a b c)\` and the two-element list \`("a b" c)\` both print as \`(a b c)\`. Because of this, \`display\` should not be used to print objects that are intended to be read with \`read\`. \`display\` is useful primarily for printing messages, with *obj* most often being a string. See Section  for an implementation of \`put-datum\`, \`write\`, and \`display\`.
`
    },
    {
        name: "(display-condition ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s7"),
        description: `**procedure**: \`(display-condition \`*obj*\`)\`
**procedure**: \`(display-condition \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *textual-output-port* is not supplied, it defaults to the current output port. This procedure displays a message to the effect that an exception has occurred with value *obj*. If *obj* is a condition (Chapter  of ), it displays information encapsulated within the condition, handling messages, *who* conditions, irritants, source information, etc., as appropriate.
`
    },
    {
        name: "(display-condition ",
        endParen: true,
        params: ["obj", "textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s7"),
        description: `**procedure**: \`(display-condition \`*obj*\`)\`
**procedure**: \`(display-condition \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *textual-output-port* is not supplied, it defaults to the current output port. This procedure displays a message to the effect that an exception has occurred with value *obj*. If *obj* is a condition (Chapter  of ), it displays information encapsulated within the condition, handling messages, *who* conditions, irritants, source information, etc., as appropriate.
`
    },
    {
        name: "(display-statistics)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s220"),
        description: `**procedure**: \`(display-statistics)\`
**procedure**: \`(display-statistics \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure displays a running total of the amount of cpu time, real time, bytes allocated, and collection overhead. If *textual-output-port* is not supplied, it defaults to the current output port.
`
    },
    {
        name: "(display-statistics ",
        endParen: true,
        params: ["textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s220"),
        description: `**procedure**: \`(display-statistics)\`
**procedure**: \`(display-statistics \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure displays a running total of the amount of cpu time, real time, bytes allocated, and collection overhead. If *textual-output-port* is not supplied, it defaults to the current output port.
`
    },
    {
        name: "(display-string ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s85"),
        description: `**procedure**: \`(display-string \`*string*\`)\`
**procedure**: \`(display-string \`*string*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`display-string\` writes the characters contained within *string* to *textual-output-port* or to the current-output port if \`textual-output-port\` is not specified. The enclosing string quotes are not printed, and special characters within the string are not escaped. \`display-string\` is a more efficient alternative to \`display\` for displaying strings.
`
    },
    {
        name: "(display-string ",
        endParen: true,
        params: ["string", "textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s85"),
        description: `**procedure**: \`(display-string \`*string*\`)\`
**procedure**: \`(display-string \`*string*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`display-string\` writes the characters contained within *string* to *textual-output-port* or to the current-output port if \`textual-output-port\` is not specified. The enclosing string quotes are not printed, and special characters within the string are not escaped. \`display-string\` is a more efficient alternative to \`display\` for displaying strings.
`
    },
    {
        name: "(div ",
        endParen: true,
        params: ["x1", "x2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s99"),
        description: `**procedure**: \`(div \`*x1*\` \`*x2*\`)\`
**procedure**: \`(mod \`*x1*\` \`*x2*\`)\`
**procedure**: \`(div-and-mod \`*x1*\` \`*x2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *x1* and *x2* are exact, *x2* must not be zero. These procedures implement number-theoretic integer division, with the \`div\` operation being related to \`quotient\` and the \`mod\` operation being related to \`remainder\` or \`modulo\`, but in both cases extended to handle real numbers.

The value *nd* of \`(div \`*x1*\` \`*x2*\`)\` is an integer, and the value *xm* of \`(mod \`*x1*\` \`*x2*\`)\` is a real number such that = · + and 0 ≤ < ||. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, \`div\` and \`mod\` return an unspecified number or raise an exception with condition type \`&implementation-restriction\`.

The \`div-and-mod\` procedure behaves as if defined as follows.

\`(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))\`

That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling \`div\` on the two arguments and the result of calling \`mod\` on the two arguments.

\`(div 17 3) \`=>\` 5\`
\` (mod 17 3) \`=>\` 2\`
\` (div -17 3) \`=>\` -6\`
\` (mod -17 3) \`=>\` 1\`
\` (div 17 -3) \`=>\` -5\`
\` (mod 17 -3) \`=>\` 2\`
\` (div -17 -3) \`=>\` 6\`
\` (mod -17 -3) \`=>\` 1 \`
\` \`
\` (div-and-mod 17.5 3) \`=>\` 5.0\`
\`                      \`\` 2.5\`
`
    },
    {
        name: "(div-and-mod ",
        endParen: true,
        params: ["x1", "x2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s99"),
        description: `**procedure**: \`(div \`*x1*\` \`*x2*\`)\`
**procedure**: \`(mod \`*x1*\` \`*x2*\`)\`
**procedure**: \`(div-and-mod \`*x1*\` \`*x2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *x1* and *x2* are exact, *x2* must not be zero. These procedures implement number-theoretic integer division, with the \`div\` operation being related to \`quotient\` and the \`mod\` operation being related to \`remainder\` or \`modulo\`, but in both cases extended to handle real numbers.

The value *nd* of \`(div \`*x1*\` \`*x2*\`)\` is an integer, and the value *xm* of \`(mod \`*x1*\` \`*x2*\`)\` is a real number such that = · + and 0 ≤ < ||. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, \`div\` and \`mod\` return an unspecified number or raise an exception with condition type \`&implementation-restriction\`.

The \`div-and-mod\` procedure behaves as if defined as follows.

\`(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))\`

That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling \`div\` on the two arguments and the result of calling \`mod\` on the two arguments.

\`(div 17 3) \`=>\` 5\`
\` (mod 17 3) \`=>\` 2\`
\` (div -17 3) \`=>\` -6\`
\` (mod -17 3) \`=>\` 1\`
\` (div 17 -3) \`=>\` -5\`
\` (mod 17 -3) \`=>\` 2\`
\` (div -17 -3) \`=>\` 6\`
\` (mod -17 -3) \`=>\` 1 \`
\` \`
\` (div-and-mod 17.5 3) \`=>\` 5.0\`
\`                      \`\` 2.5\`
`
    },
    {
        name: "(div0 ",
        endParen: true,
        params: ["x1", "x2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s100"),
        description: `**procedure**: \`(div0 \`*x1*\` \`*x2*\`)\`
**procedure**: \`(mod0 \`*x1*\` \`*x2*\`)\`
**procedure**: \`(div0-and-mod0 \`*x1*\` \`*x2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *x1* and *x2* are exact, *x2* must not be zero. These procedures are similar to \`div\`, \`mod\`, and \`div-and-mod\`, but constrain the "mod" value differently, which also affects the "div" value. The value *nd* of \`(div0 \`*x1*\` \`*x2*\`)\` is an integer, and the value *xm* of \`(mod0 \`*x1*\` \`*x2*\`)\` is a real number such that = · + and -|/2| ≤ < |/2|. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, \`div0\` and \`mod0\` return an unspecified number or raise an exception with condition type \`&implementation-restriction\`.

The \`div0-and-mod0\` procedure behaves as if defined as follows.

\`(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))\`

That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling \`div0\` on the two arguments and the result of calling \`mod0\` on the two arguments.

\`(div0 17 3) \`=>\` 6\`
\` (mod0 17 3) \`=>\` -1\`
\` (div0 -17 3) \`=>\` -6\`
\` (mod0 -17 3) \`=>\` 1\`
\` (div0 17 -3) \`=>\` -6\`
\` (mod0 17 -3) \`=>\` -1\`
\` (div0 -17 -3) \`=>\` 6\`
\` (mod0 -17 -3) \`=>\` 1 \`
\` \`
\` (div0-and-mod0 17.5 3) \`=>\` 6.0\`
\`                        \`\` -0.5\`
`
    },
    {
        name: "(div0-and-mod0 ",
        endParen: true,
        params: ["x1", "x2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s100"),
        description: `**procedure**: \`(div0 \`*x1*\` \`*x2*\`)\`
**procedure**: \`(mod0 \`*x1*\` \`*x2*\`)\`
**procedure**: \`(div0-and-mod0 \`*x1*\` \`*x2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *x1* and *x2* are exact, *x2* must not be zero. These procedures are similar to \`div\`, \`mod\`, and \`div-and-mod\`, but constrain the "mod" value differently, which also affects the "div" value. The value *nd* of \`(div0 \`*x1*\` \`*x2*\`)\` is an integer, and the value *xm* of \`(mod0 \`*x1*\` \`*x2*\`)\` is a real number such that = · + and -|/2| ≤ < |/2|. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, \`div0\` and \`mod0\` return an unspecified number or raise an exception with condition type \`&implementation-restriction\`.

The \`div0-and-mod0\` procedure behaves as if defined as follows.

\`(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))\`

That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling \`div0\` on the two arguments and the result of calling \`mod0\` on the two arguments.

\`(div0 17 3) \`=>\` 6\`
\` (mod0 17 3) \`=>\` -1\`
\` (div0 -17 3) \`=>\` -6\`
\` (mod0 -17 3) \`=>\` 1\`
\` (div0 17 -3) \`=>\` -6\`
\` (mod0 17 -3) \`=>\` -1\`
\` (div0 -17 -3) \`=>\` 6\`
\` (mod0 -17 -3) \`=>\` 1 \`
\` \`
\` (div0-and-mod0 17.5 3) \`=>\` 6.0\`
\`                        \`\` -0.5\`
`
    },
    {
        name: "(do ((",
        endParen: true,
        params: ["var", "init", "update", "test", "result", "expr", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s25"),
        description: `**syntax**: \`(do ((\`*var*\` \`*init*\` \`*update*\`) ...) (\`*test*\` \`*result*\` ...) \`*expr*\` ...)\`
**returns: **the values of the last *result* expression
**libraries: **\`(rnrs control)\`, \`(rnrs)\`
`
    },
    {
        name: "drop-prefix",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s22"),
        description: `**syntax**: \`only\`
**syntax**: \`except\`
**syntax**: \`add-prefix\`
**syntax**: \`drop-prefix\`
**syntax**: \`rename\`
**syntax**: \`alias\`
**libraries: **\`(chezscheme)\`

These identifiers are auxiliary keywords for \`import\` and \`import-only\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(dynamic-wind ",
        endParen: true,
        params: ["in", "body", "out"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s11"),
        description: `**procedure**: \`(dynamic-wind \`*in*\` \`*body*\` \`*out*\`)\`
**procedure**: \`(dynamic-wind \`*critical?*\` \`*in*\` \`*body*\` \`*out*\`)\`
**returns: **values resulting from the application of *body*
**libraries: **\`(chezscheme)\`

The first form is identical to the Revised Report \`dynamic-wind\`. When the optional *critical?* argument is present and non-false, the *in* thunk is invoked in a critical section along with the code that records that the body has been entered, and the *out* thunk is invoked in a critical section along with the code that records that the body has been exited. Extreme caution must be taken with this form of \`dynamic-wind\`, since an error or long-running computation can leave interrupts and automatic garbage collection disabled.
`
    },
    {
        name: "(dynamic-wind ",
        endParen: true,
        params: ["critical?", "in", "body", "out"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s11"),
        description: `**procedure**: \`(dynamic-wind \`*in*\` \`*body*\` \`*out*\`)\`
**procedure**: \`(dynamic-wind \`*critical?*\` \`*in*\` \`*body*\` \`*out*\`)\`
**returns: **values resulting from the application of *body*
**libraries: **\`(chezscheme)\`

The first form is identical to the Revised Report \`dynamic-wind\`. When the optional *critical?* argument is present and non-false, the *in* thunk is invoked in a critical section along with the code that records that the body has been entered, and the *out* thunk is invoked in a critical section along with the code that records that the body has been exited. Extreme caution must be taken with this form of \`dynamic-wind\`, since an error or long-running computation can leave interrupts and automatic garbage collection disabled.
`
    },
    {
        name: "(dynamic-wind ",
        endParen: true,
        params: ["in", "body", "out"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s56"),
        description: `**procedure**: \`(dynamic-wind \`*in*\` \`*body*\` \`*out*\`)\`
**returns: **values resulting from the application of *body*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "ee-auto-indent",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s1"),
        description: `**global parameter**: \`ee-auto-indent\`

The value of \`ee-auto-indent\` is a boolean value that determines whether the expression editor indents expressions as they are entered. Its default value is \`#t\`.
`
    },
    {
        name: "ee-auto-paren-balance",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s3"),
        description: `**global parameter**: \`ee-auto-paren-balance\`

The value of \`ee-auto-paren-balance\` is a boolean value that determines whether the expression editor automatically corrects a close parenthesis or bracket, when typed, to match the corresponding open parenthesis or bracket, if any. Its default value is \`#t\`.
`
    },
    {
        name: "(ee-bind-key ",
        endParen: true,
        params: ["key", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s10"),
        description: `**procedure**: \`(ee-bind-key \`*key*\` \`*procedure*\`)\`

**returns: **unspecified

The \`ee-bind-key\` procedure is used to add to or change the set of key bindings recognized by the expression editor.

The *key* must be a character or string; if it is a string, it must have the following form.

where

Note that each double-backslash in the syntax actually denotes just one backslash in the string.

For example, the *key* \`"\\\\eX"\` represents the two-character sequence Escape-x, i.e., the "escape" key followed by the (capital) "X" key. Similarly, they *key* \`"\\\\e^X"\` represents the two-character sequence Escape-Control-x, i.e., the "escape" key followed by Control-X.

Character keys and string keys consisting of a single plain character always represent a single keystroke.
`
    },
    {
        name: "ee-common-identifiers",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s9"),
        description: `**global parameter**: \`ee-common-identifiers\`

The value of \`ee-common-identifiers\` is list of symbols that are considered common enough that they should appear early when one of the incremental identifier-completion editing commands is invoked. Its default value contains a few dozen entries. They are all more than a few characters long (under the theory that users will most likely type short ones out fully) and all would appear later than they likely should when incremental identifier-completion is used.
`
    },
    {
        name: "(ee-compose ",
        endParen: true,
        params: ["ecmd", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s78"),
        description: `**procedure**: \`(ee-compose \`*ecmd*\` ...)\`

**returns: **a new editing command

Each *ecmd* must be an editing command.

The new editing command runs each of the editing commands *ecmd*\` ...\` in sequence.

For example, the following expression binds \`^X\`-p to an editing command that behaves like \`ee-history-bwd-prefix\` but leaves the cursor at the end of the expression rather than at the end of the first line, causing the entire entry to be displayed.

\`(let ()\`
\`   (import expression-editor)\`
\`   (ee-bind-key "^Xp"\`
\`     (ee-compose ee-history-bwd ee-end-of-entry)))\`

A command such as \`ee-id-completion\` that performs a different action when run twice in succession will not recognize that it has been run twice in succession if run as part of a composite command.

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "ee-default-repeat",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s6"),
        description: `**global parameter**: \`ee-default-repeat\`

The value of \`ee-default-repeat\` is a nonnegative fixnum value that determines the number of times the next command is repeated after the \`ee-command-repeat\` editing command (bound to \`Esc-^U\` by default) is used and followed by a sequence of digits. It's default value is \`4\`.
`
    },
    {
        name: "ee-flash-parens",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s4"),
        description: `**global parameter**: \`ee-flash-parens\`

The value of \`ee-flash-parens\` is a boolean value that determines whether the expression editor briefly moves the cursor when an open or close parenthesis or bracket is typed to the matching close or open parenthesis or bracket (if any). Its default value is \`#t\`.
`
    },
    {
        name: "ee-history-limit",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s8"),
        description: `**global parameter**: \`ee-history-limit\`

The value of \`ee-history-limit\` is a nonnegative fixnum value that determines the number of history entries retained by the expression editor during and across sessions. Only the last \`(ee-history-limit)\` entries are retained.
`
    },
    {
        name: "ee-noisy",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s7"),
        description: `**global parameter**: \`ee-noisy\`

The value of \`ee-noisy\` is a boolean value that determines whether the expression editor emits a beep (bell) when an error occurs, such as an attempt to find the matching delimiter for a non-delimiter character. Its default value is \`#f\`.
`
    },
    {
        name: "ee-paren-flash-delay",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s5"),
        description: `**global parameter**: \`ee-paren-flash-delay\`

The value of \`ee-paren-flash-delay\` is a nonnegative fixnum value that determines the amount of time (in milliseconds) that the expression editor pauses when the cursor is moved to the matching parenthesis or bracket, if any, when a parenthesis or bracket is entered. The value is ignored if the \`ee-flash-parens\` is false. Its default value is \`100\`.
`
    },
    {
        name: "ee-standard-indent",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s2"),
        description: `**global parameter**: \`ee-standard-indent\`

The value of \`ee-standard-indent\` is a nonnegative fixnum value that determines the amount (in single spaces) by which each expression is indented relative to the enclosing expression, if not aligned otherwise by one of the indenter's other heuristics, when \`ee-auto-indent\` is true or when one of the indentation commands is invoked explicitly. It's default value is \`2\`.
`
    },
    {
        name: "(ee-string-macro ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s77"),
        description: `**procedure**: \`(ee-string-macro \`*string*\`)\`

**returns: **a new editing command

The new editing command produced inserts *string* before the current cursor position.

Two string macros are predefined:
`
    },
    {
        name: "else",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s16"),
        description: `**syntax**: \`else\`
**syntax**: \`=>\`
**libraries: **\`(rnrs base)\`, \`(rnrs exceptions)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`cond\`. Both also serve as auxiliary keywords for \`guard\`, and \`else\` also serves as an auxiliary keyword for \`case\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "enable-cross-library-optimization",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s116"),
        description: `**thread parameter**: \`enable-cross-library-optimization\`
**libraries: **\`(chezscheme)\`

This parameter controls whether information is included with the object code for a compiled library to enable propagation of constants and inlining of procedures defined in the library into dependent libraries. When set to \`#t\` (the default), this information is included; when set to \`#f\`, the information is not included. Setting the parameter to \`#f\` potentially reduces the sizes of the resulting object files and the exposure of near-source information via the object file.
`
    },
    {
        name: "(enable-interrupts)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s26"),
        description: `**procedure**: \`(disable-interrupts)\`
**procedure**: \`(enable-interrupts)\`
**returns: **disable count
**libraries: **\`(chezscheme)\`

\`disable-interrupts\` disables the handling of interrupts, including timer, keyboard, and collect request interrupts. \`enable-interrupts\` re-enables these interrupts. The system maintains a disable count that starts at zero; when zero, interrupts are enabled. Each call to \`disable-interrupts\` increments the count, effectively disabling interrupts. Each call to \`enable-interrupts\` decrements the count, if not already zero, effectively enabling interrupts. For example, two calls to \`disable-interrupts\` followed by one call to \`enable-interrupts\` leaves interrupts disabled. Calls to \`enable-interrupts\` when the count is already zero (and interrupts are enabled) have no effect. The value returned by either procedure is the number of calls to \`enable-interrupts\` required to enable interrupts.

Great care should be exercised when using these procedures, since disabling interrupts inhibits the normal processing of keyboard interrupts, timer interrupts, and, perhaps most importantly, collect request interrupts. Since garbage collection does not happen automatically when interrupts are disabled, it is possible for the storage allocator to run out of space unnecessarily should interrupts be disabled for a long period of time.

The \`with-interrupts-disabled\` syntactic form should be used instead of these more primitive procedures whenever possible, since \`with-interrupts-disabled\` ensures that interrupts are re-enabled whenever a nonlocal exit occurs, such as when an exception is handled by the default exception handler.
`
    },
    {
        name: "enable-object-counts",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s237"),
        description: `**global parameter**: \`enable-object-counts\`
**libraries: **\`(chezscheme)\`

The value of \`enable-object-counts\` is a boolean value that determines whether the collector records object counts as it runs and hence whether the object counts returned by the procedure \`object-counts\` are accurate. The parameter is set to \`#f\` by default, since enabling object counts adds overhead to collection.

Counts for the static generation are always correct. Counts for a nonstatic generation are correct immediately after a collection of generation ≥ (regardless of whether the target generation is or + 1) if \`enable-object-counts\` was set to \`#t\` during the collection.

One strategy for collecting object counts with minimal overhead is to enable object counts only while collecting the maximum nonstatic generation and to obtain the object counts immediately after that collection.
`
    },
    {
        name: "(endianness ",
        endParen: true,
        params: ["symbol"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s240"),
        description: `**syntax**: \`(endianness \`*symbol*\`)\`
**returns: ***symbol*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*symbol* must be the symbol \`little\`, the symbol \`big\`, or some other symbol recognized by the implementation as an endianness symbol. It is a syntax violation if *symbol* is not a symbol or if it is not recognized by the implementation as an endianness symbol.

\`(endianness little) \`=>\` little\`
\` (endianness big) \`=>\` big\`
\` (endianness "spam") \`=>\` \`*exception*
`
    },
    {
        name: "(engine-block)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s27"),
        description: `**procedure**: \`(engine-block)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

This causes a running engine to stop, create a new engine capable of continuing the computation, and pass the new engine to the original engine's third argument (the expire procedure). Any remaining fuel is forfeited.

\`(define eng\`
\`   (make-engine\`
\`     (lambda ()\`
\`       (engine-block)\`
\`       "completed"))) \`
\` \`
\` (eng 100\`
\`      (lambda (ticks value) value)\`
\`      (lambda (x)\`
\`         (set! eng x)\`
\`         "expired")) \`=>\` "expired" \`
\` \`
\` (eng 100\`
\`      (lambda (ticks value) value)\`
\`      (lambda (x)\`
\`         (set! eng x)\`
\`         "expired")) \`=>\` "completed"\`
`
    },
    {
        name: "(engine-return ",
        endParen: true,
        params: ["obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s28"),
        description: `**procedure**: \`(engine-return \`*obj*\` ...)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

This causes a running engine to stop and pass control to the engine's *complete* argument. The first argument passed to the complete procedure is the amount of fuel remaining, as usual, and the remaining arguments are the objects *obj*\` ...\` passed to \`engine-return\`.

\`(define eng\`
\`   (make-engine\`
\`     (lambda ()\`
\`       (reverse (engine-return 'a 'b 'c))))) \`
\` \`
\` (eng 100\`
\`      (lambda (ticks . values) values)\`
\`      (lambda (new-eng) "expired")) \`=>\` (a b c)\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(enum-set->list ",
        endParen: true,
        params: ["enum-set"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s294"),
        description: `**procedure**: \`(enum-set->list \`*enum-set*\`)\`
**returns: **a list of the elements of *enum-set*
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

The symbols in the resulting list appear in the order given to them when the enumeration type of \`enum-set\` was created.

\`(define e1 (make-enumeration '(a b c a b c d)))\`
\` (enum-set->list e1) \`=>\` (a b c d)\`
\` (define e2 ((enum-set-constructor e1) '(d c a b)))\`
\` (enum-set->list e2) \`=>\` (a b c d)\`
`
    },
    {
        name: "(enum-set-complement ",
        endParen: true,
        params: ["enum-set"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s299"),
        description: `**procedure**: \`(enum-set-complement \`*enum-set*\`)\`
**returns: **the complement of *enum-set* relative to its universe
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

\` (define e1 (make-enumeration '(a b c d)))\`
\` (enum-set->list (enum-set-complement e1)) \`=>\` ()\`
\` (define e2 ((enum-set-constructor e1) '(a c)))\`
\` (enum-set->list (enum-set-complement e2)) \`=>\` (b d)\`
`
    },
    {
        name: "(enum-set-constructor ",
        endParen: true,
        params: ["enum-set"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s292"),
        description: `**procedure**: \`(enum-set-constructor \`*enum-set*\`)\`
**returns: **an enumeration-set construction procedure
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

This procedure returns a procedure *p* that may be used to create subsets of the universe of *enum-set*. *p* must be passed a list of symbols, and each element of the list must be an element of the universe of *enum-set*. The enumeration set returned by *p* contains all and only the symbols in the list it is passed. The value returned by *p* may contain elements not in *enum-set* if the universe of *enum-set* contains those elements.

\`(define e1 (make-enumeration '(one two three four)))\`
\` (define p1 (enum-set-constructor e1))\`
\` (define e2 (p1 '(one three)))\`
\` (enum-set->list e2) \`=>\` (one three)\`
\` (define p2 (enum-set-constructor e2))\`
\` (define e3 (p2 '(one two four)))\`
\` (enum-set->list e3) \`=>\` (one two four)\`
`
    },
    {
        name: "(enum-set-difference ",
        endParen: true,
        params: ["enum-set1", "enum-set2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s298"),
        description: `**procedure**: \`(enum-set-union \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the union of *enum-set1* and *enum-set2*
**procedure**: \`(enum-set-intersection \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the intersection of *enum-set1* and *enum-set2*
**procedure**: \`(enum-set-difference \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the difference of *enum-set1* and *enum-set2*
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

*enum-set1* and *enum-set2* must have the same enumeration type. Each procedure returns a new enumeration set representing the union, intersection, or difference of the two sets.

\`(define e1 (make-enumeration '(a b c d)))\`
\` (define e2 ((enum-set-constructor e1) '(a c)))\`
\` (define e3 ((enum-set-constructor e1) '(b c)))\`
\` (enum-set->list (enum-set-union e2 e3)) \`=>\` (a b c)\`
\` (enum-set->list (enum-set-intersection e2 e3)) \`=>\` (c)\`
\` (enum-set->list (enum-set-difference e2 e3)) \`=>\` (a)\`
\` (enum-set->list (enum-set-difference e3 e2)) \`=>\` (b)\`
\` (define e4 (make-enumeration '(b d c a)))\`
\` (enum-set-union e1 e4) \`=>\` \`*exception: different enumeration types*
`
    },
    {
        name: "(enum-set-indexer ",
        endParen: true,
        params: ["enum-set"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s301"),
        description: `**procedure**: \`(enum-set-indexer \`*enum-set*\`)\`
**returns: **a procedure that returns the index of a symbol in the universe of *enum-set*
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

\`enum-set-indexer\` returns a procedure *p* that, when applied to a symbol in the universe of *enum-set*, returns the index of the symbol (zero-based) in the ordered set of symbols that form the universe. If applied to a symbol not in the universe, *p* returns \`#f\`.

\`(define e1 (make-enumeration '(a b c d)))\`
\` (define e2 ((enum-set-constructor e1) '(a d)))\`
\` (define p (enum-set-indexer e2))\`
\` (list (p 'a) (p 'c) (p 'e)) \`=>\` (0 2 #f)\`

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(enum-set-intersection ",
        endParen: true,
        params: ["enum-set1", "enum-set2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s298"),
        description: `**procedure**: \`(enum-set-union \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the union of *enum-set1* and *enum-set2*
**procedure**: \`(enum-set-intersection \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the intersection of *enum-set1* and *enum-set2*
**procedure**: \`(enum-set-difference \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the difference of *enum-set1* and *enum-set2*
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

*enum-set1* and *enum-set2* must have the same enumeration type. Each procedure returns a new enumeration set representing the union, intersection, or difference of the two sets.

\`(define e1 (make-enumeration '(a b c d)))\`
\` (define e2 ((enum-set-constructor e1) '(a c)))\`
\` (define e3 ((enum-set-constructor e1) '(b c)))\`
\` (enum-set->list (enum-set-union e2 e3)) \`=>\` (a b c)\`
\` (enum-set->list (enum-set-intersection e2 e3)) \`=>\` (c)\`
\` (enum-set->list (enum-set-difference e2 e3)) \`=>\` (a)\`
\` (enum-set->list (enum-set-difference e3 e2)) \`=>\` (b)\`
\` (define e4 (make-enumeration '(b d c a)))\`
\` (enum-set-union e1 e4) \`=>\` \`*exception: different enumeration types*
`
    },
    {
        name: "(enum-set-member? ",
        endParen: true,
        params: ["symbol", "enum-set"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s297"),
        description: `**procedure**: \`(enum-set-member? \`*symbol*\` \`*enum-set*\`)\`
**returns: **\`#t\` if symbol is an element of *enum-set*, \`#f\` otherwise
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

\` (define e1 (make-enumeration '(a b c d e)))\`
\` (define e2 ((enum-set-constructor e1) '(d b)))\`
\` (enum-set-member? 'c e1) \`=>\` #t\`
\` (enum-set-member? 'c e2) \`=>\` #f\`
`
    },
    {
        name: "(enum-set-projection ",
        endParen: true,
        params: ["enum-set1", "enum-set2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s300"),
        description: `**procedure**: \`(enum-set-projection \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the projection of *enum-set1* into the universe of *enum-set2*
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

Any elements of *enum-set1* not in the universe of *enum-set2* are dropped. The result is of the same enumeration type as *enum-set2*.

\`(define e1 (make-enumeration '(a b c d)))\`
\` (define e2 (make-enumeration '(a b c d e f g)))\`
\` (define e3 ((enum-set-constructor e1) '(a d)))\`
\` (define e4 ((enum-set-constructor e2) '(a c e g)))\`
\` (enum-set->list (enum-set-projection e4 e3)) \`=>\` (a c)\`
\` (enum-set->list\`
\`   (enum-set-union e3\`
\`     (enum-set-projection e4 e3))) \`=>\` (a c d)\`
`
    },
    {
        name: "(enum-set-subset? ",
        endParen: true,
        params: ["enum-set1", "enum-set2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s295"),
        description: `**procedure**: \`(enum-set-subset? \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **\`#t\` if *enum-set1* is a subset of *enum-set2*, \`#f\` otherwise
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

An enumeration set *enum-set1* is a subset of an enumeration set *enum-set2* if and only if the universe of *enum-set1* is a subset of the universe of *enum-set2* and each element of *enum-set1* is an element of *enum-set2*.

\`(define e1 (make-enumeration '(a b c)))\`
\` (define e2 (make-enumeration '(a b c d e)))\`
\` (enum-set-subset? e1 e2) \`=>\` #t\`
\` (enum-set-subset? e2 e1) \`=>\` #f\`
\` (define e3 ((enum-set-constructor e2) '(a c)))\`
\` (enum-set-subset? e3 e1) \`=>\` #f\`
\` (enum-set-subset? e3 e2) \`=>\` #t\`
`
    },
    {
        name: "(enum-set-union ",
        endParen: true,
        params: ["enum-set1", "enum-set2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s298"),
        description: `**procedure**: \`(enum-set-union \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the union of *enum-set1* and *enum-set2*
**procedure**: \`(enum-set-intersection \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the intersection of *enum-set1* and *enum-set2*
**procedure**: \`(enum-set-difference \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **the difference of *enum-set1* and *enum-set2*
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

*enum-set1* and *enum-set2* must have the same enumeration type. Each procedure returns a new enumeration set representing the union, intersection, or difference of the two sets.

\`(define e1 (make-enumeration '(a b c d)))\`
\` (define e2 ((enum-set-constructor e1) '(a c)))\`
\` (define e3 ((enum-set-constructor e1) '(b c)))\`
\` (enum-set->list (enum-set-union e2 e3)) \`=>\` (a b c)\`
\` (enum-set->list (enum-set-intersection e2 e3)) \`=>\` (c)\`
\` (enum-set->list (enum-set-difference e2 e3)) \`=>\` (a)\`
\` (enum-set->list (enum-set-difference e3 e2)) \`=>\` (b)\`
\` (define e4 (make-enumeration '(b d c a)))\`
\` (enum-set-union e1 e4) \`=>\` \`*exception: different enumeration types*
`
    },
    {
        name: "(enum-set-universe ",
        endParen: true,
        params: ["enum-set"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s293"),
        description: `**procedure**: \`(enum-set-universe \`*enum-set*\`)\`
**returns: **the universe of *enum-set*, as an enumeration set
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

\` (define e1 (make-enumeration '(a b c a b c d)))\`
\` (enum-set->list (enum-set-universe e1)) \`=>\` (a b c d)\`
\` (define e2 ((enum-set-constructor e1) '(c)))\`
\` (enum-set->list (enum-set-universe e2)) \`=>\` (a b c d)\`
`
    },
    {
        name: "(enum-set=? ",
        endParen: true,
        params: ["enum-set1", "enum-set2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s296"),
        description: `**procedure**: \`(enum-set=? \`*enum-set1*\` \`*enum-set2*\`)\`
**returns: **\`#t\` if *enum-set1* and *enum-set2* are equivalent, \`#f\` otherwise
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

Two enumeration sets *enum-set1* and *enum-set2* are equivalent if each is a subset of the other.

\`(define e1 (make-enumeration '(a b c d)))\`
\` (define e2 (make-enumeration '(b d c a)))\`
\` (enum-set=? e1 e2) \`=>\` #t\`
\` (define e3 ((enum-set-constructor e1) '(a c)))\`
\` (define e4 ((enum-set-constructor e2) '(a c)))\`
\` (enum-set=? e3 e4) \`=>\` #t\`
\` (enum-set=? e3 e2) \`=>\` #f\`

\`enum-set=?\` could be defined in terms of \`enum-set-subset?\` as follows.

\`(define enum-set=?\`
\`   (lambda (e1 e2)\`
\`     (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))\`
`
    },
    {
        name: "(enum-set? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s0"),
        description: `**procedure**: \`(enum-set? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an enum set, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

This predicate is not defined by the Revised Report, but should be.
`
    },
    {
        name: "(enumerate ",
        endParen: true,
        params: ["ls"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s9"),
        description: `**procedure**: \`(enumerate \`*ls*\`)\`
**returns: **a list of integers from 0 (inclusive) to the length of *ls* (exclusive)
**libraries: **\`(chezscheme)\`

\`(enumerate '()) \`=>\` ()\`
\` (enumerate '(a b c)) \`=>\` (0 1 2)\`
\` (let ([ls '(a b c)])\`
\`   (map cons ls (enumerate ls))) \`=>\` ((a . 0) (b . 1) (c . 2))\`
`
    },
    {
        name: "(environment ",
        endParen: true,
        params: ["import-spec", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s81"),
        description: `**procedure**: \`(environment \`*import-spec*\` ...)\`
**returns: **an environment
**libraries: **\`(rnrs eval)\`

\`environment\` returns an environment formed from the combined bindings of the given import specifiers. Each *import-spec* must be an s-expression representing a valid import specifier (see Chapter ).

\`(define env (environment '(rnrs) '(prefix (rnrs lists) $)))\`
\` (eval '($cons* 3 4 (* 5 8)) env) \`=>\` (3 4 . 40)\`
`
    },
    {
        name: "(environment-mutable? ",
        endParen: true,
        params: ["env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s30"),
        description: `**procedure**: \`(environment-mutable? \`*env*\`)\`
**returns: **\`#t\` if *env* is mutable, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\`(environment-mutable? (interaction-environment)) \`=>\` #t\`
\` (environment-mutable? (scheme-environment)) \`=>\` #f\`
\` (environment-mutable? (copy-environment (scheme-environment))) \`=>\` #t\`
\` (environment-mutable? (environment '(prefix (rnrs) $rnrs-))) \`=>\` #f\`
`
    },
    {
        name: "(environment-symbols ",
        endParen: true,
        params: ["env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s35"),
        description: `**procedure**: \`(environment-symbols \`*env*\`)\`
**returns: **a list of symbols
**libraries: **\`(chezscheme)\`

This procedure returns a list of symbols representing the identifiers bound in environment *env*. It is primarily useful in building the list of symbols to be copied from one environment to another.

\`(define listless-environment\`
\`   (copy-environment\`
\`     (scheme-environment)\`
\`     #t\`
\`     (remq 'list (environment-symbols (scheme-environment)))))\`
\` (eval '(let ([x (cons 3 4)]) x) listless-environment) \`=>\` (3 . 4)\`
\` (eval '(list 3 4) listless-environment) \`=>\` \`*exception*
`
    },
    {
        name: "(environment? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s29"),
        description: `**procedure**: \`(environment? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an environment, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\`(environment? (interaction-environment)) \`=>\` #t\`
\` (environment? 'interaction-environment) \`=>\` #f\`
\` (environment? (copy-environment (scheme-environment))) \`=>\` #t\`
\` (environment? (environment '(prefix (rnrs) $rnrs-))) \`=>\` #t\`
`
    },
    {
        name: "(eof-object)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s54"),
        description: `**procedure**: \`(eof-object)\`
**returns: **the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`

\`(eof-object? (eof-object)) \`=>\` #t\`
`
    },
    {
        name: "(eof-object? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s53"),
        description: `**procedure**: \`(eof-object? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an eof object, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`

The end-of-file object is returned by input operations, e.g., \`get-datum\`, when an input port has reached the end of input.
`
    },
    {
        name: "(eol-style ",
        endParen: true,
        params: ["symbol"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s23"),
        description: `**syntax**: \`(eol-style \`*symbol*\`)\`
**returns: ***symbol*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*symbol* must be one of the symbols \`lf\`, \`cr\`, \`nel\`, \`ls\`, \`crlf\`, \`crnel\`, or \`none\`. The expression \`(eol-style \`*symbol*\`)\` is equivalent to the expression \`(quote \`*symbol*\`)\` except the former checks at expansion time that *symbol* is one of the eol-style symbols. The \`eol-style\` syntax provides useful documentation as well.

\`(eol-style crlf) \`=>\` crlf\`
\` (eol-style lfcr) \`=>\` \`*syntax violation*
`
    },
    {
        name: "(ephemeron-cons ",
        endParen: true,
        params: ["obj1", "obj2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s26"),
        description: `**procedure**: \`(ephemeron-cons \`*obj1*\` \`*obj2*\`)\`
**returns: **a new ephemeron pair
**libraries: **\`(chezscheme)\`

*obj1* becomes the car and *obj2* becomes the cdr of the new pair. Ephemeron pairs are indistinguishable from ordinary pairs in all but two ways:

An ephemeron pair behaves like a weak pair, but the cdr is treated specially in addition to the car: the cdr of an ephemeron is set to \`#!bwp\` at the same time that the car is set to \`#!bwp\`. Since the car and cdr fields are set to \`#!bwp\` at the same time, then the fact that the car object may be referenced through the cdr object does not by itself imply that car must be preserved (unlike a weak pair); instead, the car must be saved for some reason independent of the cdr object.

Like weak pairs and other pairs, ephemeron pairs may be altered using \`set-car!\` and \`set-cdr!\`, and ephemeron pairs are printed in the same manner as ordinary pairs; there is no reader syntax for ephemeron pairs.

\`(define x (cons 'a 'b))\`
\` (define p (ephemeron-cons x x))\`
\` (car p) \`=>\` (a . b)\`
\` (cdr p) \`=>\` (a . b) \`
\` \`
\` (define x (cons 'a 'b))\`
\` (define p (ephemeron-cons x x))\`
\` (set! x '*)\`
\` (collect)\`
\` (car p) \`=>\` #!bwp\`
\` (cdr p) \`=>\` #!bwp \`
\` \`
\` (define x (cons 'a 'b))\`
\` (define p (weak-cons x x)) ; \`*not an ephemeron pair*
\` (set! x '*)\`
\` (collect)\`
\` (car p) \`=>\` (a . b)\`
\` (cdr p) \`=>\` (a . b)\`

As with weak pairs, the last two expressions of the middle example above may in fact return \`(a . b)\` if a garbage collection promoting the pair into an older generation occurs prior to the assignment of \`x\` to \`*\`. In the last example above, however, the results of the last two expressions will always be \`(a . b)\`, because the cdr of a weak pair holds a non-weak reference, and that non-weak reference prevents the car field from becoming \`#!bwp\`.
`
    },
    {
        name: "(ephemeron-pair? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s27"),
        description: `**procedure**: \`(ephemeron-pair? \`*obj*\`)\`
**returns: **\`#t\` if obj is a ephemeron pair, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(ephemeron-pair? (ephemeron-cons 'a 'b)) \`=>\` #t\`
\` (ephemeron-pair? (cons 'a 'b)) \`=>\` #f\`
\` (ephemeron-pair? (weak-cons 'a 'b)) \`=>\` #f\`
\` (ephemeron-pair? "oops") \`=>\` #f\`
`
    },
    {
        name: "(eq-hashtable-cell ",
        endParen: true,
        params: ["hashtable", "key", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s132"),
        description: `**procedure**: \`(eq-hashtable-cell \`*hashtable*\` \`*key*\` \`*default*\`)\`
**returns: **a pair (see below)
**libraries: **\`(chezscheme)\`

*hashtable* must be an eq hashtable. *key* and *default* may be any Scheme values.

If no value is associated with *key* in *hashtable*, \`eq-hashtable-cell\` modifies *hashtable* to associate *key* with *default*. It returns a pair whose car is *key* and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate *key* with a new value. The *key* should not be changed.

\`(define ht (make-eq-hashtable))\`
\` (define v (vector 'a 'b 'c))\`
\` (define cell (eq-hashtable-cell ht v 3))\`
\` cell \`=>\` (#(a b c) . 3)\`
\` (eq-hashtable-ref ht v 0) \`=>\` 3\`
\` (set-cdr! cell 4)\`
\` (eq-hashtable-ref ht v 0) \`=>\` 4\`
`
    },
    {
        name: "(eq-hashtable-contains? ",
        endParen: true,
        params: ["hashtable", "key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s130"),
        description: `**procedure**: \`(eq-hashtable-contains? \`*hashtable*\` \`*key*\`)\`
**returns: **\`#t\` if an association for *key* exists in *hashtable*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*hashtable* must be an eq hashtable. *key* may be any Scheme value.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (eq-hashtable-set! ht p1 73)\`
\` (eq-hashtable-contains? ht p1) \`=>\` #t\`
\` (eq-hashtable-contains? ht p2) \`=>\` #f\`
`
    },
    {
        name: "(eq-hashtable-delete! ",
        endParen: true,
        params: ["hashtable", "key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s133"),
        description: `**procedure**: \`(eq-hashtable-delete! \`*hashtable*\` \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable eq hashtable. *key* may be any Scheme value.

\`eq-hashtable-delete!\` drops any association for *key* from *hashtable*.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (eq-hashtable-set! ht p1 73)\`
\` (eq-hashtable-contains? ht p1) \`=>\` #t\`
\` (eq-hashtable-delete! ht p1)\`
\` (eq-hashtable-contains? ht p1) \`=>\` #f\`
\` (eq-hashtable-contains? ht p2) \`=>\` #f\`
\` (eq-hashtable-delete! ht p2)\`
`
    },
    {
        name: "(eq-hashtable-ephemeron? ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s127"),
        description: `**procedure**: \`(eq-hashtable-ephemeron? \`*hashtable*\`)\`
**returns: **\`#t\` if *hashtable* uses ephemeron pairs, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*hashtable* must be an eq hashtable.

\`(eq-hashtable-ephemeron? (make-eq-hashtable)) \`=>\` #f\`
\` (eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) \`=>\` #t\`
`
    },
    {
        name: "(eq-hashtable-ref ",
        endParen: true,
        params: ["hashtable", "key", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s129"),
        description: `**procedure**: \`(eq-hashtable-ref \`*hashtable*\` \`*key*\` \`*default*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*hashtable* must be an eq hashtable. *key* and *default* may be any Scheme values.

\`eq-hashtable-ref\` returns the value associated with *key* in *hashtable*. If no value is associated with *key* in *hashtable*, \`eq-hashtable-ref\` returns *default*.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (eq-hashtable-set! ht p1 73)\`
\` (eq-hashtable-ref ht p1 55) \`=>\` 73\`
\` (eq-hashtable-ref ht p2 55) \`=>\` 55\`
`
    },
    {
        name: "(eq-hashtable-set! ",
        endParen: true,
        params: ["hashtable", "key", "value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s128"),
        description: `**procedure**: \`(eq-hashtable-set! \`*hashtable*\` \`*key*\` \`*value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable eq hashtable. *key* and *value* may be any Scheme values.

\`eq-hashtable-set!\` associates the value *value* with the key *key* in *hashtable*.

\`(define ht (make-eq-hashtable))\`
\` (eq-hashtable-set! ht 'a 73)\`
`
    },
    {
        name: "(eq-hashtable-update! ",
        endParen: true,
        params: ["hashtable", "key", "procedure", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s131"),
        description: `**procedure**: \`(eq-hashtable-update! \`*hashtable*\` \`*key*\` \`*procedure*\` \`*default*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable eq hashtable. *key* and *default* may be any Scheme values. *procedure* should accept one argument, should return one value, and should not modify *hashtable*.

\`eq-hashtable-update!\` applies *procedure* to the value associated with *key* in *hashtable*, or to *default* if no value is associated with *key* in *hashtable*. If *procedure* returns, \`eq-hashtable-update!\` associates *key* with the value returned by *procedure*, replacing the old association, if any.

A version of \`eq-hashtable-update!\` that does not verify that it receives arguments of the proper type might be defined as follows.

\`(define eq-hashtable-update!\`
\`   (lambda (ht key proc value)\`
\`     (eq-hashtable-set! ht key\`
\`       (proc (eq-hashtable-ref ht key value)))))\`

An implementation may, however, be able to implement \`eq-hashtable-update!\` more efficiently by avoiding multiple hash computations and hashtable lookups.

\`(define ht (make-eq-hashtable))\`
\` (eq-hashtable-update! ht 'a\`
\`   (lambda (x) (* x 2))\`
\`   55)\`
\` (eq-hashtable-ref ht 'a 0) \`=>\` 110\`
\` (eq-hashtable-update! ht 'a\`
\`   (lambda (x) (* x 2))\`
\`   0)\`
\` (eq-hashtable-ref ht 'a 0) \`=>\` 220\`
`
    },
    {
        name: "(eq-hashtable-weak? ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s126"),
        description: `**procedure**: \`(eq-hashtable-weak? \`*hashtable*\`)\`
**returns: **\`#t\` if *hashtable* is weak, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*hashtable* must be an eq hashtable.

\`(eq-hashtable-weak? (make-eq-hashtable)) \`=>\` #f\`
\` (eq-hashtable-weak? (make-weak-eq-hashtable)) \`=>\` #t\`
`
    },
    {
        name: "(eq-hashtable? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s125"),
        description: `**procedure**: \`(eq-hashtable? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an eq hashtable, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (eq-hashtable? (make-eq-hashtable)) \`=>\` #t\`
\` (eq-hashtable? '(not a hash table)) \`=>\` #f\`
`
    },
    {
        name: "(eq? ",
        endParen: true,
        params: ["obj1", "obj2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s10"),
        description: `**procedure**: \`(eq? \`*obj1*\` \`*obj2*\`)\`
**returns: **\`#t\` if *obj1* and *obj2* are identical, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

In most Scheme systems, two objects are considered identical if they are represented internally by the same pointer value and distinct (not identical) if they are represented internally by different pointer values, although other criteria, such as time-stamping, are possible.
`
    },
    {
        name: "(equal-hash ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s279"),
        description: `**procedure**: \`(equal-hash \`*obj*\`)\`
**procedure**: \`(string-hash \`*string*\`)\`
**procedure**: \`(string-ci-hash \`*string*\`)\`
**procedure**: \`(symbol-hash \`*symbol*\`)\`
**returns: **an exact nonnegative integer hash value
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

These procedures are hash functions suitable for use with the appropriate Scheme predicate: \`equal?\` for \`equal-hash\`, \`string=?\` for \`string-hash\`, \`string-ci=?\` for \`string-ci-hash\`, and \`symbol=?\` (or eq?) for \`symbol-hash\`. The hash values returned by \`equal-hash\`, \`string-hash\`, and \`string-ci-hash\` are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable.
`
    },
    {
        name: "(equal? ",
        endParen: true,
        params: ["obj1", "obj2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s13"),
        description: `**procedure**: \`(equal? \`*obj1*\` \`*obj2*\`)\`
**returns: **\`#t\` if *obj1* and *obj2* have the same structure and contents, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

Two objects are equal if they are equivalent according to \`eqv?\`, strings that are \`string=?\`, bytevectors that are \`bytevector=?\`, pairs whose cars and cdrs are equal, or vectors of the same length whose corresponding elements are equal.

\`equal?\` is required to terminate even for cyclic arguments and return \`#t\` "if and only if the (possibly infinite) unfoldings of its arguments into regular trees are equal as ordered trees" []. In essence, two values are equivalent, in the sense of \`equal?\`, if the structure of the two objects cannot be distinguished by any composition of pair and vector accessors along with the \`eqv?\`, \`string=?\`, and \`bytevector=?\` procedures for comparing data at the leaves.

Implementing \`equal?\` efficiently is tricky [], and even with a good implementation, it is likely to be more expensive than either \`eqv?\` or \`eq?\`.

\`(equal? 'a 3) \`=>\` #f\`
\` (equal? #t 't) \`=>\` #f\`
\` (equal? "abc" 'abc) \`=>\` #f\`
\` (equal? "hi" '(hi)) \`=>\` #f\`
\` (equal? #f '()) \`=>\` #f \`
\` \`
\` (equal? 9/2 7/2) \`=>\` #f\`
\` (equal? 3.4 53344) \`=>\` #f\`
\` (equal? 3 3.0) \`=>\` #f\`
\` (equal? 1/3 #i1/3) \`=>\` #f \`
\` \`
\` (equal? 9/2 9/2) \`=>\` #t\`
\` (equal? 3.4 (+ 3.0 .4)) \`=>\` #t\`
\` (let ([x (* 12345678987654321 2)])\`
\`   (equal? x x)) \`=>\` #t \`
\` \`
\` (equal? #\\a #\\b) \`=>\` #f\`
\` (equal? #\\a #\\a) \`=>\` #t\`
\` (let ([x (string-ref "hi" 0)])\`
\`   (equal? x x)) \`=>\` #t \`
\` \`
\` (equal? #t #t) \`=>\` #t\`
\` (equal? #f #f) \`=>\` #t\`
\` (equal? #t #f) \`=>\` #f\`
\` (equal? (null? '()) #t) \`=>\` #t\`
\` (equal? (null? '(a)) #f) \`=>\` #t \`
\` \`
\` (equal? (cdr '(a)) '()) \`=>\` #t \`
\` \`
\` (equal? 'a 'a) \`=>\` #t\`
\` (equal? 'a 'b) \`=>\` #f\`
\` (equal? 'a (string->symbol "a")) \`=>\` #t \`
\` \`
\` (equal? '(a) '(b)) \`=>\` #f\`
\` (equal? '(a) '(a)) \`=>\` #t\`
\` (let ([x '(a . b)]) (equal? x x)) \`=>\` #t\`
\` (let ([x (cons 'a 'b)])\`
\`   (equal? x x)) \`=>\` #t\`
\` (equal? (cons 'a 'b) (cons 'a 'b)) \`=>\` #t \`
\` \`
\` (equal? "abc" "cba") \`=>\` #f\`
\` (equal? "abc" "abc") \`=>\` #t\`
\` (let ([x "hi"]) (equal? x x)) \`=>\` #t\`
\` (let ([x (string #\\h #\\i)]) (equal? x x)) \`=>\` #t\`
\` (equal? (string #\\h #\\i)\`
\`         (string #\\h #\\i)) \`=>\` #t \`
\` \`
\` (equal? '#vu8(1) '#vu8(1)) \`=>\` #t\`
\` (equal? '#vu8(1) '#vu8(2)) \`=>\` #f\`
\` (let ([x (make-bytevector 10 0)])\`
\`   (equal? x x)) \`=>\` #t\`
\` (let ([x (make-bytevector 10 0)])\`
\`   (equal? x (make-bytevector 10 0))) \`=>\` #t \`
\` \`
\` (equal? '#(a) '#(b)) \`=>\` #f\`
\` (equal? '#(a) '#(a)) \`=>\` #t\`
\` (let ([x '#(a)]) (equal? x x)) \`=>\` #t\`
\` (let ([x (vector 'a)])\`
\`   (equal? x x)) \`=>\` #t\`
\` (equal? (vector 'a) (vector 'a)) \`=>\` #t \`
\` \`
\` (equal? car car) \`=>\` #t\`
\` (equal? car cdr) \`=>\` #f\`
\` (let ([f (lambda (x) x)])\`
\`   (equal? f f)) \`=>\` #t\`
\` (let ([f (lambda () (lambda (x) x))])\`
\`   (equal? (f) (f))) \`=>\` \`*unspecified*
\` (equal? (lambda (x) x) (lambda (y) y)) \`=>\` \`*unspecified*\` \`
\` \`
\` (let ([f (lambda (x)\`
\`            (lambda ()\`
\`              (set! x (+ x 1))\`
\`              x))])\`
\`   (equal? (f 0) (f 0))) \`=>\` #f \`
\` \`
\` (equal?\`
\`   (let ([x (cons 'x 'x)])\`
\`     (set-car! x x)\`
\`     (set-cdr! x x)\`
\`     x)\`
\`   (let ([x (cons 'x 'x)])\`
\`     (set-car! x x)\`
\`     (set-cdr! x x)\`
\`     (cons x x))) \`=>\` #t\`
`
    },
    {
        name: "(eqv? ",
        endParen: true,
        params: ["obj1", "obj2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s12"),
        description: `**procedure**: \`(eqv? \`*obj1*\` \`*obj2*\`)\`
**returns: **\`#t\` if *obj1* and *obj2* are equivalent, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`eqv?\` is similar to \`eq?\` except \`eqv?\` is guaranteed to return \`#t\` for two characters that are considered equal by \`char=?\` and two numbers that are (a) considered equal by \`=\` and (b) cannot be distinguished by any other operation besides \`eq?\` and \`eqv?\`. A consequence of (b) is that \`(eqv? -0.0 +0.0)\` is \`#f\` even though \`(= -0.0 +0.0)\` is \`#t\` in systems that distinguish \`-0.0\` and \`+0.0\`, such as those based on IEEE floating-point arithmetic. This is because operations such as \`/\` can expose the difference:

\`(/ 1.0 -0.0) \`=>\` -inf.0\`
\` (/ 1.0 +0.0) \`=>\` +inf.0\`

Similarly, although 3.0 and 3.0+0.0i are considered numerically equal, they are not considered equivalent by \`eqv?\` if -0.0 and 0.0 have different representations.

\`(= 3.0+0.0i 3.0) \`=>\` #t\`
\` (eqv? 3.0+0.0i 3.0) \`=>\` #f\`

The boolean value returned by \`eqv?\` is not specified when the arguments are NaNs.

\`(eqv? +nan.0 (/ 0.0 0.0)) \`=>\` \`*unspecified*

\`eqv?\` is less implementation-dependent but generally more expensive than \`eq?\`.

\`(eqv? 'a 3) \`=>\` #f\`
\` (eqv? #t 't) \`=>\` #f\`
\` (eqv? "abc" 'abc) \`=>\` #f\`
\` (eqv? "hi" '(hi)) \`=>\` #f\`
\` (eqv? #f '()) \`=>\` #f \`
\` \`
\` (eqv? 9/2 7/2) \`=>\` #f\`
\` (eqv? 3.4 53344) \`=>\` #f\`
\` (eqv? 3 3.0) \`=>\` #f\`
\` (eqv? 1/3 #i1/3) \`=>\` #f \`
\` \`
\` (eqv? 9/2 9/2) \`=>\` #t\`
\` (eqv? 3.4 (+ 3.0 .4)) \`=>\` #t\`
\` (let ([x (* 12345678987654321 2)])\`
\`   (eqv? x x)) \`=>\` #t \`
\` \`
\` (eqv? #\\a #\\b) \`=>\` #f\`
\` (eqv? #\\a #\\a) \`=>\` #t\`
\` (let ([x (string-ref "hi" 0)])\`
\`   (eqv? x x)) \`=>\` #t \`
\` \`
\` (eqv? #t #t) \`=>\` #t\`
\` (eqv? #f #f) \`=>\` #t\`
\` (eqv? #t #f) \`=>\` #f\`
\` (eqv? (null? '()) #t) \`=>\` #t\`
\` (eqv? (null? '(a)) #f) \`=>\` #t \`
\` \`
\` (eqv? (cdr '(a)) '()) \`=>\` #t \`
\` \`
\` (eqv? 'a 'a) \`=>\` #t\`
\` (eqv? 'a 'b) \`=>\` #f\`
\` (eqv? 'a (string->symbol "a")) \`=>\` #t \`
\` \`
\` (eqv? '(a) '(b)) \`=>\` #f\`
\` (eqv? '(a) '(a)) \`=>\` \`*unspecified*
\` (let ([x '(a . b)]) (eqv? x x)) \`=>\` #t\`
\` (let ([x (cons 'a 'b)])\`
\`   (eqv? x x)) \`=>\` #t\`
\` (eqv? (cons 'a 'b) (cons 'a 'b)) \`=>\` #f \`
\` \`
\` (eqv? "abc" "cba") \`=>\` #f\`
\` (eqv? "abc" "abc") \`=>\` \`*unspecified*
\` (let ([x "hi"]) (eqv? x x)) \`=>\` #t\`
\` (let ([x (string #\\h #\\i)]) (eqv? x x)) \`=>\` #t\`
\` (eqv? (string #\\h #\\i)\`
\`       (string #\\h #\\i)) \`=>\` #f \`
\` \`
\` (eqv? '#vu8(1) '#vu8(1)) \`=>\` \`*unspecified*
\` (eqv? '#vu8(1) '#vu8(2)) \`=>\` #f\`
\` (let ([x (make-bytevector 10 0)])\`
\`   (eqv? x x)) \`=>\` #t\`
\` (let ([x (make-bytevector 10 0)])\`
\`   (eqv? x (make-bytevector 10 0))) \`=>\` #f \`
\` \`
\` (eqv? '#(a) '#(b)) \`=>\` #f\`
\` (eqv? '#(a) '#(a)) \`=>\` \`*unspecified*
\` (let ([x '#(a)]) (eqv? x x)) \`=>\` #t\`
\` (let ([x (vector 'a)])\`
\`   (eqv? x x)) \`=>\` #t\`
\` (eqv? (vector 'a) (vector 'a)) \`=>\` #f \`
\` \`
\` (eqv? car car) \`=>\` #t\`
\` (eqv? car cdr) \`=>\` #f\`
\` (let ([f (lambda (x) x)])\`
\`   (eqv? f f)) \`=>\` #t\`
\` (let ([f (lambda () (lambda (x) x))])\`
\`   (eqv? (f) (f))) \`=>\` \`*unspecified*
\` (eqv? (lambda (x) x) (lambda (y) y)) \`=>\` \`*unspecified*\` \`
\` \`
\` (let ([f (lambda (x)\`
\`            (lambda ()\`
\`              (set! x (+ x 1))\`
\`              x))])\`
\`   (eqv? (f 0) (f 0))) \`=>\` #f\`
`
    },
    {
        name: "(error ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s4"),
        description: `**procedure**: \`(error \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**procedure**: \`(assertion-violation \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`error\` raises a non-continuable exception with condition type \`&error\` and should be used to describe situations for which the \`&error\` condition type is appropriate, typically a situation involving the program's interaction with something outside of the program. \`assertion-violation\` raises a non-continuable exception with condition type \`&assertion\` and should be used to describe situations for which the \`&assertion\` condition type is appropriate, typically an invalid argument to a procedure or invalid value of a subexpression of a syntactic form.

The continuation object with which the exception is raised also includes a \`&who\` condition whose who field is *who* if *who* is not \`#f\`, a \`&message\` condition whose message field is *msg*, and an \`&irritants\` condition whose irritants field is \`(\`*irritant*\` ...)\`.

*who* must be a string, a symbol, or \`#f\` identifying the procedure or syntactic form reporting the error upon whose behalf the error is being reported. It is usually best to identify a procedure the programmer has called rather than some other procedure the programmer may not be aware is involved in carrying out the operation. *msg* must be a string and should describe the exceptional situation. The irritants may be any Scheme objects and should include values that may have caused or been materially involved in the exceptional situation.
`
    },
    {
        name: "(error-handling-mode ",
        endParen: true,
        params: ["symbol"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s25"),
        description: `**syntax**: \`(error-handling-mode \`*symbol*\`)\`
**returns: ***symbol*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*symbol* must be one of the symbols \`ignore\`, \`raise\`, or \`replace\`. The expression \`(error-handling-mode \`*symbol*\`)\` is equivalent to the expression \`(quote \`*symbol*\`)\` except that the former checks at expansion time that *symbol* is one of the error-handling-mode symbols. The \`error-handling-mode\` syntax provides useful documentation as well.

\`(error-handling-mode replace) \`=>\` replace\`
\` (error-handling-mode relpace) \`=>\` \`*syntax violation*
`
    },
    {
        name: "(error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s22"),
        description: `**syntax**: \`&error\`
**procedure**: \`(make-error)\`
**returns: **a condition of type \`&error\`
**procedure**: \`(error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&error\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that an error has occurred with the program's interaction with its operating environment, such as the failure of an attempt to open a file. It is not used to describe situations in which an error in the program has been detected. This condition type might be defined as follows.

\`(define-condition-type &error &serious\`
\`   make-error error?)\`
`
    },
    {
        name: "(errorf ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s2"),
        description: `**procedure**: \`(assertion-violationf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **does not return
**procedure**: \`(errorf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **does not return
**procedure**: \`(warningf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(eval ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s38"),
        description: `**procedure**: \`(eval \`*obj*\`)\`
**procedure**: \`(eval \`*obj*\` \`*env*\`)\`
**returns: **value of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

\`eval\` treats *obj* as the representation of an expression. It evaluates the expression in environment *env* and returns its value. If no environment is provided, it defaults to the environment returned by \`interaction-environment\`.

Single-argument \`eval\` is a extension. also permits *obj* to be the representation of a nonexpression form, i.e., a definition, whenever the environment is mutable. further allows *obj* to be an annotation (Section ), and the default evaluators make use of annotations to incorporate source-file information in error messages and associate source-file information with compiled code.

In , \`eval\` is actually a wrapper that simply passes its arguments to the current evaluator. (See \`current-eval\`.) The default evaluator is \`compile\`, which expands the expression via the current expander (see \`current-expand\`), compiles it, executes the resulting code, and returns its value. If the environment argument, *env*, is present, \`compile\` passes it along to the current expander, which is \`sc-expand\` by default.
`
    },
    {
        name: "(eval ",
        endParen: true,
        params: ["obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s38"),
        description: `**procedure**: \`(eval \`*obj*\`)\`
**procedure**: \`(eval \`*obj*\` \`*env*\`)\`
**returns: **value of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

\`eval\` treats *obj* as the representation of an expression. It evaluates the expression in environment *env* and returns its value. If no environment is provided, it defaults to the environment returned by \`interaction-environment\`.

Single-argument \`eval\` is a extension. also permits *obj* to be the representation of a nonexpression form, i.e., a definition, whenever the environment is mutable. further allows *obj* to be an annotation (Section ), and the default evaluators make use of annotations to incorporate source-file information in error messages and associate source-file information with compiled code.

In , \`eval\` is actually a wrapper that simply passes its arguments to the current evaluator. (See \`current-eval\`.) The default evaluator is \`compile\`, which expands the expression via the current expander (see \`current-expand\`), compiles it, executes the resulting code, and returns its value. If the environment argument, *env*, is present, \`compile\` passes it along to the current expander, which is \`sc-expand\` by default.
`
    },
    {
        name: "(eval ",
        endParen: true,
        params: ["obj", "environment"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s80"),
        description: `**procedure**: \`(eval \`*obj*\` \`*environment*\`)\`
**returns: **values of the Scheme expression represented by *obj* in *environment*
**libraries: **\`(rnrs eval)\`

If *obj* does not represent a syntactically valid expression, \`eval\` raises an exception with condition type \`&syntax\`. The environments returned by \`environment\`, \`scheme-report-environment\`, and \`null-environment\` are immutable. Thus, \`eval\` also raises an exception with condition type \`&syntax\` if an assignment to any of the variables in the environment appears within the expression.

\`(define cons 'not-cons)\`
\` (eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) \`=>\` (3 . 4) \`
\` \`
\` (define lambda 'not-lambda)\`
\` (eval '(lambda (x) x) (environment '(rnrs))) \`=>\` #<procedure> \`
\` \`
\` (eval '(cons 3 4) (environment)) \`=>\` \`*exception*
`
    },
    {
        name: "eval-syntax-expanders-when",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s101"),
        description: `**thread parameter**: \`eval-syntax-expanders-when\`
**libraries: **\`(chezscheme)\`

This parameter must be set to a list representing a set of \`eval-when\` situations, e.g., a list containing at most one occurrence of each of the symbols \`eval\`, \`compile\`, \`load\`, \`visit\`, and \`revisit\`. It is used to determine the evaluation time of syntax definitions, module forms, and import forms are expanded. (See the discussion of \`eval-when\` above.) The default value is \`(compile load eval)\`, which causes compile-time information in a file to be established when the file is loaded from source, when it is compiled via \`compile-file\`, and when a compiled version of the file is loaded via \`load\` or \`visit\`.
`
    },
    {
        name: "(eval-when ",
        endParen: true,
        params: ["situations", "form1", "form2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s98"),
        description: `**syntax**: \`(eval-when \`*situations*\` \`*form1*\` \`*form2*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*situations* must be a list containing some combination of the symbols \`eval\`, \`compile\`, \`load\`, \`visit\`, and \`revisit\`.

When source files are loaded (see \`load\`), the forms in the file are read, compiled, and executed sequentially, so that each form in the file is fully evaluated before the next one is read. When a source file is compiled (see \`compile-file\`), however, the forms are read and compiled, , in sequence. This distinction matters only when the execution of one form in the file affects the compilation of later forms, e.g., when the form results in the definition of a module or syntactic form or sets a compilation parameter such as \`optimize-level\` or \`case-sensitive\`.

For example, assume that a file contains the following two forms:

\`(define-syntax reverse-define\`
\`   (syntax-rules ()\`
\`     [(_ e x) (define x e)])) \`
\` \`
\` (reverse-define 3 three)\`

Loading this from source has the effect of defining \`reverse-define\` as a syntactic form and binding the identifier \`three\` to 3. The situation may be different if the file is compiled with \`compile-file\`, however. Unless the system or programmer takes steps to assure that the first form is fully executed before the second expression is compiled, the syntax expander will not recognize \`reverse-define\` as a syntactic form and will generate code for a procedure call to \`reverse-define\` instead of generating code to define \`three\` to be 3. When the object file is subsequently loaded, the attempt to reference either \`reverse-define\` or \`three\` will fail.
`
    },
    {
        name: "(even? ",
        endParen: true,
        params: ["int"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s96"),
        description: `**procedure**: \`(even? \`*int*\`)\`
**returns: **\`#t\` if *int* is even, \`#f\` otherwise
**procedure**: \`(odd? \`*int*\`)\`
**returns: **\`#t\` if *int* is odd, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (even? 0) \`=>\` #t\`
\` (even? 1) \`=>\` #f\`
\` (even? 2.0) \`=>\` #t\`
\` (even? -120762398465) \`=>\` #f\`
\` (even? 2.0+0.0i) \`=>\` \`*exception: not an integer*\` \`
\` \`
\` (odd? 0) \`=>\` #f\`
\` (odd? 1) \`=>\` #t\`
\` (odd? 2.0) \`=>\` #f\`
\` (odd? -120762398465) \`=>\` #t\`
\` (odd? 2.0+0.0i) \`=>\` \`*exception: not an integer*
`
    },
    {
        name: "(exact ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s114"),
        description: `**procedure**: \`(exact \`*num*\`)\`
**returns: **an exact representation of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(exact->inexact ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s116"),
        description: `**procedure**: \`(exact->inexact \`*num*\`)\`
**returns: **an inexact representation of *num*
**procedure**: \`(inexact->exact \`*num*\`)\`
**returns: **an exact representation of *num*
**libraries: **\`(rnrs r5rs)\`

These are alternative names for \`inexact\` and \`exact\`, supported for compatibility with the Revised Report.
`
    },
    {
        name: "(exact-integer-sqrt ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s128"),
        description: `**procedure**: \`(exact-integer-sqrt \`*n*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

This procedure returns two nonnegative exact integers and where = + and < ( + 1).

\`(exact-integer-sqrt 0) \`=>\` 0\`
\`                        \`\` 0\`
\` (exact-integer-sqrt 9) \`=>\` 3\`
\`                        \`=>\` 0\`
\` (exact-integer-sqrt 19) \`=>\` 4\`
\`                         \`=>\` 3\`
`
    },
    {
        name: "(exact? ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s86"),
        description: `**procedure**: \`(exact? \`*num*\`)\`
**returns: **\`#t\` if *num* is exact, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (exact? 1) \`=>\` #t\`
\` (exact? -15/16) \`=>\` #t\`
\` (exact? 2.01) \`=>\` #f\`
\` (exact? #i77) \`=>\` #f\`
\` (exact? #i2/3) \`=>\` #f\`
\` (exact? 1.0-2i) \`=>\` #f\`
`
    },
    {
        name: "except",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s22"),
        description: `**syntax**: \`only\`
**syntax**: \`except\`
**syntax**: \`add-prefix\`
**syntax**: \`drop-prefix\`
**syntax**: \`rename\`
**syntax**: \`alias\`
**libraries: **\`(chezscheme)\`

These identifiers are auxiliary keywords for \`import\` and \`import-only\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(exclusive-cond ",
        endParen: true,
        params: ["clause1", "clause2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s0"),
        description: `**syntax**: \`(exclusive-cond \`*clause1*\` \`*clause2*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`exclusive-cond\` is a version of \`cond\` (Section  of TSPLFOUR) that differs from \`cond\` in that the tests embedded within the clauses are assumed to be exclusive in the sense that if one of the tests is true, the others are not. This allows the implementation to reorder clauses when profiling information is available at expansion time (Section ).

The \`(\`*test*\`)\` form of clause is not supported. The order chosen when profiling information is available is based on the relative numbers of times the RHS of each clause is executed, and \`(\`*test*\`)\` has no RHS. \`(\`*test*\` => values)\` is equivalent, albeit less concise.
`
    },
    {
        name: "(exists ",
        endParen: true,
        params: ["procedure", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s36"),
        description: `**procedure**: \`(exists \`*procedure*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

The lists *list1*\` \`*list2*\` ...\` must be of the same length. *procedure* should accept as many arguments as there are lists and should not mutate the *list* arguments. If the lists are empty, \`exists\` returns \`#f\`. Otherwise, \`exists\` applies *procedure* to corresponding elements of the lists *list1*\` \`*list2*\` ...\` in sequence until either the lists each have only one element or *procedure* returns a true value *t*. In the former case, \`exists\` tail-calls *procedure*, applying it to the remaining element of each list. In the latter case, \`exists\` returns *t*.

\`(exists symbol? '(1.0 #\\a "hi" '())) \`=>\` #f \`
\` \`
\` (exists member\`
\`         '(a b c)\`
\`         '((c b) (b a) (a c))) \`=>\` (b a) \`
\` \`
\` (exists (lambda (x y z) (= (+ x y) z))\`
\`         '(1 2 3 4)\`
\`         '(1.2 2.3 3.4 4.5)\`
\`         '(2.3 4.4 6.4 8.6)) \`=>\` #t\`

\`exists\` may be defined (somewhat inefficiently and without error checks) as follows:

\`(define exists\`
\`   (lambda (f ls . more)\`
\`     (and (not (null? ls))\`
\`       (let exists ([x (car ls)] [ls (cdr ls)] [more more])\`
\`         (if (null? ls)\`
\`             (apply f x (map car more))\`
\`             (or (apply f x (map car more))\`
\`                 (exists (car ls) (cdr ls) (map cdr more))))))))\`
`
    },
    {
        name: "(exit ",
        endParen: true,
        params: ["obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s180"),
        description: `**procedure**: \`(exit \`*obj*\` ...)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

\`exit\` invokes the current exit handler (see \`exit-handler\`), passing along its arguments, if any.
`
    },
    {
        name: "(exit)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/libraries.html#./libraries:s18"),
        description: `**procedure**: \`(exit)\`
**procedure**: \`(exit \`*obj*\`)\`
**returns: **does not return
**libraries: **\`(rnrs programs)\`, \`(rnrs)\`

This procedure may be used to exit from a top-level program to the operating system. If no *obj* is given, the exit value returned to the operating system should indicate a normal exit. If *obj* is false, the exit value returned to the operating system should indicate an abnormal exit. Otherwise, *obj* is translated into an exit value as appropriate for the operating system.
`
    },
    {
        name: "(exit ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/libraries.html#./libraries:s18"),
        description: `**procedure**: \`(exit)\`
**procedure**: \`(exit \`*obj*\`)\`
**returns: **does not return
**libraries: **\`(rnrs programs)\`, \`(rnrs)\`

This procedure may be used to exit from a top-level program to the operating system. If no *obj* is given, the exit value returned to the operating system should indicate a normal exit. If *obj* is false, the exit value returned to the operating system should indicate an abnormal exit. Otherwise, *obj* is translated into an exit value as appropriate for the operating system.
`
    },
    {
        name: "exit-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s181"),
        description: `**thread parameter**: \`exit-handler\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a procedure and should accept any number of arguments. The current exit handler is called by \`exit\`.

The default exit handler exits from the current café, returning its arguments as the values of the call to \`new-cafe\` that created the current café. If the current café is the original café, or if \`exit\` is called from a script, \`exit\` exits from Scheme. In this case, the exit code for the Scheme process is 0 if no arguments were supplied or if the first argument is void, the value of the first argument cast to a C int if it is an exact integer of the host machine's bit width, and 1 otherwise.
`
    },
    {
        name: "(exp ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s129"),
        description: `**procedure**: \`(exp \`*num*\`)\`
**returns: ** to the *num* power
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (exp 0.0) \`=>\` 1.0\`
\` (exp 1.0) \`=>\` 2.7182818284590455\`
\` (exp -.5) \`=>\` 0.6065306597126334\`
`
    },
    {
        name: "(expand ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s90"),
        description: `**procedure**: \`(expand \`*obj*\`)\`
**procedure**: \`(expand \`*obj*\` \`*env*\`)\`
**returns: **expansion of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

\`expand\` treats *obj* as the representation of an expression. It expands the expression in environment *env* and returns an object representing the expanded form. If no environment is provided, it defaults to the environment returned by \`interaction-environment\`.

*obj* can be an annotation (Section ), and the default expander makes use of annotations to incorporate source-file information in error messages.

\`expand\` actually passes its arguments to the current expander (see \`current-expand\`), initially \`sc-expand\`.
`
    },
    {
        name: "(expand ",
        endParen: true,
        params: ["obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s90"),
        description: `**procedure**: \`(expand \`*obj*\`)\`
**procedure**: \`(expand \`*obj*\` \`*env*\`)\`
**returns: **expansion of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

\`expand\` treats *obj* as the representation of an expression. It expands the expression in environment *env* and returns an object representing the expanded form. If no environment is provided, it defaults to the environment returned by \`interaction-environment\`.

*obj* can be an annotation (Section ), and the default expander makes use of annotations to incorporate source-file information in error messages.

\`expand\` actually passes its arguments to the current expander (see \`current-expand\`), initially \`sc-expand\`.
`
    },
    {
        name: "expand-output",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s124"),
        description: `**thread parameter**: \`expand-output\`
**thread parameter**: \`expand/optimize-output\`
**libraries: **\`(chezscheme)\`

The parameters \`expand-output\` and \`expand/optimize-output\` can be used to request that the compiler and interpreter print expander and source-optimizer output produced during the compilation or interpretation process. Each parameter must be set to either \`#f\` (the default) or a textual output port.

When \`expand-output\` is set to a textual output port, the output of the expander is printed to the port as a side effect of running \`compile\`, \`interpret\`, or any of the file compiling primitives, e.g., \`compile-file\` or \`compile-library\`. Similarly, when \`expand/optimize-output\` is set to a textual output port, the output of the source optimizer is printed.
`
    },
    {
        name: "(expand/optimize ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s96"),
        description: `**procedure**: \`(expand/optimize \`*obj*\`)\`
**procedure**: \`(expand/optimize \`*obj*\` \`*env*\`)\`
**returns: **result of expanding and optimizing form represented by *obj*
**libraries: **\`(chezscheme)\`

\`expand/optimize\` treats *obj* as the representation of an expression. *obj* can be an annotation (Section ) or unannotated value. \`expand/optimize\` expands the expression in environment *env* and passes the expression through the source optimizer \`cp0\` (unless \`cp0\` is disabled via \`run-cp0\`). It also simplifies \`letrec\` and \`letrec*\` expressions within the expression and makes their undefined checks explicit. It returns an object representing the expanded, simplified, and optimized form. If no environment is provided, it defaults to the environment returned by \`interaction-environment\`.

\`expand/optimize\` is primarily useful for understanding what \`cp0\` does and does not optimize. Many optimizations are performed later in the compiler, so \`expand/optimize\` does not give a complete picture of optimizations performed.

\`(expand/optimize\`
\`   '(let ([y '(3 . 4)])\`
\`      (+ (car y) (cdr y)))) \`=>\` 7 \`
\` \`
\` (print-gensym #f)\`
\` (expand/optimize\`
\`   '(let ([y '(3 . 4)])\`
\`      (lambda (x)\`
\`        (* (+ (car y) (cdr y)) x)))) \`=>\` (lambda (x) (#2%* 7 x)) \`
\` \`
\` (expand/optimize\`
\`   '(let ([n (expt 2 10)])\`
\`      (define even?\`
\`        (lambda (x) (or (zero? x) (not (odd? x)))))\`
\`      (define odd?\`
\`        (lambda (x) (not (even? (- x 1)))))\`
\`      (define f\`
\`        (lambda (x)\`
\`          (lambda (y)\`
\`            (lambda (z)\`
\`              (if (= z 0) (omega) (+ x y z))))))\`
\`      (define omega\`
\`        (lambda ()\`
\`          ((lambda (x) (x x)) (lambda (x) (x x)))))\`
\`      (let ([g (f 1)] [m (f n)])\`
\`        (let ([h (if (> ((g 2) 3) 5)\`
\`                     (lambda (x) (+ x 1))\`
\`                     odd?)])\`
\`          (h n))))) \`=>\` 1025\`
`
    },
    {
        name: "(expand/optimize ",
        endParen: true,
        params: ["obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s96"),
        description: `**procedure**: \`(expand/optimize \`*obj*\`)\`
**procedure**: \`(expand/optimize \`*obj*\` \`*env*\`)\`
**returns: **result of expanding and optimizing form represented by *obj*
**libraries: **\`(chezscheme)\`

\`expand/optimize\` treats *obj* as the representation of an expression. *obj* can be an annotation (Section ) or unannotated value. \`expand/optimize\` expands the expression in environment *env* and passes the expression through the source optimizer \`cp0\` (unless \`cp0\` is disabled via \`run-cp0\`). It also simplifies \`letrec\` and \`letrec*\` expressions within the expression and makes their undefined checks explicit. It returns an object representing the expanded, simplified, and optimized form. If no environment is provided, it defaults to the environment returned by \`interaction-environment\`.

\`expand/optimize\` is primarily useful for understanding what \`cp0\` does and does not optimize. Many optimizations are performed later in the compiler, so \`expand/optimize\` does not give a complete picture of optimizations performed.

\`(expand/optimize\`
\`   '(let ([y '(3 . 4)])\`
\`      (+ (car y) (cdr y)))) \`=>\` 7 \`
\` \`
\` (print-gensym #f)\`
\` (expand/optimize\`
\`   '(let ([y '(3 . 4)])\`
\`      (lambda (x)\`
\`        (* (+ (car y) (cdr y)) x)))) \`=>\` (lambda (x) (#2%* 7 x)) \`
\` \`
\` (expand/optimize\`
\`   '(let ([n (expt 2 10)])\`
\`      (define even?\`
\`        (lambda (x) (or (zero? x) (not (odd? x)))))\`
\`      (define odd?\`
\`        (lambda (x) (not (even? (- x 1)))))\`
\`      (define f\`
\`        (lambda (x)\`
\`          (lambda (y)\`
\`            (lambda (z)\`
\`              (if (= z 0) (omega) (+ x y z))))))\`
\`      (define omega\`
\`        (lambda ()\`
\`          ((lambda (x) (x x)) (lambda (x) (x x)))))\`
\`      (let ([g (f 1)] [m (f n)])\`
\`        (let ([h (if (> ((g 2) 3) 5)\`
\`                     (lambda (x) (+ x 1))\`
\`                     odd?)])\`
\`          (h n))))) \`=>\` 1025\`
`
    },
    {
        name: "expand/optimize-output",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s124"),
        description: `**thread parameter**: \`expand-output\`
**thread parameter**: \`expand/optimize-output\`
**libraries: **\`(chezscheme)\`

The parameters \`expand-output\` and \`expand/optimize-output\` can be used to request that the compiler and interpreter print expander and source-optimizer output produced during the compilation or interpretation process. Each parameter must be set to either \`#f\` (the default) or a textual output port.

When \`expand-output\` is set to a textual output port, the output of the expander is printed to the port as a side effect of running \`compile\`, \`interpret\`, or any of the file compiling primitives, e.g., \`compile-file\` or \`compile-library\`. Similarly, when \`expand/optimize-output\` is set to a textual output port, the output of the source optimizer is printed.
`
    },
    {
        name: "(export ",
        endParen: true,
        params: ["export-spec", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s17"),
        description: `**syntax**: \`(export \`*export-spec*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

An \`export\` form is a definition and can appear with other definitions at the front of a \`library\` or \`module\`. It is a syntax error for an \`export\` form to appear in other contexts, including at top level or among the definitions of a top-level program or \`lambda\` body.

Each *export-spec* must take one of the following forms.

*identifier*
\` (rename (\`*internal-name*\` \`*export-name*\`) ...)\`
\` (import \`*import-spec*\` ...)\`

where each *internal-name* and *export-name* is an identifier. The first two are syntactically identical to \`library\` *export-spec*s, while the third is syntactically identical to a \`import\` form, which is an extension of the R6RS library \`import\` subform. The first form names a single export, *identifier*, whose export name is the same as its internal name. The second names a set of exports, each of whose export name is given explicitly and may differ from its internal name.

For the third, the identifiers identified by the \`import\` form become exports, with aliasing, renaming, prefixing, etc., as specified by the *import-spec*s. The module or library whose bindings are exported by an \`import\` form appearing within an \`export\` form can be defined within or outside the exporting module or library and need not be imported elsewhere within the exporting module or library.

The following library exports a two-armed-only variant of \`if\` along with all remaining bindings of the \`(rnrs)\` library.

\`(library (rnrs-no-one-armed-if) (export) (import (except (chezscheme) if))\`
\`   (export if (import (except (rnrs) if)))\`
\`   (define-syntax if\`
\`     (let ()\`
\`       (import (only (rnrs) if))\`
\`       (syntax-rules ()\`
\`         [(_ tst thn els) (if tst thn els)])))) \`
\` \`
\` (import (rnrs-no-one-armed-if))\`
\` (if #t 3 4) \`=>\` 3\`
\` (if #t 3) \`=>\` \`*exception: invalid syntax*

Another way to define the same library would be to define the two-armed-only \`if\` with a different internal name and use \`rename\` to export it under the name \`if\`:

\`(library (rnrs-no-one-armed-if) (export) (import (chezscheme))\`
\`   (export (rename (two-armed-if if)) (import (except (rnrs) if)))\`
\`   (define-syntax two-armed-if\`
\`     (syntax-rules ()\`
\`       [(_ tst thn els) (if tst thn els)]))) \`
\` \`
\` (import (rnrs-no-one-armed-if))\`
\` (if #t 3 4) \`=>\` 3\`
\` (if #t 3) \`=>\` \`*exception: invalid syntax*

The placement of the \`export\` form in the library body is irrelevant, e.g., the \`export\` form can appear after the definition in the examples above.
`
    },
    {
        name: "expression-editor",
        endParen: false,
        params: [""],
        type: "module",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/expeditor.html#./expeditor:s0"),
        description: `**module**: \`expression-editor\`
**libraries: **\`(chezscheme)\`

The \`expression-editor\` module exports a set of bindings for parameters and other procedures that can be used to modify how the expression editor interacts with the user, including the particular keys used to invoke the various editing commands.

Basic use of the expression editor is described in Section .
`
    },
    {
        name: "(expt ",
        endParen: true,
        params: ["num1", "num2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s111"),
        description: `**procedure**: \`(expt \`*num1*\` \`*num2*\`)\`
**returns: ***num1* raised to the *num2* power
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If both arguments are 0, \`expt\` returns 1.

\`(expt 2 10) \`=>\` 1024\`
\` (expt 2 -10) \`=>\` 1/1024\`
\` (expt 2 -10.0) \`=>\` 9.765625e-4\`
\` (expt -1/2 5) \`=>\` -1/32\`
\` (expt 3.0 3) \`=>\` 27.0\`
\` (expt +i 2) \`=>\` -1\`
`
    },
    {
        name: "(expt-mod ",
        endParen: true,
        params: ["int1", "int2", "int3"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s69"),
        description: `**procedure**: \`(expt-mod \`*int1*\` \`*int2*\` \`*int3*\`)\`
**returns: ***int1* raised to the *int2* power, modulo *int3*
**libraries: **\`(chezscheme)\`

*int1*, *int2* and *int3* must be nonnegative integers. \`expt-mod\` performs its computation in such a way that the intermediate results are never much larger than *int3*. This means that when *int2* is large, \`expt-mod\` is more efficient than the equivalent procedure \`(lambda (x y z) (modulo (expt x y) z))\`.

\`(expt-mod 2 4 3) \`=>\` 1\`
\` (expt-mod 2 76543 76543) \`=>\` 2\`
`
    },
    {
        name: "(extend-syntax (",
        endParen: true,
        params: ["name", "key", "pat", "fender", "template", ") ..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s8"),
        description: `**syntax**: \`(extend-syntax (\`*name*\` \`*key*\` ...) (\`*pat*\` \`*fender*\` \`*template*\`) ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The identifier *name* is the name, or syntax keyword, for the syntactic extension to be defined. When the system expander processes any list expression whose car is *name*, the syntactic transformation procedure generated by \`extend-syntax\` is invoked on this expression. The remaining identifiers *key*\` ...\` are additional keywords to be recognized within input expressions during expansion (such as \`else\` in \`cond\` or \`case\`).
`
    },
    {
        name: "fasl-compressed",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s135"),
        description: `**thread parameter**: \`fasl-compressed\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(fasl-file ",
        endParen: true,
        params: ["ifn", "ofn"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s138"),
        description: `**procedure**: \`(fasl-file \`*ifn*\` \`*ofn*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*ifn* and *ofn* must be strings. \`fasl-file\` may be used to convert a file in human-readable format into an equivalent file written in fasl format. \`fasl-file\` reads each object in turn from the file named by *ifn* and writes the fasl format for the object onto the file named by *ofn*. If the file named by *ofn* already exists, it is replaced.
`
    },
    {
        name: "(fasl-read ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s134"),
        description: `**procedure**: \`(fasl-read \`*binary-input-port*\`)\`
**procedure**: \`(fasl-read \`*binary-input-port situation*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If present, *situation* must be one of the symbols \`load\`, \`visit\`, or \`revisit\`. It defaults to \`load\`.

\`fasl-read\` reads one object from *binary-input-port*, which must be positioned at the front of an object written in fasl format. \`fasl-read\` returns the eof object if the file is positioned at the end of file. If the situation is \`visit\`, \`fasl-read\` skips over any revisit (run-time-only) objects, and if the situation is \`revisit\`, \`fasl-read\` skips over any visit (compile-time-only) objects. It doesn't skip any if the situation is \`load\`. Similarly, objects marked as both visit and revisit (e.g., object code corresponding to source code within an \`eval-when\` form with situation \`load\` or situations \`visit\` and \`revisit\`) are never skipped.

\`fasl-read\` automatically decompresses the representation of each fasl object written in compressed format by \`fasl-write\`. Thus, *binary-input-port* generally should not be opened with the compressed option. A warning is issued (an exception with condition type \`&warning\` is raised) on the first attempt to write fasl objects to or read fasl objects from a compressed file.

\`(define bop (open-file-output-port "tmp.fsl"))\`
\` (fasl-write '(a b c) bop)\`
\` (close-port bop) \`
\` \`
\` (define bip (open-file-input-port "tmp.fsl"))\`
\` (fasl-read bip) \`=>\` (a b c)\`
\` (fasl-read bip) \`=>\` #!eof\`
\` (close-port bip)\`
`
    },
    {
        name: "(fasl-read ",
        endParen: true,
        params: ["binary-input-port situation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s134"),
        description: `**procedure**: \`(fasl-read \`*binary-input-port*\`)\`
**procedure**: \`(fasl-read \`*binary-input-port situation*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If present, *situation* must be one of the symbols \`load\`, \`visit\`, or \`revisit\`. It defaults to \`load\`.

\`fasl-read\` reads one object from *binary-input-port*, which must be positioned at the front of an object written in fasl format. \`fasl-read\` returns the eof object if the file is positioned at the end of file. If the situation is \`visit\`, \`fasl-read\` skips over any revisit (run-time-only) objects, and if the situation is \`revisit\`, \`fasl-read\` skips over any visit (compile-time-only) objects. It doesn't skip any if the situation is \`load\`. Similarly, objects marked as both visit and revisit (e.g., object code corresponding to source code within an \`eval-when\` form with situation \`load\` or situations \`visit\` and \`revisit\`) are never skipped.

\`fasl-read\` automatically decompresses the representation of each fasl object written in compressed format by \`fasl-write\`. Thus, *binary-input-port* generally should not be opened with the compressed option. A warning is issued (an exception with condition type \`&warning\` is raised) on the first attempt to write fasl objects to or read fasl objects from a compressed file.

\`(define bop (open-file-output-port "tmp.fsl"))\`
\` (fasl-write '(a b c) bop)\`
\` (close-port bop) \`
\` \`
\` (define bip (open-file-input-port "tmp.fsl"))\`
\` (fasl-read bip) \`=>\` (a b c)\`
\` (fasl-read bip) \`=>\` #!eof\`
\` (close-port bip)\`
`
    },
    {
        name: "(fasl-strip-options ",
        endParen: true,
        params: ["symbol", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s88"),
        description: `**syntax**: \`(fasl-strip-options \`*symbol*\` ...)\`
**returns: **a fasl-strip-options enumeration set
**libraries: **\`(chezscheme)\`

Fasl-strip-options enumeration sets are passed to \`strip-fasl-file\` to determine what is stripped. The available options are described below.
`
    },
    {
        name: "(fasl-write ",
        endParen: true,
        params: ["obj", "binary-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s133"),
        description: `**procedure**: \`(fasl-write \`*obj*\` \`*binary-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`fasl-write\` writes the fasl representation of *obj* to *binary-output-port*. An exception is raised with condition-type \`&assertion\` if *obj* or any portion of *obj* has no external fasl representation, e.g., if *obj* is or contains a procedure.

The fasl representation of *obj* is compressed if the parameter \`fasl-compressed\`, described below, is set to \`#t\`, its default value. For this reason, *binary-output-port* generally should not be opened with the compressed option. A warning is issued (an exception with condition type \`&warning\` is raised) on the first attempt to write fasl objects to or read fasl objects from a compressed file.

\`(define bop (open-file-output-port "tmp.fsl"))\`
\` (fasl-write '(a b c) bop)\`
\` (close-port bop) \`
\` \`
\` (define bip (open-file-input-port "tmp.fsl"))\`
\` (fasl-read bip) \`=>\` (a b c)\`
\` (fasl-read bip) \`=>\` #!eof\`
\` (close-port bip)\`
`
    },
    {
        name: "fields",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(file-access-time ",
        endParen: true,
        params: ["path/port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s145"),
        description: `**procedure**: \`(file-access-time \`*path/port*\`)\`
**procedure**: \`(file-access-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the access time of the specified file
**procedure**: \`(file-change-time \`*path/port*\`)\`
**procedure**: \`(file-change-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the change time of the specified file
**procedure**: \`(file-modification-time \`*path/port*\`)\`
**procedure**: \`(file-modification-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the modification time of the specified file
**libraries: **\`(chezscheme)\`

*path/port* must be a string or port. If *path/port* is a string, the time returned is for the file named by the string, and the optional *follow?* argument determines whether symbolic links are followed. If *follow?* is true (the default), this procedure follows symbolic links; otherwise it does not. If *path/port* is a port, it must be a file port, and the time returned is for the associated file. In this case, *follow?* is ignored.

The returned times are represented as time objects (Section ).
`
    },
    {
        name: "(file-access-time ",
        endParen: true,
        params: ["path/port", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s145"),
        description: `**procedure**: \`(file-access-time \`*path/port*\`)\`
**procedure**: \`(file-access-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the access time of the specified file
**procedure**: \`(file-change-time \`*path/port*\`)\`
**procedure**: \`(file-change-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the change time of the specified file
**procedure**: \`(file-modification-time \`*path/port*\`)\`
**procedure**: \`(file-modification-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the modification time of the specified file
**libraries: **\`(chezscheme)\`

*path/port* must be a string or port. If *path/port* is a string, the time returned is for the file named by the string, and the optional *follow?* argument determines whether symbolic links are followed. If *follow?* is true (the default), this procedure follows symbolic links; otherwise it does not. If *path/port* is a port, it must be a file port, and the time returned is for the associated file. In this case, *follow?* is ignored.

The returned times are represented as time objects (Section ).
`
    },
    {
        name: "file-buffer-size",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s51"),
        description: `**thread parameter**: \`file-buffer-size\`
**libraries: **\`(chezscheme)\`

\`file-buffer-size\` is a parameter that determines the size of each buffer created when the buffer mode is not \`none\` for a port created by one of the file open operations, e.g., \`open-input-file\` or \`open-file-output-port\`. When called with no arguments, the parameter returns the current buffer size. When called with a positive fixnum *k*, it sets the current buffer size to *k*.
`
    },
    {
        name: "(file-change-time ",
        endParen: true,
        params: ["path/port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s145"),
        description: `**procedure**: \`(file-access-time \`*path/port*\`)\`
**procedure**: \`(file-access-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the access time of the specified file
**procedure**: \`(file-change-time \`*path/port*\`)\`
**procedure**: \`(file-change-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the change time of the specified file
**procedure**: \`(file-modification-time \`*path/port*\`)\`
**procedure**: \`(file-modification-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the modification time of the specified file
**libraries: **\`(chezscheme)\`

*path/port* must be a string or port. If *path/port* is a string, the time returned is for the file named by the string, and the optional *follow?* argument determines whether symbolic links are followed. If *follow?* is true (the default), this procedure follows symbolic links; otherwise it does not. If *path/port* is a port, it must be a file port, and the time returned is for the associated file. In this case, *follow?* is ignored.

The returned times are represented as time objects (Section ).
`
    },
    {
        name: "(file-change-time ",
        endParen: true,
        params: ["path/port", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s145"),
        description: `**procedure**: \`(file-access-time \`*path/port*\`)\`
**procedure**: \`(file-access-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the access time of the specified file
**procedure**: \`(file-change-time \`*path/port*\`)\`
**procedure**: \`(file-change-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the change time of the specified file
**procedure**: \`(file-modification-time \`*path/port*\`)\`
**procedure**: \`(file-modification-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the modification time of the specified file
**libraries: **\`(chezscheme)\`

*path/port* must be a string or port. If *path/port* is a string, the time returned is for the file named by the string, and the optional *follow?* argument determines whether symbolic links are followed. If *follow?* is true (the default), this procedure follows symbolic links; otherwise it does not. If *path/port* is a port, it must be a file port, and the time returned is for the associated file. In this case, *follow?* is ignored.

The returned times are represented as time objects (Section ).
`
    },
    {
        name: "(file-directory? ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s143"),
        description: `**procedure**: \`(file-directory? \`*path*\`)\`
**procedure**: \`(file-directory? \`*path*\` \`*follow?*\`)\`
**returns: **\`#t\` if the file named by *path* is a directory, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. If the optional *follow?* argument is true (the default), this procedure follows symbolic links; otherwise it does not.
`
    },
    {
        name: "(file-directory? ",
        endParen: true,
        params: ["path", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s143"),
        description: `**procedure**: \`(file-directory? \`*path*\`)\`
**procedure**: \`(file-directory? \`*path*\` \`*follow?*\`)\`
**returns: **\`#t\` if the file named by *path* is a directory, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. If the optional *follow?* argument is true (the default), this procedure follows symbolic links; otherwise it does not.
`
    },
    {
        name: "(file-exists? ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s141"),
        description: `**procedure**: \`(file-exists? \`*path*\`)\`
**procedure**: \`(file-exists? \`*path*\` \`*follow?*\`)\`
**returns: **\`#t\` if the file named by *path* exists, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. If the optional *follow?* argument is true (the default), \`file-exists?\` follows symbolic links; otherwise it does not. Thus, \`file-exists?\` will return \`#f\` when handed the pathname of a broken symbolic link unless *follow?* is provided and is \`#f\`.

The Revised Report \`file-exists?\` does not accept the optional *follow?* argument. Whether it follows symbolic links is unspecified.
`
    },
    {
        name: "(file-exists? ",
        endParen: true,
        params: ["path", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s141"),
        description: `**procedure**: \`(file-exists? \`*path*\`)\`
**procedure**: \`(file-exists? \`*path*\` \`*follow?*\`)\`
**returns: **\`#t\` if the file named by *path* exists, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. If the optional *follow?* argument is true (the default), \`file-exists?\` follows symbolic links; otherwise it does not. Thus, \`file-exists?\` will return \`#f\` when handed the pathname of a broken symbolic link unless *follow?* is provided and is \`#f\`.

The Revised Report \`file-exists?\` does not accept the optional *follow?* argument. Whether it follows symbolic links is unspecified.
`
    },
    {
        name: "(file-exists? ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s89"),
        description: `**procedure**: \`(file-exists? \`*path*\`)\`
**returns: **\`#t\` if the file named by *path* exists, \`#f\` otherwise
**libraries: **\`(rnrs files)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. Whether \`file-exists?\` follows symbolic links is unspecified.
`
    },
    {
        name: "(file-length ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s31"),
        description: `**procedure**: \`(port-length \`*port*\`)\`
**procedure**: \`(file-length \`*port*\`)\`
**returns: **the length of the file or other object to which *port* refers
**procedure**: \`(port-has-port-length? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-length\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the length of the underlying stream of characters or bytes to be determined. If so, the procedure \`port-has-port-length?\` returns \`#t\` and \`port-length\` returns the current length. For binary ports, the length is always an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character count. The length may be used at some later time to reset the length if the port supports \`set-port-length!\`. If \`port-length\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

File lengths beyond 2 might not be reported property for compressed files on 32-bit versions of the system.

\`file-length\` is identical to \`port-length\`.
`
    },
    {
        name: "(file-modification-time ",
        endParen: true,
        params: ["path/port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s145"),
        description: `**procedure**: \`(file-access-time \`*path/port*\`)\`
**procedure**: \`(file-access-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the access time of the specified file
**procedure**: \`(file-change-time \`*path/port*\`)\`
**procedure**: \`(file-change-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the change time of the specified file
**procedure**: \`(file-modification-time \`*path/port*\`)\`
**procedure**: \`(file-modification-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the modification time of the specified file
**libraries: **\`(chezscheme)\`

*path/port* must be a string or port. If *path/port* is a string, the time returned is for the file named by the string, and the optional *follow?* argument determines whether symbolic links are followed. If *follow?* is true (the default), this procedure follows symbolic links; otherwise it does not. If *path/port* is a port, it must be a file port, and the time returned is for the associated file. In this case, *follow?* is ignored.

The returned times are represented as time objects (Section ).
`
    },
    {
        name: "(file-modification-time ",
        endParen: true,
        params: ["path/port", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s145"),
        description: `**procedure**: \`(file-access-time \`*path/port*\`)\`
**procedure**: \`(file-access-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the access time of the specified file
**procedure**: \`(file-change-time \`*path/port*\`)\`
**procedure**: \`(file-change-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the change time of the specified file
**procedure**: \`(file-modification-time \`*path/port*\`)\`
**procedure**: \`(file-modification-time \`*path/port*\` \`*follow?*\`)\`
**returns: **the modification time of the specified file
**libraries: **\`(chezscheme)\`

*path/port* must be a string or port. If *path/port* is a string, the time returned is for the file named by the string, and the optional *follow?* argument determines whether symbolic links are followed. If *follow?* is true (the default), this procedure follows symbolic links; otherwise it does not. If *path/port* is a port, it must be a file port, and the time returned is for the associated file. In this case, *follow?* is ignored.

The returned times are represented as time objects (Section ).
`
    },
    {
        name: "(file-options ",
        endParen: true,
        params: ["symbol", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s26"),
        description: `**syntax**: \`(file-options \`*symbol*\` ...)\`
**returns: **a file-options enumeration set
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

File-options enumeration sets may be passed to file-open operations to control aspects of the open operation. There are three standard file options: \`no-create\`, \`no-fail\`, and \`no-truncate\`, which affect only file-open operations that create output (including input/output) ports.

With the default file options, i.e., the value of \`(file-options)\`, when a program attempts to open a file for output, an exception is raised with condition type \`i/o-file-already-exists\` if the file already exists, and the file is created if it does not already exist. If the \`no-fail\` option is included, no exception is raised if the file already exists; instead, the file is opened and truncated to zero length. If the \`no-create\` option is included, the file is not created if it does not exist; instead, an exception is raised with condition type \`i/o-file-does-not-exist\`. The \`no-create\` option implies the \`no-fail\` option. The \`no-truncate\` option is relevant only if the \`no-fail\` option is included or implied, in which case if an existing file is opened, it is not truncated, but the port's position is still set to the beginning of the file.

It is perhaps easier to imagine that the default file options are the imaginary option symbols \`create\`, \`fail-if-exists\`, and \`truncate\`; \`no-create\` removes \`create\`, \`no-fail\` removes \`fail-if-exists\`, and \`no-truncate\` removes \`truncate\`.

Implementations may support additional file option symbols. Chez Scheme, for example, supports options that control whether the file is or should be compressed, whether it is locked for exclusive access, and what permissions are given to the file if it is created [].
`
    },
    {
        name: "(file-port? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s52"),
        description: `**procedure**: \`(file-port? \`*port*\`)\`
**returns: **\`#t\` if *port* is a file port, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A file port is any port based directly on an O/S file descriptor, e.g., one created by \`open-file-input-port\`, \`open-output-port\`, \`open-fd-input-port\`, etc., but not a string, bytevector, or custom port.
`
    },
    {
        name: "(file-position ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s35"),
        description: `**procedure**: \`(file-position \`*port*\`)\`
**procedure**: \`(file-position \`*port*\` \`*pos*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

When the second argument is omitted, this procedure behaves like the R6RS \`port-position\` procedure, and when present, like the R6RS \`set-port-position!\` procedure.

For compressed files opened with the \`compressed\` flag, \`file-position\` returns the position in the uncompressed stream of data. Changing the position of a compressed input file opened with the \`compressed\` flag generally requires rewinding and rereading the file and might thus be slow. The position of a compressed output file opened with the \`compressed\` flag can be moved forward only; this is accomplished by writing a (compressed) sequence of zeros. File positions beyond 2 might not be reported property for compressed files on 32-bit versions of the system.
`
    },
    {
        name: "(file-position ",
        endParen: true,
        params: ["port", "pos"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s35"),
        description: `**procedure**: \`(file-position \`*port*\`)\`
**procedure**: \`(file-position \`*port*\` \`*pos*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

When the second argument is omitted, this procedure behaves like the R6RS \`port-position\` procedure, and when present, like the R6RS \`set-port-position!\` procedure.

For compressed files opened with the \`compressed\` flag, \`file-position\` returns the position in the uncompressed stream of data. Changing the position of a compressed input file opened with the \`compressed\` flag generally requires rewinding and rereading the file and might thus be slow. The position of a compressed output file opened with the \`compressed\` flag can be moved forward only; this is accomplished by writing a (compressed) sequence of zeros. File positions beyond 2 might not be reported property for compressed files on 32-bit versions of the system.
`
    },
    {
        name: "(file-regular? ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s142"),
        description: `**procedure**: \`(file-regular? \`*path*\`)\`
**procedure**: \`(file-regular? \`*path*\` \`*follow?*\`)\`
**returns: **\`#t\` if the file named by *path* is a regular file, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. If the optional *follow?* argument is true (the default), \`file-regular?\` follows symbolic links; otherwise it does not.
`
    },
    {
        name: "(file-regular? ",
        endParen: true,
        params: ["path", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s142"),
        description: `**procedure**: \`(file-regular? \`*path*\`)\`
**procedure**: \`(file-regular? \`*path*\` \`*follow?*\`)\`
**returns: **\`#t\` if the file named by *path* is a regular file, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. If the optional *follow?* argument is true (the default), \`file-regular?\` follows symbolic links; otherwise it does not.
`
    },
    {
        name: "(file-symbolic-link? ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s144"),
        description: `**procedure**: \`(file-symbolic-link? \`*path*\`)\`
**returns: **\`#t\` if the file named by *path* is a symbolic link, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*path* must be a string. \`file-symbolic-link?\` never follows symbolic links in making its determination.
`
    },
    {
        name: "(filter ",
        endParen: true,
        params: ["procedure", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s55"),
        description: `**procedure**: \`(filter \`*procedure*\` \`*list*\`)\`
**returns: **a list of the elements of *list* for which *procedure* returns true
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

*procedure* should accept one argument and return a single value. It should not modify *list*.

\`filter\` applies *procedure* to each element of *list* and returns a new list containing only the elements for which *procedure* returns true. The elements of the returned list appear in the same order as they appeared in the original list.

\`(filter odd? '(1 2 3 4)) \`=>\` (1 3)\`
\` (filter\`
\`   (lambda (x) (and (> x 0) (< x 10)))\`
\`   '(-5 15 3 14 -20 6 0 -9)) \`=>\` (3 6)\`
`
    },
    {
        name: "(find ",
        endParen: true,
        params: ["procedure", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s57"),
        description: `**procedure**: \`(find \`*procedure*\` \`*list*\`)\`
**returns: **the first element of *list* for which *procedure* returns true, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

*procedure* should accept one argument and return a single value. It should not modify *list*.

\`find\` traverses the argument *list* in order, applying *procedure* to each element in turn. If *procedure* returns a true value for a given element, \`find\` returns that element without applying *procedure* to the remaining elements. If *procedure* returns \`#f\` for each element of *list*, \`find\` returns \`#f\`.

If a program must distinguish between finding \`#f\` in the list and finding no element at all, \`memp\` should be used instead.

\`(find odd? '(1 2 3 4)) \`=>\` 1\`
\` (find even? '(1 2 3 4)) \`=>\` 2\`
\` (find odd? '(2 4 6 8)) \`=>\` #f\`
\` (find not '(1 a #f 55)) \`=>\` #f\`
`
    },
    {
        name: "(finite? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s97"),
        description: `**procedure**: \`(finite? \`*real*\`)\`
**returns: **\`#t\` if *real* is finite, \`#f\` otherwise
**procedure**: \`(infinite? \`*real*\`)\`
**returns: **\`#t\` if *real* is infinite, \`#f\` otherwise
**procedure**: \`(nan? \`*real*\`)\`
**returns: **\`#t\` if *real* is a NaN, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (finite? 2/3) \`=>\` #t\`
\` (infinite? 2/3) \`=>\` #f\`
\` (nan? 2/3) \`=>\` #f \`
\` \`
\` (finite? 3.1415) \`=>\` #t\`
\` (infinite? 3.1415) \`=>\` #f\`
\` (nan? 3.1415) \`=>\` #f \`
\` \`
\` (finite? +inf.0) \`=>\` #f\`
\` (infinite? -inf.0) \`=>\` #t\`
\` (nan? -inf.0) \`=>\` #f \`
\` \`
\` (finite? +nan.0) \`=>\` #f\`
\` (infinite? +nan.0) \`=>\` #f\`
\` (nan? +nan.0) \`=>\` #t\`
`
    },
    {
        name: "(fixnum->flonum ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s198"),
        description: `**procedure**: \`(fixnum->flonum \`*fx*\`)\`
**returns: **the flonum representation closest to *fx*
**procedure**: \`(real->flonum \`*real*\`)\`
**returns: **the flonum representation closest to *real*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\`fixnum->flonum\` is a restricted variant of \`inexact\`. \`real->flonum\` is a restricted variant of \`inexact\` when the input is an exact real; when it is an inexact non-flonum real, it coverts the inexact non-flonum real into the closest flonum.

\`(fixnum->flonum 0) \`=>\` 0.0\`
\` (fixnum->flonum 13) \`=>\` 13.0 \`
\` \`
\` (real->flonum -1/2) \`=>\` -0.5\`
\` (real->flonum 1s3) \`=>\` 1000.0\`
`
    },
    {
        name: "(fixnum-width)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s152"),
        description: `**procedure**: \`(fixnum-width)\`
**returns: **the implementation-dependent
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

As described in the lead-in to this section, the fixnum width determines the size of the fixnum range and must be at least 24.

\`(define w (fixnum-width))\`
\` (= (least-fixnum) (- (expt 2 (- w 1)))) \`=>\` #t\`
\` (= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) \`=>\` #t\`
\` (>= w 24) \`=>\` #t\`
`
    },
    {
        name: "(fixnum? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s150"),
        description: `**procedure**: \`(fixnum? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a fixnum, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fixnum? 0) \`=>\` #t\`
\` (fixnum? -1) \`=>\` #t\`
\` (fixnum? (- (expt 2 23))) \`=>\` #t\`
\` (fixnum? (- (expt 2 23) 1)) \`=>\` #t\`
`
    },
    {
        name: "(fl* ",
        endParen: true,
        params: ["fl", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s186"),
        description: `**procedure**: \`(fl* \`*fl*\` ...)\`
**returns: **the product of the arguments *fl*\` ...\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

When called with no arguments, \`fl*\` returns \`1.0\`.

\`(fl*) \`=>\` 1.0\`
\` (fl* 1.5 2.5) \`=>\` 3.75\`
\` (fl* 3.0 -4.0 5.0) \`=>\` -60.0\`
\` (apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) \`=>\` 120.0\`
`
    },
    {
        name: "(fl+ ",
        endParen: true,
        params: ["fl", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s184"),
        description: `**procedure**: \`(fl+ \`*fl*\` ...)\`
**returns: **the sum of the arguments *fl*\` ...\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

When called with no arguments, \`fl+\` returns \`0.0\`.

\`(fl+) \`=>\` 0.0\`
\` (fl+ 1.0 2.5) \`=>\` 3.25\`
\` (fl+ 3.0 4.25 5.0) \`=>\` 12.25\`
\` (apply fl+ '(1.0 2.0 3.0 4.0 5.0)) \`=>\` 15.0\`
`
    },
    {
        name: "(fl- ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s185"),
        description: `**procedure**: \`(fl- \`*fl*\`)\`
**returns: **the additive inverse of *fl*
**procedure**: \`(fl- \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **the difference between *fl1* and the sum of *fl2*\` \`*fl3*\` ...\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

With an IEEE floating-point representation of flonums, the single-argument \`fl-\` is equivalent to

\`(lambda (x) (fl* -1.0 x))\`

or

\`(lambda (x) (fl- -0.0 x))\`

but not

\`(lambda (x) (fl- 0.0 x))\`

since the latter returns \`0.0\` rather than \`-0.0\` for \`0.0\`.

\`(fl- 0.0) \`=>\` -0.0\`
\` (fl- 3.0) \`=>\` -3.0\`
\` (fl- 4.0 3.0) \`=>\` 1.0\`
\` (fl- 4.0 3.0 2.0 1.0) \`=>\` -2.0\`
`
    },
    {
        name: "(fl- ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s185"),
        description: `**procedure**: \`(fl- \`*fl*\`)\`
**returns: **the additive inverse of *fl*
**procedure**: \`(fl- \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **the difference between *fl1* and the sum of *fl2*\` \`*fl3*\` ...\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

With an IEEE floating-point representation of flonums, the single-argument \`fl-\` is equivalent to

\`(lambda (x) (fl* -1.0 x))\`

or

\`(lambda (x) (fl- -0.0 x))\`

but not

\`(lambda (x) (fl- 0.0 x))\`

since the latter returns \`0.0\` rather than \`-0.0\` for \`0.0\`.

\`(fl- 0.0) \`=>\` -0.0\`
\` (fl- 3.0) \`=>\` -3.0\`
\` (fl- 4.0 3.0) \`=>\` 1.0\`
\` (fl- 4.0 3.0 2.0 1.0) \`=>\` -2.0\`
`
    },
    {
        name: "(fl-make-rectangular ",
        endParen: true,
        params: ["flonum1", "flonum2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s35"),
        description: `**procedure**: \`(fl-make-rectangular \`*flonum1*\` \`*flonum2*\`)\`
**returns: **an inexact complexnum
**libraries: **\`(chezscheme)\`

The inexact complexnum produced by fl-make-rectangular has real part equal to *flonum1* and imaginary part equal to *flonum2*.

\`(fl-make-rectangular 2.0 -3.0) \`=>\` 2.0-3.0i\`
\` (fl-make-rectangular 2.0 0.0) \`=>\` 2.0+0.0i\`
\` (fl-make-rectangular 2.0 -0.0) \`=>\` 2.0-0.0i\`
`
    },
    {
        name: "(fl/ ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s187"),
        description: `**procedure**: \`(fl/ \`*fl*\`)\`
**returns: **the multiplicative inverse of *fl*
**procedure**: \`(fl/ \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **the result of dividing *fl1* by the product of *fl2*\` \`*fl3*\` ...\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (fl/ -4.0) \`=>\` -0.25\`
\` (fl/ 8.0 -2.0) \`=>\` -4.0\`
\` (fl/ -9.0 2.0) \`=>\` -4.5\`
\` (fl/ 60.0 5.0 3.0 2.0) \`=>\` 2.0\`
`
    },
    {
        name: "(fl/ ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s187"),
        description: `**procedure**: \`(fl/ \`*fl*\`)\`
**returns: **the multiplicative inverse of *fl*
**procedure**: \`(fl/ \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **the result of dividing *fl1* by the product of *fl2*\` \`*fl3*\` ...\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (fl/ -4.0) \`=>\` -0.25\`
\` (fl/ 8.0 -2.0) \`=>\` -4.0\`
\` (fl/ -9.0 2.0) \`=>\` -4.5\`
\` (fl/ 60.0 5.0 3.0 2.0) \`=>\` 2.0\`
`
    },
    {
        name: "(fl< ",
        endParen: true,
        params: ["flonum1", "flonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s28"),
        description: `**procedure**: \`(fl= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl< \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl> \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl<= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl>= \`*flonum1*\` \`*flonum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fl=\` returns \`#t\` if its arguments are equal. The predicate \`fl<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

IEEE NANs are not comparable, i.e., comparisons involving NANs always return \`#f\`.

These procedures are similar to the Revised Report procedures \`fl=?\`, \`fl<?\`, \`fl>?\`, \`fl<=?\`, and \`fl>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fl= 0.0) \`=>\` #t\`
\` (fl= 0.0 0.0) \`=>\` #t\`
\` (fl< -1.0 0.0 1.0) \`=>\` #t\`
\` (fl> -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<= 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>= 4.0 3.0 3.0) \`=>\` #t\`
\` (fl< 7.0 +inf.0) \`=>\` #t\`
\` (fl= +nan.0 0.0) \`=>\` #f\`
\` (fl= +nan.0 +nan.0) \`=>\` #f\`
\` (fl< +nan.0 +nan.0) \`=>\` #f\`
\` (fl> +nan.0 +nan.0) \`=>\` #f\`
`
    },
    {
        name: "(fl<= ",
        endParen: true,
        params: ["flonum1", "flonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s28"),
        description: `**procedure**: \`(fl= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl< \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl> \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl<= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl>= \`*flonum1*\` \`*flonum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fl=\` returns \`#t\` if its arguments are equal. The predicate \`fl<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

IEEE NANs are not comparable, i.e., comparisons involving NANs always return \`#f\`.

These procedures are similar to the Revised Report procedures \`fl=?\`, \`fl<?\`, \`fl>?\`, \`fl<=?\`, and \`fl>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fl= 0.0) \`=>\` #t\`
\` (fl= 0.0 0.0) \`=>\` #t\`
\` (fl< -1.0 0.0 1.0) \`=>\` #t\`
\` (fl> -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<= 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>= 4.0 3.0 3.0) \`=>\` #t\`
\` (fl< 7.0 +inf.0) \`=>\` #t\`
\` (fl= +nan.0 0.0) \`=>\` #f\`
\` (fl= +nan.0 +nan.0) \`=>\` #f\`
\` (fl< +nan.0 +nan.0) \`=>\` #f\`
\` (fl> +nan.0 +nan.0) \`=>\` #f\`
`
    },
    {
        name: "(fl<=? ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s178"),
        description: `**procedure**: \`(fl=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

The predicate \`fl=?\` returns \`#t\` if its arguments are equal. The predicate \`fl<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=?\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

Comparisons involving NaNs always return \`#f\`.

\`(fl=? 0.0 0.0) \`=>\` #t\`
\` (fl<? -1.0 0.0 1.0) \`=>\` #t\`
\` (fl>? -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<=? 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>=? 4.0 3.0 3.0) \`=>\` #t\`
\` (fl<? 7.0 +inf.0) \`=>\` #t\`
\` (fl=? +nan.0 0.0) \`=>\` #f\`
\` (fl=? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<=? +nan.0 +inf.0) \`=>\` #f\`
\` (fl>=? +nan.0 +inf.0) \`=>\` #f\`
`
    },
    {
        name: "(fl<? ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s178"),
        description: `**procedure**: \`(fl=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

The predicate \`fl=?\` returns \`#t\` if its arguments are equal. The predicate \`fl<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=?\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

Comparisons involving NaNs always return \`#f\`.

\`(fl=? 0.0 0.0) \`=>\` #t\`
\` (fl<? -1.0 0.0 1.0) \`=>\` #t\`
\` (fl>? -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<=? 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>=? 4.0 3.0 3.0) \`=>\` #t\`
\` (fl<? 7.0 +inf.0) \`=>\` #t\`
\` (fl=? +nan.0 0.0) \`=>\` #f\`
\` (fl=? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<=? +nan.0 +inf.0) \`=>\` #f\`
\` (fl>=? +nan.0 +inf.0) \`=>\` #f\`
`
    },
    {
        name: "(fl= ",
        endParen: true,
        params: ["flonum1", "flonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s28"),
        description: `**procedure**: \`(fl= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl< \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl> \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl<= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl>= \`*flonum1*\` \`*flonum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fl=\` returns \`#t\` if its arguments are equal. The predicate \`fl<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

IEEE NANs are not comparable, i.e., comparisons involving NANs always return \`#f\`.

These procedures are similar to the Revised Report procedures \`fl=?\`, \`fl<?\`, \`fl>?\`, \`fl<=?\`, and \`fl>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fl= 0.0) \`=>\` #t\`
\` (fl= 0.0 0.0) \`=>\` #t\`
\` (fl< -1.0 0.0 1.0) \`=>\` #t\`
\` (fl> -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<= 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>= 4.0 3.0 3.0) \`=>\` #t\`
\` (fl< 7.0 +inf.0) \`=>\` #t\`
\` (fl= +nan.0 0.0) \`=>\` #f\`
\` (fl= +nan.0 +nan.0) \`=>\` #f\`
\` (fl< +nan.0 +nan.0) \`=>\` #f\`
\` (fl> +nan.0 +nan.0) \`=>\` #f\`
`
    },
    {
        name: "(fl=? ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s178"),
        description: `**procedure**: \`(fl=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

The predicate \`fl=?\` returns \`#t\` if its arguments are equal. The predicate \`fl<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=?\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

Comparisons involving NaNs always return \`#f\`.

\`(fl=? 0.0 0.0) \`=>\` #t\`
\` (fl<? -1.0 0.0 1.0) \`=>\` #t\`
\` (fl>? -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<=? 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>=? 4.0 3.0 3.0) \`=>\` #t\`
\` (fl<? 7.0 +inf.0) \`=>\` #t\`
\` (fl=? +nan.0 0.0) \`=>\` #f\`
\` (fl=? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<=? +nan.0 +inf.0) \`=>\` #f\`
\` (fl>=? +nan.0 +inf.0) \`=>\` #f\`
`
    },
    {
        name: "(fl> ",
        endParen: true,
        params: ["flonum1", "flonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s28"),
        description: `**procedure**: \`(fl= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl< \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl> \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl<= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl>= \`*flonum1*\` \`*flonum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fl=\` returns \`#t\` if its arguments are equal. The predicate \`fl<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

IEEE NANs are not comparable, i.e., comparisons involving NANs always return \`#f\`.

These procedures are similar to the Revised Report procedures \`fl=?\`, \`fl<?\`, \`fl>?\`, \`fl<=?\`, and \`fl>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fl= 0.0) \`=>\` #t\`
\` (fl= 0.0 0.0) \`=>\` #t\`
\` (fl< -1.0 0.0 1.0) \`=>\` #t\`
\` (fl> -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<= 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>= 4.0 3.0 3.0) \`=>\` #t\`
\` (fl< 7.0 +inf.0) \`=>\` #t\`
\` (fl= +nan.0 0.0) \`=>\` #f\`
\` (fl= +nan.0 +nan.0) \`=>\` #f\`
\` (fl< +nan.0 +nan.0) \`=>\` #f\`
\` (fl> +nan.0 +nan.0) \`=>\` #f\`
`
    },
    {
        name: "(fl>= ",
        endParen: true,
        params: ["flonum1", "flonum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s28"),
        description: `**procedure**: \`(fl= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl< \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl> \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl<= \`*flonum1*\` \`*flonum2*\` ...)\`
**procedure**: \`(fl>= \`*flonum1*\` \`*flonum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fl=\` returns \`#t\` if its arguments are equal. The predicate \`fl<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

IEEE NANs are not comparable, i.e., comparisons involving NANs always return \`#f\`.

These procedures are similar to the Revised Report procedures \`fl=?\`, \`fl<?\`, \`fl>?\`, \`fl<=?\`, and \`fl>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fl= 0.0) \`=>\` #t\`
\` (fl= 0.0 0.0) \`=>\` #t\`
\` (fl< -1.0 0.0 1.0) \`=>\` #t\`
\` (fl> -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<= 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>= 4.0 3.0 3.0) \`=>\` #t\`
\` (fl< 7.0 +inf.0) \`=>\` #t\`
\` (fl= +nan.0 0.0) \`=>\` #f\`
\` (fl= +nan.0 +nan.0) \`=>\` #f\`
\` (fl< +nan.0 +nan.0) \`=>\` #f\`
\` (fl> +nan.0 +nan.0) \`=>\` #f\`
`
    },
    {
        name: "(fl>=? ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s178"),
        description: `**procedure**: \`(fl=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

The predicate \`fl=?\` returns \`#t\` if its arguments are equal. The predicate \`fl<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=?\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

Comparisons involving NaNs always return \`#f\`.

\`(fl=? 0.0 0.0) \`=>\` #t\`
\` (fl<? -1.0 0.0 1.0) \`=>\` #t\`
\` (fl>? -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<=? 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>=? 4.0 3.0 3.0) \`=>\` #t\`
\` (fl<? 7.0 +inf.0) \`=>\` #t\`
\` (fl=? +nan.0 0.0) \`=>\` #f\`
\` (fl=? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<=? +nan.0 +inf.0) \`=>\` #f\`
\` (fl>=? +nan.0 +inf.0) \`=>\` #f\`
`
    },
    {
        name: "(fl>? ",
        endParen: true,
        params: ["fl1", "fl2", "fl3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s178"),
        description: `**procedure**: \`(fl=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl<=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**procedure**: \`(fl>=? \`*fl1*\` \`*fl2*\` \`*fl3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

The predicate \`fl=?\` returns \`#t\` if its arguments are equal. The predicate \`fl<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fl>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fl<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fl>=?\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

Comparisons involving NaNs always return \`#f\`.

\`(fl=? 0.0 0.0) \`=>\` #t\`
\` (fl<? -1.0 0.0 1.0) \`=>\` #t\`
\` (fl>? -1.0 0.0 1.0) \`=>\` #f\`
\` (fl<=? 0.0 3.0 3.0) \`=>\` #t\`
\` (fl>=? 4.0 3.0 3.0) \`=>\` #t\`
\` (fl<? 7.0 +inf.0) \`=>\` #t\`
\` (fl=? +nan.0 0.0) \`=>\` #f\`
\` (fl=? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<? +nan.0 +nan.0) \`=>\` #f\`
\` (fl<=? +nan.0 +inf.0) \`=>\` #f\`
\` (fl>=? +nan.0 +inf.0) \`=>\` #f\`
`
    },
    {
        name: "(flabs ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s192"),
        description: `**procedure**: \`(flabs \`*fl*\`)\`
**returns: **absolute value of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flabs 3.2) \`=>\` 3.2\`
\` (flabs -2e-20) \`=>\` 2e-20\`
`
    },
    {
        name: "(flacos ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s195"),
        description: `**procedure**: \`(flasin \`*fl*\`)\`
**returns: **the arc sine of *fl*
**procedure**: \`(flacos \`*fl*\`)\`
**returns: **the arc cosine of *fl*
**procedure**: \`(flatan \`*fl*\`)\`
**returns: **the arc tangent of *fl*
**procedure**: \`(flatan \`*fl1*\` \`*fl2*\`)\`
**returns: **the arc tangent of *fl1*/*fl2*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(flasin ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s195"),
        description: `**procedure**: \`(flasin \`*fl*\`)\`
**returns: **the arc sine of *fl*
**procedure**: \`(flacos \`*fl*\`)\`
**returns: **the arc cosine of *fl*
**procedure**: \`(flatan \`*fl*\`)\`
**returns: **the arc tangent of *fl*
**procedure**: \`(flatan \`*fl1*\` \`*fl2*\`)\`
**returns: **the arc tangent of *fl1*/*fl2*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(flatan ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s195"),
        description: `**procedure**: \`(flasin \`*fl*\`)\`
**returns: **the arc sine of *fl*
**procedure**: \`(flacos \`*fl*\`)\`
**returns: **the arc cosine of *fl*
**procedure**: \`(flatan \`*fl*\`)\`
**returns: **the arc tangent of *fl*
**procedure**: \`(flatan \`*fl1*\` \`*fl2*\`)\`
**returns: **the arc tangent of *fl1*/*fl2*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(flatan ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s195"),
        description: `**procedure**: \`(flasin \`*fl*\`)\`
**returns: **the arc sine of *fl*
**procedure**: \`(flacos \`*fl*\`)\`
**returns: **the arc cosine of *fl*
**procedure**: \`(flatan \`*fl*\`)\`
**returns: **the arc tangent of *fl*
**procedure**: \`(flatan \`*fl1*\` \`*fl2*\`)\`
**returns: **the arc tangent of *fl1*/*fl2*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(flceiling ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s190"),
        description: `**procedure**: \`(flround \`*fl*\`)\`
**returns: **the integer closest to *fl*
**procedure**: \`(fltruncate \`*fl*\`)\`
**returns: **the integer closest to *fl* toward zero
**procedure**: \`(flfloor \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**procedure**: \`(flceiling \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl* is an integer, NaN, or infinity, each of these procedures returns *fl*. If *fl* is exactly between two integers, \`flround\` returns the closest even integer.

\`(flround 17.3) \`=>\` 17.0\`
\` (flround -17.3) \`=>\` -17.0\`
\` (flround 2.5) \`=>\` 2.0\`
\` (flround 3.5) \`=>\` 4.0 \`
\` \`
\` (fltruncate 17.3) \`=>\` 17.0\`
\` (fltruncate -17.3) \`=>\` -17.0 \`
\` \`
\` (flfloor 17.3) \`=>\` 17.0\`
\` (flfloor -17.3) \`=>\` -18.0 \`
\` \`
\` (flceiling 17.3) \`=>\` 18.0\`
\` (flceiling -17.3) \`=>\` -17.0\`
`
    },
    {
        name: "(flcos ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s194"),
        description: `**procedure**: \`(flsin \`*fl*\`)\`
**returns: **the sine of *fl*
**procedure**: \`(flcos \`*fl*\`)\`
**returns: **the cosine of *fl*
**procedure**: \`(fltan \`*fl*\`)\`
**returns: **the tangent of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(fldenominator ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s191"),
        description: `**procedure**: \`(flnumerator \`*fl*\`)\`
**returns: **the numerator of *fl*
**procedure**: \`(fldenominator \`*fl*\`)\`
**returns: **the denominator of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl* is an integer, including 0.0, or infinity, the numerator is *fl* and the denominator is 1.0.

\`(flnumerator -9.0) \`=>\` -9.0\`
\` (fldenominator -9.0) \`=>\` 1.0\`
\` (flnumerator 0.0) \`=>\` 0.0\`
\` (fldenominator 0.0) \`=>\` 1.0\`
\` (flnumerator -inf.0) \`=>\` -inf.0\`
\` (fldenominator -inf.0) \`=>\` 1.0\`

The following hold for IEEE floats, but not necessarily other flonum representations.

\`(flnumerator 3.5) \`=>\` 7.0\`
\` (fldenominator 3.5) \`=>\` 2.0\`
`
    },
    {
        name: "(fldiv ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s188"),
        description: `**procedure**: \`(fldiv \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(flmod \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(fldiv-and-mod \`*fl1*\` \`*fl2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

These are flonum-specific versions of the generic \`div\`, \`mod\`, and \`div-and-mod\`.

\`(fldiv 17.0 3.0) \`=>\` 5.0\`
\` (flmod 17.0 3.0) \`=>\` 2.0\`
\` (fldiv -17.0 3.0) \`=>\` -6.0\`
\` (flmod -17.0 3.0) \`=>\` 1.0\`
\` (fldiv 17.0 -3.0) \`=>\` -5.0\`
\` (flmod 17.0 -3.0) \`=>\` 2.0\`
\` (fldiv -17.0 -3.0) \`=>\` 6.0\`
\` (flmod -17.0 -3.0) \`=>\` 1.0 \`
\` \`
\` (fldiv-and-mod 17.5 3.75) \`=>\` 4.0\`
\`                           \`\` 2.5\`
`
    },
    {
        name: "(fldiv-and-mod ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s188"),
        description: `**procedure**: \`(fldiv \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(flmod \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(fldiv-and-mod \`*fl1*\` \`*fl2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

These are flonum-specific versions of the generic \`div\`, \`mod\`, and \`div-and-mod\`.

\`(fldiv 17.0 3.0) \`=>\` 5.0\`
\` (flmod 17.0 3.0) \`=>\` 2.0\`
\` (fldiv -17.0 3.0) \`=>\` -6.0\`
\` (flmod -17.0 3.0) \`=>\` 1.0\`
\` (fldiv 17.0 -3.0) \`=>\` -5.0\`
\` (flmod 17.0 -3.0) \`=>\` 2.0\`
\` (fldiv -17.0 -3.0) \`=>\` 6.0\`
\` (flmod -17.0 -3.0) \`=>\` 1.0 \`
\` \`
\` (fldiv-and-mod 17.5 3.75) \`=>\` 4.0\`
\`                           \`\` 2.5\`
`
    },
    {
        name: "(fldiv0 ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s189"),
        description: `**procedure**: \`(fldiv0 \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(flmod0 \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(fldiv0-and-mod0 \`*fl1*\` \`*fl2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

These are flonum-specific versions of the generic \`div0\`, \`mod0\`, and \`div0-and-mod0\`.

\`(fldiv0 17.0 3.0) \`=>\` 6.0\`
\` (flmod0 17.0 3.0) \`=>\` -1.0\`
\` (fldiv0 -17.0 3.0) \`=>\` -6.0\`
\` (flmod0 -17.0 3.0) \`=>\` 1.0\`
\` (fldiv0 17.0 -3.0) \`=>\` -6.0\`
\` (flmod0 17.0 -3.0) \`=>\` -1.0\`
\` (fldiv0 -17.0 -3.0) \`=>\` 6.0\`
\` (flmod0 -17.0 -3.0) \`=>\` 1.0 \`
\` \`
\` (fldiv0-and-mod0 17.5 3.75) \`=>\` 5.0\`
\`                             \`\` -1.25\`
`
    },
    {
        name: "(fldiv0-and-mod0 ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s189"),
        description: `**procedure**: \`(fldiv0 \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(flmod0 \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(fldiv0-and-mod0 \`*fl1*\` \`*fl2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

These are flonum-specific versions of the generic \`div0\`, \`mod0\`, and \`div0-and-mod0\`.

\`(fldiv0 17.0 3.0) \`=>\` 6.0\`
\` (flmod0 17.0 3.0) \`=>\` -1.0\`
\` (fldiv0 -17.0 3.0) \`=>\` -6.0\`
\` (flmod0 -17.0 3.0) \`=>\` 1.0\`
\` (fldiv0 17.0 -3.0) \`=>\` -6.0\`
\` (flmod0 17.0 -3.0) \`=>\` -1.0\`
\` (fldiv0 -17.0 -3.0) \`=>\` 6.0\`
\` (flmod0 -17.0 -3.0) \`=>\` 1.0 \`
\` \`
\` (fldiv0-and-mod0 17.5 3.75) \`=>\` 5.0\`
\`                             \`\` -1.25\`
`
    },
    {
        name: "(fleven? ",
        endParen: true,
        params: ["fl-int"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s182"),
        description: `**procedure**: \`(fleven? \`*fl-int*\`)\`
**returns: **\`#t\` if *fl-int* is even, \`#f\` otherwise
**procedure**: \`(flodd? \`*fl-int*\`)\`
**returns: **\`#t\` if *fl-int* is odd, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

*fl-int* must be an integer-valued flonum.

\`(fleven? 0.0) \`=>\` #t\`
\` (fleven? 1.0) \`=>\` #f\`
\` (fleven? -1.0) \`=>\` #f\`
\` (fleven? -10.0) \`=>\` #t \`
\` \`
\` (flodd? 0.0) \`=>\` #f\`
\` (flodd? 1.0) \`=>\` #t\`
\` (flodd? -1.0) \`=>\` #t\`
\` (flodd? -10.0) \`=>\` #f\`
`
    },
    {
        name: "(flexp ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s193"),
        description: `**procedure**: \`(flexp \`*fl*\`)\`
**returns: ** to the *fl* power
**procedure**: \`(fllog \`*fl*\`)\`
**returns: **the natural logarithm of *fl*
**procedure**: \`(fllog \`*fl1*\` \`*fl2*\`)\`
**returns: **the base-*fl2* logarithm of *fl1*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flexp 0.0) \`=>\` 1.0\`
\` (flexp 1.0) \`=>\` 2.7182818284590455 \`
\` \`
\` (fllog 1.0) \`=>\` 0.0\`
\` (fllog (exp 1.0)) \`=>\` 1.0\`
\` (fl/ (fllog 100.0) (fllog 10.0)) \`=>\` 2.0 \`
\` \`
\` (fllog 100.0 10.0) \`=>\` 2.0\`
\` (fllog .125 2.0) \`=>\` -3.0\`
`
    },
    {
        name: "(flexpt ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s197"),
        description: `**procedure**: \`(flexpt \`*fl1*\` \`*fl2*\`)\`
**returns: ***fl1* raised to the *fl2* power
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl1* is negative and *fl2* is not an integer, the result may be a NaN or some other unspecified flonum. If *fl1* and *fl2* are both zero, the result is 1.0. If *fl1* is zero and *fl2* is positive, the result is zero. In other cases where *fl1* is zero, the result may be a NaN or some other unspecified flonum.

\`(flexpt 3.0 2.0) \`=>\` 9.0\`
\` (flexpt 0.0 +inf.0) \`=>\` 0.0\`
`
    },
    {
        name: "(flfinite? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s181"),
        description: `**procedure**: \`(flfinite? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is finite, \`#f\` otherwise
**procedure**: \`(flinfinite? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is infinite, \`#f\` otherwise
**procedure**: \`(flnan? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is a NaN, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flfinite? 3.1415) \`=>\` #t\`
\` (flinfinite? 3.1415) \`=>\` #f\`
\` (flnan? 3.1415) \`=>\` #f \`
\` \`
\` (flfinite? +inf.0) \`=>\` #f\`
\` (flinfinite? -inf.0) \`=>\` #t\`
\` (flnan? -inf.0) \`=>\` #f \`
\` \`
\` (flfinite? +nan.0) \`=>\` #f\`
\` (flinfinite? +nan.0) \`=>\` #f\`
\` (flnan? +nan.0) \`=>\` #t\`
`
    },
    {
        name: "(flfloor ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s190"),
        description: `**procedure**: \`(flround \`*fl*\`)\`
**returns: **the integer closest to *fl*
**procedure**: \`(fltruncate \`*fl*\`)\`
**returns: **the integer closest to *fl* toward zero
**procedure**: \`(flfloor \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**procedure**: \`(flceiling \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl* is an integer, NaN, or infinity, each of these procedures returns *fl*. If *fl* is exactly between two integers, \`flround\` returns the closest even integer.

\`(flround 17.3) \`=>\` 17.0\`
\` (flround -17.3) \`=>\` -17.0\`
\` (flround 2.5) \`=>\` 2.0\`
\` (flround 3.5) \`=>\` 4.0 \`
\` \`
\` (fltruncate 17.3) \`=>\` 17.0\`
\` (fltruncate -17.3) \`=>\` -17.0 \`
\` \`
\` (flfloor 17.3) \`=>\` 17.0\`
\` (flfloor -17.3) \`=>\` -18.0 \`
\` \`
\` (flceiling 17.3) \`=>\` 18.0\`
\` (flceiling -17.3) \`=>\` -17.0\`
`
    },
    {
        name: "(flinfinite? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s181"),
        description: `**procedure**: \`(flfinite? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is finite, \`#f\` otherwise
**procedure**: \`(flinfinite? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is infinite, \`#f\` otherwise
**procedure**: \`(flnan? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is a NaN, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flfinite? 3.1415) \`=>\` #t\`
\` (flinfinite? 3.1415) \`=>\` #f\`
\` (flnan? 3.1415) \`=>\` #f \`
\` \`
\` (flfinite? +inf.0) \`=>\` #f\`
\` (flinfinite? -inf.0) \`=>\` #t\`
\` (flnan? -inf.0) \`=>\` #f \`
\` \`
\` (flfinite? +nan.0) \`=>\` #f\`
\` (flinfinite? +nan.0) \`=>\` #f\`
\` (flnan? +nan.0) \`=>\` #t\`
`
    },
    {
        name: "(flinteger? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s180"),
        description: `**procedure**: \`(flinteger? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is integer, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flinteger? 0.0) \`=>\` #t\`
\` (flinteger? -17.0) \`=>\` #t\`
\` (flinteger? +nan.0) \`=>\` #f\`
\` (flinteger? +inf.0) \`=>\` #f\`
`
    },
    {
        name: "(fllog ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s193"),
        description: `**procedure**: \`(flexp \`*fl*\`)\`
**returns: ** to the *fl* power
**procedure**: \`(fllog \`*fl*\`)\`
**returns: **the natural logarithm of *fl*
**procedure**: \`(fllog \`*fl1*\` \`*fl2*\`)\`
**returns: **the base-*fl2* logarithm of *fl1*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flexp 0.0) \`=>\` 1.0\`
\` (flexp 1.0) \`=>\` 2.7182818284590455 \`
\` \`
\` (fllog 1.0) \`=>\` 0.0\`
\` (fllog (exp 1.0)) \`=>\` 1.0\`
\` (fl/ (fllog 100.0) (fllog 10.0)) \`=>\` 2.0 \`
\` \`
\` (fllog 100.0 10.0) \`=>\` 2.0\`
\` (fllog .125 2.0) \`=>\` -3.0\`
`
    },
    {
        name: "(fllog ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s193"),
        description: `**procedure**: \`(flexp \`*fl*\`)\`
**returns: ** to the *fl* power
**procedure**: \`(fllog \`*fl*\`)\`
**returns: **the natural logarithm of *fl*
**procedure**: \`(fllog \`*fl1*\` \`*fl2*\`)\`
**returns: **the base-*fl2* logarithm of *fl1*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flexp 0.0) \`=>\` 1.0\`
\` (flexp 1.0) \`=>\` 2.7182818284590455 \`
\` \`
\` (fllog 1.0) \`=>\` 0.0\`
\` (fllog (exp 1.0)) \`=>\` 1.0\`
\` (fl/ (fllog 100.0) (fllog 10.0)) \`=>\` 2.0 \`
\` \`
\` (fllog 100.0 10.0) \`=>\` 2.0\`
\` (fllog .125 2.0) \`=>\` -3.0\`
`
    },
    {
        name: "(fllp ",
        endParen: true,
        params: ["flonum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s31"),
        description: `**procedure**: \`(fllp \`*flonum*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`fllp\` returns the 12-bit integer consisting of the exponent plus highest order represented bit of a flonum (ieee 64-bit floating-point number). It can be used to compute a fast approximation of the logarithm of the number.

\`(fllp 0.0) \`=>\` 0\`
\` (fllp 1.0) \`=>\` 2046\`
\` (fllp -1.0) \`=>\` 2046 \`
\` \`
\` (fllp 1.5) \`=>\` 2047 \`
\` \`
\` (fllp +inf.0) \`=>\` 4094\`
\` (fllp -inf.0) \`=>\` 4094 \`
\` \`
\` (fllp #b1.0e-1111111111) \`=>\` 1\`
\` (fllp #b1.0e-10000000000) \`=>\` 0\`
`
    },
    {
        name: "(flmax ",
        endParen: true,
        params: ["fl1", "fl2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s183"),
        description: `**procedure**: \`(flmin \`*fl1*\` \`*fl2*\` ...)\`
**returns: **the minimum of *fl1* *fl2* ...
**procedure**: \`(flmax \`*fl1*\` \`*fl2*\` ...)\`
**returns: **the maximum of *fl1* *fl2* ...
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flmin 4.2 -7.5 2.0 0.0 -6.4) \`=>\` -7.5 \`
\` \`
\` (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\`
\`   (apply flmin ls)) \`=>\` 2.6 \`
\` \`
\` (flmax 4.2 -7.5 2.0 0.0 -6.4) \`=>\` 4.2 \`
\` \`
\` (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\`
\`   (apply flmax ls)) \`=>\` 8.0\`
`
    },
    {
        name: "(flmin ",
        endParen: true,
        params: ["fl1", "fl2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s183"),
        description: `**procedure**: \`(flmin \`*fl1*\` \`*fl2*\` ...)\`
**returns: **the minimum of *fl1* *fl2* ...
**procedure**: \`(flmax \`*fl1*\` \`*fl2*\` ...)\`
**returns: **the maximum of *fl1* *fl2* ...
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flmin 4.2 -7.5 2.0 0.0 -6.4) \`=>\` -7.5 \`
\` \`
\` (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\`
\`   (apply flmin ls)) \`=>\` 2.6 \`
\` \`
\` (flmax 4.2 -7.5 2.0 0.0 -6.4) \`=>\` 4.2 \`
\` \`
\` (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\`
\`   (apply flmax ls)) \`=>\` 8.0\`
`
    },
    {
        name: "(flmod ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s188"),
        description: `**procedure**: \`(fldiv \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(flmod \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(fldiv-and-mod \`*fl1*\` \`*fl2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

These are flonum-specific versions of the generic \`div\`, \`mod\`, and \`div-and-mod\`.

\`(fldiv 17.0 3.0) \`=>\` 5.0\`
\` (flmod 17.0 3.0) \`=>\` 2.0\`
\` (fldiv -17.0 3.0) \`=>\` -6.0\`
\` (flmod -17.0 3.0) \`=>\` 1.0\`
\` (fldiv 17.0 -3.0) \`=>\` -5.0\`
\` (flmod 17.0 -3.0) \`=>\` 2.0\`
\` (fldiv -17.0 -3.0) \`=>\` 6.0\`
\` (flmod -17.0 -3.0) \`=>\` 1.0 \`
\` \`
\` (fldiv-and-mod 17.5 3.75) \`=>\` 4.0\`
\`                           \`\` 2.5\`
`
    },
    {
        name: "(flmod0 ",
        endParen: true,
        params: ["fl1", "fl2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s189"),
        description: `**procedure**: \`(fldiv0 \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(flmod0 \`*fl1*\` \`*fl2*\`)\`
**procedure**: \`(fldiv0-and-mod0 \`*fl1*\` \`*fl2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

These are flonum-specific versions of the generic \`div0\`, \`mod0\`, and \`div0-and-mod0\`.

\`(fldiv0 17.0 3.0) \`=>\` 6.0\`
\` (flmod0 17.0 3.0) \`=>\` -1.0\`
\` (fldiv0 -17.0 3.0) \`=>\` -6.0\`
\` (flmod0 -17.0 3.0) \`=>\` 1.0\`
\` (fldiv0 17.0 -3.0) \`=>\` -6.0\`
\` (flmod0 17.0 -3.0) \`=>\` -1.0\`
\` (fldiv0 -17.0 -3.0) \`=>\` 6.0\`
\` (flmod0 -17.0 -3.0) \`=>\` 1.0 \`
\` \`
\` (fldiv0-and-mod0 17.5 3.75) \`=>\` 5.0\`
\`                             \`\` -1.25\`
`
    },
    {
        name: "(flnan? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s181"),
        description: `**procedure**: \`(flfinite? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is finite, \`#f\` otherwise
**procedure**: \`(flinfinite? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is infinite, \`#f\` otherwise
**procedure**: \`(flnan? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is a NaN, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flfinite? 3.1415) \`=>\` #t\`
\` (flinfinite? 3.1415) \`=>\` #f\`
\` (flnan? 3.1415) \`=>\` #f \`
\` \`
\` (flfinite? +inf.0) \`=>\` #f\`
\` (flinfinite? -inf.0) \`=>\` #t\`
\` (flnan? -inf.0) \`=>\` #f \`
\` \`
\` (flfinite? +nan.0) \`=>\` #f\`
\` (flinfinite? +nan.0) \`=>\` #f\`
\` (flnan? +nan.0) \`=>\` #t\`
`
    },
    {
        name: "(flnegative? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s179"),
        description: `**procedure**: \`(flzero? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is zero, \`#f\` otherwise
**procedure**: \`(flpositive? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is greater than zero, \`#f\` otherwise
**procedure**: \`(flnegative? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\`flzero?\` is equivalent to \`(lambda (x) (fl=? x 0.0))\`, \`flpositive?\` is equivalent to \`(lambda (x) (fl>? x 0.0))\`, and \`flnegative?\` to \`(lambda (x) (fl<? x 0.0))\`.

Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative.

\`(flzero? 0.0) \`=>\` #t\`
\` (flzero? 1.0) \`=>\` #f \`
\` \`
\` (flpositive? 128.0) \`=>\` #t\`
\` (flpositive? 0.0) \`=>\` #f\`
\` (flpositive? -1.0) \`=>\` #f \`
\` \`
\` (flnegative? -65.0) \`=>\` #t\`
\` (flnegative? 0.0) \`=>\` #f\`
\` (flnegative? 1.0) \`=>\` #f \`
\` \`
\` (flzero? -0.0) \`=>\` #t\`
\` (flnegative? -0.0) \`=>\` #f \`
\` \`
\` (flnegative? +nan.0) \`=>\` #f\`
\` (flzero? +nan.0) \`=>\` #f\`
\` (flpositive? +nan.0) \`=>\` #f \`
\` \`
\` (flnegative? +inf.0) \`=>\` #f\`
\` (flnegative? -inf.0) \`=>\` #t\`
`
    },
    {
        name: "(flnonnegative? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s29"),
        description: `**procedure**: \`(flnonpositive? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is not greater than zero, \`#f\` otherwise
**procedure**: \`(flnonnegative? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is not less than zero, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`flnonpositive?\` is equivalent to \`(lambda (x) (fl<= x 0.0))\`, and \`flnonnegative?\` is equivalent to \`(lambda (x) (fl>= x 0.0))\`.

Even if the flonum representation distinguishes -0.0 from +0.0, both are considered nonpositive and nonnegative.

\`(flnonpositive? 128.0) \`=>\` #f\`
\` (flnonpositive? 0.0) \`=>\` #t\`
\` (flnonpositive? -0.0) \`=>\` #t\`
\` (flnonpositive? -1.0) \`=>\` #t \`
\` \`
\` (flnonnegative? -65.0) \`=>\` #f\`
\` (flnonnegative? 0.0) \`=>\` #t\`
\` (flnonnegative? -0.0) \`=>\` #t\`
\` (flnonnegative? 1.0) \`=>\` #t \`
\` \`
\` (flnonnegative? +nan.0) \`=>\` #f\`
\` (flnonpositive? +nan.0) \`=>\` #f \`
\` \`
\` (flnonnegative? +inf.0) \`=>\` #t\`
\` (flnonnegative? -inf.0) \`=>\` #f\`
`
    },
    {
        name: "(flnonpositive? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s29"),
        description: `**procedure**: \`(flnonpositive? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is not greater than zero, \`#f\` otherwise
**procedure**: \`(flnonnegative? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is not less than zero, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`flnonpositive?\` is equivalent to \`(lambda (x) (fl<= x 0.0))\`, and \`flnonnegative?\` is equivalent to \`(lambda (x) (fl>= x 0.0))\`.

Even if the flonum representation distinguishes -0.0 from +0.0, both are considered nonpositive and nonnegative.

\`(flnonpositive? 128.0) \`=>\` #f\`
\` (flnonpositive? 0.0) \`=>\` #t\`
\` (flnonpositive? -0.0) \`=>\` #t\`
\` (flnonpositive? -1.0) \`=>\` #t \`
\` \`
\` (flnonnegative? -65.0) \`=>\` #f\`
\` (flnonnegative? 0.0) \`=>\` #t\`
\` (flnonnegative? -0.0) \`=>\` #t\`
\` (flnonnegative? 1.0) \`=>\` #t \`
\` \`
\` (flnonnegative? +nan.0) \`=>\` #f\`
\` (flnonpositive? +nan.0) \`=>\` #f \`
\` \`
\` (flnonnegative? +inf.0) \`=>\` #t\`
\` (flnonnegative? -inf.0) \`=>\` #f\`
`
    },
    {
        name: "(flnumerator ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s191"),
        description: `**procedure**: \`(flnumerator \`*fl*\`)\`
**returns: **the numerator of *fl*
**procedure**: \`(fldenominator \`*fl*\`)\`
**returns: **the denominator of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl* is an integer, including 0.0, or infinity, the numerator is *fl* and the denominator is 1.0.

\`(flnumerator -9.0) \`=>\` -9.0\`
\` (fldenominator -9.0) \`=>\` 1.0\`
\` (flnumerator 0.0) \`=>\` 0.0\`
\` (fldenominator 0.0) \`=>\` 1.0\`
\` (flnumerator -inf.0) \`=>\` -inf.0\`
\` (fldenominator -inf.0) \`=>\` 1.0\`

The following hold for IEEE floats, but not necessarily other flonum representations.

\`(flnumerator 3.5) \`=>\` 7.0\`
\` (fldenominator 3.5) \`=>\` 2.0\`
`
    },
    {
        name: "(flodd? ",
        endParen: true,
        params: ["fl-int"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s182"),
        description: `**procedure**: \`(fleven? \`*fl-int*\`)\`
**returns: **\`#t\` if *fl-int* is even, \`#f\` otherwise
**procedure**: \`(flodd? \`*fl-int*\`)\`
**returns: **\`#t\` if *fl-int* is odd, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

*fl-int* must be an integer-valued flonum.

\`(fleven? 0.0) \`=>\` #t\`
\` (fleven? 1.0) \`=>\` #f\`
\` (fleven? -1.0) \`=>\` #f\`
\` (fleven? -10.0) \`=>\` #t \`
\` \`
\` (flodd? 0.0) \`=>\` #f\`
\` (flodd? 1.0) \`=>\` #t\`
\` (flodd? -1.0) \`=>\` #t\`
\` (flodd? -10.0) \`=>\` #f\`
`
    },
    {
        name: "(flonum->fixnum ",
        endParen: true,
        params: ["flonum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s26"),
        description: `**procedure**: \`(flonum->fixnum \`*flonum*\`)\`
**returns: **the fixnum representation of *flonum*, truncated
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(flonum? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s177"),
        description: `**procedure**: \`(flonum? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a flonum, otherwise \`#f\`
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\` (flonum? 0) \`=>\` #f\`
\` (flonum? 3/4) \`=>\` #f\`
\` (flonum? 3.5) \`=>\` #t\`
\` (flonum? .02) \`=>\` #t\`
\` (flonum? 1e10) \`=>\` #t\`
\` (flonum? 3.0+0.0i) \`=>\` #f\`
`
    },
    {
        name: "(floor ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s102"),
        description: `**procedure**: \`(floor \`*real*\`)\`
**returns: **the integer closest to *real* toward
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *real* is an infinity or NaN, \`floor\` returns *real*.

\`(floor 19) \`=>\` 19\`
\` (floor 2/3) \`=>\` 0\`
\` (floor -2/3) \`=>\` -1\`
\` (floor 17.3) \`=>\` 17.0\`
\` (floor -17/2) \`=>\` -9\`
`
    },
    {
        name: "(flpositive? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s179"),
        description: `**procedure**: \`(flzero? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is zero, \`#f\` otherwise
**procedure**: \`(flpositive? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is greater than zero, \`#f\` otherwise
**procedure**: \`(flnegative? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\`flzero?\` is equivalent to \`(lambda (x) (fl=? x 0.0))\`, \`flpositive?\` is equivalent to \`(lambda (x) (fl>? x 0.0))\`, and \`flnegative?\` to \`(lambda (x) (fl<? x 0.0))\`.

Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative.

\`(flzero? 0.0) \`=>\` #t\`
\` (flzero? 1.0) \`=>\` #f \`
\` \`
\` (flpositive? 128.0) \`=>\` #t\`
\` (flpositive? 0.0) \`=>\` #f\`
\` (flpositive? -1.0) \`=>\` #f \`
\` \`
\` (flnegative? -65.0) \`=>\` #t\`
\` (flnegative? 0.0) \`=>\` #f\`
\` (flnegative? 1.0) \`=>\` #f \`
\` \`
\` (flzero? -0.0) \`=>\` #t\`
\` (flnegative? -0.0) \`=>\` #f \`
\` \`
\` (flnegative? +nan.0) \`=>\` #f\`
\` (flzero? +nan.0) \`=>\` #f\`
\` (flpositive? +nan.0) \`=>\` #f \`
\` \`
\` (flnegative? +inf.0) \`=>\` #f\`
\` (flnegative? -inf.0) \`=>\` #t\`
`
    },
    {
        name: "(flround ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s190"),
        description: `**procedure**: \`(flround \`*fl*\`)\`
**returns: **the integer closest to *fl*
**procedure**: \`(fltruncate \`*fl*\`)\`
**returns: **the integer closest to *fl* toward zero
**procedure**: \`(flfloor \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**procedure**: \`(flceiling \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl* is an integer, NaN, or infinity, each of these procedures returns *fl*. If *fl* is exactly between two integers, \`flround\` returns the closest even integer.

\`(flround 17.3) \`=>\` 17.0\`
\` (flround -17.3) \`=>\` -17.0\`
\` (flround 2.5) \`=>\` 2.0\`
\` (flround 3.5) \`=>\` 4.0 \`
\` \`
\` (fltruncate 17.3) \`=>\` 17.0\`
\` (fltruncate -17.3) \`=>\` -17.0 \`
\` \`
\` (flfloor 17.3) \`=>\` 17.0\`
\` (flfloor -17.3) \`=>\` -18.0 \`
\` \`
\` (flceiling 17.3) \`=>\` 18.0\`
\` (flceiling -17.3) \`=>\` -17.0\`
`
    },
    {
        name: "(flsin ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s194"),
        description: `**procedure**: \`(flsin \`*fl*\`)\`
**returns: **the sine of *fl*
**procedure**: \`(flcos \`*fl*\`)\`
**returns: **the cosine of *fl*
**procedure**: \`(fltan \`*fl*\`)\`
**returns: **the tangent of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(flsqrt ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s196"),
        description: `**procedure**: \`(flsqrt \`*fl*\`)\`
**returns: **the principal square root of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

Returns the principal square root of *fl*. The square root of -0.0 should be -0.0. The result for other negative numbers may be a NaN or some other unspecified flonum.

\`(flsqrt 4.0) \`=>\` 2.0\`
\` (flsqrt 0.0) \`=>\` 0.0\`
\` (flsqrt -0.0) \`=>\` -0.0\`
`
    },
    {
        name: "(fltan ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s194"),
        description: `**procedure**: \`(flsin \`*fl*\`)\`
**returns: **the sine of *fl*
**procedure**: \`(flcos \`*fl*\`)\`
**returns: **the cosine of *fl*
**procedure**: \`(fltan \`*fl*\`)\`
**returns: **the tangent of *fl*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`
`
    },
    {
        name: "(fltruncate ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s190"),
        description: `**procedure**: \`(flround \`*fl*\`)\`
**returns: **the integer closest to *fl*
**procedure**: \`(fltruncate \`*fl*\`)\`
**returns: **the integer closest to *fl* toward zero
**procedure**: \`(flfloor \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**procedure**: \`(flceiling \`*fl*\`)\`
**returns: **the integer closest to *fl* toward
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

If *fl* is an integer, NaN, or infinity, each of these procedures returns *fl*. If *fl* is exactly between two integers, \`flround\` returns the closest even integer.

\`(flround 17.3) \`=>\` 17.0\`
\` (flround -17.3) \`=>\` -17.0\`
\` (flround 2.5) \`=>\` 2.0\`
\` (flround 3.5) \`=>\` 4.0 \`
\` \`
\` (fltruncate 17.3) \`=>\` 17.0\`
\` (fltruncate -17.3) \`=>\` -17.0 \`
\` \`
\` (flfloor 17.3) \`=>\` 17.0\`
\` (flfloor -17.3) \`=>\` -18.0 \`
\` \`
\` (flceiling 17.3) \`=>\` 18.0\`
\` (flceiling -17.3) \`=>\` -17.0\`
`
    },
    {
        name: "(fluid-let ((",
        endParen: true,
        params: ["var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s19"),
        description: `**syntax**: \`(fluid-let ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the body *body1*\` \`*body2*\` ...\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(fluid-let-syntax ((",
        endParen: true,
        params: ["keyword", "expr", "form1", "form2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s0"),
        description: `**syntax**: \`(fluid-let-syntax ((\`*keyword*\` \`*expr*\`) ...) \`*form1*\` \`*form2*\` ...)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`

Each *expr* must evaluate to a transformer. \`fluid-let-syntax\` is similar to the standard \`let-syntax\`, except that instead of introducing new bindings for the keywords *keyword*\` ...\`, \`fluid-let-syntax\` temporarily alters the existing bindings for the keywords during the expansion of its body. That is, during the expansion of *form1*\` \`*form2*\` ...\`, the visible lexical (or top-level) binding for each \`keyword\` is temporarily replaced by a new association between the keyword and the corresponding transformer. This affects any references to the keyword that resolve to the same lexical (or top-level) binding whether the references occur in the text of the body or are introduced during its expansion. In contrast, \`let-syntax\` captures only those references that occur within the text of its body.

The following example shows how \`fluid-let-syntax\` differs from \`let-syntax\`.

\`(let ([f (lambda (x) (+ x 1))])\`
\`   (let-syntax ([g (syntax-rules ()\`
\`                     [(_ x) (f x)])])\`
\`     (let-syntax ([f (syntax-rules ()\`
\`                       [(_ x) x])])\`
\`       (g 1)))) \`=>\` 2 \`
\` \`
\` (let ([f (lambda (x) (+ x 1))])\`
\`   (let-syntax ([g (syntax-rules ()\`
\`                     [(_ x) (f x)])])\`
\`     (fluid-let-syntax ([f (syntax-rules ()\`
\`                             [(_ x) x])])\`
\`       (g 1)))) \`=>\` 1\`

The two expressions are identical except that the inner \`let-syntax\` form in the first expression is a \`fluid-let-syntax\` form in the second. In the first expression, the \`f\` occurring in the expansion of \`(g 1)\` refers to the \`let\`-bound variable \`f\`, whereas in the second it refers to the keyword \`f\` by virtue of the fluid syntax binding for \`f\`.
`
    },
    {
        name: "(flush-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s38"),
        description: `**procedure**: \`(flush-output-port)\`
**procedure**: \`(flush-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *output-port* is not supplied, it defaults to the current output port. This procedure forces any data in the buffer associated with *output-port* to be printed immediately. The console output port is automatically flushed after a newline and before input from the console input port; all ports are automatically flushed when they are closed. \`flush-output-port\` may be necessary, however, to force a message without a newline to be sent to the console output port or to force output to appear on a file without delay.
`
    },
    {
        name: "(flush-output-port ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s38"),
        description: `**procedure**: \`(flush-output-port)\`
**procedure**: \`(flush-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *output-port* is not supplied, it defaults to the current output port. This procedure forces any data in the buffer associated with *output-port* to be printed immediately. The console output port is automatically flushed after a newline and before input from the console input port; all ports are automatically flushed when they are closed. \`flush-output-port\` may be necessary, however, to force a message without a newline to be sent to the console output port or to force output to appear on a file without delay.
`
    },
    {
        name: "(flush-output-port ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s74"),
        description: `**procedure**: \`(flush-output-port \`*output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure forces any bytes or characters in the buffer associated with *output-port* to be sent immediately to the underlying stream.
`
    },
    {
        name: "(flzero? ",
        endParen: true,
        params: ["fl"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s179"),
        description: `**procedure**: \`(flzero? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is zero, \`#f\` otherwise
**procedure**: \`(flpositive? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is greater than zero, \`#f\` otherwise
**procedure**: \`(flnegative? \`*fl*\`)\`
**returns: **\`#t\` if *fl* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\`flzero?\` is equivalent to \`(lambda (x) (fl=? x 0.0))\`, \`flpositive?\` is equivalent to \`(lambda (x) (fl>? x 0.0))\`, and \`flnegative?\` to \`(lambda (x) (fl<? x 0.0))\`.

Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative.

\`(flzero? 0.0) \`=>\` #t\`
\` (flzero? 1.0) \`=>\` #f \`
\` \`
\` (flpositive? 128.0) \`=>\` #t\`
\` (flpositive? 0.0) \`=>\` #f\`
\` (flpositive? -1.0) \`=>\` #f \`
\` \`
\` (flnegative? -65.0) \`=>\` #t\`
\` (flnegative? 0.0) \`=>\` #f\`
\` (flnegative? 1.0) \`=>\` #f \`
\` \`
\` (flzero? -0.0) \`=>\` #t\`
\` (flnegative? -0.0) \`=>\` #f \`
\` \`
\` (flnegative? +nan.0) \`=>\` #f\`
\` (flzero? +nan.0) \`=>\` #f\`
\` (flpositive? +nan.0) \`=>\` #f \`
\` \`
\` (flnegative? +inf.0) \`=>\` #f\`
\` (flnegative? -inf.0) \`=>\` #t\`
`
    },
    {
        name: "(fold-left ",
        endParen: true,
        params: ["procedure", "obj", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s38"),
        description: `**procedure**: \`(fold-left \`*procedure*\` \`*obj*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`
`
    },
    {
        name: "(fold-right ",
        endParen: true,
        params: ["procedure", "obj", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s41"),
        description: `**procedure**: \`(fold-right \`*procedure*\` \`*obj*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`
`
    },
    {
        name: "(for-all ",
        endParen: true,
        params: ["procedure", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s37"),
        description: `**procedure**: \`(for-all \`*procedure*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

The lists *list1*\` \`*list2*\` ...\` must be of the same length. *procedure* should accept as many arguments as there are lists and should not mutate the *list* arguments. If the lists are empty, \`for-all\` returns \`#t\`. Otherwise, \`for-all\` applies *procedure* to corresponding elements of the lists *list1*\` \`*list2*\` ...\` in sequence until either the lists each have only one element left or *procedure* returns \`#f\`. In the former case, \`for-all\` tail-calls *procedure*, applying it to the remaining element of each list. In the latter case, \`for-all\` returns \`#f\`.

\`(for-all symbol? '(a b c d)) \`=>\` #t \`
\` \`
\` (for-all =\`
\`          '(1 2 3 4)\`
\`          '(1.0 2.0 3.0 4.0)) \`=>\` #t \`
\` \`
\` (for-all (lambda (x y z) (= (+ x y) z))\`
\`          '(1 2 3 4)\`
\`          '(1.2 2.3 3.4 4.5)\`
\`          '(2.2 4.3 6.5 8.5)) \`=>\` #f\`

\`for-all\` may be defined (somewhat inefficiently and without error checks) as follows:

\`(define for-all\`
\`   (lambda (f ls . more)\`
\`     (or (null? ls)\`
\`       (let for-all ([x (car ls)] [ls (cdr ls)] [more more])\`
\`         (if (null? ls)\`
\`             (apply f x (map car more))\`
\`             (and (apply f x (map car more))\`
\`                  (for-all (car ls) (cdr ls) (map cdr more))))))))\`
`
    },
    {
        name: "(for-each ",
        endParen: true,
        params: ["procedure", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s33"),
        description: `**procedure**: \`(for-each \`*procedure*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **unspecified
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(force ",
        endParen: true,
        params: ["promise"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s65"),
        description: `**syntax**: \`(delay \`*expr*\`)\`
**returns: **a promise
**procedure**: \`(force \`*promise*\`)\`
**returns: **result of forcing *promise*
**libraries: **\`(rnrs r5rs)\`

The first time a promise created by \`delay\` is (with \`force\`), it evaluates *expr*, "remembering" the resulting value. Thereafter, each time the promise is forced, it returns the remembered value instead of reevaluating *expr*.

\`delay\` and \`force\` are typically used only in the absence of side effects, e.g., assignments, so that the order of evaluation is unimportant.
`
    },
    {
        name: "(foreign-address-name ",
        endParen: true,
        params: ["address"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s159"),
        description: `**procedure**: \`(foreign-address-name \`*address*\`)\`
**returns: **the entry name corresponding to *address*, if known, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

The following examples assume that a library that defines *strlen* has been loaded via \`load-shared-object\` or that \`strlen\` has been registered via one of the other methods described in this section.

\`(foreign-address-name (foreign-entry "strlen")) \`=>\` "strlen"\`
`
    },
    {
        name: "(foreign-alloc ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s132"),
        description: `**procedure**: \`(foreign-alloc \`*n*\`)\`
**returns: **the address of a freshly allocated block of foreign data *n* bytes long
**libraries: **\`(chezscheme)\`

*n* must be a positive fixnum. The returned value is an exact integer and is guaranteed to be properly aligned for any type of value according to the requirements of the underlying hardware. An exception is raised with condition type \`&assertion\` if the block of foreign data cannot be allocated.
`
    },
    {
        name: "(foreign-callable ",
        endParen: true,
        params: ["conv", "proc-exp", "param-type", "res-type"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s127"),
        description: `**syntax**: \`(foreign-callable \`*conv*\` ... \`*proc-exp*\` (\`*param-type*\` ...) \`*res-type*\`)\`
**returns: **a code object
**libraries: **\`(chezscheme)\`

*proc-exp* must evaluate to a procedure, the Scheme procedure that is to be invoked by foreign code. The parameter and result types are as described for \`foreign-procedure\` in Section , except that the requirements and conversions are effectively reversed, e.g., the conversions described for \`foreign-procedure\` arguments are performed for \`foreign-callable\` return values. A \`(& \`*ftype*\`)\` argument to the callable refers to an address that is valid only during the dynamic extent of the callback invocation. A \`(& \`*ftype*\`)\` result type for a callable causes the Scheme procedure to receive an extra \`(& \`*ftype*\`)\` argument before all others; the Scheme procedure should write a result into the extra argument, and the direct result of the Scheme procedure is ignored. Type checking is performed for result values but not argument values, since the parameter values are provided by the foreign code and must be assumed to be correct.

Each *conv* adjusts the calling convention to be used. \`foreign-callable\` supports the same conventions as \`foreign-procedure\` with the exception of \`__com\`. The \`__collect_safe\` convention for a callable activates a calling thread if the thread is not already activated, and the thread's activation state is reverted when the callable returns. If a calling thread is not currently registered with the Scheme system, then reverting the thread's activation state implies destroying the thread's registration (see \`Sdestroy_thread\`).
`
    },
    {
        name: "(foreign-callable-code-object ",
        endParen: true,
        params: ["address"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s131"),
        description: `**procedure**: \`(foreign-callable-code-object \`*address*\`)\`
**returns: **the code object corresponding to the foreign-callable entry point *address*
**libraries: **\`(chezscheme)\`

*address* must be an exact integer and should be the address of the entry point of a code object produced by \`foreign-callable\`.
`
    },
    {
        name: "(foreign-callable-entry-point ",
        endParen: true,
        params: ["code"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s130"),
        description: `**procedure**: \`(foreign-callable-entry-point \`*code*\`)\`
**returns: **the address of the foreign-callable entry point in *code*
**libraries: **\`(chezscheme)\`

*code* should be a code object produced by \`foreign-callable\`.
`
    },
    {
        name: "(foreign-entry ",
        endParen: true,
        params: ["entry-name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s158"),
        description: `**procedure**: \`(foreign-entry \`*entry-name*\`)\`
**returns: **the address of *entry-name* as an exact integer
**libraries: **\`(chezscheme)\`

*entry-name* must be a string naming an existing foreign entry point.

The following examples assume that a library that defines *strlen* has been loaded via \`load-shared-object\` or that \`strlen\` has been registered via one of the other methods described in this section.

\`(let ([addr (foreign-entry "strlen")])\`
\`   (and (integer? addr) (exact? addr))) \`=>\` #t \`
\` \`
\` (define-ftype strlen-type (function (string) size_t))\`
\` (define strlen\`
\`   (ftype-ref strlen-type ()\`
\`     (make-ftype-pointer strlen-type "strlen")))\`
\` (strlen "hey!") \`=>\` 4\`
`
    },
    {
        name: "(foreign-entry? ",
        endParen: true,
        params: ["entry-name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s157"),
        description: `**procedure**: \`(foreign-entry? \`*entry-name*\`)\`
**returns: **\`#t\` if *entry-name* is an existing foreign procedure entry point, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*entry-name* must be a string. \`foreign-entry?\` may be used to determine if an entry exists for a foreign procedure.

The following examples assume that a library that defines *strlen* has been loaded via \`load-shared-object\` or that \`strlen\` has been registered via one of the other methods described in this section.

\`(foreign-entry? "strlen") \`=>\` #t\`
\` ((foreign-procedure "strlen"\`
\`     (string) size_t)\`
\`  "hey!") \`=>\` 4\`
`
    },
    {
        name: "(foreign-free ",
        endParen: true,
        params: ["address"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s133"),
        description: `**procedure**: \`(foreign-free \`*address*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure frees the block of storage to which *address* points. *address* must be an exact integer in the range -2 through 2 - 1, where is the width in bits of a pointer, e.g., 64 for a 64-bit machine. It should be an address returned by an earlier call to \`foreign-alloc\` and not subsequently passed to \`foreign-free\`.
`
    },
    {
        name: "(foreign-procedure ",
        endParen: true,
        params: ["conv", "entry-exp", "param-type", "res-type"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s10"),
        description: `**syntax**: \`(foreign-procedure \`*conv*\` ... \`*entry-exp*\` (\`*param-type*\` ...) \`*res-type*\`)\`
**returns: **a procedure
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(foreign-ref ",
        endParen: true,
        params: ["type", "address", "offset"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s134"),
        description: `**procedure**: \`(foreign-ref \`*type*\` \`*address*\` \`*offset*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`foreign-ref\` extracts the value of type *type* from the memory location at *offset* bytes offset from *address*.

*type* must be a symbol identifying the type of value to be extracted. The following types have machine-dependent sizes and correspond to the like-named C types:

The types \`long-long\` and \`unsigned-long-long\` correspond to the C types \`long long\` and \`unsigned long long\`. A value of type \`char\` is referenced as a single byte and converted (as if via \`integer->char\`) into a Scheme character. A value of type \`wchar_t\` is converted (as if via \`integer->char\`) into a Scheme character. The value must be a valid Unicode scalar value.

\`wchar\` is an alias for \`wchar_t\`.

Several additional machine-dependent types are recognized:

\`uptr\` is equivalent to \`void*\`; both are treated as unsigned integers the size of a pointer. \`iptr\` is treated as a signed integer the size of a pointer. \`fixnum\` is treated as an \`iptr\`, but with a range limited to the fixnum range. \`boolean\` is treated as an \`int\`, with zero converted to the Scheme value \`#f\` and all other values converted to \`#t\`.

Finally, several fixed-sized types are also supported:

*address* must be an exact integer in the range -2 through 2 - 1, where is the width in bits of a pointer, e.g., 64 for a 64-bit machine. *offset* must be an exact fixnum. The sum of *address* and *offset* should address a readable block of memory large enough to hold a value of type *type*, within a block of storage previously returned by \`foreign-alloc\` and not subsequently freed by \`foreign-free\` or within a block of storage obtained via some other mechanism, e.g., a foreign call. For multiple-byte values, the native endianness of the machine is assumed.
`
    },
    {
        name: "(foreign-set! ",
        endParen: true,
        params: ["type", "address", "offset", "value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s135"),
        description: `**procedure**: \`(foreign-set! \`*type*\` \`*address*\` \`*offset*\` \`*value*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`foreign-set!\` stores a representation of *value* as type *type* *offset* bytes into the block of foreign data addressed by *address*.

*type* must be a symbol identifying the type of value to be stored, one of those listed in the description of \`foreign-ref\` above. Scheme characters are converted to type \`char\` or \`wchar_t\` as if via \`char->integer\`. For type \`boolean\`, Scheme \`#f\` is converted to the \`int\` 0, and any other Scheme object is converted to 1.

*address* must be an exact integer in the range -2 through 2 - 1, where is the width in bits of a pointer, e.g., 64 for a 64-bit machine. *offset* must be an exact fixnum. The sum of *address* and *offset* should address a writable block of memory large enough to hold a value of type *type*, within a block of storage previously returned by \`foreign-alloc\` and not subsequently freed by \`foreign-free\` or within a block of storage obtained via some other mechanism, e.g., a foreign call. *value* must be an appropriate value for *type*, e.g., a floating-point number for the float types or an exact integer within the appropriate range for the integer types. For multiple-byte values, the native endianness of the machine is assumed.
`
    },
    {
        name: "(foreign-sizeof ",
        endParen: true,
        params: ["type"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s136"),
        description: `**procedure**: \`(foreign-sizeof \`*type*\`)\`
**returns: **the size in bytes of *type*
**libraries: **\`(chezscheme)\`

*type* must be one of the symbols listed in the description of \`foreign-ref\` above.
`
    },
    {
        name: "(fork-thread ",
        endParen: true,
        params: ["thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s2"),
        description: `**procedure**: \`(fork-thread \`*thunk*\`)\`
**returns: **a thread object
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure that accepts zero arguments.

\`fork-thread\` invokes *thunk* in a new thread and returns a thread object.

Nothing can be done with the thread object returned by \`fork-thread\`, other than to print it.

Threads created by foreign code using some means other than \`fork-thread\` must call \`Sactivate_thread\` (Section ) before touching any Scheme data or calling any Scheme procedures.
`
    },
    {
        name: "(format ",
        endParen: true,
        params: ["format-string", "obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s104"),
        description: `**procedure**: \`(format \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #f \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #t \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format \`*textual-output-port*\` \`*format-string*\` \`*obj*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(format #f ",
        endParen: true,
        params: ["format-string", "obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s104"),
        description: `**procedure**: \`(format \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #f \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #t \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format \`*textual-output-port*\` \`*format-string*\` \`*obj*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(format #t ",
        endParen: true,
        params: ["format-string", "obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s104"),
        description: `**procedure**: \`(format \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #f \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #t \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format \`*textual-output-port*\` \`*format-string*\` \`*obj*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(format ",
        endParen: true,
        params: ["textual-output-port", "format-string", "obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s104"),
        description: `**procedure**: \`(format \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #f \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format #t \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(format \`*textual-output-port*\` \`*format-string*\` \`*obj*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(format-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s4"),
        description: `**syntax**: \`&format\`
**procedure**: \`(make-format-condition)\`
**returns: **a condition of type \`&format\`
**procedure**: \`(format-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&format\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Presence of this condition type within a compound condition indicates that the string provided by the \`&message\` condition, if present, is a \`format\` string and the list of objects provided by the \`&irritants\` condition, if present, should be treated as additional \`format\` arguments. This condition type might be defined as follows.

\`(define-condition-type &format &condition\`
\`   make-format-condition format-condition?)\`
`
    },
    {
        name: "(fprintf ",
        endParen: true,
        params: ["textual-output-port", "format-string", "obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s106"),
        description: `**procedure**: \`(printf \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(fprintf \`*textual-output-port*\` \`*format-string*\` \`*obj*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

These procedures are simple wrappers for \`format\`. \`printf\` prints the formatted output to the current output, as with a first-argument of \`#t\` to \`format\`, and \`fprintf\` prints the formatted output to the *textual-output-port*, as when the first argument to \`format\` is a port.
`
    },
    {
        name: "(free-identifier=? ",
        endParen: true,
        params: ["identifier1", "identifier2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s37"),
        description: `**procedure**: \`(free-identifier=? \`*identifier1*\` \`*identifier2*\`)\`
**procedure**: \`(bound-identifier=? \`*identifier1*\` \`*identifier2*\`)\`
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

Symbolic names alone do not distinguish identifiers unless the identifiers are to be used only as symbolic data. The predicates \`free-identifier=?\` and \`bound-identifier=?\` are used to compare identifiers according to their as free references or bound identifiers in a given context.

\`free-identifier=?\` is used to determine whether two identifiers would be equivalent if they were to appear as free identifiers in the output of a transformer. Because identifier references are lexically scoped, this means \`(free-identifier=? \`*id1*\` \`*id2*\`)\` is true if and only if the identifiers *id1* and *id2* refer to the same binding. (For this comparison, two like-named identifiers are assumed to have the same binding if neither is bound.) Literal identifiers (auxiliary keywords) appearing in \`syntax-case\` patterns (such as \`else\` in \`case\` and \`cond\`) are matched with \`free-identifier=?\`.

Similarly, \`bound-identifier=?\` is used to determine whether two identifiers would be equivalent if they were to appear as bound identifiers in the output of a transformer. In other words, if \`bound-identifier=?\` returns true for two identifiers, a binding for one will capture references to the other within its scope. In general, two identifiers are \`bound-identifier=?\` only if both are present in the original program or both are introduced by the same transformer application (perhaps implicitly---see \`datum->syntax\`). \`bound-identifier=?\` can be used for detecting duplicate identifiers in a binding construct or for other preprocessing of a binding construct that requires detecting instances of the bound identifiers.

The definition below is equivalent to the earlier definition of a simplified version of \`cond\` with \`syntax-rules\`, except that \`else\` is recognized via an explicit call to \`free-identifier?\` within a fender rather than via inclusion in the literals list.

\`(define-syntax cond\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(_ (e0 e1 e2 ...))\`
\`        (and (identifier? #'e0) (free-identifier=? #'e0 #'else))\`
\`        #'(begin e1 e2 ...)]\`
\`       [(_ (e0 e1 e2 ...)) #'(if e0 (begin e1 e2 ...))]\`
\`       [(_ (e0 e1 e2 ...) c1 c2 ...)\`
\`        #'(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))\`

With either definition of \`cond\`, \`else\` is not recognized as an auxiliary keyword if an enclosing lexical binding for \`else\` exists. For example,

\`(let ([else #f])\`
\`   (cond [else (write "oops")]))\`

does write \`"oops"\`, since \`else\` is bound lexically and is therefore not the same \`else\` that appears in the definition of \`cond\`.

The following definition of unnamed \`let\` uses \`bound-identifier=?\` to detect duplicate identifiers.

\`(define-syntax let\`
\`   (lambda (x)\`
\`     (define ids?\`
\`       (lambda (ls)\`
\`         (or (null? ls)\`
\`             (and (identifier? (car ls)) (ids? (cdr ls))))))\`
\`     (define unique-ids?\`
\`       (lambda (ls)\`
\`         (or (null? ls)\`
\`             (and (not (memp\`
\`                         (lambda (x) (bound-identifier=? x (car ls)))\`
\`                         (cdr ls)))\`
\`                  (unique-ids? (cdr ls))))))\`
\`     (syntax-case x ()\`
\`       [(_ ((i e) ...) b1 b2 ...)\`
\`        (and (ids? #'(i ...)) (unique-ids? #'(i ...)))\`
\`        #'((lambda (i ...) b1 b2 ...) e ...)])))\`

With the definition of \`let\` above, the expression

\`(let ([a 3] [a 4]) (+ a a))\`

is a syntax violation, whereas

\`(let ([a 0])\`
\`   (let-syntax ([dolet (lambda (x)\`
\`                         (syntax-case x ()\`
\`                           [(_ b)\`
\`                            #'(let ([a 3] [b 4]) (+ a b))]))])\`
\`     (dolet a)))\`

evaluates to \`7\` since the identifier \`a\` introduced by \`dolet\` and the identifier \`a\` extracted from the input form are not \`bound-identifier=?\`. Since both occurrences of \`a\`, however, if left as free references, would refer to the same binding for \`a\`, \`free-identifier=?\` would not distinguish them.

Two identifiers that are \`free-identifier=?\` may not be \`bound-identifier=?\`. An identifier introduced by a transformer may refer to the same enclosing binding as an identifier not introduced by the transformer, but an introduced binding for one will not capture references to the other. On the other hand, identifiers that are \`bound-identifier=?\` are \`free-identifier=?\`, as long as the identifiers have valid bindings in the context where they are compared.
`
    },
    {
        name: "(fresh-line)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s88"),
        description: `**procedure**: \`(fresh-line)\`
**procedure**: \`(fresh-line \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *textual-output-port* is not supplied, it defaults to the current output port.

This procedure behaves like \`newline\`, i.e., sends a newline character to *textual-output-port*, unless it can determine that the port is already positioned at the start of a line. It does this by flushing the port and consulting the "beginning-of-line" (BOL) flag associated with the port. (See page .)
`
    },
    {
        name: "(fresh-line ",
        endParen: true,
        params: ["textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s88"),
        description: `**procedure**: \`(fresh-line)\`
**procedure**: \`(fresh-line \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *textual-output-port* is not supplied, it defaults to the current output port.

This procedure behaves like \`newline\`, i.e., sends a newline character to *textual-output-port*, unless it can determine that the port is already positioned at the start of a line. It does this by flushing the port and consulting the "beginning-of-line" (BOL) flag associated with the port. (See page .)
`
    },
    {
        name: "(ftype-&ref ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s151"),
        description: `**syntax**: \`(ftype-&ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-&ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

The ftype-pointer object returned by \`ftype-&ref\` encapsulates the address of some object embedded directly or indirectly within the foreign object pointed to by the value of *fptr-expr*, offset by *index*, if present. The value of *fptr-expr* must be an ftype pointer (fptr) of the ftype identified by *ftype-name*, and *index* must either be the identifier \`*\` or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by *ftype-name*, which allows the fptr to be treated as an array of *ftype-name* objects and *index* as an index into that array. An index of \`*\` or 0 is the same as no index.

The sequence of accessors *a*\` ...\` must specify a valid path through the identified ftype. For \`struct\`, \`union\`, and \`bits\` ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier \`*\` or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length.

The examples below assume the definitions of \`B\` and \`BB\` shown above in the description of \`ftype-sizeof\`. Fixed addresses are shown for illustrative purposes and are assumed to be valid, although addresses are generally determined at run time via \`foreign-alloc\` or some other mechanism.

\`(define x (make-ftype-pointer B #x80000000))\`
\` (ftype-&ref B () x) \`=>\` #<ftype-pointer #x80000000>\`
\` (let ([idx 1])             \`=>\` #<ftype-pointer #x8000002C>\`
\`   (ftype-&ref B () x idx))\`
\` (let ([idx -1])            \`=>\` #<ftype-pointer #x7FFFFFD4>\`
\`   (ftype-&ref B () x idx))\`
\` (ftype-&ref B (b1) x) \`=>\` #<ftype-pointer #x80000000>\`
\` (ftype-&ref B (b2) x) \`=>\` #<ftype-pointer #x80000004>\`
\` (ftype-&ref B (b2 5) x) \`=>\` #<ftype-pointer #x80000018>\`
\` (let ([n 5]) (ftype-&ref B (b2 n) x)) \`=>\` #<ftype-pointer #x80000018> \`
\` \`
\` (ftype-&ref B (b1 b2) x) \`=>\` \`*syntax error*
\` (ftype-&ref B (b2 15) x) \`=>\` \`*run-time exception*\` \`
\` \`
\` (define y (make-ftype-pointer BB #x90000000))\`
\` (ftype-set! BB (bb2) y x)\`
\` (ftype-&ref BB (bb1 b2) y) \`=>\` #<ftype-pointer #x90000004>\`
\` (ftype-&ref BB (bb2 * b2) y) \`=>\` #<ftype-pointer #x80000004>\`
\` (let ([idx 1])                    \`=>\` #<ftype-pointer #x80000030>\`
\`   (ftype-&ref BB (bb2 idx b2) y))\`

With no accessors and no index, as in the first use of \`ftype-&ref\` above, the returned \`ftype-pointer\` might be \`eq?\` to the input. Otherwise, the \`ftype-pointer\` is freshly allocated.
`
    },
    {
        name: "(ftype-&ref ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s151"),
        description: `**syntax**: \`(ftype-&ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-&ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

The ftype-pointer object returned by \`ftype-&ref\` encapsulates the address of some object embedded directly or indirectly within the foreign object pointed to by the value of *fptr-expr*, offset by *index*, if present. The value of *fptr-expr* must be an ftype pointer (fptr) of the ftype identified by *ftype-name*, and *index* must either be the identifier \`*\` or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by *ftype-name*, which allows the fptr to be treated as an array of *ftype-name* objects and *index* as an index into that array. An index of \`*\` or 0 is the same as no index.

The sequence of accessors *a*\` ...\` must specify a valid path through the identified ftype. For \`struct\`, \`union\`, and \`bits\` ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier \`*\` or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length.

The examples below assume the definitions of \`B\` and \`BB\` shown above in the description of \`ftype-sizeof\`. Fixed addresses are shown for illustrative purposes and are assumed to be valid, although addresses are generally determined at run time via \`foreign-alloc\` or some other mechanism.

\`(define x (make-ftype-pointer B #x80000000))\`
\` (ftype-&ref B () x) \`=>\` #<ftype-pointer #x80000000>\`
\` (let ([idx 1])             \`=>\` #<ftype-pointer #x8000002C>\`
\`   (ftype-&ref B () x idx))\`
\` (let ([idx -1])            \`=>\` #<ftype-pointer #x7FFFFFD4>\`
\`   (ftype-&ref B () x idx))\`
\` (ftype-&ref B (b1) x) \`=>\` #<ftype-pointer #x80000000>\`
\` (ftype-&ref B (b2) x) \`=>\` #<ftype-pointer #x80000004>\`
\` (ftype-&ref B (b2 5) x) \`=>\` #<ftype-pointer #x80000018>\`
\` (let ([n 5]) (ftype-&ref B (b2 n) x)) \`=>\` #<ftype-pointer #x80000018> \`
\` \`
\` (ftype-&ref B (b1 b2) x) \`=>\` \`*syntax error*
\` (ftype-&ref B (b2 15) x) \`=>\` \`*run-time exception*\` \`
\` \`
\` (define y (make-ftype-pointer BB #x90000000))\`
\` (ftype-set! BB (bb2) y x)\`
\` (ftype-&ref BB (bb1 b2) y) \`=>\` #<ftype-pointer #x90000004>\`
\` (ftype-&ref BB (bb2 * b2) y) \`=>\` #<ftype-pointer #x80000004>\`
\` (let ([idx 1])                    \`=>\` #<ftype-pointer #x80000030>\`
\`   (ftype-&ref BB (bb2 idx b2) y))\`

With no accessors and no index, as in the first use of \`ftype-&ref\` above, the returned \`ftype-pointer\` might be \`eq?\` to the input. Otherwise, the \`ftype-pointer\` is freshly allocated.
`
    },
    {
        name: "(ftype-guardian ",
        endParen: true,
        params: ["ftype-name"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s25"),
        description: `**syntax**: \`(ftype-guardian \`*ftype-name*\`)\`
**returns: **a new ftype guardian
**libraries: **\`(chezscheme)\`

*ftype-name* must name an ftype. The first base field of the ftype (or one of the first base fields in the case of unions) must be a word-sized integer (iptr or uptr) with native endianness. This field is assumed to hold a reference count.

The return value is a new ftype guardian *g*, with which ftype-pointers of type *ftype-name* (or some subtype of *ftype-name*) can be registered. An ftype pointer is registered with *g* by invoking *g* with the ftype pointer as an argument.

An ftype guardian does not automatically protect from collection the ftype pointers registered with it, as a normal guardian would do. Instead, for each registered ftype pointer that becomes inaccessible via normal (non-weak, non-guardian pointers), the guardian decrements the reference count of the object to which the ftype pointer points. If the resulting reference-count value is zero, the ftype pointer is preserved and can be retrieved from the guardian. If the resulting reference-count value is non-zero, however, the ftype pointer is not preserved. Objects retrieved from an ftype guardian (by calling it without arguments) are guaranteed to have zero reference counts, assuming reference counts are maintained properly by code outside the collector.
`
    },
    {
        name: "(ftype-init-lock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-init-lock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-lock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-lock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-locked-decr! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s20"),
        description: `**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-locked-incr!\` atomically reads the value of the specified field, adds 1 to the value, and writes the new value back into the field. Similarly, \`ftype-locked-decr!\` atomically reads the value of the specified field, subtracts 1 from the value, and writes the new value back into the field. Both return \`#t\` if the new value is 0, otherwise \`#f\`.
`
    },
    {
        name: "(ftype-locked-decr! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s20"),
        description: `**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-locked-incr!\` atomically reads the value of the specified field, adds 1 to the value, and writes the new value back into the field. Similarly, \`ftype-locked-decr!\` atomically reads the value of the specified field, subtracts 1 from the value, and writes the new value back into the field. Both return \`#t\` if the new value is 0, otherwise \`#f\`.
`
    },
    {
        name: "(ftype-locked-incr! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s20"),
        description: `**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-locked-incr!\` atomically reads the value of the specified field, adds 1 to the value, and writes the new value back into the field. Similarly, \`ftype-locked-decr!\` atomically reads the value of the specified field, subtracts 1 from the value, and writes the new value back into the field. Both return \`#t\` if the new value is 0, otherwise \`#f\`.
`
    },
    {
        name: "(ftype-locked-incr! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s20"),
        description: `**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-incr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-locked-decr! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the updated value is 0, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-locked-incr!\` atomically reads the value of the specified field, adds 1 to the value, and writes the new value back into the field. Similarly, \`ftype-locked-decr!\` atomically reads the value of the specified field, subtracts 1 from the value, and writes the new value back into the field. Both return \`#t\` if the new value is 0, otherwise \`#f\`.
`
    },
    {
        name: "(ftype-pointer->sexpr ",
        endParen: true,
        params: ["fptr"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s156"),
        description: `**procedure**: \`(ftype-pointer->sexpr \`*fptr*\`)\`
**returns: **an s-expression representation of the object to which *fptr* points
**libraries: **\`(chezscheme)\`

*fptr* must be an ftype-pointer object.

For each unnamed field, i.e., each whose field name is an underscore, the corresponding field value in the resulting s-expression is also an underscore. Similarly, if a field is inaccessible, i.e., if its address is invalid, the value is the symbol \`invalid\`.

\`(define-ftype Frob\`
\`   (struct\`
\`     [p boolean]\`
\`     [q char]))\`
\` (define-ftype Snurk\`
\`   (struct\`
\`     [a Frob]\`
\`     [b (* Frob)]\`
\`     [c (* Frob)]\`
\`     [d (bits\`
\`          [_ unsigned 15]\`
\`          [dx signed 17])]\`
\`     [e (array 5 double)]))\`
\` (define x\`
\`   (make-ftype-pointer Snurk\`
\`     (foreign-alloc (ftype-sizeof Snurk))))\`
\` (ftype-set! Snurk (b) x\`
\`   (make-ftype-pointer Frob\`
\`     (foreign-alloc (ftype-sizeof Frob))))\`
\` (ftype-set! Snurk (c) x\`
\`   (make-ftype-pointer Frob 0))\`
\` (ftype-set! Snurk (a p) x #t)\`
\` (ftype-set! Snurk (a q) x #\\A)\`
\` (ftype-set! Snurk (b * p) x #f)\`
\` (ftype-set! Snurk (b * q) x #\\B)\`
\` (ftype-set! Snurk (d dx) x -2500)\`
\` (do ([i 0 (fx+ i 1)])\`
\`     ((fx= i 5))\`
\`   (ftype-set! Snurk (e i) x (+ (* i 5.0) 3.0)))\`
\` (ftype-pointer->sexpr x) \`=>\` (struct\`
\`                          \`\`   [a (struct [p #t] [q #\\A])]\`
\`                          \`\`   [b (* (struct [p #f] [q #\\B]))]\`
\`                          \`\`   [c (* (struct [p invalid] [q invalid]))]\`
\`                          \`\`   [d (bits [_ _] [dx -2500])]\`
\`                          \`\`   [e (array 5 3.0 8.0 13.0 18.0 23.0)])\`
`
    },
    {
        name: "(ftype-pointer-address ",
        endParen: true,
        params: ["fptr"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s148"),
        description: `**procedure**: \`(ftype-pointer-address \`*fptr*\`)\`
**returns: **the address encapsulated within *fptr*
**libraries: **\`(chezscheme)\`

*fptr* must be an ftype-pointer object.

\`(define x (make-ftype-pointer E #x80000000))\`
\` (ftype-pointer-address x) \`=>\` #x80000000\`
`
    },
    {
        name: "(ftype-pointer-ftype ",
        endParen: true,
        params: ["fptr"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s155"),
        description: `**procedure**: \`(ftype-pointer-ftype \`*fptr*\`)\`
**returns: ***fptr*'s ftype, represented as an s-expression
**libraries: **\`(chezscheme)\`

*fptr* must be an ftype-pointer object.

\`(define-ftype Q0\`
\`   (struct\`
\`     [x int]\`
\`     [y int]))\`
\` (define-ftype Q1\`
\`   (struct\`
\`     [x double]\`
\`     [y char]\`
\`     [z (endian big\`
\`          (bits\`
\`            [_ unsigned 3]\`
\`            [a unsigned 9]\`
\`            [b unsigned 4]))]\`
\`     [w (* Q0)]))\`
\` (define q1 (make-ftype-pointer Q1 0))\`
\` (ftype-pointer-ftype q1) \`=>\` (struct \`
\`                          \`\`   [x double]\`
\`                          \`\`   [y char]\`
\`                          \`\`   [z (endian big\`
\`                          \`\`        (bits\`
\`                          \`\`          [_ unsigned 3]\`
\`                          \`\`          [a unsigned 9]\`
\`                          \`\`          [b unsigned 4]))]\`
\`                          \`\`   [w (* Q0)])\`
`
    },
    {
        name: "(ftype-pointer-null? ",
        endParen: true,
        params: ["fptr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s150"),
        description: `**syntax**: \`(ftype-pointer-null? \`*fptr*\`)\`
**returns: **\`#t\` if the address of *fptr* is 0, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*fptr* must be an ftype-pointer object.

\`ftype-pointer-null?\` might be defined as follows:

\`(define ftype-pointer-null?\`
\`   (lambda (fptr)\`
\`     (= (ftype-pointer-address fptr) 0)))\`

It is, however, guaranteed not to allocate a bignum for the address even if the address does not fit in fixnum range.
`
    },
    {
        name: "(ftype-pointer=? ",
        endParen: true,
        params: ["fptr1", "fptr2"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s149"),
        description: `**syntax**: \`(ftype-pointer=? \`*fptr1*\` \`*fptr2*\`)\`
**returns: **\`#t\` if *fptr1* and *fptr2* have the same address, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*fptr1* and *fptr2* must be ftype-pointer objects.

\`ftype-pointer=?\` might be defined as follows:

\`(define ftype-pointer=?\`
\`   (lambda (fptr1 fptr2)\`
\`     (= (ftype-pointer-address fptr1) (ftype-pointer-address fptr2))))\`

It is, however, guaranteed not to allocate bignums for the addresses even if the addresses do not fit in fixnum range.
`
    },
    {
        name: "(ftype-pointer? ",
        endParen: true,
        params: ["obj"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s147"),
        description: `**syntax**: \`(ftype-pointer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an ftype pointer, otherwise \`#f\`
**syntax**: \`(ftype-pointer? \`*ftype-name*\` \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an *ftype-name*, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\`(define-ftype Widget1 (struct [x int] [y int]))\`
\` (define-ftype Widget2 (struct [w Widget1] [b boolean])) \`
\` \`
\` (define x1 (make-ftype-pointer Widget1 #x80000000))\`
\` (define x2 (make-ftype-pointer Widget2 #x80000000)) \`
\` \`
\` (ftype-pointer? x1) \`=>\` #t\`
\` (ftype-pointer? x2) \`=>\` #t \`
\` \`
\` (ftype-pointer? Widget1 x1) \`=>\` #t\`
\` (ftype-pointer? Widget1 x2) \`=>\` #t \`
\` \`
\` (ftype-pointer? Widget2 x1) \`=>\` #f\`
\` (ftype-pointer? Widget2 x2) \`=>\` #t \`
\` \`
\` (ftype-pointer? #x80000000) \`=>\` #f\`
\` (ftype-pointer? Widget1 #x80000000) \`=>\` #f\`
`
    },
    {
        name: "(ftype-pointer? ",
        endParen: true,
        params: ["ftype-name", "obj"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s147"),
        description: `**syntax**: \`(ftype-pointer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an ftype pointer, otherwise \`#f\`
**syntax**: \`(ftype-pointer? \`*ftype-name*\` \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an *ftype-name*, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\`(define-ftype Widget1 (struct [x int] [y int]))\`
\` (define-ftype Widget2 (struct [w Widget1] [b boolean])) \`
\` \`
\` (define x1 (make-ftype-pointer Widget1 #x80000000))\`
\` (define x2 (make-ftype-pointer Widget2 #x80000000)) \`
\` \`
\` (ftype-pointer? x1) \`=>\` #t\`
\` (ftype-pointer? x2) \`=>\` #t \`
\` \`
\` (ftype-pointer? Widget1 x1) \`=>\` #t\`
\` (ftype-pointer? Widget1 x2) \`=>\` #t \`
\` \`
\` (ftype-pointer? Widget2 x1) \`=>\` #f\`
\` (ftype-pointer? Widget2 x2) \`=>\` #t \`
\` \`
\` (ftype-pointer? #x80000000) \`=>\` #f\`
\` (ftype-pointer? Widget1 #x80000000) \`=>\` #f\`
`
    },
    {
        name: "(ftype-ref ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s152"),
        description: `**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*val-expr*\`)\`
**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\` \`*val-expr*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

These forms are used to store values into or retrieve values from the object pointed to by the value of *fptr-expr*, offset by *index*, if present. The value of *fptr-expr* must be an ftype pointer (fptr) of the ftype identified by *ftype-name*, and *index* must either be the identifier \`*\` or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by *ftype-name*, which allows the fptr to be treated as an array of *ftype-name* objects and *index* as an index into that array. An index of \`*\` or 0 is the same as no index.

The sequence of accessors *a*\` ...\` must specify a valid path through the identified ftype. For \`struct\`, \`union\`, and \`bits\` ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier \`*\` or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length. The field or element specified by the sequence of accessors must be a scalar field, e.g., a pointer field or a field containing a base type such as an \`int\`, \`char\`, or \`double\`.

For \`ftype-set!\`, *val-expr* must evaluate to a value of the appropriate type for the specified field, e.g., an ftype pointer of the appropriate type or an appropriate base-type value.

For both signed and unsigned integer fields, values in the range -2 through 2 - 1 are accepted, where is the width in bits of the integer field. For signed integer fields, values in the range 2 through 2 - 1 are treated as two's complement representations of the corresponding negative numbers. For unsigned integer fields, values in the range -2 through -1 are similarly treated as two's complement representations of the corresponding positive numbers.

\`char\` and \`wchar_t\` (\`wchar\`) field values are converted from (\`ftype-set!\`) or to (\`ftype-ref\`) Scheme characters, as if with \`char->integer\` and \`integer->char\`. Characters stored by \`ftype-set!\` into a \`char\` field must have Unicode scalar values in the range 0 through 255. Under Windows and any other system where \`wchar_t\` (\`wchar\`) is a 16-bit value, characters stored by \`ftype-set!\` into a \`whar_t\` (\`wchar\`) field must have Unicode scalar values in the range 0 through 2 - 1. On systems where \`wchar_t\` is a 32-bit value, any character can be stored in a \`wchar_t\` (\`wchar\`) field.

The examples below assume that \`B\` and \`C\` have been defined as shown in the description of \`ftype-sizeof\` above.

\`(define b\`
\`   (make-ftype-pointer B\`
\`     (foreign-alloc\`
\`       (* (ftype-sizeof B) 3))))\`
\` (define c\`
\`   (make-ftype-pointer C\`
\`     (foreign-alloc (ftype-sizeof C)))) \`
\` \`
\` (ftype-set! B (b1) b 5)\`
\` (ftype-set! B (b1) b 1 6)\`
\` (ftype-set! B (b1) c 5) \`=>\` \`*exception: ftype mismatch*
\` (ftype-set! B (b2) b 0) \`=>\` \`*exception: not a scalar*
\` (ftype-set! B (b2 -1) b 0) \`=>\` \`*exception: invalid index*
\` (ftype-set! B (b2 0) b 50)\`
\` (ftype-set! B (b2 4) b 55)\`
\` (ftype-set! B (b2 10) b 55) \`=>\` \`*exception: invalid index*\` \`
\` \`
\` (ftype-set! C () c (ftype-&ref B () b 1)) \`
\` \`
\` (= (ftype-pointer-address (ftype-ref C () c))      \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (*) c)) \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (-1) c)) \`=>\` #t\`
\`    (ftype-pointer-address b)) \`
\` \`
\` (ftype-ref C (-1 b1) c) \`=>\` 5\`
\` (ftype-ref C (* b1) c) \`=>\` 6\`
\` (ftype-ref C (-1 b2 0) c) \`=>\` 50\`
\` (let ([i 4]) (ftype-ref C (-1 b2 i) c)) \`=>\` 55 \`
\` \`
\` (ftype-set! C (-1 b2 0) c 75)\`
\` (ftype-ref B (b2 0) b) \`=>\` 75\`
\` (foreign-free (ftype-pointer-address c))\`
\` (foreign-free (ftype-pointer-address b))\`
`
    },
    {
        name: "(ftype-ref ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s152"),
        description: `**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*val-expr*\`)\`
**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\` \`*val-expr*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

These forms are used to store values into or retrieve values from the object pointed to by the value of *fptr-expr*, offset by *index*, if present. The value of *fptr-expr* must be an ftype pointer (fptr) of the ftype identified by *ftype-name*, and *index* must either be the identifier \`*\` or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by *ftype-name*, which allows the fptr to be treated as an array of *ftype-name* objects and *index* as an index into that array. An index of \`*\` or 0 is the same as no index.

The sequence of accessors *a*\` ...\` must specify a valid path through the identified ftype. For \`struct\`, \`union\`, and \`bits\` ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier \`*\` or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length. The field or element specified by the sequence of accessors must be a scalar field, e.g., a pointer field or a field containing a base type such as an \`int\`, \`char\`, or \`double\`.

For \`ftype-set!\`, *val-expr* must evaluate to a value of the appropriate type for the specified field, e.g., an ftype pointer of the appropriate type or an appropriate base-type value.

For both signed and unsigned integer fields, values in the range -2 through 2 - 1 are accepted, where is the width in bits of the integer field. For signed integer fields, values in the range 2 through 2 - 1 are treated as two's complement representations of the corresponding negative numbers. For unsigned integer fields, values in the range -2 through -1 are similarly treated as two's complement representations of the corresponding positive numbers.

\`char\` and \`wchar_t\` (\`wchar\`) field values are converted from (\`ftype-set!\`) or to (\`ftype-ref\`) Scheme characters, as if with \`char->integer\` and \`integer->char\`. Characters stored by \`ftype-set!\` into a \`char\` field must have Unicode scalar values in the range 0 through 255. Under Windows and any other system where \`wchar_t\` (\`wchar\`) is a 16-bit value, characters stored by \`ftype-set!\` into a \`whar_t\` (\`wchar\`) field must have Unicode scalar values in the range 0 through 2 - 1. On systems where \`wchar_t\` is a 32-bit value, any character can be stored in a \`wchar_t\` (\`wchar\`) field.

The examples below assume that \`B\` and \`C\` have been defined as shown in the description of \`ftype-sizeof\` above.

\`(define b\`
\`   (make-ftype-pointer B\`
\`     (foreign-alloc\`
\`       (* (ftype-sizeof B) 3))))\`
\` (define c\`
\`   (make-ftype-pointer C\`
\`     (foreign-alloc (ftype-sizeof C)))) \`
\` \`
\` (ftype-set! B (b1) b 5)\`
\` (ftype-set! B (b1) b 1 6)\`
\` (ftype-set! B (b1) c 5) \`=>\` \`*exception: ftype mismatch*
\` (ftype-set! B (b2) b 0) \`=>\` \`*exception: not a scalar*
\` (ftype-set! B (b2 -1) b 0) \`=>\` \`*exception: invalid index*
\` (ftype-set! B (b2 0) b 50)\`
\` (ftype-set! B (b2 4) b 55)\`
\` (ftype-set! B (b2 10) b 55) \`=>\` \`*exception: invalid index*\` \`
\` \`
\` (ftype-set! C () c (ftype-&ref B () b 1)) \`
\` \`
\` (= (ftype-pointer-address (ftype-ref C () c))      \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (*) c)) \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (-1) c)) \`=>\` #t\`
\`    (ftype-pointer-address b)) \`
\` \`
\` (ftype-ref C (-1 b1) c) \`=>\` 5\`
\` (ftype-ref C (* b1) c) \`=>\` 6\`
\` (ftype-ref C (-1 b2 0) c) \`=>\` 50\`
\` (let ([i 4]) (ftype-ref C (-1 b2 i) c)) \`=>\` 55 \`
\` \`
\` (ftype-set! C (-1 b2 0) c 75)\`
\` (ftype-ref B (b2 0) b) \`=>\` 75\`
\` (foreign-free (ftype-pointer-address c))\`
\` (foreign-free (ftype-pointer-address b))\`
`
    },
    {
        name: "(ftype-set! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "val-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s152"),
        description: `**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*val-expr*\`)\`
**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\` \`*val-expr*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

These forms are used to store values into or retrieve values from the object pointed to by the value of *fptr-expr*, offset by *index*, if present. The value of *fptr-expr* must be an ftype pointer (fptr) of the ftype identified by *ftype-name*, and *index* must either be the identifier \`*\` or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by *ftype-name*, which allows the fptr to be treated as an array of *ftype-name* objects and *index* as an index into that array. An index of \`*\` or 0 is the same as no index.

The sequence of accessors *a*\` ...\` must specify a valid path through the identified ftype. For \`struct\`, \`union\`, and \`bits\` ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier \`*\` or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length. The field or element specified by the sequence of accessors must be a scalar field, e.g., a pointer field or a field containing a base type such as an \`int\`, \`char\`, or \`double\`.

For \`ftype-set!\`, *val-expr* must evaluate to a value of the appropriate type for the specified field, e.g., an ftype pointer of the appropriate type or an appropriate base-type value.

For both signed and unsigned integer fields, values in the range -2 through 2 - 1 are accepted, where is the width in bits of the integer field. For signed integer fields, values in the range 2 through 2 - 1 are treated as two's complement representations of the corresponding negative numbers. For unsigned integer fields, values in the range -2 through -1 are similarly treated as two's complement representations of the corresponding positive numbers.

\`char\` and \`wchar_t\` (\`wchar\`) field values are converted from (\`ftype-set!\`) or to (\`ftype-ref\`) Scheme characters, as if with \`char->integer\` and \`integer->char\`. Characters stored by \`ftype-set!\` into a \`char\` field must have Unicode scalar values in the range 0 through 255. Under Windows and any other system where \`wchar_t\` (\`wchar\`) is a 16-bit value, characters stored by \`ftype-set!\` into a \`whar_t\` (\`wchar\`) field must have Unicode scalar values in the range 0 through 2 - 1. On systems where \`wchar_t\` is a 32-bit value, any character can be stored in a \`wchar_t\` (\`wchar\`) field.

The examples below assume that \`B\` and \`C\` have been defined as shown in the description of \`ftype-sizeof\` above.

\`(define b\`
\`   (make-ftype-pointer B\`
\`     (foreign-alloc\`
\`       (* (ftype-sizeof B) 3))))\`
\` (define c\`
\`   (make-ftype-pointer C\`
\`     (foreign-alloc (ftype-sizeof C)))) \`
\` \`
\` (ftype-set! B (b1) b 5)\`
\` (ftype-set! B (b1) b 1 6)\`
\` (ftype-set! B (b1) c 5) \`=>\` \`*exception: ftype mismatch*
\` (ftype-set! B (b2) b 0) \`=>\` \`*exception: not a scalar*
\` (ftype-set! B (b2 -1) b 0) \`=>\` \`*exception: invalid index*
\` (ftype-set! B (b2 0) b 50)\`
\` (ftype-set! B (b2 4) b 55)\`
\` (ftype-set! B (b2 10) b 55) \`=>\` \`*exception: invalid index*\` \`
\` \`
\` (ftype-set! C () c (ftype-&ref B () b 1)) \`
\` \`
\` (= (ftype-pointer-address (ftype-ref C () c))      \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (*) c)) \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (-1) c)) \`=>\` #t\`
\`    (ftype-pointer-address b)) \`
\` \`
\` (ftype-ref C (-1 b1) c) \`=>\` 5\`
\` (ftype-ref C (* b1) c) \`=>\` 6\`
\` (ftype-ref C (-1 b2 0) c) \`=>\` 50\`
\` (let ([i 4]) (ftype-ref C (-1 b2 i) c)) \`=>\` 55 \`
\` \`
\` (ftype-set! C (-1 b2 0) c 75)\`
\` (ftype-ref B (b2 0) b) \`=>\` 75\`
\` (foreign-free (ftype-pointer-address c))\`
\` (foreign-free (ftype-pointer-address b))\`
`
    },
    {
        name: "(ftype-set! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index", "val-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s152"),
        description: `**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*val-expr*\`)\`
**syntax**: \`(ftype-set! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\` \`*val-expr*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-ref \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

These forms are used to store values into or retrieve values from the object pointed to by the value of *fptr-expr*, offset by *index*, if present. The value of *fptr-expr* must be an ftype pointer (fptr) of the ftype identified by *ftype-name*, and *index* must either be the identifier \`*\` or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by *ftype-name*, which allows the fptr to be treated as an array of *ftype-name* objects and *index* as an index into that array. An index of \`*\` or 0 is the same as no index.

The sequence of accessors *a*\` ...\` must specify a valid path through the identified ftype. For \`struct\`, \`union\`, and \`bits\` ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier \`*\` or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length. The field or element specified by the sequence of accessors must be a scalar field, e.g., a pointer field or a field containing a base type such as an \`int\`, \`char\`, or \`double\`.

For \`ftype-set!\`, *val-expr* must evaluate to a value of the appropriate type for the specified field, e.g., an ftype pointer of the appropriate type or an appropriate base-type value.

For both signed and unsigned integer fields, values in the range -2 through 2 - 1 are accepted, where is the width in bits of the integer field. For signed integer fields, values in the range 2 through 2 - 1 are treated as two's complement representations of the corresponding negative numbers. For unsigned integer fields, values in the range -2 through -1 are similarly treated as two's complement representations of the corresponding positive numbers.

\`char\` and \`wchar_t\` (\`wchar\`) field values are converted from (\`ftype-set!\`) or to (\`ftype-ref\`) Scheme characters, as if with \`char->integer\` and \`integer->char\`. Characters stored by \`ftype-set!\` into a \`char\` field must have Unicode scalar values in the range 0 through 255. Under Windows and any other system where \`wchar_t\` (\`wchar\`) is a 16-bit value, characters stored by \`ftype-set!\` into a \`whar_t\` (\`wchar\`) field must have Unicode scalar values in the range 0 through 2 - 1. On systems where \`wchar_t\` is a 32-bit value, any character can be stored in a \`wchar_t\` (\`wchar\`) field.

The examples below assume that \`B\` and \`C\` have been defined as shown in the description of \`ftype-sizeof\` above.

\`(define b\`
\`   (make-ftype-pointer B\`
\`     (foreign-alloc\`
\`       (* (ftype-sizeof B) 3))))\`
\` (define c\`
\`   (make-ftype-pointer C\`
\`     (foreign-alloc (ftype-sizeof C)))) \`
\` \`
\` (ftype-set! B (b1) b 5)\`
\` (ftype-set! B (b1) b 1 6)\`
\` (ftype-set! B (b1) c 5) \`=>\` \`*exception: ftype mismatch*
\` (ftype-set! B (b2) b 0) \`=>\` \`*exception: not a scalar*
\` (ftype-set! B (b2 -1) b 0) \`=>\` \`*exception: invalid index*
\` (ftype-set! B (b2 0) b 50)\`
\` (ftype-set! B (b2 4) b 55)\`
\` (ftype-set! B (b2 10) b 55) \`=>\` \`*exception: invalid index*\` \`
\` \`
\` (ftype-set! C () c (ftype-&ref B () b 1)) \`
\` \`
\` (= (ftype-pointer-address (ftype-ref C () c))      \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (*) c)) \`=>\` #t\`
\`    (+ (ftype-pointer-address b) (ftype-sizeof B)))\`
\` (= (ftype-pointer-address (ftype-&ref C (-1) c)) \`=>\` #t\`
\`    (ftype-pointer-address b)) \`
\` \`
\` (ftype-ref C (-1 b1) c) \`=>\` 5\`
\` (ftype-ref C (* b1) c) \`=>\` 6\`
\` (ftype-ref C (-1 b2 0) c) \`=>\` 50\`
\` (let ([i 4]) (ftype-ref C (-1 b2 i) c)) \`=>\` 55 \`
\` \`
\` (ftype-set! C (-1 b2 0) c 75)\`
\` (ftype-ref B (b2 0) b) \`=>\` 75\`
\` (foreign-free (ftype-pointer-address c))\`
\` (foreign-free (ftype-pointer-address b))\`
`
    },
    {
        name: "(ftype-sizeof ",
        endParen: true,
        params: ["ftype-name"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s142"),
        description: `**syntax**: \`(ftype-sizeof \`*ftype-name*\`)\`
**returns: **the size in bytes of the ftype identified by *ftype-name*
**libraries: **\`(chezscheme)\`

The size includes the sizes of any ftypes directly embedded within the identified ftype but excludes those indirectly embedded via a pointer ftype. In the latter case, the size of the pointer is included.

*ftype-name* must not be defined as a function ftype, since the size of a function cannot generally be determined.

\`(define-ftype B\`
\`   (struct\`
\`     [b1 integer-32]\`
\`     [b2 (array 10 integer-32)]))\`
\` (ftype-sizeof B) \`=>\` 44 \`
\` \`
\` (define-ftype C (* B))\`
\` (ftype-sizeof C) \`=>\` 4  \`*; on 32-bit machines*
\` (ftype-sizeof C) \`=>\` 8  \`*; on 64-bit machines*\` \`
\` \`
\` (define-ftype BB\`
\`   (struct\`
\`     [bb1 B]\`
\`     [bb2 (* B)]))\`
\` (- (ftype-sizeof BB) (ftype-sizeof void*)) \`=>\` 44\`
`
    },
    {
        name: "(ftype-spin-lock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-spin-lock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-unlock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(ftype-unlock! ",
        endParen: true,
        params: ["ftype-name", "a", "fptr-expr", "index"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s19"),
        description: `**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-init-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **\`#t\` if the lock is not already locked, \`#f\` otherwise
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-spin-lock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\`)\`
**syntax**: \`(ftype-unlock! \`*ftype-name*\` (\`*a*\` ...) \`*fptr-expr*\` \`*index*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each of these has a syntax like and behaves similarly to \`ftype-set!\` (page ), though with an implicit *val-expr*. In particular, the restrictions on and handling of *fptr-expr* and the accessors *a*\` ...\` is similar, with one important restriction: the field specified by the last accessor, upon which the form operates, must be a word-size integer, i.e., an \`iptr\`, \`uptr\`, or the equivalent, with the native endianness.

\`ftype-init-lock!\` should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined.

\`ftype-lock!\` can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns \`#t\`; if it finds the lock already locked, it returns \`#f\` without changing the lock.

\`ftype-spin-lock!\` can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock.

\`ftype-unlock!\` is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock.
`
    },
    {
        name: "(fx* ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s19"),
        description: `**procedure**: \`(fx* \`*fixnum*\` ...)\`
**returns: **the product of the arguments *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

When called with no arguments, \`fx*\` returns \`1\`.

\`(fx*) \`=>\` 1\`
\` (fx* 1 2) \`=>\` 2\`
\` (fx* 3 -4 5) \`=>\` -60\`
\` (apply fx* '(1 -2 3 -4 5)) \`=>\` 120\`
`
    },
    {
        name: "(fx* ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s159"),
        description: `**procedure**: \`(fx* \`*fx1*\` \`*fx2*\`)\`
**returns: **the product of *fx1* and *fx2*
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fx* -3 4) \`=>\` -12\`
`
    },
    {
        name: "(fx*/carry ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s162"),
        description: `**procedure**: \`(fx+/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**procedure**: \`(fx-/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**procedure**: \`(fx*/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They can be used to implement portable code for multiple-precision arithmetic.

These procedures return the two fixnum values of the following computations. For \`fx+/carry\`:

\`(let* ([s (+ \`*fx1*\` \`*fx2*\` \`*fx3*\`)]\`
\`        [s0 (mod0 s (expt 2 (fixnum-width)))]\`
\`        [s1 (div0 s (expt 2 (fixnum-width)))])\`
\`   (values s0 s1))\`

for \`fx-/carry\`:

\`(let* ([d (- \`*fx1*\` \`*fx2*\` \`*fx3*\`)]\`
\`        [d0 (mod0 d (expt 2 (fixnum-width)))]\`
\`        [d1 (div0 d (expt 2 (fixnum-width)))])\`
\`   (values d0 d1))\`

and for \`fx*/carry\`:

\`(let* ([s (+ (* \`*fx1*\` \`*fx2*\`) \`*fx3*\`)]\`
\`        [s0 (mod0 s (expt 2 (fixnum-width)))]\`
\`        [s1 (div0 s (expt 2 (fixnum-width)))])\`
\`   (values s0 s1))\`
`
    },
    {
        name: "(fx+ ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s17"),
        description: `**procedure**: \`(fx+ \`*fixnum*\` ...)\`
**returns: **the sum of the arguments *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

When called with no arguments, \`fx+\` returns \`0\`.

\`(fx+) \`=>\` 0\`
\` (fx+ 1 2) \`=>\` 3\`
\` (fx+ 3 4 5) \`=>\` 12\`
\` (apply fx+ '(1 2 3 4 5)) \`=>\` 15\`
`
    },
    {
        name: "(fx+ ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s157"),
        description: `**procedure**: \`(fx+ \`*fx1*\` \`*fx2*\`)\`
**returns: **the sum of *fx1* and *fx2*
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fx+ -3 4) \`=>\` 1\`
`
    },
    {
        name: "(fx+/carry ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s162"),
        description: `**procedure**: \`(fx+/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**procedure**: \`(fx-/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**procedure**: \`(fx*/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They can be used to implement portable code for multiple-precision arithmetic.

These procedures return the two fixnum values of the following computations. For \`fx+/carry\`:

\`(let* ([s (+ \`*fx1*\` \`*fx2*\` \`*fx3*\`)]\`
\`        [s0 (mod0 s (expt 2 (fixnum-width)))]\`
\`        [s1 (div0 s (expt 2 (fixnum-width)))])\`
\`   (values s0 s1))\`

for \`fx-/carry\`:

\`(let* ([d (- \`*fx1*\` \`*fx2*\` \`*fx3*\`)]\`
\`        [d0 (mod0 d (expt 2 (fixnum-width)))]\`
\`        [d1 (div0 d (expt 2 (fixnum-width)))])\`
\`   (values d0 d1))\`

and for \`fx*/carry\`:

\`(let* ([s (+ (* \`*fx1*\` \`*fx2*\`) \`*fx3*\`)]\`
\`        [s0 (mod0 s (expt 2 (fixnum-width)))]\`
\`        [s1 (div0 s (expt 2 (fixnum-width)))])\`
\`   (values s0 s1))\`
`
    },
    {
        name: "(fx- ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s18"),
        description: `**procedure**: \`(fx- \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **a fixnum
**libraries: **\`(chezscheme)\`

When called with one argument, \`fx-\` returns the negative of *fixnum1*. Thus, \`(fx- \`*fixnum1*\`)\` is an idiom for \`(fx- 0 \`*fixnum1*\`)\`.

When called with two or more arguments, \`fx-\` returns the result of subtracting the sum of the numbers *fixnum2*\` ...\` from *fixnum1*.

\`(fx- 3) \`=>\` -3\`
\` (fx- 4 3) \`=>\` 1\`
\` (fx- 4 3 2 1) \`=>\` -2\`
`
    },
    {
        name: "(fx- ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s158"),
        description: `**procedure**: \`(fx- \`*fx*\`)\`
**returns: **the additive inverse of *fx*
**procedure**: \`(fx- \`*fx1*\` \`*fx2*\`)\`
**returns: **the difference between *fx1* and *fx2*
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fx- 3) \`=>\` -3\`
\` (fx- -3 4) \`=>\` -7\`
`
    },
    {
        name: "(fx- ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s158"),
        description: `**procedure**: \`(fx- \`*fx*\`)\`
**returns: **the additive inverse of *fx*
**procedure**: \`(fx- \`*fx1*\` \`*fx2*\`)\`
**returns: **the difference between *fx1* and *fx2*
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fx- 3) \`=>\` -3\`
\` (fx- -3 4) \`=>\` -7\`
`
    },
    {
        name: "(fx-/carry ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s162"),
        description: `**procedure**: \`(fx+/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**procedure**: \`(fx-/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**procedure**: \`(fx*/carry \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They can be used to implement portable code for multiple-precision arithmetic.

These procedures return the two fixnum values of the following computations. For \`fx+/carry\`:

\`(let* ([s (+ \`*fx1*\` \`*fx2*\` \`*fx3*\`)]\`
\`        [s0 (mod0 s (expt 2 (fixnum-width)))]\`
\`        [s1 (div0 s (expt 2 (fixnum-width)))])\`
\`   (values s0 s1))\`

for \`fx-/carry\`:

\`(let* ([d (- \`*fx1*\` \`*fx2*\` \`*fx3*\`)]\`
\`        [d0 (mod0 d (expt 2 (fixnum-width)))]\`
\`        [d1 (div0 d (expt 2 (fixnum-width)))])\`
\`   (values d0 d1))\`

and for \`fx*/carry\`:

\`(let* ([s (+ (* \`*fx1*\` \`*fx2*\`) \`*fx3*\`)]\`
\`        [s0 (mod0 s (expt 2 (fixnum-width)))]\`
\`        [s1 (div0 s (expt 2 (fixnum-width)))])\`
\`   (values s0 s1))\`
`
    },
    {
        name: "(fx/ ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s20"),
        description: `**procedure**: \`(fx/ \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`

When called with one argument, \`fx/\` returns the reciprocal of *fixnum1*. That is, \`(fx/ \`*fixnum1*\`)\` is an idiom for \`(fx/ 1 \`*fixnum1*\`)\`.

When called with two or more arguments, \`fx/\` returns the result of dividing *fixnum1* by the product of the remaining arguments *fixnum2*\` ...\`.

\`(fx/ 1) \`=>\` 1\`
\` (fx/ -17) \`=>\` 0\`
\` (fx/ 8 -2) \`=>\` -4\`
\` (fx/ -9 2) \`=>\` -4\`
\` (fx/ 60 5 3 2) \`=>\` 2\`
`
    },
    {
        name: "(fx1+ ",
        endParen: true,
        params: ["fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s21"),
        description: `**procedure**: \`(fx1+ \`*fixnum*\`)\`
**procedure**: \`(fx1- \`*fixnum*\`)\`
**returns: ***fixnum* plus 1 or *fixnum* minus 1
**libraries: **\`(chezscheme)\`

\`(define fxplus\`
\`   (lambda (x y)\`
\`     (if (fxzero? x)\`
\`         y\`
\`         (fxplus (fx1- x) (fx1+ y))))) \`
\` \`
\` (fxplus 7 8) \`=>\` 15\`

\`fx1+\` and \`fx1-\` can be defined as follows:

\`(define fx1+ (lambda (x) (fx+ x 1)))\`
\` (define fx1- (lambda (x) (fx- x 1)))\`
`
    },
    {
        name: "(fx1- ",
        endParen: true,
        params: ["fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s21"),
        description: `**procedure**: \`(fx1+ \`*fixnum*\`)\`
**procedure**: \`(fx1- \`*fixnum*\`)\`
**returns: ***fixnum* plus 1 or *fixnum* minus 1
**libraries: **\`(chezscheme)\`

\`(define fxplus\`
\`   (lambda (x y)\`
\`     (if (fxzero? x)\`
\`         y\`
\`         (fxplus (fx1- x) (fx1+ y))))) \`
\` \`
\` (fxplus 7 8) \`=>\` 15\`

\`fx1+\` and \`fx1-\` can be defined as follows:

\`(define fx1+ (lambda (x) (fx+ x 1)))\`
\` (define fx1- (lambda (x) (fx- x 1)))\`
`
    },
    {
        name: "(fx< ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s15"),
        description: `**procedure**: \`(fx= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx< \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx> \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx<= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx>= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fx=\` returns \`#t\` if its arguments are equal. The predicate \`fx<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

These procedures are similar to the Revised Report procedures \`fx=?\`, \`fx<?\`, \`fx>?\`, \`fx<=?\`, and \`fx>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fx= 0) \`=>\` #t\`
\` (fx= 0 0) \`=>\` #t\`
\` (fx< (most-negative-fixnum) 0 (most-positive-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<= 0 x 9)) \`=>\` #t\`
\` (fx<= 0 3 3) \`=>\` #t\`
\` (fx>= 0 0 (most-negative-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx<= ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s15"),
        description: `**procedure**: \`(fx= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx< \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx> \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx<= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx>= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fx=\` returns \`#t\` if its arguments are equal. The predicate \`fx<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

These procedures are similar to the Revised Report procedures \`fx=?\`, \`fx<?\`, \`fx>?\`, \`fx<=?\`, and \`fx>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fx= 0) \`=>\` #t\`
\` (fx= 0 0) \`=>\` #t\`
\` (fx< (most-negative-fixnum) 0 (most-positive-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<= 0 x 9)) \`=>\` #t\`
\` (fx<= 0 3 3) \`=>\` #t\`
\` (fx>= 0 0 (most-negative-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx<=? ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s153"),
        description: `**procedure**: \`(fx=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

The predicate \`fx=?\` returns \`#t\` if its arguments are equal. The predicate \`fx<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=?\` returns \`#t\` if its arguments are monotonically nonincreasing.

\`(fx=? 0 0) \`=>\` #t\`
\` (fx=? -1 1) \`=>\` #f\`
\` (fx<? (least-fixnum) 0 (greatest-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<=? 0 x 9)) \`=>\` #t\`
\` (fx>? 5 4 3 2 1) \`=>\` #t\`
\` (fx<=? 1 3 2) \`=>\` #f\`
\` (fx>=? 0 0 (least-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx<? ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s153"),
        description: `**procedure**: \`(fx=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

The predicate \`fx=?\` returns \`#t\` if its arguments are equal. The predicate \`fx<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=?\` returns \`#t\` if its arguments are monotonically nonincreasing.

\`(fx=? 0 0) \`=>\` #t\`
\` (fx=? -1 1) \`=>\` #f\`
\` (fx<? (least-fixnum) 0 (greatest-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<=? 0 x 9)) \`=>\` #t\`
\` (fx>? 5 4 3 2 1) \`=>\` #t\`
\` (fx<=? 1 3 2) \`=>\` #f\`
\` (fx>=? 0 0 (least-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx= ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s15"),
        description: `**procedure**: \`(fx= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx< \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx> \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx<= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx>= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fx=\` returns \`#t\` if its arguments are equal. The predicate \`fx<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

These procedures are similar to the Revised Report procedures \`fx=?\`, \`fx<?\`, \`fx>?\`, \`fx<=?\`, and \`fx>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fx= 0) \`=>\` #t\`
\` (fx= 0 0) \`=>\` #t\`
\` (fx< (most-negative-fixnum) 0 (most-positive-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<= 0 x 9)) \`=>\` #t\`
\` (fx<= 0 3 3) \`=>\` #t\`
\` (fx>= 0 0 (most-negative-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx=? ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s153"),
        description: `**procedure**: \`(fx=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

The predicate \`fx=?\` returns \`#t\` if its arguments are equal. The predicate \`fx<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=?\` returns \`#t\` if its arguments are monotonically nonincreasing.

\`(fx=? 0 0) \`=>\` #t\`
\` (fx=? -1 1) \`=>\` #f\`
\` (fx<? (least-fixnum) 0 (greatest-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<=? 0 x 9)) \`=>\` #t\`
\` (fx>? 5 4 3 2 1) \`=>\` #t\`
\` (fx<=? 1 3 2) \`=>\` #f\`
\` (fx>=? 0 0 (least-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx> ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s15"),
        description: `**procedure**: \`(fx= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx< \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx> \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx<= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx>= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fx=\` returns \`#t\` if its arguments are equal. The predicate \`fx<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

These procedures are similar to the Revised Report procedures \`fx=?\`, \`fx<?\`, \`fx>?\`, \`fx<=?\`, and \`fx>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fx= 0) \`=>\` #t\`
\` (fx= 0 0) \`=>\` #t\`
\` (fx< (most-negative-fixnum) 0 (most-positive-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<= 0 x 9)) \`=>\` #t\`
\` (fx<= 0 3 3) \`=>\` #t\`
\` (fx>= 0 0 (most-negative-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx>= ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s15"),
        description: `**procedure**: \`(fx= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx< \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx> \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx<= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**procedure**: \`(fx>= \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The predicate \`fx=\` returns \`#t\` if its arguments are equal. The predicate \`fx<\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=\` returns \`#t\` if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns \`#t\`.

These procedures are similar to the Revised Report procedures \`fx=?\`, \`fx<?\`, \`fx>?\`, \`fx<=?\`, and \`fx>=?\` except that the Revised Report procedures require two or more arguments, and their names have the "\`?\`" suffix.

\`(fx= 0) \`=>\` #t\`
\` (fx= 0 0) \`=>\` #t\`
\` (fx< (most-negative-fixnum) 0 (most-positive-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<= 0 x 9)) \`=>\` #t\`
\` (fx<= 0 3 3) \`=>\` #t\`
\` (fx>= 0 0 (most-negative-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx>=? ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s153"),
        description: `**procedure**: \`(fx=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

The predicate \`fx=?\` returns \`#t\` if its arguments are equal. The predicate \`fx<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=?\` returns \`#t\` if its arguments are monotonically nonincreasing.

\`(fx=? 0 0) \`=>\` #t\`
\` (fx=? -1 1) \`=>\` #f\`
\` (fx<? (least-fixnum) 0 (greatest-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<=? 0 x 9)) \`=>\` #t\`
\` (fx>? 5 4 3 2 1) \`=>\` #t\`
\` (fx<=? 1 3 2) \`=>\` #f\`
\` (fx>=? 0 0 (least-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fx>? ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s153"),
        description: `**procedure**: \`(fx=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx<=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**procedure**: \`(fx>=? \`*fx1*\` \`*fx2*\` \`*fx3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

The predicate \`fx=?\` returns \`#t\` if its arguments are equal. The predicate \`fx<?\` returns \`#t\` if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while \`fx>?\` returns \`#t\` if its arguments are monotonically decreasing. The predicate \`fx<=?\` returns \`#t\` if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while \`fx>=?\` returns \`#t\` if its arguments are monotonically nonincreasing.

\`(fx=? 0 0) \`=>\` #t\`
\` (fx=? -1 1) \`=>\` #f\`
\` (fx<? (least-fixnum) 0 (greatest-fixnum)) \`=>\` #t\`
\` (let ([x 3]) (fx<=? 0 x 9)) \`=>\` #t\`
\` (fx>? 5 4 3 2 1) \`=>\` #t\`
\` (fx<=? 1 3 2) \`=>\` #f\`
\` (fx>=? 0 0 (least-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fxabs ",
        endParen: true,
        params: ["fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s25"),
        description: `**procedure**: \`(fxabs \`*fixnum*\`)\`
**returns: **the absolute value of *fixnum*
**libraries: **\`(chezscheme)\`

\` (fxabs 1) \`=>\` 1\`
\` (fxabs -1) \`=>\` 1\`
\` (fxabs 0) \`=>\` 0\`
`
    },
    {
        name: "(fxand ",
        endParen: true,
        params: ["fx", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s163"),
        description: `**procedure**: \`(fxnot \`*fx*\`)\`
**returns: **the bitwise not of *fx*
**procedure**: \`(fxand \`*fx*\` ...)\`
**returns: **the bitwise and of *fx*\` ...\`
**procedure**: \`(fxior \`*fx*\` ...)\`
**returns: **the bitwise inclusive or of *fx*\` ...\`
**procedure**: \`(fxxor \`*fx*\` ...)\`
**returns: **the bitwise exclusive or of *fx*\` ...\`
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxnot 0) \`=>\` -1\`
\` (fxnot 3) \`=>\` -4 \`
\` \`
\` (fxand #b01101 #b00111) \`=>\` #b00101\`
\` (fxior #b01101 #b00111) \`=>\` #b01111\`
\` (fxxor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(fxarithmetic-shift ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s173"),
        description: `**procedure**: \`(fxarithmetic-shift \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

The absolute value of *fx2* must be less than the value of \`(fixnum-width)\`. If *fx2* is negative, \`fxarithmetic-shift\` returns the result of arithmetically shifting *fx1* right by *fx2* bits. Otherwise, \`fxarithmetic-shift\` returns the result of shifting *fx1* left by *fx2* bits.

\`(fxarithmetic-shift #b10000 -3) \`=>\` #b00010\`
\` (fxarithmetic-shift -1 -1) \`=>\` -1\`
\` (fxarithmetic-shift -64 -3) \`=>\` -8\`
\` (fxarithmetic-shift #b00010 2) \`=>\` #b01000\`
\` (fxarithmetic-shift -1 2) \`=>\` -4\`

Thus, \`fxarithmetic-shift\` behaves as if defined as follows.

\`(define fxarithmetic-shift\`
\`   (lambda (fx1 fx2)\`
\`     (if (fx<? fx2 0)\`
\`         (fxarithmetic-shift-right fx1 (fx- fx2))\`
\`         (fxarithmetic-shift-left fx1 fx2))))\`
`
    },
    {
        name: "(fxarithmetic-shift-left ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s172"),
        description: `**procedure**: \`(fxarithmetic-shift-right \`*fx1*\` \`*fx2*\`)\`
**returns: ***fx1* arithmetically shifted right by *fx2* bits
**procedure**: \`(fxarithmetic-shift-left \`*fx1*\` \`*fx2*\`)\`
**returns: ***fx1* shifted left by *fx2* bits
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must be nonnegative and less than the value of \`(fixnum-width)\`.

\`(fxarithmetic-shift-right #b10000 3) \`=>\` #b00010\`
\` (fxarithmetic-shift-right -1 1) \`=>\` -1\`
\` (fxarithmetic-shift-right -64 3) \`=>\` -8 \`
\` \`
\` (fxarithmetic-shift-left #b00010 2) \`=>\` #b01000\`
\` (fxarithmetic-shift-left -1 2) \`=>\` -4\`
`
    },
    {
        name: "(fxarithmetic-shift-right ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s172"),
        description: `**procedure**: \`(fxarithmetic-shift-right \`*fx1*\` \`*fx2*\`)\`
**returns: ***fx1* arithmetically shifted right by *fx2* bits
**procedure**: \`(fxarithmetic-shift-left \`*fx1*\` \`*fx2*\`)\`
**returns: ***fx1* shifted left by *fx2* bits
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must be nonnegative and less than the value of \`(fixnum-width)\`.

\`(fxarithmetic-shift-right #b10000 3) \`=>\` #b00010\`
\` (fxarithmetic-shift-right -1 1) \`=>\` -1\`
\` (fxarithmetic-shift-right -64 3) \`=>\` -8 \`
\` \`
\` (fxarithmetic-shift-left #b00010 2) \`=>\` #b01000\`
\` (fxarithmetic-shift-left -1 2) \`=>\` -4\`
`
    },
    {
        name: "(fxbit-count ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s165"),
        description: `**procedure**: \`(fxbit-count \`*fx*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

For nonnegative inputs, \`fxbit-count\` returns the number of bits set in the two's complement representation of *fx*. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in *fx*, which is equivalent to \`(fxnot (fxbit-count (fxnot \`*fx*\`)))\`.

\`(fxbit-count #b00000) \`=>\` 0\`
\` (fxbit-count #b00001) \`=>\` 1\`
\` (fxbit-count #b00100) \`=>\` 1\`
\` (fxbit-count #b10101) \`=>\` 3 \`
\` \`
\` (fxbit-count -1) \`=>\` -1\`
\` (fxbit-count -2) \`=>\` -2\`
\` (fxbit-count -4) \`=>\` -3\`
`
    },
    {
        name: "(fxbit-field ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s170"),
        description: `**procedure**: \`(fxbit-field \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* and *fx3* must be nonnegative and less than the value of \`(fixnum-width)\`, and *fx2* must not be greater than *fx3*. This procedure returns the number represented by extracting from *fx1* the sequence of bits from *fx2* (inclusive) to *fx3* (exclusive).

\`(fxbit-field #b10110 0 3) \`=>\` #b00110\`
\` (fxbit-field #b10110 1 3) \`=>\` #b00011\`
\` (fxbit-field #b10110 2 3) \`=>\` #b00001\`
\` (fxbit-field #b10110 3 3) \`=>\` #b00000\`
`
    },
    {
        name: "(fxbit-set? ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s168"),
        description: `**procedure**: \`(fxbit-set? \`*fx1*\` \`*fx2*\`)\`
**returns: **\`#t\` if bit *fx2* of *fx1* is set, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must be nonnegative. It is taken as a zero-based index for the bits in the two's complement representation of *fx1*, with the sign bit virtually replicated an infinite number of positions to the left.

\`(fxbit-set? #b01011 0) \`=>\` #t\`
\` (fxbit-set? #b01011 2) \`=>\` #f \`
\` \`
\` (fxbit-set? -1 0) \`=>\` #t\`
\` (fxbit-set? -1 20) \`=>\` #t\`
\` (fxbit-set? -3 1) \`=>\` #f\`
\` (fxbit-set? 0 (- (fixnum-width) 1)) \`=>\` #f\`
\` (fxbit-set? -1 (- (fixnum-width) 1)) \`=>\` #t\`
`
    },
    {
        name: "(fxcopy-bit ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s169"),
        description: `**procedure**: \`(fxcopy-bit \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: ***fx1* with bit *fx2* replaced by *fx3*
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must be nonnegative and less than the value of \`(- (fixnum-width) 1)\`. *fx3* must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of *fx3*.

\`(fxcopy-bit #b01110 0 1) \`=>\` #b01111\`
\` (fxcopy-bit #b01110 2 0) \`=>\` #b01010\`
`
    },
    {
        name: "(fxcopy-bit-field ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "fx4"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s171"),
        description: `**procedure**: \`(fxcopy-bit-field \`*fx1*\` \`*fx2*\` \`*fx3*\` \`*fx4*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* and *fx3* must be nonnegative and less than the value of \`(fixnum-width)\`, and *fx2* must not be greater than *fx3*. This procedure returns *fx1* with *n* bits from *fx2* (inclusive) to *fx3* (exclusive) replaced by the low-order *n* bits of *x4*.

\`(fxcopy-bit-field #b10000 0 3 #b10101) \`=>\` #b10101\`
\` (fxcopy-bit-field #b10000 1 3 #b10101) \`=>\` #b10010\`
\` (fxcopy-bit-field #b10000 2 3 #b10101) \`=>\` #b10100\`
\` (fxcopy-bit-field #b10000 3 3 #b10101) \`=>\` #b10000\`
`
    },
    {
        name: "(fxdiv ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s160"),
        description: `**procedure**: \`(fxdiv \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxmod \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxdiv-and-mod \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must not be zero. These are fixnum-specific versions of the generic \`div\`, \`mod\`, and \`div-and-mod\`.

\`(fxdiv 17 3) \`=>\` 5\`
\` (fxmod 17 3) \`=>\` 2\`
\` (fxdiv -17 3) \`=>\` -6\`
\` (fxmod -17 3) \`=>\` 1\`
\` (fxdiv 17 -3) \`=>\` -5\`
\` (fxmod 17 -3) \`=>\` 2\`
\` (fxdiv -17 -3) \`=>\` 6\`
\` (fxmod -17 -3) \`=>\` 1 \`
\` \`
\` (fxdiv-and-mod 17 3) \`=>\` 5\`
\`                      \`\` 2\`
`
    },
    {
        name: "(fxdiv-and-mod ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s160"),
        description: `**procedure**: \`(fxdiv \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxmod \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxdiv-and-mod \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must not be zero. These are fixnum-specific versions of the generic \`div\`, \`mod\`, and \`div-and-mod\`.

\`(fxdiv 17 3) \`=>\` 5\`
\` (fxmod 17 3) \`=>\` 2\`
\` (fxdiv -17 3) \`=>\` -6\`
\` (fxmod -17 3) \`=>\` 1\`
\` (fxdiv 17 -3) \`=>\` -5\`
\` (fxmod 17 -3) \`=>\` 2\`
\` (fxdiv -17 -3) \`=>\` 6\`
\` (fxmod -17 -3) \`=>\` 1 \`
\` \`
\` (fxdiv-and-mod 17 3) \`=>\` 5\`
\`                      \`\` 2\`
`
    },
    {
        name: "(fxdiv0 ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s161"),
        description: `**procedure**: \`(fxdiv0 \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxmod0 \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxdiv0-and-mod0 \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must not be zero. These are fixnum-specific versions of the generic \`div0\`, \`mod0\`, and \`div0-and-mod0\`.

\`(fxdiv0 17 3) \`=>\` 6\`
\` (fxmod0 17 3) \`=>\` -1\`
\` (fxdiv0 -17 3) \`=>\` -6\`
\` (fxmod0 -17 3) \`=>\` 1\`
\` (fxdiv0 17 -3) \`=>\` -6\`
\` (fxmod0 17 -3) \`=>\` -1\`
\` (fxdiv0 -17 -3) \`=>\` 6\`
\` (fxmod0 -17 -3) \`=>\` 1 \`
\` \`
\` (fxdiv0-and-mod0 17 3) \`=>\` 6\`
\`                        \`\` -1\`
`
    },
    {
        name: "(fxdiv0-and-mod0 ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s161"),
        description: `**procedure**: \`(fxdiv0 \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxmod0 \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxdiv0-and-mod0 \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must not be zero. These are fixnum-specific versions of the generic \`div0\`, \`mod0\`, and \`div0-and-mod0\`.

\`(fxdiv0 17 3) \`=>\` 6\`
\` (fxmod0 17 3) \`=>\` -1\`
\` (fxdiv0 -17 3) \`=>\` -6\`
\` (fxmod0 -17 3) \`=>\` 1\`
\` (fxdiv0 17 -3) \`=>\` -6\`
\` (fxmod0 17 -3) \`=>\` -1\`
\` (fxdiv0 -17 -3) \`=>\` 6\`
\` (fxmod0 -17 -3) \`=>\` 1 \`
\` \`
\` (fxdiv0-and-mod0 17 3) \`=>\` 6\`
\`                        \`\` -1\`
`
    },
    {
        name: "(fxeven? ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s155"),
        description: `**procedure**: \`(fxeven? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is even, \`#f\` otherwise
**procedure**: \`(fxodd? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is odd, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxeven? 0) \`=>\` #t\`
\` (fxeven? 1) \`=>\` #f\`
\` (fxeven? -1) \`=>\` #f\`
\` (fxeven? -10) \`=>\` #t \`
\` \`
\` (fxodd? 0) \`=>\` #f\`
\` (fxodd? 1) \`=>\` #t\`
\` (fxodd? -1) \`=>\` #t\`
\` (fxodd? -10) \`=>\` #f\`
`
    },
    {
        name: "(fxfirst-bit-set ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s167"),
        description: `**procedure**: \`(fxfirst-bit-set \`*fx*\`)\`
**returns: **the index of the least significant bit set in *fx*
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

If *fx* is 0, \`fxfirst-bit-set\` returns -1.

\`(fxfirst-bit-set #b00000) \`=>\` -1\`
\` (fxfirst-bit-set #b00001) \`=>\` 0\`
\` (fxfirst-bit-set #b01100) \`=>\` 2 \`
\` \`
\` (fxfirst-bit-set -1) \`=>\` 0\`
\` (fxfirst-bit-set -2) \`=>\` 1\`
\` (fxfirst-bit-set -3) \`=>\` 0\`
`
    },
    {
        name: "(fxif ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s164"),
        description: `**procedure**: \`(fxif \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: **the bitwise "if" of its arguments
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

For each bit set in *fx1*, the corresponding bit of the result is taken from *fx2*, and for each bit not set in *fx1*, the corresponding bit of the result is taken from *x3*.

\`(fxif #b101010 #b111000 #b001100) \`=>\` #b101100\`

\`fxif\` might be defined as follows:

\`(define fxif\`
\`   (lambda (fx1 fx2 fx3)\`
\`     (fxior (fxand fx1 fx2)\`
\`            (fxand (fxnot fx1) fx3))))\`
`
    },
    {
        name: "(fxior ",
        endParen: true,
        params: ["fx", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s163"),
        description: `**procedure**: \`(fxnot \`*fx*\`)\`
**returns: **the bitwise not of *fx*
**procedure**: \`(fxand \`*fx*\` ...)\`
**returns: **the bitwise and of *fx*\` ...\`
**procedure**: \`(fxior \`*fx*\` ...)\`
**returns: **the bitwise inclusive or of *fx*\` ...\`
**procedure**: \`(fxxor \`*fx*\` ...)\`
**returns: **the bitwise exclusive or of *fx*\` ...\`
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxnot 0) \`=>\` -1\`
\` (fxnot 3) \`=>\` -4 \`
\` \`
\` (fxand #b01101 #b00111) \`=>\` #b00101\`
\` (fxior #b01101 #b00111) \`=>\` #b01111\`
\` (fxxor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(fxlength ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s166"),
        description: `**procedure**: \`(fxlength \`*fx*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

This procedure returns the number of bits of the smallest two's complement representation of *fx*, not including the sign bit for negative numbers. For 0 \`fxlength\` returns 0.

\`(fxlength #b00000) \`=>\` 0\`
\` (fxlength #b00001) \`=>\` 1\`
\` (fxlength #b00100) \`=>\` 3\`
\` (fxlength #b00110) \`=>\` 3 \`
\` \`
\` (fxlength -1) \`=>\` 0\`
\` (fxlength -6) \`=>\` 3\`
\` (fxlength -9) \`=>\` 4\`
`
    },
    {
        name: "(fxlogand ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s53"),
        description: `**procedure**: \`(fxlogand \`*fixnum*\` ...)\`
**returns: **the logical "and" of the arguments *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`fxlogand\` returns -1, i.e., all bits set.

\`(fxlogand) \`=>\` -1\`
\` (fxlogand 15) \`=>\` 15\`
\` (fxlogand -1 -1) \`=>\` -1\`
\` (fxlogand -1 0) \`=>\` 0\`
\` (fxlogand 5 3) \`=>\` 1\`
\` (fxlogand #b111000 #b101010) \`=>\` #b101000\`
\` (fxlogand #b1100 #b1111 #b1101) \`=>\` #b1100\`
`
    },
    {
        name: "(fxlogbit0 ",
        endParen: true,
        params: ["index", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s59"),
        description: `**procedure**: \`(fxlogbit0 \`*index*\` \`*fixnum*\`)\`
**returns: **the result of clearing bit *index* of *fixnum*
**libraries: **\`(chezscheme)\`

*fixnum* is treated as a two's complement integer, regardless of the underlying representation. *index* must be nonnegative and less than the number of bits in a fixnum, excluding the sign bit, i.e., less than \`(integer-length (most-positive-fixnum))\`. The index is zero-based, counting from the lowest-order toward higher-order bits.

\`fxlogbit0\` is equivalent to

\`(lambda (i n) (fxlogand (fxlognot (fxsll 1 i)) n))\`

but more efficient.

\`(fxlogbit0 3 #b10101010) \`=>\` #b10100010\`
\` (fxlogbit0 4 #b10101010) \`=>\` #b10101010\`
\` (fxlogbit0 0 -1) \`=>\` -2\`
`
    },
    {
        name: "(fxlogbit1 ",
        endParen: true,
        params: ["index", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s60"),
        description: `**procedure**: \`(fxlogbit1 \`*index*\` \`*fixnum*\`)\`
**returns: **the result of setting bit *index* of *fixnum*
**libraries: **\`(chezscheme)\`

*fixnum* is treated as a two's complement integer, regardless of the underlying representation. *index* must be nonnegative and less than the number of bits in a fixnum, excluding the sign bit, i.e., less than \`(integer-length (most-positive-fixnum))\`. The index is zero-based, counting from the lowest-order toward higher-order bits.

\`fxlogbit1\` is equivalent to

\`(lambda (i n) (fxlogor (fxsll 1 i) n))\`

but more efficient.

\`(fxlogbit1 3 #b10101010) \`=>\` #b10101010\`
\` (fxlogbit1 4 #b10101010) \`=>\` #b10111010\`
\` (fxlogbit1 4 0) \`=>\` #b10000\`
\` (fxlogbit1 0 -2) \`=>\` -1\`
`
    },
    {
        name: "(fxlogbit? ",
        endParen: true,
        params: ["index", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s57"),
        description: `**procedure**: \`(fxlogbit? \`*index*\` \`*fixnum*\`)\`
**returns: **\`#t\` if the specified bit is set, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*index* must be a nonnegative fixnum. *fixnum* is treated as a two's complement integer, regardless of the underlying representation.

\`fxlogbit?\` returns \`#t\` if the bit at index *index* of *fixnum* is set (one) and \`#f\` otherwise. The index is zero-based, counting from the lowest-order toward higher-order bits. The index is limited only by the fixnum range; for nonnegative values of *fixnum*, the bits above the highest order set bit are all considered to be zero, and for negative values, the bits above the highest order reset bit are all considered to be one.

\`(fxlogbit? 0 #b1110) \`=>\` #f\`
\` (fxlogbit? 1 #b1110) \`=>\` #t\`
\` (fxlogbit? 2 #b1110) \`=>\` #t\`
\` (fxlogbit? 3 #b1110) \`=>\` #t\`
\` (fxlogbit? 4 #b1110) \`=>\` #f\`
\` (fxlogbit? 100 #b1110) \`=>\` #f \`
\` \`
\` (fxlogbit? 0 -6) \`=>\` #f  ; \`*the two's complement of*\` -6 \`*is*\` 1...1010\`
\` (fxlogbit? 1 -6) \`=>\` #t\`
\` (fxlogbit? 2 -6) \`=>\` #f\`
\` (fxlogbit? 3 -6) \`=>\` #t\`
\` (fxlogbit? 100 -6) \`=>\` #t \`
\` \`
\` (fxlogbit? (random 1000000) 0) \`=>\` #f\`
\` (fxlogbit? (random 1000000) -1) \`=>\` #t\`
`
    },
    {
        name: "(fxlogior ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s54"),
        description: `**procedure**: \`(fxlogior \`*fixnum*\` ...)\`
**procedure**: \`(fxlogor \`*fixnum*\` ...)\`
**returns: **the logical "or" of the arguments *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`fxlogior\` returns 0, i.e., all bits reset.

\`(fxlogior) \`=>\` 0\`
\` (fxlogior 15) \`=>\` 15\`
\` (fxlogior -1 -1) \`=>\` -1\`
\` (fxlogior -1 0) \`=>\` -1\`
\` (fxlogior #b111000 #b101010) \`=>\` #b111010\`
\` (fxlogior #b1000 #b0100 #b0010) \`=>\` #b1110\`
\` (apply fxlogior '(1 2 4 8 16)) \`=>\` 31\`
`
    },
    {
        name: "(fxlognot ",
        endParen: true,
        params: ["fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s56"),
        description: `**procedure**: \`(fxlognot \`*fixnum*\`)\`
**returns: **the logical "not" of *fixnum*
**libraries: **\`(chezscheme)\`

The argument is treated as a two's complement integer, regardless of the underlying representation.

\`(fxlognot -1) \`=>\` 0\`
\` (fxlognot 0) \`=>\` -1\`
\` (fxlognot 1) \`=>\` -2\`
\` (fxlognot -2) \`=>\` 1\`
`
    },
    {
        name: "(fxlogor ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s54"),
        description: `**procedure**: \`(fxlogior \`*fixnum*\` ...)\`
**procedure**: \`(fxlogor \`*fixnum*\` ...)\`
**returns: **the logical "or" of the arguments *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`fxlogior\` returns 0, i.e., all bits reset.

\`(fxlogior) \`=>\` 0\`
\` (fxlogior 15) \`=>\` 15\`
\` (fxlogior -1 -1) \`=>\` -1\`
\` (fxlogior -1 0) \`=>\` -1\`
\` (fxlogior #b111000 #b101010) \`=>\` #b111010\`
\` (fxlogior #b1000 #b0100 #b0010) \`=>\` #b1110\`
\` (apply fxlogior '(1 2 4 8 16)) \`=>\` 31\`
`
    },
    {
        name: "(fxlogtest ",
        endParen: true,
        params: ["fixnum1", "fixnum2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s58"),
        description: `**procedure**: \`(fxlogtest \`*fixnum1*\` \`*fixnum2*\`)\`
**returns: **\`#t\` if any common bits are set, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

The arguments are treated as two's complement integers, regardless of the underlying representation.

\`fxlogtest\` returns \`#t\` if any bit set in one argument is also set in the other. It returns \`#f\` if the two arguments have no set bits in common.

\`(fxlogtest #b10001 #b1110) \`=>\` #f\`
\` (fxlogtest #b10101 #b1110) \`=>\` #t\`
\` (fxlogtest #b111000 #b110111) \`=>\` #t \`
\` \`
\` (fxlogtest #b101 -6) \`=>\` #f  ; \`*the two's complement of*\` -6 \`*is*\` 1...1010\`
\` (fxlogtest #b1000 -6) \`=>\` #t\`
\` (fxlogtest 100 -6) \`=>\` #t \`
\` \`
\` (fxlogtest (+ (random 1000000) 1) 0) \`=>\` #f\`
\` (fxlogtest (+ (random 1000000) 1) -1) \`=>\` #t\`
`
    },
    {
        name: "(fxlogxor ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s55"),
        description: `**procedure**: \`(fxlogxor \`*fixnum*\` ...)\`
**returns: **the logical "exclusive or" of the arguments *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`fxlogxor\` returns 0, i.e., all bits reset.

\`(fxlogxor) \`=>\` 0\`
\` (fxlogxor 15) \`=>\` 15\`
\` (fxlogxor -1 -1) \`=>\` 0\`
\` (fxlogxor -1 0) \`=>\` -1\`
\` (fxlogxor 5 3) \`=>\` 6\`
\` (fxlogxor #b111000 #b101010) \`=>\` #b010010\`
\` (fxlogxor #b1100 #b0100 #b0110) \`=>\` #b1110\`
`
    },
    {
        name: "(fxmax ",
        endParen: true,
        params: ["fx1", "fx2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s156"),
        description: `**procedure**: \`(fxmin \`*fx1*\` \`*fx2*\` ...)\`
**returns: **the minimum of *fx1* *fx2* ...
**procedure**: \`(fxmax \`*fx1*\` \`*fx2*\` ...)\`
**returns: **the maximum of *fx1* *fx2* ...
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxmin 4 -7 2 0 -6) \`=>\` -7 \`
\` \`
\` (let ([ls '(7 3 5 2 9 8)])\`
\`   (apply fxmin ls)) \`=>\` 2 \`
\` \`
\` (fxmax 4 -7 2 0 -6) \`=>\` 4 \`
\` \`
\` (let ([ls '(7 3 5 2 9 8)])\`
\`   (apply fxmax ls)) \`=>\` 9\`
`
    },
    {
        name: "(fxmin ",
        endParen: true,
        params: ["fx1", "fx2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s156"),
        description: `**procedure**: \`(fxmin \`*fx1*\` \`*fx2*\` ...)\`
**returns: **the minimum of *fx1* *fx2* ...
**procedure**: \`(fxmax \`*fx1*\` \`*fx2*\` ...)\`
**returns: **the maximum of *fx1* *fx2* ...
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxmin 4 -7 2 0 -6) \`=>\` -7 \`
\` \`
\` (let ([ls '(7 3 5 2 9 8)])\`
\`   (apply fxmin ls)) \`=>\` 2 \`
\` \`
\` (fxmax 4 -7 2 0 -6) \`=>\` 4 \`
\` \`
\` (let ([ls '(7 3 5 2 9 8)])\`
\`   (apply fxmax ls)) \`=>\` 9\`
`
    },
    {
        name: "(fxmod ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s160"),
        description: `**procedure**: \`(fxdiv \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxmod \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxdiv-and-mod \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must not be zero. These are fixnum-specific versions of the generic \`div\`, \`mod\`, and \`div-and-mod\`.

\`(fxdiv 17 3) \`=>\` 5\`
\` (fxmod 17 3) \`=>\` 2\`
\` (fxdiv -17 3) \`=>\` -6\`
\` (fxmod -17 3) \`=>\` 1\`
\` (fxdiv 17 -3) \`=>\` -5\`
\` (fxmod 17 -3) \`=>\` 2\`
\` (fxdiv -17 -3) \`=>\` 6\`
\` (fxmod -17 -3) \`=>\` 1 \`
\` \`
\` (fxdiv-and-mod 17 3) \`=>\` 5\`
\`                      \`\` 2\`
`
    },
    {
        name: "(fxmod0 ",
        endParen: true,
        params: ["fx1", "fx2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s161"),
        description: `**procedure**: \`(fxdiv0 \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxmod0 \`*fx1*\` \`*fx2*\`)\`
**procedure**: \`(fxdiv0-and-mod0 \`*fx1*\` \`*fx2*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* must not be zero. These are fixnum-specific versions of the generic \`div0\`, \`mod0\`, and \`div0-and-mod0\`.

\`(fxdiv0 17 3) \`=>\` 6\`
\` (fxmod0 17 3) \`=>\` -1\`
\` (fxdiv0 -17 3) \`=>\` -6\`
\` (fxmod0 -17 3) \`=>\` 1\`
\` (fxdiv0 17 -3) \`=>\` -6\`
\` (fxmod0 17 -3) \`=>\` -1\`
\` (fxdiv0 -17 -3) \`=>\` 6\`
\` (fxmod0 -17 -3) \`=>\` 1 \`
\` \`
\` (fxdiv0-and-mod0 17 3) \`=>\` 6\`
\`                        \`\` -1\`
`
    },
    {
        name: "(fxmodulo ",
        endParen: true,
        params: ["fixnum1", "fixnum2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s24"),
        description: `**procedure**: \`(fxmodulo \`*fixnum1*\` \`*fixnum2*\`)\`
**returns: **the fixnum modulus of *fixnum1* and *fixnum2*
**libraries: **\`(chezscheme)\`

The result of \`fxmodulo\` has the same sign as *fixnum2*.

\`(fxmodulo 16 4) \`=>\` 0\`
\` (fxmodulo 5 2) \`=>\` 1\`
\` (fxmodulo -45 7) \`=>\` 4\`
\` (fxmodulo 10 -3) \`=>\` -2\`
\` (fxmodulo -17 -9) \`=>\` -8\`
`
    },
    {
        name: "(fxnegative? ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s154"),
        description: `**procedure**: \`(fxzero? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is zero, \`#f\` otherwise
**procedure**: \`(fxpositive? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is greater than zero, \`#f\` otherwise
**procedure**: \`(fxnegative? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\`fxzero?\` is equivalent to \`(lambda (x) (fx=? x 0))\`, \`fxpositive?\` is equivalent to \`(lambda (x) (fx>? x 0))\`, and \`fxnegative?\` to \`(lambda (x) (fx<? x 0))\`.

\`(fxzero? 0) \`=>\` #t\`
\` (fxzero? 1) \`=>\` #f \`
\` \`
\` (fxpositive? 128) \`=>\` #t\`
\` (fxpositive? 0) \`=>\` #f\`
\` (fxpositive? -1) \`=>\` #f \`
\` \`
\` (fxnegative? -65) \`=>\` #t\`
\` (fxnegative? 0) \`=>\` #f\`
\` (fxnegative? 1) \`=>\` #f\`
`
    },
    {
        name: "(fxnonnegative? ",
        endParen: true,
        params: ["fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s16"),
        description: `**procedure**: \`(fxnonpositive? \`*fixnum*\`)\`
**returns: **\`#t\` if *fixnum* is not greater than zero, \`#f\` otherwise
**procedure**: \`(fxnonnegative? \`*fixnum*\`)\`
**returns: **\`#t\` if *fixnum* is not less than zero, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`fxnonpositive?\` is equivalent to \`(lambda (x) (fx<= x 0))\`, and \`fxnonnegative?\` is equivalent to \`(lambda (x) (fx>= x 0))\`.

\`(fxnonpositive? 128) \`=>\` #f\`
\` (fxnonpositive? 0) \`=>\` #t\`
\` (fxnonpositive? -1) \`=>\` #t \`
\` \`
\` (fxnonnegative? -65) \`=>\` #f\`
\` (fxnonnegative? 0) \`=>\` #t\`
\` (fxnonnegative? 1) \`=>\` #t\`
`
    },
    {
        name: "(fxnonpositive? ",
        endParen: true,
        params: ["fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s16"),
        description: `**procedure**: \`(fxnonpositive? \`*fixnum*\`)\`
**returns: **\`#t\` if *fixnum* is not greater than zero, \`#f\` otherwise
**procedure**: \`(fxnonnegative? \`*fixnum*\`)\`
**returns: **\`#t\` if *fixnum* is not less than zero, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`fxnonpositive?\` is equivalent to \`(lambda (x) (fx<= x 0))\`, and \`fxnonnegative?\` is equivalent to \`(lambda (x) (fx>= x 0))\`.

\`(fxnonpositive? 128) \`=>\` #f\`
\` (fxnonpositive? 0) \`=>\` #t\`
\` (fxnonpositive? -1) \`=>\` #t \`
\` \`
\` (fxnonnegative? -65) \`=>\` #f\`
\` (fxnonnegative? 0) \`=>\` #t\`
\` (fxnonnegative? 1) \`=>\` #t\`
`
    },
    {
        name: "(fxnot ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s163"),
        description: `**procedure**: \`(fxnot \`*fx*\`)\`
**returns: **the bitwise not of *fx*
**procedure**: \`(fxand \`*fx*\` ...)\`
**returns: **the bitwise and of *fx*\` ...\`
**procedure**: \`(fxior \`*fx*\` ...)\`
**returns: **the bitwise inclusive or of *fx*\` ...\`
**procedure**: \`(fxxor \`*fx*\` ...)\`
**returns: **the bitwise exclusive or of *fx*\` ...\`
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxnot 0) \`=>\` -1\`
\` (fxnot 3) \`=>\` -4 \`
\` \`
\` (fxand #b01101 #b00111) \`=>\` #b00101\`
\` (fxior #b01101 #b00111) \`=>\` #b01111\`
\` (fxxor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(fxodd? ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s155"),
        description: `**procedure**: \`(fxeven? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is even, \`#f\` otherwise
**procedure**: \`(fxodd? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is odd, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxeven? 0) \`=>\` #t\`
\` (fxeven? 1) \`=>\` #f\`
\` (fxeven? -1) \`=>\` #f\`
\` (fxeven? -10) \`=>\` #t \`
\` \`
\` (fxodd? 0) \`=>\` #f\`
\` (fxodd? 1) \`=>\` #t\`
\` (fxodd? -1) \`=>\` #t\`
\` (fxodd? -10) \`=>\` #f\`
`
    },
    {
        name: "(fxpositive? ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s154"),
        description: `**procedure**: \`(fxzero? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is zero, \`#f\` otherwise
**procedure**: \`(fxpositive? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is greater than zero, \`#f\` otherwise
**procedure**: \`(fxnegative? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\`fxzero?\` is equivalent to \`(lambda (x) (fx=? x 0))\`, \`fxpositive?\` is equivalent to \`(lambda (x) (fx>? x 0))\`, and \`fxnegative?\` to \`(lambda (x) (fx<? x 0))\`.

\`(fxzero? 0) \`=>\` #t\`
\` (fxzero? 1) \`=>\` #f \`
\` \`
\` (fxpositive? 128) \`=>\` #t\`
\` (fxpositive? 0) \`=>\` #f\`
\` (fxpositive? -1) \`=>\` #f \`
\` \`
\` (fxnegative? -65) \`=>\` #t\`
\` (fxnegative? 0) \`=>\` #f\`
\` (fxnegative? 1) \`=>\` #f\`
`
    },
    {
        name: "(fxquotient ",
        endParen: true,
        params: ["fixnum1", "fixnum2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s22"),
        description: `**procedure**: \`(fxquotient \`*fixnum1*\` \`*fixnum2*\` ...)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`

\`fxquotient\` is identical to \`fx/\`. See the description of \`fx/\` above.
`
    },
    {
        name: "(fxremainder ",
        endParen: true,
        params: ["fixnum1", "fixnum2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s23"),
        description: `**procedure**: \`(fxremainder \`*fixnum1*\` \`*fixnum2*\`)\`
**returns: **the fixnum remainder of *fixnum1* divided by *fixnum2*
**libraries: **\`(chezscheme)\`

The result of \`fxremainder\` has the same sign as *fixnum1*.

\`(fxremainder 16 4) \`=>\` 0\`
\` (fxremainder 5 2) \`=>\` 1\`
\` (fxremainder -45 7) \`=>\` -3\`
\` (fxremainder 10 -3) \`=>\` 1\`
\` (fxremainder -17 -9) \`=>\` -8\`
`
    },
    {
        name: "(fxreverse-bit-field ",
        endParen: true,
        params: ["fx1", "fx2", "fx3"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s175"),
        description: `**procedure**: \`(fxreverse-bit-field \`*fx1*\` \`*fx2*\` \`*fx3*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2* and *fx3* must be nonnegative and less than the value of \`(fixnum-width)\`, and *fx2* must not be greater than *fx3*. This procedure returns the result of reversing the bits of *fx1* from bit *fx2* (inclusive) through bit *fx3* (exclusive).

\`(fxreverse-bit-field #b00011010 0 5) \`=>\` #b00001011\`
\` (fxreverse-bit-field #b01101011 2 7) \`=>\` #b00101111\`
`
    },
    {
        name: "(fxrotate-bit-field ",
        endParen: true,
        params: ["fx1", "fx2", "fx3", "fx4"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s174"),
        description: `**procedure**: \`(fxrotate-bit-field \`*fx1*\` \`*fx2*\` \`*fx3*\` \`*fx4*\`)\`
**returns: **see below
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

*fx2*, *fx3*, and *fx4* must be nonnegative and less than the value of \`(fixnum-width)\`, *fx2* must not be greater than *fx3*, and *fx4* must not be greater than the difference between *fx3* and *fx2*.

This procedure returns the result of shifting the bits of *fx1* from bit *fx2* (inclusive) through bit *fx3* (exclusive) left by *fx4* bits, with the bits shifted out of the range inserted at the bottom end of the range.

\`(fxrotate-bit-field #b00011010 0 5 3) \`=>\` #b00010110\`
\` (fxrotate-bit-field #b01101011 2 7 3) \`=>\` #b01011011\`
`
    },
    {
        name: "(fxsll ",
        endParen: true,
        params: ["fixnum", "count"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s61"),
        description: `**procedure**: \`(fxsll \`*fixnum*\` \`*count*\`)\`
**returns: ***fixnum* shifted left by *count*
**libraries: **\`(chezscheme)\`

*fixnum* is treated as a two's complement integer, regardless of the underlying representation. *count* must be nonnegative and not more than the number of bits in a fixnum, i.e., \`(+ (integer-length (most-positive-fixnum)) 1)\`. An exception is raised with condition-type \`&implementation-restriction\` if the result cannot be represented as a fixnum.

\`(fxsll 1 2) \`=>\` 4\`
\` (fxsll -1 2) \`=>\` -4\`
`
    },
    {
        name: "(fxsra ",
        endParen: true,
        params: ["fixnum", "count"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s63"),
        description: `**procedure**: \`(fxsra \`*fixnum*\` \`*count*\`)\`
**returns: ***fixnum* arithmetically shifted right by *count*
**libraries: **\`(chezscheme)\`

*fixnum* is treated as a two's complement integer, regardless of the underlying representation. *count* must be nonnegative and not more than the number of bits in a fixnum, i.e., \`(+ (integer-length (most-positive-fixnum)) 1)\`.

\`(fxsra 64 3) \`=>\` 8\`
\` (fxsra -1 1) \`=>\` -1\`
\` (fxsra -64 3) \`=>\` -8\`
`
    },
    {
        name: "(fxsrl ",
        endParen: true,
        params: ["fixnum", "count"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s62"),
        description: `**procedure**: \`(fxsrl \`*fixnum*\` \`*count*\`)\`
**returns: ***fixnum* logically shifted right by *count*
**libraries: **\`(chezscheme)\`

*fixnum* is treated as a two's complement integer, regardless of the underlying representation. *count* must be nonnegative and not more than the number of bits in a fixnum, i.e., \`(+ (integer-length (most-positive-fixnum)) 1)\`.

\`(fxsrl 4 2) \`=>\` 1\`
\` (= (fxsrl -1 1) (most-positive-fixnum)) \`=>\` #t\`
`
    },
    {
        name: "(fxvector ",
        endParen: true,
        params: ["fixnum", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s44"),
        description: `**procedure**: \`(fxvector \`*fixnum*\` ...)\`
**returns: **an fxvector of the fixnums *fixnum*\` ...\`
**libraries: **\`(chezscheme)\`

\` (fxvector) \`=>\` #vfx()\`
\` (fxvector 1 3 5) \`=>\` #vfx(1 3 5)\`
`
    },
    {
        name: "(fxvector->immutable-fxvector ",
        endParen: true,
        params: ["fxvector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s54"),
        description: `**procedure**: \`(fxvector->immutable-fxvector \`*fxvector*\`)\`
**returns: **either an immutable copy of *fxvector* or *fxvector* itself
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(fxvector->list ",
        endParen: true,
        params: ["fxvector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s50"),
        description: `**procedure**: \`(fxvector->list \`*fxvector*\`)\`
**returns: **a list of the elements of *fxvector*
**libraries: **\`(chezscheme)\`

\`(fxvector->list (fxvector)) \`=>\` ()\`
\` (fxvector->list #vfx(7 5 2)) \`=>\` (7 5 2) \`
\` \`
\` (let ([v #vfx(1 2 3 4 5)])\`
\`   (apply fx* (fxvector->list v))) \`=>\` 120\`
`
    },
    {
        name: "(fxvector-copy ",
        endParen: true,
        params: ["fxvector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s52"),
        description: `**procedure**: \`(fxvector-copy \`*fxvector*\`)\`
**returns: **a copy of *fxvector*
**libraries: **\`(chezscheme)\`

\`fxvector-copy\` creates a new fxvector with the same length and contents as *fxvector*.

\`(fxvector-copy #vfx(3 4 5)) \`=>\` #vfx(3 4 5) \`
\` \`
\` (let ([v #vfx(3 4 5)])\`
\`   (eq? v (fxvector-copy v))) \`=>\` #f\`
`
    },
    {
        name: "(fxvector-fill! ",
        endParen: true,
        params: ["fxvector", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s49"),
        description: `**procedure**: \`(fxvector-fill! \`*fxvector*\` \`*fixnum*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*fxvector* must be mutable. \`fxvector-fill!\` replaces each element of *fxvector* with *fixnum*.

\`(let ([v (fxvector 1 2 3)])\`
\`   (fxvector-fill! v 0)\`
\`   v) \`=>\` #vfx(0 0 0)\`
`
    },
    {
        name: "(fxvector-length ",
        endParen: true,
        params: ["fxvector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s46"),
        description: `**procedure**: \`(fxvector-length \`*fxvector*\`)\`
**returns: **the number of elements in *fxvector*
**libraries: **\`(chezscheme)\`

\`(fxvector-length #vfx()) \`=>\` 0\`
\` (fxvector-length #vfx(1 2 3)) \`=>\` 3\`
\` (fxvector-length #10vfx(1 2 3)) \`=>\` 10\`
\` (fxvector-length (fxvector 1 2 3 4)) \`=>\` 4\`
\` (fxvector-length (make-fxvector 300)) \`=>\` 300\`
`
    },
    {
        name: "(fxvector-ref ",
        endParen: true,
        params: ["fxvector", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s47"),
        description: `**procedure**: \`(fxvector-ref \`*fxvector*\` \`*n*\`)\`
**returns: **the *n*th element (zero-based) of *fxvector*
**libraries: **\`(chezscheme)\`

*n* must be a nonnegative fixnum strictly less than the length of *fxvector*.

\`(fxvector-ref #vfx(-1 2 4 7) 0) \`=>\` -1\`
\` (fxvector-ref #vfx(-1 2 4 7) 1) \`=>\` 2\`
\` (fxvector-ref #vfx(-1 2 4 7) 3) \`=>\` 7\`
`
    },
    {
        name: "(fxvector-set! ",
        endParen: true,
        params: ["fxvector", "n", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s48"),
        description: `**procedure**: \`(fxvector-set! \`*fxvector*\` \`*n*\` \`*fixnum*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*fxvector* must be mutable. *n* must be a nonnegative fixnum strictly less than the length of *fxvector*. \`fxvector-set!\` changes the *n*th element of *fxvector* to *fixnum*.

\`(let ([v (fxvector 1 2 3 4 5)])\`
\`   (fxvector-set! v 2 (fx- (fxvector-ref v 2)))\`
\`   v) \`=>\` #vfx(1 2 -3 4 5)\`
`
    },
    {
        name: "(fxvector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s43"),
        description: `**procedure**: \`(fxvector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an fxvector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (fxvector? #vfx()) \`=>\` #t\`
\` (fxvector? #vfx(1 2 3)) \`=>\` #t\`
\` (fxvector? (fxvector 1 2 3)) \`=>\` #t\`
\` (fxvector? '#(a b c)) \`=>\` #f\`
\` (fxvector? '(a b c)) \`=>\` #f\`
\` (fxvector? "abc") \`=>\` #f\`
`
    },
    {
        name: "(fxxor ",
        endParen: true,
        params: ["fx", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s163"),
        description: `**procedure**: \`(fxnot \`*fx*\`)\`
**returns: **the bitwise not of *fx*
**procedure**: \`(fxand \`*fx*\` ...)\`
**returns: **the bitwise and of *fx*\` ...\`
**procedure**: \`(fxior \`*fx*\` ...)\`
**returns: **the bitwise inclusive or of *fx*\` ...\`
**procedure**: \`(fxxor \`*fx*\` ...)\`
**returns: **the bitwise exclusive or of *fx*\` ...\`
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fxnot 0) \`=>\` -1\`
\` (fxnot 3) \`=>\` -4 \`
\` \`
\` (fxand #b01101 #b00111) \`=>\` #b00101\`
\` (fxior #b01101 #b00111) \`=>\` #b01111\`
\` (fxxor #b01101 #b00111) \`=>\` #b01010\`
`
    },
    {
        name: "(fxzero? ",
        endParen: true,
        params: ["fx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s154"),
        description: `**procedure**: \`(fxzero? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is zero, \`#f\` otherwise
**procedure**: \`(fxpositive? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is greater than zero, \`#f\` otherwise
**procedure**: \`(fxnegative? \`*fx*\`)\`
**returns: **\`#t\` if *fx* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\`fxzero?\` is equivalent to \`(lambda (x) (fx=? x 0))\`, \`fxpositive?\` is equivalent to \`(lambda (x) (fx>? x 0))\`, and \`fxnegative?\` to \`(lambda (x) (fx<? x 0))\`.

\`(fxzero? 0) \`=>\` #t\`
\` (fxzero? 1) \`=>\` #f \`
\` \`
\` (fxpositive? 128) \`=>\` #t\`
\` (fxpositive? 0) \`=>\` #f\`
\` (fxpositive? -1) \`=>\` #f \`
\` \`
\` (fxnegative? -65) \`=>\` #t\`
\` (fxnegative? 0) \`=>\` #f\`
\` (fxnegative? 1) \`=>\` #f\`
`
    },
    {
        name: "(gcd ",
        endParen: true,
        params: ["int", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s109"),
        description: `**procedure**: \`(gcd \`*int*\` ...)\`
**returns: **the greatest common divisor of its arguments *int*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The result is always nonnegative, i.e., factors of -1 are ignored. When called with no arguments, \`gcd\` returns 0.

\`(gcd) \`=>\` 0\`
\` (gcd 34) \`=>\` 34\`
\` (gcd 33.0 15.0) \`=>\` 3.0\`
\` (gcd 70 -42 28) \`=>\` 14\`
`
    },
    {
        name: "generate-allocation-counts",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s239"),
        description: `**thread parameter**: \`generate-allocation-counts\`
**libraries: **\`(chezscheme)\`

When this parameter has a true value, the compiler inserts a short sequence of instructions at each allocation point in generated code to track the amount of allocation that occurs. This parameter is initially false.
`
    },
    {
        name: "generate-covin-files",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s142"),
        description: `**thread parameter**: \`generate-covin-files\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "generate-inspector-information",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s114"),
        description: `**thread parameter**: \`generate-inspector-information\`
**libraries: **\`(chezscheme)\`

When this parameter is set to a true value (the default), information about the source and contents of procedures and continuations is generated during compilation and retained in tables associated with each code segment. This information allows the inspector to provide more complete information, at the expense of using more memory and producing larger object files (via \`compile-file\`). Although compilation and loading may be slower when inspector information is generated, the speed of the compiled code is not affected. If this parameter is changed during the compilation of a file, the original value will be restored. For example, if:

\`(eval-when (compile) (generate-inspector-information #f))\`

is included in a file, generation of inspector information will be disabled only for the remainder of that particular file.
`
    },
    {
        name: "generate-instruction-counts",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s240"),
        description: `**thread parameter**: \`generate-instruction-counts\`
**libraries: **\`(chezscheme)\`

When this parameter has a true value, the compiler inserts a short sequence of instructions in each block of generated code to track the number of instructions executed by that block. This parameter is initially false.
`
    },
    {
        name: "generate-interrupt-trap",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s111"),
        description: `**thread parameter**: \`generate-interrupt-trap\`
**libraries: **\`(chezscheme)\`

To support interrupts, including keyboard, timer, and collect request interrupts, the compiler inserts a short sequence of instructions at the entry to each nonleaf procedure (Section ). This small overhead may be eliminated by setting \`generate-interrupt-trap\` to \`#f\`. The default value of this parameter is \`#t\`.

It is rarely a good idea to compile code without interrupt trap generation, since a tight loop in the generated code may completely prevent interrupts from being serviced, including the collect request interrupt that causes garbage collections to occur automatically. Disabling trap generation may be useful, however, for routines that act simply as "wrappers" for other routines for which code is presumably generated with interrupt trap generation enabled. It may also be useful for short performance-critical routines with embedded loops or recursions that are known to be short running and that make no other calls.
`
    },
    {
        name: "generate-procedure-source-information",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s115"),
        description: `**thread parameter**: \`generate-procedure-source-information\`
**libraries: **\`(chezscheme)\`

When \`generate-inspector-information\` is set to \`#f\` and this parameter is set to \`#t\`, then a source location is preserved for a procedure, even though other inspector information is not preserved. Source information provides a small amount of debugging support at a much lower cost in memory and object-file size than full inspector information. If this parameter is changed during the compilation of a file, the original value will be restored.
`
    },
    {
        name: "(generate-profile-forms)",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s145"),
        description: `**thread parameter**: \`(generate-profile-forms)\`
**libraries: **\`(chezscheme)\`

When this parameter is set to \`#t\`, the default, the expander implicitly introduces \`profile\` forms for each annotated input expression, unless the annotation has not been marked for use in profiling (Section ). It can be set to \`#f\` to inhibit the expander's implicit generation of \`profile\` forms, typically when explicit \`profile\` forms are already present for all source positions that should be profiled.
`
    },
    {
        name: "(generate-temporaries ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s49"),
        description: `**procedure**: \`(generate-temporaries \`*list*\`)\`
**returns: **a list of distinct generated identifiers
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

Transformers can introduce a fixed number of identifiers into their output by naming each identifier. In some cases, however, the number of identifiers to be introduced depends upon some characteristic of the input expression. A straightforward definition of \`letrec\`, for example, requires as many temporary identifiers as there are binding pairs in the input expression. The procedure \`generate-temporaries\` is used to construct lists of temporary identifiers.

*list* may be any list; its contents are not important. The number of temporaries generated is the number of elements in *list*. Each temporary is guaranteed to be different from all other identifiers.
`
    },
    {
        name: "generate-wpo-files",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s117"),
        description: `**thread parameter**: \`generate-wpo-files\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(gensym)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s93"),
        description: `**procedure**: \`(gensym)\`
**procedure**: \`(gensym \`*pretty-name*\`)\`
**procedure**: \`(gensym \`*pretty-name*\` \`*unique-name*\`)\`
**returns: **a unique generated symbol
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(gensym ",
        endParen: true,
        params: ["pretty-name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s93"),
        description: `**procedure**: \`(gensym)\`
**procedure**: \`(gensym \`*pretty-name*\`)\`
**procedure**: \`(gensym \`*pretty-name*\` \`*unique-name*\`)\`
**returns: **a unique generated symbol
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(gensym ",
        endParen: true,
        params: ["pretty-name", "unique-name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s93"),
        description: `**procedure**: \`(gensym)\`
**procedure**: \`(gensym \`*pretty-name*\`)\`
**procedure**: \`(gensym \`*pretty-name*\` \`*unique-name*\`)\`
**returns: **a unique generated symbol
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(gensym->unique-string ",
        endParen: true,
        params: ["gensym"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s103"),
        description: `**procedure**: \`(gensym->unique-string \`*gensym*\`)\`
**returns: **the unique name of *gensym*
**libraries: **\`(chezscheme)\`

\` (gensym->unique-string (gensym)) \`=>\` "bd3kufa7ypjcuvut-g"\`
`
    },
    {
        name: "gensym-count",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s101"),
        description: `**thread parameter**: \`gensym-prefix\`
**thread parameter**: \`gensym-count\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "gensym-prefix",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s101"),
        description: `**thread parameter**: \`gensym-prefix\`
**thread parameter**: \`gensym-count\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(gensym? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s104"),
        description: `**procedure**: \`(gensym? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is gensym, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (gensym? (string->symbol "z")) \`=>\` #f\`
\` (gensym? (gensym "z")) \`=>\` #t\`
\` (gensym? 'a) \`=>\` #f\`
\` (gensym? 3) \`=>\` #f\`
\` (gensym? (gensym)) \`=>\` #t\`
\` (gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) \`=>\` #t\`
`
    },
    {
        name: "(get-bytevector-all ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s60"),
        description: `**procedure**: \`(get-bytevector-all \`*binary-input-port*\`)\`
**returns: **a nonempty bytevector or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *binary-input-port* is at end of file, the eof object is returned. Otherwise, \`get-bytevector-all\` reads (as if with \`get-u8\`) all of the bytes available before the port is at end of file and returns a bytevector containing these bytes. The port's position is advanced past the bytes read.
`
    },
    {
        name: "(get-bytevector-n ",
        endParen: true,
        params: ["binary-input-port", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s57"),
        description: `**procedure**: \`(get-bytevector-n \`*binary-input-port*\` \`*n*\`)\`
**returns: **a nonempty bytevector containing up to *n* bytes, or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. If *binary-input-port* is at end of file, the eof object is returned. Otherwise, \`get-bytevector-n\` reads (as if with \`get-u8\`) as many bytes, up to *n*, as are available before the port is at end of file, and returns a new (nonempty) bytevector containing these bytes. The port's position is advanced past the bytes read.
`
    },
    {
        name: "(get-bytevector-n! ",
        endParen: true,
        params: ["binary-input-port", "bytevector", "start", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s58"),
        description: `**procedure**: \`(get-bytevector-n! \`*binary-input-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **the count of bytes read or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be exact nonnegative integers, and the sum of *start* and *n* must not exceed the length of *bytevector*.

If *binary-input-port* is at end of file, the eof object is returned. Otherwise, \`get-bytevector-n!\` reads (as if with \`get-u8\`) as many bytes, up to *n*, as are available before the port is at end of file, stores the bytes in consecutive locations of *bytevector* starting at *start*, and returns the count of bytes read as an exact positive integer. The port's position is advanced past the bytes read.
`
    },
    {
        name: "(get-bytevector-some ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s59"),
        description: `**procedure**: \`(get-bytevector-some \`*binary-input-port*\`)\`
**returns: **a nonempty bytevector or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *binary-input-port* is at end of file, the eof object is returned. Otherwise, \`get-bytevector-some\` reads (as if with \`get-u8\`) at least one byte and possibly more, and returns a bytevector containing these bytes. The port's position is advanced past the bytes read. The maximum number of bytes read by this operation is implementation-dependent.
`
    },
    {
        name: "(get-bytevector-some! ",
        endParen: true,
        params: ["binary-input-port", "bytevector", "start", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s64"),
        description: `**procedure**: \`(get-bytevector-some! \`*binary-input-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **the count of bytes read, as an exact nonnegative integer, or the eof object
**libraries: **\`(chezscheme)\`

*start* and *n* must be exact nonnegative integers, and the sum of *start* and *n* must not exceed the length of *bytevector*.

If *n* is 0, this procedure returns zero without attempting to read from *binary-input-port* and without modifying *bytevector*.

Otherwise, if *binary-input-port* is at end of file, this procedure returns the eof object, except it returns zero when the port is in nonblocking mode (see \`set-port-nonblocking!\`) and the port cannot be determined to be at end of file without blocking. In either case, *bytevector* is not modified.

Otherwise, this procedure reads (as if with \`get-u8\`) up to *n* bytes from the port, stores the bytes in consecutive locations of *bytevector* starting at *start*, advances the port's position just past the bytes read, and returns the count of bytes read.

If the port is in nonblocking mode, this procedure reads no more than it can without blocking and thus might read zero bytes; otherwise, it reads at least one byte but no more than are available when the first byte becomes available.
`
    },
    {
        name: "(get-char ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s61"),
        description: `**procedure**: \`(get-char \`*textual-input-port*\`)\`
**returns: **the next character from *textual-input-port*, or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *textual-input-port* is at end of file, the eof object is returned. Otherwise, the next available character is returned and the port's position is advanced one character. If *textual-input-port* is a transcoded port, the position in the underlying byte stream may advance by more than one byte.
`
    },
    {
        name: "(get-datum ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s67"),
        description: `**procedure**: \`(get-datum \`*textual-input-port*\`)\`
**returns: **a Scheme datum object or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure scans past whitespace and comments to find the start of the external representation of a datum. If *textual-input-port* reaches end of file before the start of the external representation of a datum is found, the eof object is returned.

Otherwise, \`get-datum\` reads as many characters as necessary, and no more, to parse a single datum, and returns a newly allocated object whose structure is determined by the external representation. The port's position is advanced past the characters read. If an end-of-file is reached before the external representation of the datum is complete, or an unexpected character is read, an exception is raised with condition types \`&lexical\` and \`i/o-read\`.

\`(let ([sip (open-string-input-port "; a\\n\\n one (two)\\n")])\`
\`   (let* ([x1 (get-datum sip)]\`
\`          [c1 (lookahead-char sip)]\`
\`          [x2 (get-datum sip)])\`
\`     (list x1 c1 x2 (port-eof? sip)))) \`=>\` (one #\\space (two) #f)\`
`
    },
    {
        name: "(get-datum/annotations ",
        endParen: true,
        params: ["textual-input-port", "sfd", "bfp"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s70"),
        description: `**procedure**: \`(get-datum/annotations \`*textual-input-port*\` \`*sfd*\` \`*bfp*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. *bfp* must be an exact nonnegative integer and should be the character position of the next character to be read from *textual-input-port*.

This procedure returns two values: an annotated object and an ending file position. In most cases, *bfp* should be 0 for the first call to \`get-datum/annotation\` at the start of a file, and it should be the second return value of the preceding call to \`get-datum/annotation\` for each subsequent call. This protocol is necessary to handle files containing multiple-byte characters, since file positions do not necessarily correspond to character positions.
`
    },
    {
        name: "(get-hash-table ",
        endParen: true,
        params: ["ht", "k", "d"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s3"),
        description: `**procedure**: \`(get-hash-table \`*ht*\` \`*k*\` \`*d*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`get-hash-table\` returns the value associated with *k* in *ht*. If no value is associated with *k* in *ht*, \`get-hash-table\` returns *d*.

Key comparisons are performed with *eq?*.

Because objects may be moved by the garbage collector, \`get-hash-table\` may need to rehash some objects and therefore cause side effects in the hash table. Thus, it is not safe to perform concurrent accesses of the same hash table from multiple threads using \`get-hash-table\`.
`
    },
    {
        name: "(get-line ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s66"),
        description: `**procedure**: \`(get-line \`*textual-input-port*\`)\`
**returns: **a string or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *textual-input-port* is at end of file, the eof object is returned. Otherwise, \`get-line\` reads (as if with \`get-char\`) all of the characters available before the port is at end of file or a line-feed character has been read and returns a string containing all but the line-feed character of the characters read. The port's position is advanced past the characters read.

\`(let ([sip (open-string-input-port "one\\ntwo\\n")])\`
\`   (let* ([s1 (get-line sip)] [s2 (get-line sip)])\`
\`     (list s1 s2 (port-eof? sip)))) \`=>\` ("one" "two" #t) \`
\` \`
\` (let ([sip (open-string-input-port "one\\ntwo")])\`
\`   (let* ([s1 (get-line sip)] [s2 (get-line sip)])\`
\`     (list s1 s2 (port-eof? sip)))) \`=>\` ("one" "two" #t)\`
`
    },
    {
        name: "(get-mode ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s151"),
        description: `**procedure**: \`(get-mode \`*path*\`)\`
**procedure**: \`(get-mode \`*path*\` \`*follow?*\`)\`
**returns: **the current permissions mode for *path*
**libraries: **\`(chezscheme)\`

*path* must be a string. \`get-mode\` retrieves the permissions on the file named by *path* and returns them as a fixnum in the same form as the *mode* argument to \`chmod\`. If the optional *follow?* argument is true (the default), this procedure follows symbolic links; otherwise it does not.
`
    },
    {
        name: "(get-mode ",
        endParen: true,
        params: ["path", "follow?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s151"),
        description: `**procedure**: \`(get-mode \`*path*\`)\`
**procedure**: \`(get-mode \`*path*\` \`*follow?*\`)\`
**returns: **the current permissions mode for *path*
**libraries: **\`(chezscheme)\`

*path* must be a string. \`get-mode\` retrieves the permissions on the file named by *path* and returns them as a fixnum in the same form as the *mode* argument to \`chmod\`. If the optional *follow?* argument is true (the default), this procedure follows symbolic links; otherwise it does not.
`
    },
    {
        name: "(get-output-string ",
        endParen: true,
        params: ["string-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s49"),
        description: `**procedure**: \`(get-output-string \`*string-output-port*\`)\`
**returns: **the string associated with *string-output-port*
**libraries: **\`(chezscheme)\`

*string-output-port* must be an port returned by \`open-output-string\`.

As a side effect, \`get-output-string\` resets *string-output-port* so that subsequent output to *string-output-port* is placed into a fresh string.

\`(let ([p (open-output-string)])\`
\`   (write 'hi p)\`
\`   (write-char #\\space p)\`
\`   (write 'mom! p)\`
\`   (get-output-string p)) \`=>\` "hi mom!"\`

An implementation of \`format\` (Section ) might be written using string-output ports to produce string output.
`
    },
    {
        name: "(get-process-id)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s259"),
        description: `**procedure**: \`(get-process-id)\`
**returns: **the operating system process id of the current process
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(get-registry ",
        endParen: true,
        params: ["key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s262"),
        description: `**procedure**: \`(get-registry \`*key*\`)\`
**returns: **registry value of *key* or \`#f\`
**procedure**: \`(put-registry! \`*key*\` \`*val*\`)\`
**procedure**: \`(remove-registry! \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*key* and *val* must be strings.

\`get-registry\` returns a string containing the registry value of *key* if the value exists. If no registry value for *key* exists, \`get-registry\` returns \`#f\`.

\`put-registry!\` sets the registry value of *key* to *val*. It raises an exception with condition type \`&assertion\` if the value cannot be set, which may happen if the user has insufficient access.

\`remove-registry!\` removes the registry key or value named by *key*. It raises an exception with condition type \`&assertion\` if the value cannot be removed. Reasons for failure include the key not being present, the user having insufficient access, or *key* being a key with subkeys.

These routines are defined for Windows only.

\`(get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` #f\`
\` (put-registry! "hkey_local_machine\\\\Software\\\\North\\\\South" "east")\`
\` (get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` "east"\`
\` (remove-registry! "hkey_local_machine\\\\Software\\\\North")\`
\` (get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` #f\`
`
    },
    {
        name: "(get-source-table! ",
        endParen: true,
        params: ["textual-input-port", "source-table"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s90"),
        description: `**procedure**: \`(get-source-table! \`*textual-input-port*\` \`*source-table*\`)\`
**procedure**: \`(get-source-table! \`*textual-input-port*\` \`*source-table*\` \`*combine*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The port must be positioned at a representation of source-table information written by some previous call to \`put-source-table\`, which reads the information and merges it into \`source-table\`.

If present and non-false, *combine* must be a procedure and should accept two arguments. It is called whenever associations for the same source object are present both in *source-table* and in the information read from the port. In this case, *combine* is passed two arguments: the associated value from *source-table* and the associated value from the port (in that order) and must return one value, which is recorded as the new associated value for the source object in *source-table*.

If *combine* is not present, *combine* is \`#f\`, or no association for a source object read from the port already exists in *source-table*, the value read from the port is recorded as the associated value of the source object in *source-table*.

\`(define st (make-source-table))\`
\` (call-with-port (open-input-file "profile.out1")\`
\`   (lambda (ip) (get-source-table! ip st)))\`
\` (call-with-port (open-input-file "profile.out2")\`
\`   (lambda (ip) (get-source-table! ip st +)))\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(get-source-table! ",
        endParen: true,
        params: ["textual-input-port", "source-table", "combine"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s90"),
        description: `**procedure**: \`(get-source-table! \`*textual-input-port*\` \`*source-table*\`)\`
**procedure**: \`(get-source-table! \`*textual-input-port*\` \`*source-table*\` \`*combine*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The port must be positioned at a representation of source-table information written by some previous call to \`put-source-table\`, which reads the information and merges it into \`source-table\`.

If present and non-false, *combine* must be a procedure and should accept two arguments. It is called whenever associations for the same source object are present both in *source-table* and in the information read from the port. In this case, *combine* is passed two arguments: the associated value from *source-table* and the associated value from the port (in that order) and must return one value, which is recorded as the new associated value for the source object in *source-table*.

If *combine* is not present, *combine* is \`#f\`, or no association for a source object read from the port already exists in *source-table*, the value read from the port is recorded as the associated value of the source object in *source-table*.

\`(define st (make-source-table))\`
\` (call-with-port (open-input-file "profile.out1")\`
\`   (lambda (ip) (get-source-table! ip st)))\`
\` (call-with-port (open-input-file "profile.out2")\`
\`   (lambda (ip) (get-source-table! ip st +)))\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(get-string-all ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s65"),
        description: `**procedure**: \`(get-string-all \`*textual-input-port*\`)\`
**returns: **a nonempty string or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *textual-input-port* is at end of file, the eof object is returned. Otherwise, \`get-string-all\` reads (as if with \`get-char\`) all of the characters available before the port is at end of file and returns a string containing these characters. The port's position is advanced past the characters read.
`
    },
    {
        name: "(get-string-n ",
        endParen: true,
        params: ["textual-input-port", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s63"),
        description: `**procedure**: \`(get-string-n \`*textual-input-port*\` \`*n*\`)\`
**returns: **a nonempty string containing up to *n* characters, or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. If *textual-input-port* is at end of file, the eof object is returned. Otherwise, \`get-string-n\` reads (as if with \`get-char\`) as many characters, up to *n*, as are available before the port is at end of file, and returns a new (nonempty) string containing these characters. The port's position is advanced past the characters read.
`
    },
    {
        name: "(get-string-n! ",
        endParen: true,
        params: ["textual-input-port", "string", "start", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s64"),
        description: `**procedure**: \`(get-string-n! \`*textual-input-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **the count of characters read or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be exact nonnegative integers, and the sum of *start* and *n* must not exceed the length of *string*.

If *textual-input-port* is at end of file, the eof object is returned. Otherwise, \`get-string-n!\` reads (as if with \`get-char\`) as many characters, up to *n*, as are available before the port is at end of file, stores the characters in consecutive locations of *string* starting at *start*, and returns the count of characters read as an exact positive integer. The port's position is advanced past the characters read.

\`get-string-n!\` may be used to implement \`string-set!\` and \`string-fill!\`, as illustrated below, although this is not its primary purpose.
`
    },
    {
        name: "(get-string-some ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s62"),
        description: `**procedure**: \`(get-string-some \`*textual-input-port*\`)\`
**returns: **a nonempty string or the eof object
**libraries: **\`(chezscheme)\`

If *textual-input-port* is at end of file, the eof object is returned. Otherwise, \`get-string-some\` reads (as if with \`get-u8\`) at least one character and possibly more, and returns a string containing these characters. The port's position is advanced past the characters read. The maximum number of characters read by this operation is implementation-dependent.

An exception to the "at least one character" guarantee occurs if the port is in nonblocking mode (see \`set-port-nonblocking!\`) and no input is ready. In this case, an empty string is returned.
`
    },
    {
        name: "(get-string-some! ",
        endParen: true,
        params: ["textual-input-port", "string", "start", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s63"),
        description: `**procedure**: \`(get-string-some! \`*textual-input-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **the count of characters read, as an exact nonnegative integer, or the eof object
**libraries: **\`(chezscheme)\`

*start* and *n* must be exact nonnegative integers, and the sum of *start* and *n* must not exceed the length of *string*.

If *n* is 0, this procedure returns zero without attempting to read from *textual-input-port* and without modifying *string*.

Otherwise, if *textual-input-port* is at end of file, this procedure returns the eof object, except it returns zero when the port is in nonblocking mode (see \`set-port-nonblocking!\`) and the port cannot be determined to be at end of file without blocking. In either case, *string* is not modified.

Otherwise, this procedure reads (as if with \`get-char\`) up to *n* characters from the port, stores the characters in consecutive locations of *string* starting at *start*, advances the port's position just past the characters read, and returns the count of characters read.

If the port is in nonblocking mode, this procedure reads no more than it can without blocking and thus might read zero characters; otherwise, it reads at least one character but no more than are available when the first character becomes available.
`
    },
    {
        name: "(get-thread-id)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s4"),
        description: `**procedure**: \`(get-thread-id)\`
**returns: **the thread id of the current thread
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(get-u8 ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s55"),
        description: `**procedure**: \`(get-u8 \`*binary-input-port*\`)\`
**returns: **the next byte from *binary-input-port*, or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *binary-input-port* is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255, and the port's position is advanced one byte.
`
    },
    {
        name: "(getenv ",
        endParen: true,
        params: ["key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s260"),
        description: `**procedure**: \`(getenv \`*key*\`)\`
**returns: **environment value of *key* or \`#f\`
**libraries: **\`(chezscheme)\`

*key* must be a string. \`getenv\` returns the operating system shell's environment value associated with *key*, or \`#f\` if no environment value is associated with *key*.

\`(getenv "HOME") \`=>\` "/u/freddy"\`
`
    },
    {
        name: "(getprop ",
        endParen: true,
        params: ["symbol", "key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s107"),
        description: `**procedure**: \`(getprop \`*symbol*\` \`*key*\`)\`
**procedure**: \`(getprop \`*symbol*\` \`*key*\` \`*default*\`)\`
**returns: **the value associated with *key* on the property list of *symbol*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(getprop ",
        endParen: true,
        params: ["symbol", "key", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s107"),
        description: `**procedure**: \`(getprop \`*symbol*\` \`*key*\`)\`
**procedure**: \`(getprop \`*symbol*\` \`*key*\` \`*default*\`)\`
**returns: **the value associated with *key* on the property list of *symbol*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(greatest-fixnum)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s151"),
        description: `**procedure**: \`(least-fixnum)\`
**returns: **the least (most negative) fixnum supported by the implementation
**procedure**: \`(greatest-fixnum)\`
**returns: **the greatest (most positive) fixnum supported by the implementation
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fixnum? (- (least-fixnum) 1)) \`=>\` #f\`
\` (fixnum? (least-fixnum)) \`=>\` #t\`
\` (fixnum? (greatest-fixnum)) \`=>\` #t\`
\` (fixnum? (+ (greatest-fixnum) 1)) \`=>\` #f\`
`
    },
    {
        name: "(guard (",
        endParen: true,
        params: ["var", "clause1", "clause2", "b1", "b2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s8"),
        description: `**syntax**: \`(guard (\`*var*\` \`*clause1*\` \`*clause2*\` ...) \`*b1*\` \`*b2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs exceptions)\`, \`(rnrs)\`

A \`guard\` expression establishes a new current exception handler, *procedure* (described below), in place of the old current exception handler, *old-proc*, and evaluates the body *b1*\` \`*b2*\` ...\`. If the body returns, \`guard\` reestablishes *old-proc* as the current exception handler. If control leaves or subsequently reenters the body via the invocation of a continuation obtained via \`call/cc\`, the procedure that was the current exception handler when the continuation was captured is reinstated.

The procedure *procedure* established by \`guard\` binds *var* to the value it receives and, within the scope of that binding, processes the clauses *clause1*\` \`*clause2*\` ...\` in turn, as if contained within an implicit \`cond\` expression. This implicit \`cond\` expression is evaluated in the continuation of the \`guard\` expression, with *old-proc* as the current exception handler.

If no \`else\` clause is provided, \`guard\` supplies one that reraises the exception with the same value, as if with \`raise-continuable\`, in the continuation of the call to *procedure*, with *old-proc* as the current exception handler.

\`(guard (x [else x]) (raise "oops")) \`=>\` "oops"\`
\` (guard (x [#f #f]) (raise (make-error))) \`=>\`  \`*error*
\` (define-syntax try\`
\`   (syntax-rules ()\`
\`     [(_ e1 e2 ...)\`
\`      (guard (x [(error? x) #f]) e1 e2 ...)]))\`
\` (define open-one\`
\`   (lambda fn*\`
\`     (let loop ([ls fn*])\`
\`       (if (null? ls)\`
\`           (error 'open-one "all open attempts failed" fn*)\`
\`           (or (try (open-input-file (car ls)))\`
\`               (loop (cdr ls)))))))\`
\` ; say bar.ss exists but not foo.ss:\`
\` (open-one "foo.ss" "bar.ss") \`=>\` #<input port bar.ss>\`
`
    },
    {
        name: "(guardian? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s31"),
        description: `**procedure**: \`(guardian? \`*obj*\`)\`
**returns: **\`#t\` if obj is a guardian, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(guardian? (make-guardian)) \`=>\` #t\`
\` (guardian? (ftype-guardian iptr)) \`=>\` #t\`
\` (guardian? (lambda x x)) \`=>\` #f\`
\` (guardian? "oops") \`=>\` #f\`
`
    },
    {
        name: "(hash-table-for-each ",
        endParen: true,
        params: ["ht", "p"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s6"),
        description: `**procedure**: \`(hash-table-for-each \`*ht*\` \`*p*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`hash-table-for-each\` applies *p* to each key, value association in *ht*, in no particular order. Unlike \`hash-table-map\`, it does not create a list of the values; instead, it's value is unspecified. *p* should accept two arguments, a key and a value.
`
    },
    {
        name: "(hash-table-map ",
        endParen: true,
        params: ["ht", "p"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s5"),
        description: `**procedure**: \`(hash-table-map \`*ht*\` \`*p*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`hash-table-map\` applies *p* to each key, value association in *ht*, in no particular order, and returns a list of the resulting values, again in no particular order. *p* should accept two arguments, a key and a value.
`
    },
    {
        name: "(hash-table? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s1"),
        description: `**procedure**: \`(hash-table? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a hash table, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(hashtable-cell ",
        endParen: true,
        params: ["hashtable", "key", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s116"),
        description: `**procedure**: \`(hashtable-cell \`*hashtable*\` \`*key*\` \`*default*\`)\`
**returns: **a pair (see below)
**libraries: **\`(chezscheme)\`

*hashtable* must be a hashtable. *key* and *default* may be any Scheme values.

If no value is associated with *key* in *hashtable*, \`hashtable-cell\` modifies *hashtable* to associate *key* with *default*. It returns a pair whose car is *key* and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate *key* with a new value. The *key* in the car field should not be changed. The advantage of this procedure over the Revised Report procedures for manipulating hashtable entries is that the value associated with a key may be read or written many times with only a single hashtable lookup.

\`(define ht (make-eq-hashtable))\`
\` (define v (vector 'a 'b 'c))\`
\` (define cell (hashtable-cell ht v 3))\`
\` cell \`=>\` (#(a b c) . 3)\`
\` (hashtable-ref ht v 0) \`=>\` 3\`
\` (set-cdr! cell 4)\`
\` (hashtable-ref ht v 0) \`=>\` 4\`
`
    },
    {
        name: "(hashtable-cells ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s120"),
        description: `**procedure**: \`(hashtable-cells \`*hashtable*\`)\`
**procedure**: \`(hashtable-cells \`*hashtable*\` \`*size*\`)\`
**returns: **a vector of up to *size* elements containing the cells of *hashtable*
**libraries: **\`(chezscheme)\`

Each element of the result vector is the value of one of the cells in *hashtable*. The cells may appear in any order in the returned vector. If *size* is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than *size* cells. If *size* is not specified, then the result vector has \`(hashtable-size \`*hashtable*\`)\` elements. Different calls to \`hashtable-cells\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s cells.

\`(define ht (make-eqv-hashtable))\`
\` (hashtable-set! ht 1 'one)\`
\` (hashtable-set! ht 2 'two)\`
\` (hashtable-cells ht) \`=>\` #((1 . one) (2 . two)) \`*or*\` #((2 . two) (1 . one))\`
\` (hashtable-cells ht 1) \`=>\` #((1 . one)) \`*or*\` #((2 . two))\`
\` (hashtable-cells ht 0) \`=>\` #()\`
`
    },
    {
        name: "(hashtable-cells ",
        endParen: true,
        params: ["hashtable", "size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s120"),
        description: `**procedure**: \`(hashtable-cells \`*hashtable*\`)\`
**procedure**: \`(hashtable-cells \`*hashtable*\` \`*size*\`)\`
**returns: **a vector of up to *size* elements containing the cells of *hashtable*
**libraries: **\`(chezscheme)\`

Each element of the result vector is the value of one of the cells in *hashtable*. The cells may appear in any order in the returned vector. If *size* is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than *size* cells. If *size* is not specified, then the result vector has \`(hashtable-size \`*hashtable*\`)\` elements. Different calls to \`hashtable-cells\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s cells.

\`(define ht (make-eqv-hashtable))\`
\` (hashtable-set! ht 1 'one)\`
\` (hashtable-set! ht 2 'two)\`
\` (hashtable-cells ht) \`=>\` #((1 . one) (2 . two)) \`*or*\` #((2 . two) (1 . one))\`
\` (hashtable-cells ht 1) \`=>\` #((1 . one)) \`*or*\` #((2 . two))\`
\` (hashtable-cells ht 0) \`=>\` #()\`
`
    },
    {
        name: "(hashtable-clear! ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s287"),
        description: `**procedure**: \`(hashtable-clear! \`*hashtable*\`)\`
**procedure**: \`(hashtable-clear! \`*hashtable*\` \`*size*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hashtable* must be a mutable hashtable. If *size* is provided, it must be a nonnegative exact integer.

\`hashtable-clear!\` removes all entries from *hashtable*. If size is provided, the hashtable is reset to the given size, as if newly created by one of the hashtable creation operations with size argument *size*.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "first")\`
\` (hashtable-set! ht p2 "second")\`
\` (hashtable-size ht) \`=>\` 2\`
\` (hashtable-clear! ht)\`
\` (hashtable-size ht) \`=>\` 0\`
\` (hashtable-ref ht p1 #f) \`=>\` #f\`
`
    },
    {
        name: "(hashtable-clear! ",
        endParen: true,
        params: ["hashtable", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s287"),
        description: `**procedure**: \`(hashtable-clear! \`*hashtable*\`)\`
**procedure**: \`(hashtable-clear! \`*hashtable*\` \`*size*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hashtable* must be a mutable hashtable. If *size* is provided, it must be a nonnegative exact integer.

\`hashtable-clear!\` removes all entries from *hashtable*. If size is provided, the hashtable is reset to the given size, as if newly created by one of the hashtable creation operations with size argument *size*.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "first")\`
\` (hashtable-set! ht p2 "second")\`
\` (hashtable-size ht) \`=>\` 2\`
\` (hashtable-clear! ht)\`
\` (hashtable-size ht) \`=>\` 0\`
\` (hashtable-ref ht p1 #f) \`=>\` #f\`
`
    },
    {
        name: "(hashtable-contains? ",
        endParen: true,
        params: ["hashtable", "key"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s282"),
        description: `**procedure**: \`(hashtable-contains? \`*hashtable*\` \`*key*\`)\`
**returns: **\`#t\` if an association for *key* exists in *hashtable*, \`#f\` otherwise
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*key* should be an appropriate key for the hashtable's hash and equivalence functions.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 73)\`
\` (hashtable-contains? ht p1) \`=>\` #t\`
\` (hashtable-contains? ht p2) \`=>\` #f\`
`
    },
    {
        name: "(hashtable-copy ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s286"),
        description: `**procedure**: \`(hashtable-copy \`*hashtable*\`)\`
**procedure**: \`(hashtable-copy \`*hashtable*\` \`*mutable?*\`)\`
**returns: **a new hashtable containing the same entries as *hashtable*
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

If *mutable?* is present and not false, the copy is mutable; otherwise, the copy is immutable.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "c")\`
\` (define ht-copy (hashtable-copy ht))\`
\` (hashtable-mutable? ht-copy) \`=>\` #f\`
\` (hashtable-delete! ht p1)\`
\` (hashtable-ref ht p1 #f) \`=>\` #f\`
\` (hashtable-delete! ht-copy p1) \`=>\` \`*exception: not mutable*
\` (hashtable-ref ht-copy p1 #f) \`=>\` "c"\`
`
    },
    {
        name: "(hashtable-copy ",
        endParen: true,
        params: ["hashtable", "mutable?"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s286"),
        description: `**procedure**: \`(hashtable-copy \`*hashtable*\`)\`
**procedure**: \`(hashtable-copy \`*hashtable*\` \`*mutable?*\`)\`
**returns: **a new hashtable containing the same entries as *hashtable*
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

If *mutable?* is present and not false, the copy is mutable; otherwise, the copy is immutable.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "c")\`
\` (define ht-copy (hashtable-copy ht))\`
\` (hashtable-mutable? ht-copy) \`=>\` #f\`
\` (hashtable-delete! ht p1)\`
\` (hashtable-ref ht p1 #f) \`=>\` #f\`
\` (hashtable-delete! ht-copy p1) \`=>\` \`*exception: not mutable*
\` (hashtable-ref ht-copy p1 #f) \`=>\` "c"\`
`
    },
    {
        name: "(hashtable-delete! ",
        endParen: true,
        params: ["hashtable", "key"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s284"),
        description: `**procedure**: \`(hashtable-delete! \`*hashtable*\` \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hashtable* must be a mutable hashtable. *key* should be an appropriate key for the hashtable's hash and equivalence functions.

\`hashtable-delete!\` drops any association for *key* from *hashtable*.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 73)\`
\` (hashtable-contains? ht p1) \`=>\` #t\`
\` (hashtable-delete! ht p1)\`
\` (hashtable-contains? ht p1) \`=>\` #f\`
\` (hashtable-contains? ht p2) \`=>\` #f\`
\` (hashtable-delete! ht p2)\`
`
    },
    {
        name: "(hashtable-entries ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s119"),
        description: `**procedure**: \`(hashtable-entries \`*hashtable*\`)\`
**procedure**: \`(hashtable-entries \`*hashtable*\` \`*size*\`)\`
**returns: **two vectors containing the keys and values in *hashtable*
**libraries: **\`(chezscheme)\`

Identical to the Revised Report counterpart, but allowing an optional *size* argument. If *size* is specified, then it must be an exact, nonnegative integer, and the result vectors contain no more than *size* elements. Different calls to \`hashtable-entries\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s entries.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-set! ht 'a "one")\`
\` (hashtable-set! ht 'b "two")\`
\` (hashtable-entries ht) \`=>\` #(a b) #("one" "two") \`*or the other permutation*
\` (hashtable-entries ht 1) \`=>\` #(a) #("one") \`*or*\` #(b) #("two") \`
`
    },
    {
        name: "(hashtable-entries ",
        endParen: true,
        params: ["hashtable", "size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s119"),
        description: `**procedure**: \`(hashtable-entries \`*hashtable*\`)\`
**procedure**: \`(hashtable-entries \`*hashtable*\` \`*size*\`)\`
**returns: **two vectors containing the keys and values in *hashtable*
**libraries: **\`(chezscheme)\`

Identical to the Revised Report counterpart, but allowing an optional *size* argument. If *size* is specified, then it must be an exact, nonnegative integer, and the result vectors contain no more than *size* elements. Different calls to \`hashtable-entries\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s entries.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-set! ht 'a "one")\`
\` (hashtable-set! ht 'b "two")\`
\` (hashtable-entries ht) \`=>\` #(a b) #("one" "two") \`*or the other permutation*
\` (hashtable-entries ht 1) \`=>\` #(a) #("one") \`*or*\` #(b) #("two") \`
`
    },
    {
        name: "(hashtable-entries ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s289"),
        description: `**procedure**: \`(hashtable-entries \`*hashtable*\`)\`
**returns: **two vectors: one of keys and a second of values
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

\`hashtable-entries\` returns two values. The first is a vector containing the keys in *hashtable*, and the second is a vector containing the corresponding values. The keys and values may appear in any order, but the order is the same for the keys and for the corresponding values.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "one")\`
\` (hashtable-set! ht p2 "two")\`
\` (hashtable-set! ht 'q "three")\`
\` (hashtable-entries ht) \`=>\` #((a . b) q (a . b))\`
\`                        \`\` #("two" "three" "one")\`
`
    },
    {
        name: "(hashtable-ephemeron? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s124"),
        description: `**procedure**: \`(hashtable-ephemeron? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an ephemeron eq or eqv hashtable, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(define ht1 (make-ephemeron-eq-hashtable))\`
\` (define ht2 (hashtable-copy ht1))\`
\` (hashtable-ephemeron? ht2) \`=>\` #t\`
`
    },
    {
        name: "(hashtable-equivalence-function ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s278"),
        description: `**procedure**: \`(hashtable-hash-function \`*hashtable*\`)\`
**returns: **the hash function associated with *hashtable*
**procedure**: \`(hashtable-equivalence-function \`*hashtable*\`)\`
**returns: **the equivalence function associated with *hashtable*
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

\`hashtable-hash-function\` returns \`#f\` for eq and eqv hashtables.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-hash-function ht) \`=>\` #f\`
\` (eq? (hashtable-equivalence-function ht) eq?) \`=>\` #t \`
\` \`
\` (define ht (make-hashtable string-hash string=?))\`
\` (eq? (hashtable-hash-function ht) string-hash) \`=>\` #t\`
\` (eq? (hashtable-equivalence-function ht) string=?) \`=>\` #t\`
`
    },
    {
        name: "(hashtable-hash-function ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s278"),
        description: `**procedure**: \`(hashtable-hash-function \`*hashtable*\`)\`
**returns: **the hash function associated with *hashtable*
**procedure**: \`(hashtable-equivalence-function \`*hashtable*\`)\`
**returns: **the equivalence function associated with *hashtable*
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

\`hashtable-hash-function\` returns \`#f\` for eq and eqv hashtables.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-hash-function ht) \`=>\` #f\`
\` (eq? (hashtable-equivalence-function ht) eq?) \`=>\` #t \`
\` \`
\` (define ht (make-hashtable string-hash string=?))\`
\` (eq? (hashtable-hash-function ht) string-hash) \`=>\` #t\`
\` (eq? (hashtable-equivalence-function ht) string=?) \`=>\` #t\`
`
    },
    {
        name: "(hashtable-keys ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s117"),
        description: `**procedure**: \`(hashtable-keys \`*hashtable*\`)\`
**procedure**: \`(hashtable-keys \`*hashtable*\` \`*size*\`)\`
**returns: **a vector containing the keys in *hashtable*
**libraries: **\`(chezscheme)\`

Identical to the Revised Report counterpart, but allowing an optional *size* argument. If *size* is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than *size* elements. Different calls to \`hashtable-keys\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s keys.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-set! ht 'a "one")\`
\` (hashtable-set! ht 'b "two")\`
\` (hashtable-set! ht 'c "three")\`
\` (hashtable-keys ht) \`=>\` #(a b c) \`*or any permutation*
\` (hashtable-keys ht 1) \`=>\` #(a) \`*or*\` #(b) \`*or*\` #(c)\`
`
    },
    {
        name: "(hashtable-keys ",
        endParen: true,
        params: ["hashtable", "size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s117"),
        description: `**procedure**: \`(hashtable-keys \`*hashtable*\`)\`
**procedure**: \`(hashtable-keys \`*hashtable*\` \`*size*\`)\`
**returns: **a vector containing the keys in *hashtable*
**libraries: **\`(chezscheme)\`

Identical to the Revised Report counterpart, but allowing an optional *size* argument. If *size* is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than *size* elements. Different calls to \`hashtable-keys\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s keys.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-set! ht 'a "one")\`
\` (hashtable-set! ht 'b "two")\`
\` (hashtable-set! ht 'c "three")\`
\` (hashtable-keys ht) \`=>\` #(a b c) \`*or any permutation*
\` (hashtable-keys ht 1) \`=>\` #(a) \`*or*\` #(b) \`*or*\` #(c)\`
`
    },
    {
        name: "(hashtable-keys ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s288"),
        description: `**procedure**: \`(hashtable-keys \`*hashtable*\`)\`
**returns: **a vector containing the keys in *hashtable*
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

The keys may appear in any order in the returned vector.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "one")\`
\` (hashtable-set! ht p2 "two")\`
\` (hashtable-set! ht 'q "three")\`
\` (hashtable-keys ht) \`=>\` #((a . b) q (a . b))\`
`
    },
    {
        name: "(hashtable-mutable? ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s277"),
        description: `**procedure**: \`(hashtable-mutable? \`*hashtable*\`)\`
**returns: **\`#t\` if *hashtable* is mutable, \`#f\` otherwise
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

Hashtables returned by one of the hashtable creation procedures above are mutable, but those created by \`hashtable-copy\` may be immutable. Immutable hashtables cannot be altered by any of the procedures \`hashtable-set!\`, \`hashtable-update!\`, \`hashtable-delete!\`, or \`hashtable-clear!\`.

\`(hashtable-mutable? (make-eq-hashtable)) \`=>\` #t\`
\` (hashtable-mutable? (hashtable-copy (make-eq-hashtable))) \`=>\` #f\`
`
    },
    {
        name: "(hashtable-ref ",
        endParen: true,
        params: ["hashtable", "key", "default"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s281"),
        description: `**procedure**: \`(hashtable-ref \`*hashtable*\` \`*key*\` \`*default*\`)\`
**returns: **see below
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*key* should be an appropriate key for the hashtable's hash and equivalence functions. *default* may be any Scheme object.

\`hashtable-ref\` returns the value associated with *key* in *hashtable*. If no value is associated with *key* in *hashtable*, \`hashtable-ref\` returns *default*.

\`(define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b)) \`
\` \`
\` (define eqht (make-eq-hashtable))\`
\` (hashtable-set! eqht p1 73)\`
\` (hashtable-ref eqht p1 55) \`=>\` 73\`
\` (hashtable-ref eqht p2 55) \`=>\` 55 \`
\` \`
\` (define equalht (make-hashtable equal-hash equal?))\`
\` (hashtable-set! equalht p1 73)\`
\` (hashtable-ref equalht p1 55) \`=>\` 73\`
\` (hashtable-ref equalht p2 55) \`=>\` 73\`
`
    },
    {
        name: "(hashtable-set! ",
        endParen: true,
        params: ["hashtable", "key", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s280"),
        description: `**procedure**: \`(hashtable-set! \`*hashtable*\` \`*key*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hashtable* must be a mutable hashtable. *key* should be an appropriate key for the hashtable's hash and equivalence functions. *obj* may be any Scheme object.

\`hashtable-set!\` associates *key* with *obj* in *hashtable*, replacing the existing association, if any.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-set! ht 'a 73)\`
`
    },
    {
        name: "(hashtable-size ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s285"),
        description: `**procedure**: \`(hashtable-size \`*hashtable*\`)\`
**returns: **number of entries in *hashtable*
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-size ht) \`=>\` 0\`
\` (hashtable-set! ht p1 73)\`
\` (hashtable-size ht) \`=>\` 1\`
\` (hashtable-delete! ht p1)\`
\` (hashtable-size ht) \`=>\` 0\`
`
    },
    {
        name: "(hashtable-update! ",
        endParen: true,
        params: ["hashtable", "key", "procedure", "default"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s283"),
        description: `**procedure**: \`(hashtable-update! \`*hashtable*\` \`*key*\` \`*procedure*\` \`*default*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hashtable* must be a mutable hashtable. *key* should be an appropriate key for the hashtable's hash and equivalence functions. *default* may be any Scheme object. *procedure* should accept one argument, should return one value, and should not modify *hashtable*.

\`hashtable-update!\` applies *procedure* to the value associated with *key* in *hashtable*, or to *default* if no value is associated with *key* in *hashtable*. If *procedure* returns, \`hashtable-update!\` associates *key* with the value returned by *procedure*, replacing the old association, if any.

A version of \`hashtable-update!\` that does not verify that it receives arguments of the proper type might be defined as follows.

\`(define hashtable-update!\`
\`   (lambda (ht key proc value)\`
\`     (hashtable-set! ht key\`
\`       (proc (hashtable-ref ht key value)))))\`

An implementation may, however, be able to implement \`hashtable-update!\` more efficiently by avoiding multiple hash computations and hashtable lookups.

\`(define ht (make-eq-hashtable))\`
\` (hashtable-update! ht 'a\`
\`   (lambda (x) (* x 2))\`
\`   55)\`
\` (hashtable-ref ht 'a 0) \`=>\` 110\`
\` (hashtable-update! ht 'a\`
\`   (lambda (x) (* x 2))\`
\`   0)\`
\` (hashtable-ref ht 'a 0) \`=>\` 220\`
`
    },
    {
        name: "(hashtable-values ",
        endParen: true,
        params: ["hashtable"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s118"),
        description: `**procedure**: \`(hashtable-values \`*hashtable*\`)\`
**procedure**: \`(hashtable-values \`*hashtable*\` \`*size*\`)\`
**returns: **a vector containing the values in *hashtable*
**libraries: **\`(chezscheme)\`

Each value is the value of one of the keys in *hashtable*. Duplicate values are not removed. The values may appear in any order in the returned vector. If *size* is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than *size* elements. Different calls to \`hashtable-values\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s values.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "one")\`
\` (hashtable-set! ht p2 "two")\`
\` (hashtable-set! ht 'q "two")\`
\` (hashtable-values ht) \`=>\` #("one" "two" "two") \`*or any permutation*
\` (hashtable-values ht 1) \`=>\` #("one") \`*or*\` #("two")\`

This procedure is equivalent to calling \`hashtable-entries\` and returning only the second result, but it is more efficient since the separate vector of keys need not be created.
`
    },
    {
        name: "(hashtable-values ",
        endParen: true,
        params: ["hashtable", "size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s118"),
        description: `**procedure**: \`(hashtable-values \`*hashtable*\`)\`
**procedure**: \`(hashtable-values \`*hashtable*\` \`*size*\`)\`
**returns: **a vector containing the values in *hashtable*
**libraries: **\`(chezscheme)\`

Each value is the value of one of the keys in *hashtable*. Duplicate values are not removed. The values may appear in any order in the returned vector. If *size* is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than *size* elements. Different calls to \`hashtable-values\` with a *size* less than \`(hashtable-size \`*hashtable*\`)\` may return different subsets of *hashtable*'s values.

\`(define ht (make-eq-hashtable))\`
\` (define p1 (cons 'a 'b))\`
\` (define p2 (cons 'a 'b))\`
\` (hashtable-set! ht p1 "one")\`
\` (hashtable-set! ht p2 "two")\`
\` (hashtable-set! ht 'q "two")\`
\` (hashtable-values ht) \`=>\` #("one" "two" "two") \`*or any permutation*
\` (hashtable-values ht 1) \`=>\` #("one") \`*or*\` #("two")\`

This procedure is equivalent to calling \`hashtable-entries\` and returning only the second result, but it is more efficient since the separate vector of keys need not be created.
`
    },
    {
        name: "(hashtable-weak? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s123"),
        description: `**procedure**: \`(hashtable-weak? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a weak eq or eqv hashtable, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(define ht1 (make-weak-eq-hashtable))\`
\` (define ht2 (hashtable-copy ht1))\`
\` (hashtable-weak? ht2) \`=>\` #t\`
`
    },
    {
        name: "(hashtable? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s25"),
        description: `**procedure**: \`(hashtable? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a hashtable, \`#f\` otherwise
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

\`(hashtable? (make-eq-hashtable)) \`=>\` #t\`
\` (hashtable? '(not a hash table)) \`=>\` #f\`
`
    },
    {
        name: "heap-reserve-ratio",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s19"),
        description: `**global parameter**: \`heap-reserve-ratio\`
**libraries: **\`(chezscheme)\`

This parameter determines the approximate amount of memory reserved (not returned to the O/S as described in the entry for \`release-minimum-generation\`) in proportion to the amount currently occupied, excluding areas of memory that have been made static. Its value must be an inexact nonnegative flonum value; if set to an exact real value, the exact value is converted to an inexact value. The default value, 1.0, reserves one page of memory for each currently occupied nonstatic page. Setting it to a smaller value may result in a smaller average virtual memory footprint, while setting it to a larger value may result in fewer calls into the operating system to request and free memory space.
`
    },
    {
        name: "(i/o-decoding-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s42"),
        description: `**syntax**: \`&i/o-decoding\`
**procedure**: \`(make-i/o-decoding-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-decoding\`
**procedure**: \`(i/o-decoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-decoding\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that a decoding error has occurred during the transcoding of bytes to characters. The *pobj* argument to the constructor should be the port involved, if any. The port should be positioned past the invalid encoding. This condition type might be defined as follows.

\`(define-condition-type &i/o-decoding &i/o-port\`
\`   make-i/o-decoding-error i/o-decoding-error?)\`
`
    },
    {
        name: "(i/o-encoding-error-char ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s43"),
        description: `**syntax**: \`&i/o-encoding\`
**procedure**: \`(make-i/o-encoding-error \`*pobj*\` \`*cobj*\`)\`
**returns: **a condition of type \`&i/o-encoding\`
**procedure**: \`(i/o-encoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-encoding\`, \`#f\` otherwise
**procedure**: \`(i/o-encoding-error-char \`*condition*\`)\`
**returns: **the contents of *condition*'s \`cobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that an encoding error has occurred during the transcoding of characters to bytes. The *pobj* argument to the constructor should be the port involved, if any, and the *cobj* argument should be the character for which the encoding failed. This condition type might be defined as follows.

\`(define-condition-type &i/o-encoding &i/o-port\`
\`   make-i/o-encoding-error i/o-encoding-error?\`
\`   (cobj i/o-encoding-error-char))\`

The final two condition types describe conditions that occur when implementations are required to produce a NaN or infinity but have no representations for these values.
`
    },
    {
        name: "(i/o-encoding-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s43"),
        description: `**syntax**: \`&i/o-encoding\`
**procedure**: \`(make-i/o-encoding-error \`*pobj*\` \`*cobj*\`)\`
**returns: **a condition of type \`&i/o-encoding\`
**procedure**: \`(i/o-encoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-encoding\`, \`#f\` otherwise
**procedure**: \`(i/o-encoding-error-char \`*condition*\`)\`
**returns: **the contents of *condition*'s \`cobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that an encoding error has occurred during the transcoding of characters to bytes. The *pobj* argument to the constructor should be the port involved, if any, and the *cobj* argument should be the character for which the encoding failed. This condition type might be defined as follows.

\`(define-condition-type &i/o-encoding &i/o-port\`
\`   make-i/o-encoding-error i/o-encoding-error?\`
\`   (cobj i/o-encoding-error-char))\`

The final two condition types describe conditions that occur when implementations are required to produce a NaN or infinity but have no representations for these values.
`
    },
    {
        name: "(i/o-error-filename ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s36"),
        description: `**syntax**: \`&i/o-filename\`
**procedure**: \`(make-i/o-filename-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-filename\`
**procedure**: \`(i/o-filename-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-filename\`, \`#f\` otherwise
**procedure**: \`(i/o-error-filename \`*condition*\`)\`
**returns: **the contents of *condition*'s \`filename\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an input/output error that occurred while operating on a file. The *filename* argument to the constructor should be the name of the file. This condition type might be defined as follows.

\`(define-condition-type &i/o-filename &i/o\`
\`   make-i/o-filename-error i/o-filename-error?\`
\`   (filename i/o-error-filename))\`
`
    },
    {
        name: "(i/o-error-port ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s41"),
        description: `**syntax**: \`&i/o-port\`
**procedure**: \`(make-i/o-port-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-port\`
**procedure**: \`(i/o-port-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-port\`, \`#f\` otherwise
**procedure**: \`(i/o-error-port \`*condition*\`)\`
**returns: **the contents of *condition*'s \`pobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type is usually included with a condition of one of the other \`&i/o\` subtypes to indicate the port involved in the exceptional situation, if a port is involved. The *pobj* argument to the constructor should be the port. This condition type might be defined as follows.

\`(define-condition-type &i/o-port &i/o\`
\`   make-i/o-port-error i/o-port-error?\`
\`   (pobj i/o-error-port))\`
`
    },
    {
        name: "(i/o-error-position ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s35"),
        description: `**syntax**: \`&i/o-invalid-position\`
**procedure**: \`(make-i/o-invalid-position-error \`*position*\`)\`
**returns: **a condition of type \`&i/o-invalid-position\`
**procedure**: \`(i/o-invalid-position-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-invalid-position\`, \`#f\` otherwise
**procedure**: \`(i/o-error-position \`*condition*\`)\`
**returns: **the contents of *condition*'s \`position\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an attempt to set a port's position to a position that is out of range for the underlying file or other object. The *position* argument to the constructor should be the invalid position. This condition type might be defined as follows.

\`(define-condition-type &i/o-invalid-position &i/o\`
\`   make-i/o-invalid-position-error\`
\`   i/o-invalid-position-error?\`
\`   (position i/o-error-position))\`
`
    },
    {
        name: "(i/o-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s32"),
        description: `**syntax**: \`&i/o\`
**procedure**: \`(make-i/o-error)\`
**returns: **a condition of type \`&i/o\`
**procedure**: \`(i/o-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of type \`&i/o\` indicates that an input/output error of some sort has occurred. Conditions of this type typically occur as one of the more specific subtypes described below. This condition type might be defined as follows.

\`(define-condition-type &i/o &error\`
\`   make-i/o-error i/o-error?)\`
`
    },
    {
        name: "(i/o-file-already-exists-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s39"),
        description: `**syntax**: \`&i/o-file-already-exists\`
**procedure**: \`(make-i/o-file-already-exists-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-already-exists\`
**procedure**: \`(i/o-file-already-exists-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-already-exists\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates a situation in which an operation on a file failed because the file already exists, e.g., an attempt is made to open an existing file for output without the \`no-fail\` file option. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-already-exists &i/o-filename\`
\`   make-i/o-file-already-exists-error\`
\`   i/o-file-already-exists-error?)\`
`
    },
    {
        name: "(i/o-file-does-not-exist-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s40"),
        description: `**syntax**: \`&i/o-file-does-not-exist\`
**procedure**: \`(make-i/o-file-does-not-exist-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-does-not-exist\`
**procedure**: \`(i/o-file-does-not-exist-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-does-not-exist\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates a situation in which an operation on a file failed because the file does not exist, e.g., an attempt is made to open a nonexistent file for input only. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-does-not-exist &i/o-filename\`
\`   make-i/o-file-does-not-exist-error\`
\`   i/o-file-does-not-exist-error?)\`
`
    },
    {
        name: "(i/o-file-is-read-only-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s38"),
        description: `**syntax**: \`&i/o-file-is-read-only\`
**procedure**: \`(make-i/o-file-is-read-only-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-is-read-only\`
**procedure**: \`(i/o-file-is-read-only-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-is-read-only\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates an attempt to treat as writeable a read-only file. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-is-read-only &i/o-file-protection\`
\`   make-i/o-file-is-read-only-error\`
\`   i/o-file-is-read-only-error?)\`
`
    },
    {
        name: "(i/o-file-protection-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s37"),
        description: `**syntax**: \`&i/o-file-protection\`
**procedure**: \`(make-i/o-file-protection-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-protection\`
**procedure**: \`(i/o-file-protection-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-protection\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates that an attempt has been made to perform some input/output operation on a file for which the program does not have the proper permission. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-protection &i/o-filename\`
\`   make-i/o-file-protection-error\`
\`   i/o-file-protection-error?)\`
`
    },
    {
        name: "(i/o-filename-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s36"),
        description: `**syntax**: \`&i/o-filename\`
**procedure**: \`(make-i/o-filename-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-filename\`
**procedure**: \`(i/o-filename-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-filename\`, \`#f\` otherwise
**procedure**: \`(i/o-error-filename \`*condition*\`)\`
**returns: **the contents of *condition*'s \`filename\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an input/output error that occurred while operating on a file. The *filename* argument to the constructor should be the name of the file. This condition type might be defined as follows.

\`(define-condition-type &i/o-filename &i/o\`
\`   make-i/o-filename-error i/o-filename-error?\`
\`   (filename i/o-error-filename))\`
`
    },
    {
        name: "(i/o-invalid-position-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s35"),
        description: `**syntax**: \`&i/o-invalid-position\`
**procedure**: \`(make-i/o-invalid-position-error \`*position*\`)\`
**returns: **a condition of type \`&i/o-invalid-position\`
**procedure**: \`(i/o-invalid-position-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-invalid-position\`, \`#f\` otherwise
**procedure**: \`(i/o-error-position \`*condition*\`)\`
**returns: **the contents of *condition*'s \`position\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an attempt to set a port's position to a position that is out of range for the underlying file or other object. The *position* argument to the constructor should be the invalid position. This condition type might be defined as follows.

\`(define-condition-type &i/o-invalid-position &i/o\`
\`   make-i/o-invalid-position-error\`
\`   i/o-invalid-position-error?\`
\`   (position i/o-error-position))\`
`
    },
    {
        name: "(i/o-port-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s41"),
        description: `**syntax**: \`&i/o-port\`
**procedure**: \`(make-i/o-port-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-port\`
**procedure**: \`(i/o-port-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-port\`, \`#f\` otherwise
**procedure**: \`(i/o-error-port \`*condition*\`)\`
**returns: **the contents of *condition*'s \`pobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type is usually included with a condition of one of the other \`&i/o\` subtypes to indicate the port involved in the exceptional situation, if a port is involved. The *pobj* argument to the constructor should be the port. This condition type might be defined as follows.

\`(define-condition-type &i/o-port &i/o\`
\`   make-i/o-port-error i/o-port-error?\`
\`   (pobj i/o-error-port))\`
`
    },
    {
        name: "(i/o-read-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s33"),
        description: `**syntax**: \`&i/o-read\`
**procedure**: \`(make-i/o-read-error)\`
**returns: **a condition of type \`&i/o-read\`
**procedure**: \`(i/o-read-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-read\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates that an error has occurred while reading from a port. This condition type might be defined as follows.

\`(define-condition-type &i/o-read &i/o\`
\`   make-i/o-read-error i/o-read-error?)\`
`
    },
    {
        name: "(i/o-write-error? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s34"),
        description: `**syntax**: \`&i/o-write\`
**procedure**: \`(make-i/o-write-error)\`
**returns: **a condition of type \`&i/o-write\`
**procedure**: \`(i/o-write-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-write\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates that an error has occurred while writing to a port. This condition type might be defined as follows.

\`(define-condition-type &i/o-write &i/o\`
\`   make-i/o-write-error i/o-write-error?)\`
`
    },
    {
        name: "(iconv-codec ",
        endParen: true,
        params: ["code-page"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s10"),
        description: `**procedure**: \`(iconv-codec \`*code-page*\`)\`
**returns: **a codec
**libraries: **\`(chezscheme)\`

*code-page* must be a string and should identify a codec accepted by the \`iconv\` library installed on the target machine. The codec returned by this procedure can be used to convert from the non-Unicode single- and multiple-byte character sets supported by \`iconv\`. When used in the input direction, the codec converts byte sequences into Scheme strings, and when used in the output direction, it converts Scheme strings to byte sequences.

The set of supported code pages depends on the version of \`iconv\` available; consult the \`iconv\` documentation or use the shell command \`iconv --list\` to obtain a list of supported code pages.

While the Windows operating system does not supply an \`iconv\` library, it is possible to use \`iconv-codec\` on Windows systems by supplying an \`iconv\` dynamic-link library (named \`iconv.dll\`, \`libiconv.dll\`, or \`libiconv-2.dll\`) that provides Posix-conformant \`iconv_open\`, \`iconv\`, and \`iconv_close\` entry points either under those names or under the alternative names \`libiconv_open\`, \`libiconv\`, and \`libiconv_close\`. The dll must be located in a standard location for dlls or in the current directory of the process the first time \`iconv-codec\` is called.
`
    },
    {
        name: "(identifier-syntax ",
        endParen: true,
        params: ["tmpl"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s27"),
        description: `**syntax**: \`(identifier-syntax \`*tmpl*\`)\`
**syntax**: \`(identifier-syntax (\`*id1*\` \`*tmpl1*\`) ((set! \`*id2*\` \`*e2*\`) \`*tmpl2*\`))\`
**returns: **a transformer
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

When a keyword is bound to a transformer produced by the first form of \`identifier-syntax\`, references to the keyword within the scope of the binding are replaced by *tmpl*.

\`(let ()\`
\`   (define-syntax a (identifier-syntax car))\`
\`   (list (a '(1 2 3)) a)) \`=>\` (1 #<procedure>)\`

With the first form of \`identifier-syntax\`, an apparent assignment of the associated keyword with \`set!\` is a syntax violation. The second, more general, form of \`identifier-syntax\` permits the transformer to specify what happens when \`set!\` is used.

\`(let ([ls (list 0)])\`
\`   (define-syntax a\`
\`     (identifier-syntax\`
\`       [id (car ls)]\`
\`       [(set! id e) (set-car! ls e)]))\`
\`   (let ([before a])\`
\`     (set! a 1)\`
\`     (list before a ls))) \`=>\` (0 1 (1))\`
`
    },
    {
        name: "(identifier-syntax (",
        endParen: true,
        params: ["id1", "tmpl1", "id2", "e2", "tmpl2", ")"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s27"),
        description: `**syntax**: \`(identifier-syntax \`*tmpl*\`)\`
**syntax**: \`(identifier-syntax (\`*id1*\` \`*tmpl1*\`) ((set! \`*id2*\` \`*e2*\`) \`*tmpl2*\`))\`
**returns: **a transformer
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

When a keyword is bound to a transformer produced by the first form of \`identifier-syntax\`, references to the keyword within the scope of the binding are replaced by *tmpl*.

\`(let ()\`
\`   (define-syntax a (identifier-syntax car))\`
\`   (list (a '(1 2 3)) a)) \`=>\` (1 #<procedure>)\`

With the first form of \`identifier-syntax\`, an apparent assignment of the associated keyword with \`set!\` is a syntax violation. The second, more general, form of \`identifier-syntax\` permits the transformer to specify what happens when \`set!\` is used.

\`(let ([ls (list 0)])\`
\`   (define-syntax a\`
\`     (identifier-syntax\`
\`       [id (car ls)]\`
\`       [(set! id e) (set-car! ls e)]))\`
\`   (let ([before a])\`
\`     (set! a 1)\`
\`     (list before a ls))) \`=>\` (0 1 (1))\`
`
    },
    {
        name: "(identifier? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s35"),
        description: `**procedure**: \`(identifier? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an identifier, \`#f\` otherwise
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`
`
    },
    {
        name: "ieee",
        endParen: false,
        params: [""],
        type: "module",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s33"),
        description: `**module**: \`ieee\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(ieee-environment)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s32"),
        description: `**procedure**: \`(ieee-environment)\`
**returns: **an IEEE/ANSI standard compatibility environment
**libraries: **\`(chezscheme)\`

\`ieee-environment\` returns an environment containing bindings for the keywords and variables whose meanings are defined by the IEEE/ANSI Standard for Scheme [].

The bindings for each of the identifiers in the IEEE environment are those of the corresponding Revised Report library, so this does not provide full backward compatibility.

The environment returned by this procedure is immutable.

\`(define cons 3)\`
\` (top-level-value 'cons (ieee-environment)) \`=>\` #<procedure cons>\`
\` (set-top-level-value! 'cons 3 (ieee-environment)) \`=>\` \`*exception*
`
    },
    {
        name: "(if ",
        endParen: true,
        params: ["test", "consequent", "alternative"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s8"),
        description: `**syntax**: \`(if \`*test*\` \`*consequent*\` \`*alternative*\`)\`
**syntax**: \`(if \`*test*\` \`*consequent*\`)\`
**returns: **the values of *consequent* or *alternative* depending on the value of *test*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(if ",
        endParen: true,
        params: ["test", "consequent"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s8"),
        description: `**syntax**: \`(if \`*test*\` \`*consequent*\` \`*alternative*\`)\`
**syntax**: \`(if \`*test*\` \`*consequent*\`)\`
**returns: **the values of *consequent* or *alternative* depending on the value of *test*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(imag-part ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s121"),
        description: `**procedure**: \`(imag-part \`*num*\`)\`
**returns: **the imaginary component of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *num* is real, \`imag-part\` returns exact zero.

\`(imag-part 3+4i) \`=>\` 4\`
\` (imag-part -2.3+0.7i) \`=>\` 0.7\`
\` (imag-part -i) \`=>\` -1\`
\` (imag-part -2.5) \`=>\` 0\`
\` (imag-part -17/100) \`=>\` 0\`
`
    },
    {
        name: "immutable",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(immutable-box? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s87"),
        description: `**procedure**: \`(mutable-box? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable box, \`#f\` otherwise
**procedure**: \`(immutable-box? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable box, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-box? (box 1)) \`=>\` #t\`
\` (mutable-box? (box-immutable 1)) \`=>\` #f\`
\` (immutable-box? (box 1)) \`=>\` #f\`
\` (immutable-box? (box-immutable 1)) \`=>\` #t\`
\` (mutable-box? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(immutable-bytevector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s66"),
        description: `**procedure**: \`(mutable-bytevector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable bytevector, \`#f\` otherwise
**procedure**: \`(immutable-bytevector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable bytevector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-bytevector? (bytevector 1 2 3)) \`=>\` #t\`
\` (mutable-bytevector?\`
\`   (bytevector->immutable-bytevector (bytevector 1 2 3))) \`=>\` #f\`
\` (immutable-bytevector? (bytevector 1 2 3)) \`=>\` #f\`
\` (immutable-bytevector?\`
\`   (bytevector->immutable-bytevector (bytevector 1 2 3))) \`=>\` #t\`
\` (immutable-bytevector? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(immutable-fxvector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s53"),
        description: `**procedure**: \`(mutable-fxvector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable fxvector, \`#f\` otherwise
**procedure**: \`(immutable-fxvector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable fxvector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-fxvector? (fxvector 1 2 3)) \`=>\` #t\`
\` (mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) \`=>\` #f\`
\` (immutable-fxvector? (fxvector 1 2 3)) \`=>\` #f\`
\` (immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) \`=>\` #t\`
\` (immutable-fxvector? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(immutable-string? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s24"),
        description: `**procedure**: \`(mutable-string? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable string, \`#f\` otherwise
**procedure**: \`(immutable-string? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable string, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-string? (string #\\a #\\b #\\c)) \`=>\` #t\`
\` (mutable-string? (string->immutable-string "abc")) \`=>\` #f\`
\` (immutable-string? (string #\\a #\\b #\\c)) \`=>\` #f\`
\` (immutable-string? (string->immutable-string "abc")) \`=>\` #t\`
\` (immutable-string? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(immutable-vector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s34"),
        description: `**procedure**: \`(mutable-vector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable vector, \`#f\` otherwise
**procedure**: \`(immutable-vector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable vector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-vector? (vector 1 2 3)) \`=>\` #t\`
\` (mutable-vector? (vector->immutable-vector (vector 1 2 3))) \`=>\` #f\`
\` (immutable-vector? (vector 1 2 3)) \`=>\` #f\`
\` (immutable-vector? (vector->immutable-vector (vector 1 2 3))) \`=>\` #t\`
\` (immutable-vector? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(implementation-restriction-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s28"),
        description: `**syntax**: \`&implementation-restriction\`
**procedure**: \`(make-implementation-restriction-violation)\`
**returns: **a condition of type \`&implementation-restriction\`
**procedure**: \`(implementation-restriction-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&implementation-restriction\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

An implementation-restriction condition indicates that the program has attempted to exceed some limitation in the implementation, such as when the value of a fixnum addition operation would result in a number that exceeds the implementation's fixnum range. It does not normally indicate a deficiency in the implementation but rather a mismatch between what the program is attempting to do and what the implementation can support. In many cases, implementation restrictions are dictated by the underlying hardware. This condition type might be defined as follows.

\`(define-condition-type &implementation-restriction &violation\`
\`   make-implementation-restriction-violation\`
\`   implementation-restriction-violation?)\`
`
    },
    {
        name: "(implicit-exports #t)",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s19"),
        description: `**syntax**: \`(implicit-exports #t)\`
**syntax**: \`(implicit-exports #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

An \`implicit-exports\` form is a definition and can appear with other definitions at the front of a \`library\` or \`module\`. It is a syntax error for an \`implicit-exports\` form to appear in other contexts, including at top level or among the definitions of a top-level program or \`lambda\` body.

The \`implicit-exports\` form determines whether identifiers not directly exported from a module or library are automatically indirectly exported to the top level if any meta-binding (keyword, meta definition, or property definition) is directly exported to top level from the library or module. The default for libraries is \`#t\`, to match the behavior required by the Revised Report, while the default for modules is \`#f\`. The \`implicit-exports\` form is meaningful only within a library, top-level module, or module enclosed within a library or top-level module. It is allowed in a module enclosed within a \`lambda\`, \`let\`, or similar body, but ignored there because none of that module's bindings can be exported to top level.

The advantage of \`(implicit-exports #t)\` is that indirect exports need not be listed explicitly, which is convenient. A disadvantage is that it often results in more bindings than necessary being elevated to top level where they cannot be discarded as useless by the optimizer. For modules, another disadvantage is such bindings cannot be proven immutable, which inhibits important optimizations such as procedure inlining. This can result in significantly lower run-time performance.
`
    },
    {
        name: "(implicit-exports #f)",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s19"),
        description: `**syntax**: \`(implicit-exports #t)\`
**syntax**: \`(implicit-exports #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

An \`implicit-exports\` form is a definition and can appear with other definitions at the front of a \`library\` or \`module\`. It is a syntax error for an \`implicit-exports\` form to appear in other contexts, including at top level or among the definitions of a top-level program or \`lambda\` body.

The \`implicit-exports\` form determines whether identifiers not directly exported from a module or library are automatically indirectly exported to the top level if any meta-binding (keyword, meta definition, or property definition) is directly exported to top level from the library or module. The default for libraries is \`#t\`, to match the behavior required by the Revised Report, while the default for modules is \`#f\`. The \`implicit-exports\` form is meaningful only within a library, top-level module, or module enclosed within a library or top-level module. It is allowed in a module enclosed within a \`lambda\`, \`let\`, or similar body, but ignored there because none of that module's bindings can be exported to top level.

The advantage of \`(implicit-exports #t)\` is that indirect exports need not be listed explicitly, which is convenient. A disadvantage is that it often results in more bindings than necessary being elevated to top level where they cannot be discarded as useless by the optimizer. For modules, another disadvantage is such bindings cannot be proven immutable, which inhibits important optimizations such as procedure inlining. This can result in significantly lower run-time performance.
`
    },
    {
        name: "(import ",
        endParen: true,
        params: ["import-spec", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s16"),
        description: `**syntax**: \`(import \`*import-spec*\` ...)\`
**syntax**: \`(import-only \`*import-spec*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

An \`import\` or \`import-only\` form is a definition and can appear anywhere other definitions can appear, including at the top level of a program, nested within the bodies of \`lambda\` expressions, and nested within modules and libraries.

Each *import-spec* must take one of the following forms.

*import-set*
\` (for \`*import-set*\` \`*import-level*\` ...)\`

The \`for\` wrapper and *import-level* are described in Chapter  of . They are ignored by , which determines automatically the levels at which identifiers must be imported, as permitted by the Revised Report. This frees the programmer from the obligation to do so and results in more generality as well as more precision in the set of libraries actually imported at compile and run time [,].

An *import-set* must take one of the following forms:

*library-spec*
\` \`*module-name*
\` (only \`*import-set*\` \`*identifier*\` ...)\`
\` (except \`*import-set*\` \`*identifier*\` ...)\`
\` (prefix \`*import-set*\` \`*prefix*\`)\`
\` (add-prefix \`*import-set*\` \`*prefix*\`)\`
\` (drop-prefix \`*import-set*\` \`*prefix*\`)\`
\` (rename \`*import-set*\` (\`*import-name*\` \`*internal-name*\`) ...)\`
\` (alias \`*import-set*\` (\`*import-name*\` \`*internal-name*\`) ...)\`

Several of these are specified by the Revised Report; the remainder are extensions, including *module-name* and the \`add-prefix\`, \`drop-prefix\`, and \`alias\` forms.

An \`import\` or \`import-only\` form makes the specified bindings visible in the scope in which they appear. Except at top level, they differ in that \`import\` leaves all bindings except for those shadowed by the imported names visible, whereas \`import-only\` hides all existing bindings, i.e., makes only the imported names visible. At top level, \`import-only\` behaves like \`import\`.

Each *import-set* identifies a set of names to make visible as follows.

The \`alias\` form differs from the \`rename\` form in that both *import-name* and *internal-name* are in the resulting set, rather than just *internal-name*.

It is a syntax violation if the given selection or transformation cannot be made because of a missing export or prefix.

An identifier made visible via an import of a module or library is scoped as if its definition appears where the import occurs. The following example illustrates these scoping rules, using a local module \`m\`.

\`(library (A) (export x) (import (rnrs)) (define x 0))\`
\` (let ([x 1])\`
\`   (module m (x setter)\`
\`     (define-syntax x (identifier-syntax z))\`
\`     (define setter (lambda (x) (set! z x)))\`
\`     (define z 2))\`
\`   (let ([y x] [z 3])\`
\`     (import m (prefix (A) a:))\`
\`     (setter 4)\`
\`     (list x a:x y z))) \`=>\` (4 0 1 3)\`

The inner \`let\` expression binds \`y\` to the value of the \`x\` bound by the outer \`let\`. The import of \`m\` makes the definitions of \`x\` and \`setter\` visible within the inner \`let\`. The import of \`(A)\` makes the variable \`x\` exported from \`(A)\` visible as \`a:x\` within the body of the inner \`let\`. Thus, in the expression \`(list x a:x y z)\`, \`x\` refers to the identifier macro exported from \`m\` while \`a:x\` refers to the variable \`x\` exported from \`(A)\` and \`y\` and \`z\` refer to the bindings established by the inner \`let\`. The identifier macro \`x\` expands into a reference to the variable \`z\` defined within the module.

With local import forms, it is rarely necessary to use the extended import specifiers. For example, an abstraction that encapsulates the import and reference can easily be defined and used as follows.

\`(define-syntax from\`
\`   (syntax-rules ()\`
\`     [(_ m id) (let () (import-only m) id)])) \`
\` \`
\` (library (A) (export x) (import (rnrs)) (define x 1))\`
\` (let ([x 10])\`
\`   (module M (x) (define x 2))\`
\`   (cons (from (A) x) (from M x))) \`=>\` (1 . 2)\`

The definition of \`from\` could use \`import\` rather than \`import-only\`, but by using \`import-only\` we get feedback if an attempt is made to import an identifier from a library or module that does not export the identifier. With \`import\` instead of \`import-only\`, the current binding, if any, would be visible if the library or module does not export the specified name.

\`(define-syntax lax-from\`
\`   (syntax-rules ()\`
\`     [(_ m id) (let () (import m) id)])) \`
\` \`
\` (library (A) (export x) (import (rnrs)) (define x 1)) \`
\` \`
\` (let ([x 10])\`
\`   (module M (x) (define x 2))\`
\`   (+ (from (A) x) (from M y))) \`=>\` \`*exception: unbound identifier y*
\`  \`
\` (let ([x 10] [y 20])\`
\`   (module M (x) (define x 2))\`
\`   (+ (lax-from (A) x) (lax-from M y))) \`=>\` 21\`

Import visibility interacts with hygienic macro expansion in such a way that, as one might expect, an identifier *x* imported from a module *M* is treated in the importing context as if the corresponding export identifier had been present in the import form along with *M*.

The \`from\` abstraction above works because both *M* and *id* appear in the input to the abstraction, so the imported *id* captures the reference to *id*.

The following variant of *from* also works, because both names are introduced into the output by the transformer.

\`(module M (x) (define x 'x-of-M))\`
\` (define-syntax x-from-M\`
\`   (syntax-rules ()\`
\`     [(_) (let () (import M) x)])) \`
\` \`
\` (let ([x 'local-x]) (x-from-M)) \`=>\` x-of-M\`

On the other hand, imports of introduced module names do not capture free references.

\`(let ([x 'local-x])\`
\`   (define-syntax alpha\`
\`     (syntax-rules ()\`
\`       [(_ var) (let () (import M) (list x var))]))\`
\`  \`
\`   (alpha x)) \`=>\` (x-of-M local-x)\`

Similarly, imports from free module names do not capture references to introduced variables.

\`(let ([x 'local-x])\`
\`   (define-syntax beta\`
\`     (syntax-rules ()\`
\`       [(_ m var) (let () (import m) (list x var))])) \`
\` \`
\`   (beta M x)) \`=>\` (local-x x-of-M)\`

This semantics extends to prefixed, renamed, and aliased bindings created by the extended \`import\` specifiers \`prefix\`, \`rename\`, and \`alias\`.

The \`from\` abstraction works for variables but not for exported keywords, record names, or module names, since the output is an expression and may thus appear only where expressions may appear. A generalization of this technique is used in the following definition of \`import*\`, which supports renaming of imported bindings and selective import of specific bindings---without the use of the built-in \`import\` subforms for selecting and renaming identifiers

\`(define-syntax import*\`
\`   (syntax-rules ()\`
\`     [(_ m) (begin)]\`
\`     [(_ m (new old))\`
\`      (module (new)\`
\`        (module (tmp)\`
\`          (import m)\`
\`          (alias tmp old))\`
\`        (alias new tmp))]\`
\`     [(_ m id) (module (id) (import m))]\`
\`     [(_ m spec0 spec1 ...)\`
\`      (begin (import* m spec0) (import* m spec1 ...))]))\`

To selectively import an identifier from module or library \`m\`, the \`import*\` form expands into an anonymous module that first imports all exports of \`m\` then re-exports only the selected identifier. To rename on import the macro expands into an anonymous module that instead exports an alias (Section ) bound to the new name.

If the output placed the definition of \`new\` in the same scope as the import of \`m\`, a naming conflict would arise whenever \`new\` is also present in the interface of \`m\`. To prevent this, the output instead places the import within a nested anonymous module and links \`old\` and \`new\` by means of an alias for the introduced identifier \`tmp\`.

The macro expands recursively to handle multiple import specifications. Each of the following examples imports \`cons\` as \`+\` and \`+\` as \`cons\`, which is probably not a very good idea.

\`(let ()\`
\`   (import* scheme (+ cons) (cons +))\`
\`   (+ (cons 1 2) (cons 3 4))) \`=>\` (3 . 7) \`
\` \`
\` (let ()\`
\`   (import* (rnrs) (+ cons) (cons +))\`
\`   (+ (cons 1 2) (cons 3 4))) \`=>\` (3 . 7)\`
`
    },
    {
        name: "import-notify",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s29"),
        description: `**thread parameter**: \`import-notify\`
**libraries: **\`(chezscheme)\`

When the new parameter \`import-notify\` is set to a true value, \`import\` displays messages to the console-output port as it searches for the file containing each library it needs to load. The default value of this parameter is \`#f\`.
`
    },
    {
        name: "(import-only ",
        endParen: true,
        params: ["import-spec", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s16"),
        description: `**syntax**: \`(import \`*import-spec*\` ...)\`
**syntax**: \`(import-only \`*import-spec*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

An \`import\` or \`import-only\` form is a definition and can appear anywhere other definitions can appear, including at the top level of a program, nested within the bodies of \`lambda\` expressions, and nested within modules and libraries.

Each *import-spec* must take one of the following forms.

*import-set*
\` (for \`*import-set*\` \`*import-level*\` ...)\`

The \`for\` wrapper and *import-level* are described in Chapter  of . They are ignored by , which determines automatically the levels at which identifiers must be imported, as permitted by the Revised Report. This frees the programmer from the obligation to do so and results in more generality as well as more precision in the set of libraries actually imported at compile and run time [,].

An *import-set* must take one of the following forms:

*library-spec*
\` \`*module-name*
\` (only \`*import-set*\` \`*identifier*\` ...)\`
\` (except \`*import-set*\` \`*identifier*\` ...)\`
\` (prefix \`*import-set*\` \`*prefix*\`)\`
\` (add-prefix \`*import-set*\` \`*prefix*\`)\`
\` (drop-prefix \`*import-set*\` \`*prefix*\`)\`
\` (rename \`*import-set*\` (\`*import-name*\` \`*internal-name*\`) ...)\`
\` (alias \`*import-set*\` (\`*import-name*\` \`*internal-name*\`) ...)\`

Several of these are specified by the Revised Report; the remainder are extensions, including *module-name* and the \`add-prefix\`, \`drop-prefix\`, and \`alias\` forms.

An \`import\` or \`import-only\` form makes the specified bindings visible in the scope in which they appear. Except at top level, they differ in that \`import\` leaves all bindings except for those shadowed by the imported names visible, whereas \`import-only\` hides all existing bindings, i.e., makes only the imported names visible. At top level, \`import-only\` behaves like \`import\`.

Each *import-set* identifies a set of names to make visible as follows.

The \`alias\` form differs from the \`rename\` form in that both *import-name* and *internal-name* are in the resulting set, rather than just *internal-name*.

It is a syntax violation if the given selection or transformation cannot be made because of a missing export or prefix.

An identifier made visible via an import of a module or library is scoped as if its definition appears where the import occurs. The following example illustrates these scoping rules, using a local module \`m\`.

\`(library (A) (export x) (import (rnrs)) (define x 0))\`
\` (let ([x 1])\`
\`   (module m (x setter)\`
\`     (define-syntax x (identifier-syntax z))\`
\`     (define setter (lambda (x) (set! z x)))\`
\`     (define z 2))\`
\`   (let ([y x] [z 3])\`
\`     (import m (prefix (A) a:))\`
\`     (setter 4)\`
\`     (list x a:x y z))) \`=>\` (4 0 1 3)\`

The inner \`let\` expression binds \`y\` to the value of the \`x\` bound by the outer \`let\`. The import of \`m\` makes the definitions of \`x\` and \`setter\` visible within the inner \`let\`. The import of \`(A)\` makes the variable \`x\` exported from \`(A)\` visible as \`a:x\` within the body of the inner \`let\`. Thus, in the expression \`(list x a:x y z)\`, \`x\` refers to the identifier macro exported from \`m\` while \`a:x\` refers to the variable \`x\` exported from \`(A)\` and \`y\` and \`z\` refer to the bindings established by the inner \`let\`. The identifier macro \`x\` expands into a reference to the variable \`z\` defined within the module.

With local import forms, it is rarely necessary to use the extended import specifiers. For example, an abstraction that encapsulates the import and reference can easily be defined and used as follows.

\`(define-syntax from\`
\`   (syntax-rules ()\`
\`     [(_ m id) (let () (import-only m) id)])) \`
\` \`
\` (library (A) (export x) (import (rnrs)) (define x 1))\`
\` (let ([x 10])\`
\`   (module M (x) (define x 2))\`
\`   (cons (from (A) x) (from M x))) \`=>\` (1 . 2)\`

The definition of \`from\` could use \`import\` rather than \`import-only\`, but by using \`import-only\` we get feedback if an attempt is made to import an identifier from a library or module that does not export the identifier. With \`import\` instead of \`import-only\`, the current binding, if any, would be visible if the library or module does not export the specified name.

\`(define-syntax lax-from\`
\`   (syntax-rules ()\`
\`     [(_ m id) (let () (import m) id)])) \`
\` \`
\` (library (A) (export x) (import (rnrs)) (define x 1)) \`
\` \`
\` (let ([x 10])\`
\`   (module M (x) (define x 2))\`
\`   (+ (from (A) x) (from M y))) \`=>\` \`*exception: unbound identifier y*
\`  \`
\` (let ([x 10] [y 20])\`
\`   (module M (x) (define x 2))\`
\`   (+ (lax-from (A) x) (lax-from M y))) \`=>\` 21\`

Import visibility interacts with hygienic macro expansion in such a way that, as one might expect, an identifier *x* imported from a module *M* is treated in the importing context as if the corresponding export identifier had been present in the import form along with *M*.

The \`from\` abstraction above works because both *M* and *id* appear in the input to the abstraction, so the imported *id* captures the reference to *id*.

The following variant of *from* also works, because both names are introduced into the output by the transformer.

\`(module M (x) (define x 'x-of-M))\`
\` (define-syntax x-from-M\`
\`   (syntax-rules ()\`
\`     [(_) (let () (import M) x)])) \`
\` \`
\` (let ([x 'local-x]) (x-from-M)) \`=>\` x-of-M\`

On the other hand, imports of introduced module names do not capture free references.

\`(let ([x 'local-x])\`
\`   (define-syntax alpha\`
\`     (syntax-rules ()\`
\`       [(_ var) (let () (import M) (list x var))]))\`
\`  \`
\`   (alpha x)) \`=>\` (x-of-M local-x)\`

Similarly, imports from free module names do not capture references to introduced variables.

\`(let ([x 'local-x])\`
\`   (define-syntax beta\`
\`     (syntax-rules ()\`
\`       [(_ m var) (let () (import m) (list x var))])) \`
\` \`
\`   (beta M x)) \`=>\` (local-x x-of-M)\`

This semantics extends to prefixed, renamed, and aliased bindings created by the extended \`import\` specifiers \`prefix\`, \`rename\`, and \`alias\`.

The \`from\` abstraction works for variables but not for exported keywords, record names, or module names, since the output is an expression and may thus appear only where expressions may appear. A generalization of this technique is used in the following definition of \`import*\`, which supports renaming of imported bindings and selective import of specific bindings---without the use of the built-in \`import\` subforms for selecting and renaming identifiers

\`(define-syntax import*\`
\`   (syntax-rules ()\`
\`     [(_ m) (begin)]\`
\`     [(_ m (new old))\`
\`      (module (new)\`
\`        (module (tmp)\`
\`          (import m)\`
\`          (alias tmp old))\`
\`        (alias new tmp))]\`
\`     [(_ m id) (module (id) (import m))]\`
\`     [(_ m spec0 spec1 ...)\`
\`      (begin (import* m spec0) (import* m spec1 ...))]))\`

To selectively import an identifier from module or library \`m\`, the \`import*\` form expands into an anonymous module that first imports all exports of \`m\` then re-exports only the selected identifier. To rename on import the macro expands into an anonymous module that instead exports an alias (Section ) bound to the new name.

If the output placed the definition of \`new\` in the same scope as the import of \`m\`, a naming conflict would arise whenever \`new\` is also present in the interface of \`m\`. To prevent this, the output instead places the import within a nested anonymous module and links \`old\` and \`new\` by means of an alias for the introduced identifier \`tmp\`.

The macro expands recursively to handle multiple import specifications. Each of the following examples imports \`cons\` as \`+\` and \`+\` as \`cons\`, which is probably not a very good idea.

\`(let ()\`
\`   (import* scheme (+ cons) (cons +))\`
\`   (+ (cons 1 2) (cons 3 4))) \`=>\` (3 . 7) \`
\` \`
\` (let ()\`
\`   (import* (rnrs) (+ cons) (cons +))\`
\`   (+ (cons 1 2) (cons 3 4))) \`=>\` (3 . 7)\`
`
    },
    {
        name: "(include ",
        endParen: true,
        params: ["path"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s12"),
        description: `**syntax**: \`(include \`*path*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`include\` expands into a \`begin\` expression containing the forms found in the file named by *path*. For example, if the file \`f-def.ss\` contains \`(define f (lambda () x))\`, the expression

\`(let ([x "okay"])\`
\`   (include "f-def.ss")\`
\`   (f))\`

evaluates to \`"okay"\`. An include form is treated as a definition if it appears within a sequence of definitions and the forms on the file named by *path* are all definitions, as in the above example. If the file contains expressions instead, the \`include\` form is treated as an expression.

\`include\` may be defined portably as follows, although uses an implementation-dependent definition that allows it to capture and maintain source information for included code.

\`(define-syntax include\`
\`   (lambda (x)\`
\`     (define read-file\`
\`       (lambda (fn k)\`
\`         (let ([p (open-input-file fn)])\`
\`           (let f ([x (read p)])\`
\`             (if (eof-object? x)\`
\`                 (begin (close-input-port p) '())\`
\`                 (cons (datum->syntax k x)\`
\`                       (f (read p))))))))\`
\`     (syntax-case x ()\`
\`       [(k filename)\`
\`        (let ([fn (datum filename)])\`
\`          (with-syntax ([(exp ...) (read-file fn #'k)])\`
\`            #'(begin exp ...)))])))\`

The definition of \`include\` uses \`datum->syntax\` to convert the objects read from the file into syntax objects in the proper lexical context, so that identifier references and definitions within those expressions are scoped where the \`include\` form appears.

In 's implementation of \`include\`, the parameter \`source-directories\` (Section ) determines the set of directories searched for source files not identified by absolute path names.
`
    },
    {
        name: "(indirect-export ",
        endParen: true,
        params: ["id", "indirect-id", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s18"),
        description: `**syntax**: \`(indirect-export \`*id*\` \`*indirect-id*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This form is a definition and can appear wherever any other definition can appear.

An \`indirect-export\` form declares that the named *indirect-id*s are indirectly exported to top level if *id* is exported to top level.

In general, if an identifier is not directly exported by a library or module, it can be referenced outside of the library or module only in the expansion of a macro defined within and exported from the library or module. Even this cannot occur for libraries or modules defined at top level (or nested within other libraries or modules), unless either (1) the library or module has been set up to implicitly export all identifiers as indirect exports, or (2) each indirectly exported identifier is explicitly declared as an indirect export of some other identifier that is exported, either directly or indirectly, from the library or module, via an \`indirect-export\` or the built-in indirect export feature of a \`module\` export subform. By default, (1) is true for a library and false for a module, but the default can be overridden via the \`implicit-exports\` form, which is described below.

This form is meaningful only within a top-level library, top-level module, or module enclosed within a library or top-level module, although it has no effect if the library or module already implicitly exports all bindings. It is allowed anywhere else definitions can appear, however, so macros that expand into indirect export forms can be used in any definition context.

Indirect exports are listed so the compiler can determine the exact set of bindings (direct and indirect) that must be inserted into the top-level environment, and conversely, the set of bindings that may be treated more efficiently as local bindings (and perhaps discarded, if they are not used).

In the example below, \`indirect-export\` is used to indirectly export \`count\` to top level when \`current-count\` is exported to top level.

\`(module M (bump-count current-count)\`
\`   (define-syntax current-count (identifier-syntax count))\`
\`   (indirect-export current-count count)\`
\`   (define count 0)\`
\`   (define bump-count\`
\`     (lambda ()\`
\`       (set! count (+ count 1))))) \`
\` \`
\` (import M)\`
\` (bump-count)\`
\` current-count \`=>\` 1\`
\` count \`=>\` \`*exception: unbound identifier count*

An \`indirect-export\` form is not required to make \`count\` visible for \`bump-count\`, since it is a procedure whose code is contained within the module rather than a macro that might expand into a reference to \`count\` somewhere outside the module.

It is often useful to use \`indirect-export\` in the output of a macro that expands into another macro named *a* if *a* expands into references to identifiers that might not be directly exported, as illustrated by the alternative definition of module \`M\` above.

\`(define-syntax define-counter\`
\`   (syntax-rules ()\`
\`     [(_ getter bumper init incr)\`
\`      (begin\`
\`        (define count init)\`
\`        (define-syntax getter (identifier-syntax count))\`
\`        (indirect-export getter count)\`
\`        (define bumper\`
\`          (lambda ()\`
\`            (set! count (incr count)))))])) \`
\` \`
\` (module M (bump-count current-count)\`
\`   (define-counter current-count bump-count 0 add1))\`
`
    },
    {
        name: "(inexact ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s112"),
        description: `**procedure**: \`(inexact \`*num*\`)\`
**returns: **an inexact representation of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(inexact->exact ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s116"),
        description: `**procedure**: \`(exact->inexact \`*num*\`)\`
**returns: **an inexact representation of *num*
**procedure**: \`(inexact->exact \`*num*\`)\`
**returns: **an exact representation of *num*
**libraries: **\`(rnrs r5rs)\`

These are alternative names for \`inexact\` and \`exact\`, supported for compatibility with the Revised Report.
`
    },
    {
        name: "(inexact? ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s87"),
        description: `**procedure**: \`(inexact? \`*num*\`)\`
**returns: **\`#t\` if *num* is inexact, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (inexact? -123) \`=>\` #f\`
\` (inexact? #i123) \`=>\` #t\`
\` (inexact? 1e23) \`=>\` #t\`
\` (inexact? +i) \`=>\` #f\`
`
    },
    {
        name: "(infinite? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s97"),
        description: `**procedure**: \`(finite? \`*real*\`)\`
**returns: **\`#t\` if *real* is finite, \`#f\` otherwise
**procedure**: \`(infinite? \`*real*\`)\`
**returns: **\`#t\` if *real* is infinite, \`#f\` otherwise
**procedure**: \`(nan? \`*real*\`)\`
**returns: **\`#t\` if *real* is a NaN, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (finite? 2/3) \`=>\` #t\`
\` (infinite? 2/3) \`=>\` #f\`
\` (nan? 2/3) \`=>\` #f \`
\` \`
\` (finite? 3.1415) \`=>\` #t\`
\` (infinite? 3.1415) \`=>\` #f\`
\` (nan? 3.1415) \`=>\` #f \`
\` \`
\` (finite? +inf.0) \`=>\` #f\`
\` (infinite? -inf.0) \`=>\` #t\`
\` (nan? -inf.0) \`=>\` #f \`
\` \`
\` (finite? +nan.0) \`=>\` #f\`
\` (infinite? +nan.0) \`=>\` #f\`
\` (nan? +nan.0) \`=>\` #t\`
`
    },
    {
        name: "(initial-bytes-allocated)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s224"),
        description: `**procedure**: \`(initial-bytes-allocated)\`
**returns: **the total number of bytes allocated after loading boot files
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(input-port-ready? ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s67"),
        description: `**procedure**: \`(input-port-ready? \`*input-port*\`)\`
**returns: **\`#t\` if data is available on *input-port*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`input-port-ready?\` allows a program to check to see if input is available on a textual or binary input port without hanging. If input is available or the port is at end of file, \`input-port-ready?\` returns \`#t\`. If it cannot determine from the port whether input is ready, \`input-port-ready?\` raises an exception with condition type \`&i/o-read-error\`. Otherwise, it returns \`#f\`.
`
    },
    {
        name: "(input-port? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s44"),
        description: `**procedure**: \`(input-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an input or input/output port, \`#f\` otherwise
**procedure**: \`(output-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an output or input/output port, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`
`
    },
    {
        name: "(inspect ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s22"),
        description: `**procedure**: \`(inspect \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Invokes the inspector on *obj*, as described above. The commands recognized by the inspector are listed below, categorized by the type of the current object.

**Generally applicable commands**

\`help\` or \`h\` displays a brief description of how to use the inspector.

\`?\` displays commands applicable to the current type of object.

\`??\` displays the generally applicable commands.

\`print\` or \`p\` prints the current object (using \`pretty-print\`).

\`write\` or \`w\` writes the current object (using \`write\`).
`
    },
    {
        name: "(inspect/object ",
        endParen: true,
        params: ["object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s25"),
        description: `**procedure**: \`(inspect/object \`*object*\`)\`
**returns: **an inspector object procedure
**libraries: **\`(chezscheme)\`

\`inspect/object\` is used to turn an ordinary Scheme object into an inspector object. All inspector objects accept the messages \`type\`, \`print\`, \`write\`, and \`size\`. The \`type\` message returns a symbolic representation of the type of the object. The \`print\` and \`write\` messages must be accompanied by a port parameter. They cause a representation of the object to be written to the port, using the Scheme procedures \`pretty-print\` and \`write\`. The \`size\` message returns a fixnum representing the size in bytes occupied by the object, including any objects accessible from the current object except those for which the size was already requested via an inspector object derived from the argument of the same \`inspect/object\` call.

All inspector objects except for variable inspector objects accept the message \`value\`, which returns the actual object encapsulated in the inspector object.

\`(define x (inspect/object '(1 2 3)))\`
\` (x 'type) \`=>\` pair\`
\` (define p (open-output-string))\`
\` (x 'write p)\`
\` (get-output-string p) \`=>\` "(1 2 3)"\`
\` (x 'length) \`=>\` (proper 3)\`
\` (define y (x 'car))\`
\` (y 'type) \`=>\` simple\`
\` (y 'value) \`=>\` 1\`

**Pair inspector objects.** Pair inspector objects contain Scheme pairs.

\`(\` \`'type\`\`)\` returns the symbol \`pair\`.

\`(\` \`'car\`\`)\` returns an inspector object containing the "car" field of the pair.

\`(\` \`'cdr\`\`)\` returns an inspector object containing the "cdr" field of the pair.

\`(\` \`'length\`\`)\` returns a list of the form (*type* *count*). The type field contains the symbol \`proper\`, the symbol \`improper\`, or the symbol \`circular\`, depending on the structure of the list. The count field contains the number of distinct pairs in the list.

**Box inspector objects.** Box inspector objects contain boxes.

\`(\` \`'type\`\`)\` returns the symbol \`box\`.

\`(\` \`'unbox\`\`)\` returns an inspector object containing the contents of the box.

**TLC inspector objects.** Box inspector objects contain boxes.

\`(\` \`'type\`\`)\` returns the symbol \`tlc\`.

\`(\` \`'keyval\`\`)\` returns an inspector object containing the TLC's keyval.

\`(\` \`'tconc\`\`)\` returns an inspector object containing the TLC's tconc.

\`(\` \`'next\`\`)\` returns an inspector object containing the TLC's next link.

**Vector, String, Bytevector, and Fxvector inspector objects.** Vector (bytevector, string, fxvector) inspector objects contain Scheme vectors (bytevectors, strings, fxvectors).

\`(\` \`'type\`\`)\` returns the symbol \`vector\` (\`string\`, \`bytevector\`, \`fxvector\`).

\`(\` \`'length\`\`)\` returns the number of elements in the vector or string.

\`(\` \`'ref\` *n*\`)\` returns an inspector object containing the *nth* element of the vector or string.

**Simple inspector objects.** Simple inspector objects contain unstructured, unmodifiable objects. These include numbers, booleans, the empty list, the end-of-file object, and the void object. They may be examined directly by asking for the \`value\` of the object.

\`(\` \`'type\`\`)\` returns the symbol \`simple\`.

**Unbound inspector objects.** Although unbound objects are not normally accessible to Scheme programs, they may be encountered when inspecting variables.

\`(\` \`'type\`\`)\` returns the symbol \`unbound\`.

**Procedure inspector objects.** Procedure inspector objects contain Scheme procedures.

\`(\` \`'type\`\`)\` returns the symbol \`procedure\`.

\`(\` \`'length\`\`)\` returns the number of free variables.

\`(\` \`'ref\` *n*\`)\` returns an inspector object containing the *nth* free variable of the procedure. See the description below of variable inspector objects. *n* must be nonnegative and less than the length of the procedure.

\`(\` \`'eval\` *expr*\`)\` evaluates *expr* and returns its value. The values of the procedure's free variables are bound within the evaluated expression to identifiers of the form %, where is the location number displayed by the inspector. The values of named variables are also bound to their names.

\`(\` \`'code\`\`)\` returns an inspector object containing the procedure's code object. See the description below of code inspector objects.

**Continuation inspector objects.** Continuations created by \`call/cc\` are actually procedures. However, when inspecting such a procedure the underlying data structure that embodies the continuation may be exposed. A continuation structure contains the location at which computation is to resume, the variable values necessary to perform the computation, and a link to the next continuation.

\`(\` \`'type\`\`)\` returns the symbol \`continuation\`.

\`(\` \`'length\`\`)\` returns the number of free variables.

\`(\` \`'ref\` *n*\`)\` returns an inspector object containing the *nth* free variable of the continuation. See the description below of variable inspector objects. *n* must be nonnegative and less than the length of the continuation.

\`(\` \`'eval\` *expr*\`)\` evaluates *expr* and returns its value. The values of frame locations are bound within the evaluated expression to identifiers of the form %, where is the location number displayed by the inspector. The values of named locations are also bound to their names.

\`(\` \`'code\`\`)\` returns an inspector object containing the code object for the procedure that was active when the current continuation frame was created. See the description below of code inspector objects.

\`(\` \`'depth\`\`)\` returns the number of frames in the continuation.

\`(\` \`'link\`\`)\` returns an inspector object containing the next continuation frame. The depth must be greater than 1.

\`(\` \`'link*\` *n*\`)\` returns an inspector object containing the *nth* continuation link. *n* must be less than the depth.

\`(\` \`'source\`\`)\` returns an inspector object containing the source information attached to the continuation (representing the source for the application that resulted in the formation of the continuation) or \`#f\` if no source information is attached.

\`(\` \`'source-object\`\`)\` returns an inspector object containing the source object for the procedure application that resulted in the formation of the continuation or \`#f\` if no source object is attached.

\`(\` \`'source-path\`\`)\` attempts to find the pathname of the file containing the source for the procedure application that resulted in the formation of the continuation. If successful, three values are returned to identify the file and position of the application within the file: *path*, *line*, and *char*. Two values, a file name and an absolute character position, are returned if the file name is known but the named file cannot be found. The search may be unsuccessful even if a file by the expected name is found in the path if the file has been modified since the source code was compiled. If no file name is known, no values are returned. The parameter \`source-directories\` (Section ) determines the set of directories searched for source files identified by relative path names.

**Code inspector objects.** Code inspector objects contain code objects.

\`(\` \`'type\`\`)\` returns the symbol \`code\`.

\`(\` \`'name\`\`)\` returns a string or \`#f\`. The name associated with a code inspector object is the name of the variable to which the procedure was originally bound or assigned. Since the binding of a variable can be changed, this name association may not always be accurate. \`#f\` is returned if the inspector cannot determine a name for the procedure.

\`(\` \`'source\`\`)\` returns an inspector object containing the source information attached to the code object or \`#f\` if no source information is attached.

\`(\` \`'source-object\`\`)\` returns an inspector object containing the source object for the code object or \`#f\` if no source object is attached.

\`(\` \`'source-path\`\`)\` attempts to find the pathname of the file containing the source for the lambda expression that produced the code object. If successful, three values are returned to identify the file and position of the application within the file: *path*, *line*, and *char*. Two values, a file name and an absolute character position, are returned if the file name is known but the named file cannot be found. The search may be unsuccessful even if a file by the expected name is found in the path if the file has been modified since the source code was compiled. If no file name is known, no values are returned. The parameter \`source-directories\` (Section ) determines the set of directories searched for source files identified by relative path names.

\`(\` \`'free-count\`\`)\` returns the number of free variables in any procedure for which this is the corresponding code.

**Variable inspector objects.** Variable inspector objects encapsulate variable bindings. Although the actual underlying representation varies, the variable inspector object provides a uniform interface.

\`(\` \`'type\`\`)\` returns the symbol \`variable\`.

\`(\` \`'name\`\`)\` returns a symbol or \`#f\`. \`#f\` is returned if the name is not available or if the variable is a compiler-generated temporary variable. Variable names are not retained when the parameter \`generate-inspector-information\` (page ) is false during compilation.

\`(\` \`'ref\`\`)\` returns an inspector object containing the current value of the variable.

\`(\` \`'set!\` *e*\`)\` returns unspecified, after setting the current value of the variable to *e*. An exception is raised with condition type \`&assertion\` if the variable is not assignable.

**Port inspector objects.** Port inspector objects contain ports.

\`(\` \`'type\`\`)\` returns the symbol \`port\`.

\`(\` \`'input?\`\`)\` returns \`#t\` if the port is an input port, \`#f\` otherwise.

\`(\` \`'output?\`\`)\` returns \`#t\` if the port is an output port, \`#f\` otherwise.

\`(\` \`'binary?\`\`)\` returns \`#t\` if the port is a binary port, \`#f\` otherwise.

\`(\` \`'closed?\`\`)\` returns \`#t\` if the port is closed, \`#f\` if the port is open.

\`(\` \`'name\`\`)\` returns an inspector object containing the port's name.

\`(\` \`'handler\`\`)\` returns a procedure inspector object encapsulating the port handler, such as would be returned by \`port-handler\`.

\`(\` \`'output-size\`\`)\` returns the output buffer size as a fixnum if the port is an output port (otherwise the value is unspecified).

\`(\` \`'output-index\`\`)\` returns the output buffer index as a fixnum if the port is an output port (otherwise the value is unspecified).

\`(\` \`'output-buffer\`\`)\` returns an inspector object containing the string used for buffered output.

\`(\` \`'input-size\`\`)\` returns the input buffer size as a fixnum if the port is an input port (otherwise the value is unspecified).

\`(\` \`'input-index\`\`)\` returns the input buffer index as a fixnum if the port is an input port (otherwise the value is unspecified).

\`(\` \`'input-buffer\`\`)\` returns an inspector object containing the string used for buffered input.

**Symbol inspector objects.** Symbol inspector objects contain symbols. These include gensyms.

\`(\` \`'type\`\`)\` returns the symbol \`symbol\`.

\`(\` \`'name\`\`)\` returns a string inspector object. The string name associated with a symbol inspector object is the print representation of a symbol, such as would be returned by the procedure \`symbol->string\`.

\`(\` \`'gensym?\`\`)\` returns \`#t\` if the symbol is a gensym, \`#f\` otherwise. Gensyms are created by \`gensym\`.

\`(\` \`'top-level-value\`\`)\` returns an inspector object containing the global value of the symbol.

\`(\` \`'property-list\`\`)\` returns an inspector object containing the property list for the symbol.

**Record inspector objects.** Record inspector objects contain records.

\`(\` \`'type\`\`)\` returns the symbol \`record\`.

\`(\` \`'name\`\`)\` returns a string inspector object corresponding to the name of the record type.

\`(\` \`'fields\`\`)\` returns an inspector object containing a list of the field names of the record type.

\`(\` \`'length\`\`)\` returns the number of fields.

\`(\` \`'rtd\`\`)\` returns an inspector object containing the record-type descriptor of the record type.

\`(\` \`'accessible?\` *name*\`)\` returns \`#t\` if the named field is accessible, \`#f\` otherwise. A field may be inaccessible if optimized away by the compiler.

\`(\` \`'ref\` *name*\`)\` returns an inspector object containing the value of the named field. An exception is raised with condition type \`&assertion\` if the named field is not accessible.

\`(\` \`'mutable?\` *name*\`)\` returns \`#t\` if the named field is mutable, \`#f\` otherwise. A field is immutable if it is not declared mutable or if the compiler optimizes away all assignments to the field.

\`(\` \`'set!\` *name* *value*\`)\` sets the value of the named field to *value*. An exception is raised with condition type \`&assertion\` if the named field is not assignable.
`
    },
    {
        name: "(integer->char ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s211"),
        description: `**procedure**: \`(integer->char \`*n*\`)\`
**returns: **the character corresponding to the Unicode scalar value *n*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact integer and a valid Unicode scalar value, i.e., or .

\`(integer->char 48) \`=>\` #\\0\`
\` (integer->char #x3BB) \`=>\` #\\\`
`
    },
    {
        name: "(integer-length ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s71"),
        description: `**procedure**: \`(integer-length \`*n*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

The procedure \`integer-length\` returns the length in bits of the smallest two's complement representation for *n*, with an assumed leading 1 (sign) bit for negative numbers. For zero, \`integer-length\` returns 0.

\`(integer-length 0) \`=>\` 0\`
\` (integer-length 1) \`=>\` 1\`
\` (integer-length 2) \`=>\` 2\`
\` (integer-length 3) \`=>\` 2\`
\` (integer-length 4) \`=>\` 3\`
\` (integer-length #b10000000) \`=>\` 8\`
\` (integer-length #b11111111) \`=>\` 8\`
\` (integer-length -1) \`=>\` 0\`
\` (integer-length -2) \`=>\` 1\`
\` (integer-length -3) \`=>\` 2\`
\` (integer-length -4) \`=>\` 2\`
`
    },
    {
        name: "(integer-valued? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s18"),
        description: `**procedure**: \`(real-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number, \`#f\` otherwise
**procedure**: \`(rational-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number, \`#f\` otherwise
**procedure**: \`(integer-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates are similar to \`real?\`, \`rational?\`, and \`integer?\`, but treat as real, rational, or integral complex numbers with inexact zero imaginary parts.

\`(integer-valued? 1901) \`=>\` #t\`
\` (rational-valued? 1901) \`=>\` #t\`
\` (real-valued? 1901) \`=>\` #t \`
\` \`
\` (integer-valued? -3.0) \`=>\` #t\`
\` (rational-valued? -3.0) \`=>\` #t\`
\` (real-valued? -3.0) \`=>\` #t \`
\` \`
\` (integer-valued? 7+0i) \`=>\` #t\`
\` (rational-valued? 7+0i) \`=>\` #t\`
\` (real-valued? 7+0i) \`=>\` #t \`
\` \`
\` (integer-valued? -2/3) \`=>\` #f\`
\` (rational-valued? -2/3) \`=>\` #t\`
\` (real-valued? -2/3) \`=>\` #t \`
\` \`
\` (integer-valued? -2.345) \`=>\` #f\`
\` (rational-valued? -2.345) \`=>\` #t\`
\` (real-valued? -2.345) \`=>\` #t \`
\` \`
\` (integer-valued? 7.0+0.0i) \`=>\` #t\`
\` (rational-valued? 7.0+0.0i) \`=>\` #t\`
\` (real-valued? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer-valued? 3.2-2.01i) \`=>\` #f\`
\` (rational-valued? 3.2-2.01i) \`=>\` #f\`
\` (real-valued? 3.2-2.01i) \`=>\` #f\`

As with \`real?\`, \`rational?\`, and \`integer?\`, these predicates return \`#f\` for all non-numeric values.

\`(integer-valued? 'a) \`=>\` #f\`
\` (rational-valued? '(a b c)) \`=>\` #f\`
\` (real-valued? "3") \`=>\` #f\`
`
    },
    {
        name: "(integer? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s17"),
        description: `**procedure**: \`(number? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a number object, \`#f\` otherwise
**procedure**: \`(complex? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a complex number object, \`#f\` otherwise
**procedure**: \`(real? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number object, \`#f\` otherwise
**procedure**: \`(rational? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number object, \`#f\` otherwise
**procedure**: \`(integer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer object, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well.

The \`real?\`, \`rational?\`, and \`integer?\` predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts.

\`(integer? 1901) \`=>\` #t\`
\` (rational? 1901) \`=>\` #t\`
\` (real? 1901) \`=>\` #t\`
\` (complex? 1901) \`=>\` #t\`
\` (number? 1901) \`=>\` #t \`
\` \`
\` (integer? -3.0) \`=>\` #t\`
\` (rational? -3.0) \`=>\` #t\`
\` (real? -3.0) \`=>\` #t\`
\` (complex? -3.0) \`=>\` #t\`
\` (number? -3.0) \`=>\` #t \`
\` \`
\` (integer? 7+0i) \`=>\` #t\`
\` (rational? 7+0i) \`=>\` #t\`
\` (real? 7+0i) \`=>\` #t\`
\` (complex? 7+0i) \`=>\` #t\`
\` (number? 7+0i) \`=>\` #t \`
\` \`
\` (integer? -2/3) \`=>\` #f\`
\` (rational? -2/3) \`=>\` #t\`
\` (real? -2/3) \`=>\` #t\`
\` (complex? -2/3) \`=>\` #t\`
\` (number? -2/3) \`=>\` #t \`
\` \`
\` (integer? -2.345) \`=>\` #f\`
\` (rational? -2.345) \`=>\` #t\`
\` (real? -2.345) \`=>\` #t\`
\` (complex? -2.345) \`=>\` #t\`
\` (number? -2.345) \`=>\` #t \`
\` \`
\` (integer? 7.0+0.0i) \`=>\` #f\`
\` (rational? 7.0+0.0i) \`=>\` #f\`
\` (real? 7.0+0.0i) \`=>\` #f\`
\` (complex? 7.0+0.0i) \`=>\` #t\`
\` (number? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer? 3.2-2.01i) \`=>\` #f\`
\` (rational? 3.2-2.01i) \`=>\` #f\`
\` (real? 3.2-2.01i) \`=>\` #f\`
\` (complex? 3.2-2.01i) \`=>\` #t\`
\` (number? 3.2-2.01i) \`=>\` #t \`
\` \`
\` (integer? 'a) \`=>\` #f\`
\` (rational? '(a b c)) \`=>\` #f\`
\` (real? "3") \`=>\` #f\`
\` (complex? '#(1 2)) \`=>\` #f\`
\` (number? #\\a) \`=>\` #f\`
`
    },
    {
        name: "interaction-environment",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s33"),
        description: `**thread parameter**: \`interaction-environment\`
**libraries: **\`(chezscheme)\`

The original value of \`interaction-environment\` is the default top-level environment. It is initially set to a mutable copy of \`(scheme-environment)\` and which may be extended or otherwise altered by top-level definitions and assignments. It may be set to any environment, mutable or not, to change the default top-level evaluation environment.

An expression's top-level bindings resolve to the environment that is in effect when the expression is expanded, and changing the value of this parameter has no effect on running code. Changes affect only code that is subsequently expanded, e.g., as the result of a call to \`eval\`, \`load\`, or \`compile-file\`.

\`(define cons 3)\`
\` cons \`=>\` 3\`
\` (top-level-value 'cons (interaction-environment)) \`=>\` 3 \`
\` \`
\` (interaction-environment (scheme-environment))\`
\` cons \`=>\` #<procedure cons>\`
\` (set! cons 3) \`=>\` \`*exception: attempt to assign immutable variable*
\` (define cons 3) \`=>\` \`*exception: invalid definition in immutable environment*
`
    },
    {
        name: "(interactive?)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s258"),
        description: `**procedure**: \`(interactive?)\`
**returns: **\`#t\` if system is run interactively, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

This predicate returns \`#t\` if the Scheme process's stdin and stdout are connected to a tty (Unix-based systems) or console (Windows). Otherwise, it returns \`#f\`.
`
    },
    {
        name: "internal-defines-as-letrec*",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s15"),
        description: `**thread parameter**: \`internal-defines-as-letrec*\`
**libraries: **\`(chezscheme)\`

When this parameter is set to \`#t\` (the default), internal variable definitions are evaluated using \`letrec*\` semantics. It may be set to \`#f\` to revert to the \`letrec\` semantics for internal variable definitions, for backward compatibility.
`
    },
    {
        name: "(interpret ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s44"),
        description: `**procedure**: \`(interpret \`*obj*\`)\`
**procedure**: \`(interpret \`*obj*\` \`*env*\`)\`
**returns: **value of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

\`interpret\` is like \`compile\`, except that the expression is interpreted rather than compiled. \`interpret\` may be used as a replacement for \`compile\`, with the following caveats:

\`interpret\` is sometimes faster than \`compile\` when the form to be evaluated is short running, since it avoids some of the work done by \`compile\` prior to evaluation.
`
    },
    {
        name: "(interpret ",
        endParen: true,
        params: ["obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s44"),
        description: `**procedure**: \`(interpret \`*obj*\`)\`
**procedure**: \`(interpret \`*obj*\` \`*env*\`)\`
**returns: **value of the Scheme form represented by *obj*
**libraries: **\`(chezscheme)\`

\`interpret\` is like \`compile\`, except that the expression is interpreted rather than compiled. \`interpret\` may be used as a replacement for \`compile\`, with the following caveats:

\`interpret\` is sometimes faster than \`compile\` when the form to be evaluated is short running, since it avoids some of the work done by \`compile\` prior to evaluation.
`
    },
    {
        name: "(invoke-library ",
        endParen: true,
        params: ["libref"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s20"),
        description: `**procedure**: \`(invoke-library \`*libref*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*libref* must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter  of and in the Revised Report.

A library is implicitly invoked when or before some expression outside the library (e.g., in another library or in a top-level program) evaluates a reference to one of the library's exported variables. When the library is invoked, its body expressions (the right-hand-sides of the library's variable definitions and its initialization expressions) are evaluated. Once invoked, the library is not invoked again within the same process, unless it is first explicitly redefined or reloaded.

\`invoke-library\` explicitly invokes the library specified by *libref* if it has not already been invoked or has since been redefined or reloaded. If the library has not yet been loaded, \`invoke-library\` first loads the library via the process described in Section .

\`invoke-library\` is typically only useful for libraries whose body expressions have side effects. It is useful to control when the side effects occur and to force invocation of a library that has no exported variables. Invoking a library does not force the compile-time code (macro transformer expressions and meta definitions) to be loaded or evaluated, nor does it cause the library's bindings to become visible.
`
    },
    {
        name: "(iota ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s8"),
        description: `**procedure**: \`(iota \`*n*\`)\`
**returns: **a list of integers from 0 (inclusive) to *n* (exclusive)
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer.

\`(iota 0) \`=>\` ()\`
\` (iota 5) \`=>\` (0 1 2 3 4)\`
`
    },
    {
        name: "(irritants-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s25"),
        description: `**syntax**: \`&irritants\`
**procedure**: \`(make-irritants-condition \`*irritants*\`)\`
**returns: **a condition of type \`&irritants\`
**procedure**: \`(irritants-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&irritants\`, \`#f\` otherwise
**procedure**: \`(condition-irritants \`*condition*\`)\`
**returns: **the contents of *condition*'s \`irritants\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&message\` condition to provide information about Scheme values that may have caused or been materially involved in the exceptional situation. For example, if a procedure receives the wrong type of argument, it may raise an exception with a compound condition consisting of an assertion condition, a who condition naming the procedure, a message condition stating that the wrong type of argument was received, and an irritants condition listing the argument. The *irritants* argument to the constructor should be a list. This condition type might be defined as follows.

\`(define-condition-type &irritants &condition\`
\`   make-irritants-condition irritants-condition?\`
\`   (irritants condition-irritants))\`
`
    },
    {
        name: "(isqrt ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s70"),
        description: `**procedure**: \`(isqrt \`*n*\`)\`
**returns: **the integer square root of *n*
**libraries: **\`(chezscheme)\`

*n* must be a nonnegative integer. The integer square root of is defined to be .

\`(isqrt 0) \`=>\` 0\`
\` (isqrt 16) \`=>\` 4\`
\` (isqrt 16.0) \`=>\` 4.0\`
\` (isqrt 20) \`=>\` 4\`
\` (isqrt 20.0) \`=>\` 4.0\`
\` (isqrt (* 2 (expt 10 20))) \`=>\` 14142135623\`
`
    },
    {
        name: "keyboard-interrupt-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s20"),
        description: `**thread parameter**: \`keyboard-interrupt-handler\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(lambda ",
        endParen: true,
        params: ["formals", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s3"),
        description: `**syntax**: \`(lambda \`*formals*\` \`*body1*\` \`*body2*\` ...)\`
**returns: **a procedure
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(last-pair ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s4"),
        description: `**procedure**: \`(last-pair \`*list*\`)\`
**returns: **the last pair of a *list*
**libraries: **\`(chezscheme)\`

*list* must not be empty. \`last-pair\` returns the last pair (not the last element) of *list*. *list* may be an improper list, in which case the last pair is the pair containing the last element and the terminating object.

\`(last-pair '(a b c d)) \`=>\` (d)\`
\` (last-pair '(a b c . d)) \`=>\` (c . d)\`
`
    },
    {
        name: "(latin-1-codec)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s22"),
        description: `**procedure**: \`(latin-1-codec)\`
**returns: **a codec for ISO 8859-1 (Latin 1) character encodings
**procedure**: \`(utf-8-codec)\`
**returns: **a codec for Unicode UTF-8 character encodings
**procedure**: \`(utf-16-codec)\`
**returns: **a codec for Unicode UTF-16 character encodings
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(lcm ",
        endParen: true,
        params: ["int", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s110"),
        description: `**procedure**: \`(lcm \`*int*\` ...)\`
**returns: **the least common multiple of its arguments *int*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The result is always nonnegative, i.e., common multiples of -1 are ignored. Although \`lcm\` should probably return when called with no arguments, it is defined to return 1. If one or more of the arguments is 0, \`lcm\` returns 0.

\`(lcm) \`=>\` 1\`
\` (lcm 34) \`=>\` 34\`
\` (lcm 33.0 15.0) \`=>\` 165.0\`
\` (lcm 70 -42 28) \`=>\` 420\`
\` (lcm 17.0 0) \`=>\` 0.0\`
`
    },
    {
        name: "(least-fixnum)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s151"),
        description: `**procedure**: \`(least-fixnum)\`
**returns: **the least (most negative) fixnum supported by the implementation
**procedure**: \`(greatest-fixnum)\`
**returns: **the greatest (most positive) fixnum supported by the implementation
**libraries: **\`(rnrs arithmetic fixnums)\`, \`(rnrs)\`

\` (fixnum? (- (least-fixnum) 1)) \`=>\` #f\`
\` (fixnum? (least-fixnum)) \`=>\` #t\`
\` (fixnum? (greatest-fixnum)) \`=>\` #t\`
\` (fixnum? (+ (greatest-fixnum) 1)) \`=>\` #f\`
`
    },
    {
        name: "(length ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s46"),
        description: `**procedure**: \`(length \`*list*\`)\`
**returns: **the number of elements in *list*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`length\` may be defined as follows, using an adaptation of the hare and tortoise algorithm used for the definition of \`list?\` on page .

\`(define length\`
\`   (lambda (x)\`
\`     (define improper-list\`
\`       (lambda ()\`
\`         (assertion-violation 'length "not a proper list" x))) \`
\` \`
\`     (let f ([h x] [t x] [n 0])\`
\`       (if (pair? h)\`
\`           (let ([h (cdr h)])\`
\`             (if (pair? h)\`
\`                 (if (eq? h t)\`
\`                     (improper-list)\`
\`                     (f (cdr h) (cdr t) (+ n 2)))\`
\`                 (if (null? h)\`
\`                     (+ n 1)\`
\`                     (improper-list))))\`
\`           (if (null? h)\`
\`               n\`
\`               (improper-list)))))) \`
\` \`
\` (length '()) \`=>\` 0\`
\` (length '(a b c)) \`=>\` 3\`
\` (length '(a b . c)) \`=>\` \`*exception*
\` (length\`
\`   (let ([ls (list 'a 'b)])\`
\`     (set-cdr! (cdr ls) ls) \`=>\` \`*exception*
\`     ls))\`
\` (length\`
\`   (let ([ls (list 'a 'b)])\`
\`     (set-car! (cdr ls) ls) \`=>\` 2\`
\`     ls))\`
`
    },
    {
        name: "(let ((",
        endParen: true,
        params: ["var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s16"),
        description: `**syntax**: \`(let ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(let ",
        endParen: true,
        params: ["name", "var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s20"),
        description: `**syntax**: \`(let \`*name*\` ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(let* ((",
        endParen: true,
        params: ["var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s18"),
        description: `**syntax**: \`(let* ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`let*\` is similar to \`let\` except that the expressions *expr*\` ...\` are evaluated in sequence from left to right, and each of these expressions is within the scope of the variables to the left. Use \`let*\` when there is a linear dependency among the values or when the order of evaluation is important.

\`(let* ([x (* 5.0 5.0)]\`
\`        [y (- x (* 4.0 4.0))])\`
\`   (sqrt y)) \`=>\` 3.0 \`
\` \`
\` (let ([x 0] [y 1])\`
\`   (let* ([x y] [y x])\`
\`     (list x y))) \`=>\` (1 1)\`
`
    },
    {
        name: "(let*-values ((",
        endParen: true,
        params: ["formals", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s23"),
        description: `**syntax**: \`(let-values ((\`*formals*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(let*-values ((\`*formals*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`let-values\` is a convenient way to receive multiple values and bind them to variables. It is structured like \`let\` but permits an arbitrary formals list (like \`lambda\`) on each left-hand side. \`let*-values\` is similar but performs the bindings in left-to-right order, as with \`let*\`. An exception with condition type \`&assertion\` is raised if the number of values returned by an *expr* is not appropriate for the corresponding *formals*, as described in the entry for \`lambda\` above. A definition of \`let-values\` is given on page .

\`(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])\`
\`   (list a b c)) \`=>\` (1 2 (1 2 3)) \`
\` \`
\` (let*-values ([(a b) (values 1 2)] [(a b) (values b a)])\`
\`   (list a b)) \`=>\` (2 1)\`
`
    },
    {
        name: "(let-syntax ((",
        endParen: true,
        params: ["keyword", "expr", "form1", "form2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s13"),
        description: `**syntax**: \`(let-syntax ((\`*keyword*\` \`*expr*\`) ...) \`*form1*\` \`*form2*\` ...)\`
**syntax**: \`(letrec-syntax ((\`*keyword*\` \`*expr*\`) ...) \`*form1*\` \`*form2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

Each *expr* must evaluate to a transformer. For \`let-syntax\` and \`letrec-syntax\` both, each *keyword* is bound within the forms *form1*\` \`*form2*\` ...\`. For \`letrec-syntax\` the binding scope also includes each *expr*.
`
    },
    {
        name: "(let-values ((",
        endParen: true,
        params: ["formals", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s23"),
        description: `**syntax**: \`(let-values ((\`*formals*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(let*-values ((\`*formals*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`let-values\` is a convenient way to receive multiple values and bind them to variables. It is structured like \`let\` but permits an arbitrary formals list (like \`lambda\`) on each left-hand side. \`let*-values\` is similar but performs the bindings in left-to-right order, as with \`let*\`. An exception with condition type \`&assertion\` is raised if the number of values returned by an *expr* is not appropriate for the corresponding *formals*, as described in the entry for \`lambda\` above. A definition of \`let-values\` is given on page .

\`(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])\`
\`   (list a b c)) \`=>\` (1 2 (1 2 3)) \`
\` \`
\` (let*-values ([(a b) (values 1 2)] [(a b) (values b a)])\`
\`   (list a b)) \`=>\` (2 1)\`
`
    },
    {
        name: "(letrec ((",
        endParen: true,
        params: ["var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s20"),
        description: `**syntax**: \`(letrec ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(letrec* ((",
        endParen: true,
        params: ["var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s22"),
        description: `**syntax**: \`(letrec* ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`letrec*\` is similar to \`letrec\`, except that \`letrec*\` evaluates *expr*\` ...\` in sequence from left to right. While programs must still not evaluate a reference to any *var* before the corresponding *expr* has been evaluated, references to *var* may be evaluated any time thereafter, including during the evaluation of the *expr* of any subsequent binding.

A \`letrec*\` expression of the form

\`(letrec* ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`

may be expressed in terms of \`let\` and \`set!\` as

\`(let ((\`*var*\` #f) ...)\`
\`   (set! \`*var*\` \`*expr*\`) ...\`
\`   (let () \`*body1*\` \`*body2*\` ...))\`

The outer \`let\` expression creates the bindings, each assignment evaluates an expression and immediately sets the corresponding variable to its value, in sequence, and the inner let evaluates the body. \`let\` is used in the latter case rather than \`begin\` since the body may include internal definitions as well as expressions.

\`(letrec* ([sum (lambda (x)\`
\`                  (if (zero? x)\`
\`                      0\`
\`                      (+ x (sum (- x 1)))))]\`
\`           [f (lambda () (cons n n-sum))]\`
\`           [n 15]\`
\`           [n-sum (sum n)])\`
\`   (f)) \`=>\` (15 . 120) \`
\` \`
\` (letrec* ([f (lambda () (lambda () g))]\`
\`           [g (f)])\`
\`   (eq? (g) g)) \`=>\` #t \`
\` \`
\` (letrec* ([g (f)]\`
\`           [f (lambda () (lambda () g))])\`
\`   (eq? (g) g)) \`=>\` \`*exception: attempt to reference undefined variable f*
`
    },
    {
        name: "(letrec-syntax ((",
        endParen: true,
        params: ["keyword", "expr", "form1", "form2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s13"),
        description: `**syntax**: \`(let-syntax ((\`*keyword*\` \`*expr*\`) ...) \`*form1*\` \`*form2*\` ...)\`
**syntax**: \`(letrec-syntax ((\`*keyword*\` \`*expr*\`) ...) \`*form1*\` \`*form2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

Each *expr* must evaluate to a transformer. For \`let-syntax\` and \`letrec-syntax\` both, each *keyword* is bound within the forms *form1*\` \`*form2*\` ...\`. For \`letrec-syntax\` the binding scope also includes each *expr*.
`
    },
    {
        name: "(lexical-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s29"),
        description: `**syntax**: \`&lexical\`
**procedure**: \`(make-lexical-violation)\`
**returns: **a condition of type \`&lexical\`
**procedure**: \`(lexical-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&lexical\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a lexical error has occurred in the parsing of a Scheme program or datum, such as mismatched parentheses or an invalid character appearing within a numeric constant. This condition type might be defined as follows.

\`(define-condition-type &lexical &violation\`
\`   make-lexical-violation lexical-violation?)\`
`
    },
    {
        name: "(library ",
        endParen: true,
        params: ["name", "exports", "imports", "library-body"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s13"),
        description: `**syntax**: \`(library \`*name*\` \`*exports*\` \`*imports*\` \`*library-body*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The \`library\` form defines a new library with the specified name, exports, imports, and body. Details on the syntax and semantics of the library form are given in Section  of and in the Revised Report.

Only one version of a library can be loaded at any given time, and an exception is raised if a library is implicitly loaded via \`import\` when another version of the library has already been loaded. permits a different version of the library, or a new instance of the same version, to be entered explicitly into the REPL or loaded explicitly from a file, to facilitate interactive testing and debugging. The programmer should take care to make sure that any code that uses the library is also reentered or reloaded, to make sure that code accesses the bindings of the new instance of the library.

\`(library (test (1)) (export x) (import (rnrs)) (define x 3))\`
\` (import (test))\`
\` (define f (lambda () x))\`
\` (f) \`=>\` 3 \`
\` \`
\` (library (test (1)) (export x) (import (rnrs)) (define x 4))\`
\` (import (test))\`
\` (f) \`=>\` 3    ; oops---forgot to redefine f\`
\` (define f (lambda () x))\`
\` (f) \`=>\` 4 \`
\` \`
\` (library (test (2)) (export x) (import (rnrs)) (define x 5))\`
\` (import (test))\`
\` (define f (lambda () x))\`
\` (f) \`=>\` 5\`

As with module imports (Section ), a library \`import\` may appear anywhere a definition may appear, including at top level in the REPL, in a file to be loaded by \`load\`, or within a \`lambda\`, \`let\`, \`letrec\`, \`letrec*\`, etc., body. The same \`import\` form may be used to import from both libraries and modules.

\`(library (foo) (export a) (import (rnrs)) (define a 'a-from-foo))\`
\` (module bar (b) (define b 'b-from-bar))\`
\` (let () (import (foo) bar) (list a b)) \`=>\` (a-from-foo b-from-bar)\`

The \`import\` keyword is not visible within a library body unless the library imports it from the \`(chezscheme)\` library.
`
    },
    {
        name: "library-directories",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s23"),
        description: `**thread parameter**: \`library-directories\`
**thread parameter**: \`library-extensions\`
**libraries: **\`(chezscheme)\`

The parameter \`library-directories\` determines where the files containing library source and object code are located in the file system, and the parameter \`library-extensions\` determines the filename extensions for the files holding the code, as described in section . The values of both parameters are lists of pairs of strings. The first string in each \`library-directories\` pair identifies a source-file root directory, and the second identifies the corresponding object-file root directory. Similarly, the first string in each \`library-extensions\` pair identifies a source-file extension, and the second identifies the corresponding object-file extension. The full path of a library source or object file consists of the source or object root followed by the components of the library name prefixed by slashes, with the library extension added on the end. For example, for root \`/usr/lib/scheme\`, library name \`(app lib1)\`, and extension \`.sls\`, the full path is \`/usr/lib/scheme/app/lib1.sls\`. If the library name portion forms an absolute pathname, e.g., \`~/.myappinit\`, the \`library-directories\` parameter is ignored and no prefix is added.

The initial values of these parameters are shown below.

\`(library-directories) \`=>\` (("." . ".")) \`
\` \`
\` (library-extensions) \`=>\` ((".chezscheme.sls" . ".chezscheme.so")\`
\`                      \`\`  (".ss" . ".so")\`
\`                      \`\`  (".sls" . ".so")\`
\`                      \`\`  (".scm" . ".so")\`
\`                      \`\`  (".sch" . ".so"))\`
`
    },
    {
        name: "(library-exports ",
        endParen: true,
        params: ["libref"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s33"),
        description: `**procedure**: \`(library-version \`*libref*\`)\`
**returns: **the version of the specified library
**procedure**: \`(library-exports \`*libref*\`)\`
**returns: **a list of the exports of the specified library
**procedure**: \`(library-requirements \`*libref*\`)\`
**returns: **a list of libraries required by the specified library
**procedure**: \`(library-requirements \`*libref*\` \`*options*\`)\`
**returns: **a list of libraries required by the specified library, filtered by *options*
**procedure**: \`(library-object-filename \`*libref*\`)\`
**returns: **the name of the object file holding the specified library, if any
**libraries: **\`(chezscheme)\`

Information can be obtained only for built-in libraries or libraries previously loaded into the system. *libref* must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter  of and in the Revised Report.

The \`library-version\` return value is a list of numbers (possibly empty) representing the library's version.

The list of exports returned by \`library-exports\` is a list of symbols, each identifying one of the library's exports. The order in which the elements appear is unspecified.

When the optional *options* argument is supplied, it must be an enumeration set over the symbols constituting valid library-requirements options, as described in the \`library-requirements-options\` entry below. It defaults to a set containing all of the options. Each element of the list of libraries returned by \`library-requirements\` is an s-expression form of a library reference. The library reference includes the actual version of the library that is present in the system (if nonempty), even if a version was not specified when it was imported. The order in which the libraries appear in the list returned by \`library-requirements\` is unspecified.

\`library-object-filename\` returns a string naming the object file if the specified library was loaded from or compiled to an object file. Otherwise, it returns \`#f\`.

\`(with-output-to-file "A.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (A (1 2)) (export x z)\`
\`          (import (rnrs))\`
\`          (define x 'ex)\`
\`          (define y 23)\`
\`          (define-syntax z\`
\`            (syntax-rules ()\`
\`              [(_ e) (+ y e)])))))\`
\`   'replace)\`
\` (with-output-to-file "B.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (B) (export x w)\`
\`          (import (rnrs) (A))\`
\`          (define w (cons (z 12) x)))))\`
\`   'replace)\`
\` (compile-imported-libraries #t)\`
\` (import (B))\`
\` (library-exports '(A)) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(A (1 2))) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(B)) \`=>\` (x w) ; or (w x)\`
\` (library-version '(A)) \`=>\` (1 2)\`
\` (library-version '(B)) \`=>\` ()\`
\` (library-requirements '(A)) \`=>\` ((rnrs (6)))\`
\` (library-requirements '(B)) \`=>\` ((rnrs (6)) (A (1 2)))\`
\` (library-object-filename '(A)) \`=>\` "A.so"\`
\` (library-object-filename '(B)) \`=>\` "B.so"\`
`
    },
    {
        name: "library-extensions",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s23"),
        description: `**thread parameter**: \`library-directories\`
**thread parameter**: \`library-extensions\`
**libraries: **\`(chezscheme)\`

The parameter \`library-directories\` determines where the files containing library source and object code are located in the file system, and the parameter \`library-extensions\` determines the filename extensions for the files holding the code, as described in section . The values of both parameters are lists of pairs of strings. The first string in each \`library-directories\` pair identifies a source-file root directory, and the second identifies the corresponding object-file root directory. Similarly, the first string in each \`library-extensions\` pair identifies a source-file extension, and the second identifies the corresponding object-file extension. The full path of a library source or object file consists of the source or object root followed by the components of the library name prefixed by slashes, with the library extension added on the end. For example, for root \`/usr/lib/scheme\`, library name \`(app lib1)\`, and extension \`.sls\`, the full path is \`/usr/lib/scheme/app/lib1.sls\`. If the library name portion forms an absolute pathname, e.g., \`~/.myappinit\`, the \`library-directories\` parameter is ignored and no prefix is added.

The initial values of these parameters are shown below.

\`(library-directories) \`=>\` (("." . ".")) \`
\` \`
\` (library-extensions) \`=>\` ((".chezscheme.sls" . ".chezscheme.so")\`
\`                      \`\`  (".ss" . ".so")\`
\`                      \`\`  (".sls" . ".so")\`
\`                      \`\`  (".scm" . ".so")\`
\`                      \`\`  (".sch" . ".so"))\`
`
    },
    {
        name: "(library-list)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s32"),
        description: `**procedure**: \`(library-list)\`
**returns: **a list of the libraries currently defined
**libraries: **\`(chezscheme)\`

The set of libraries initially defined includes those listed in Section  above.
`
    },
    {
        name: "(library-object-filename ",
        endParen: true,
        params: ["libref"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s33"),
        description: `**procedure**: \`(library-version \`*libref*\`)\`
**returns: **the version of the specified library
**procedure**: \`(library-exports \`*libref*\`)\`
**returns: **a list of the exports of the specified library
**procedure**: \`(library-requirements \`*libref*\`)\`
**returns: **a list of libraries required by the specified library
**procedure**: \`(library-requirements \`*libref*\` \`*options*\`)\`
**returns: **a list of libraries required by the specified library, filtered by *options*
**procedure**: \`(library-object-filename \`*libref*\`)\`
**returns: **the name of the object file holding the specified library, if any
**libraries: **\`(chezscheme)\`

Information can be obtained only for built-in libraries or libraries previously loaded into the system. *libref* must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter  of and in the Revised Report.

The \`library-version\` return value is a list of numbers (possibly empty) representing the library's version.

The list of exports returned by \`library-exports\` is a list of symbols, each identifying one of the library's exports. The order in which the elements appear is unspecified.

When the optional *options* argument is supplied, it must be an enumeration set over the symbols constituting valid library-requirements options, as described in the \`library-requirements-options\` entry below. It defaults to a set containing all of the options. Each element of the list of libraries returned by \`library-requirements\` is an s-expression form of a library reference. The library reference includes the actual version of the library that is present in the system (if nonempty), even if a version was not specified when it was imported. The order in which the libraries appear in the list returned by \`library-requirements\` is unspecified.

\`library-object-filename\` returns a string naming the object file if the specified library was loaded from or compiled to an object file. Otherwise, it returns \`#f\`.

\`(with-output-to-file "A.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (A (1 2)) (export x z)\`
\`          (import (rnrs))\`
\`          (define x 'ex)\`
\`          (define y 23)\`
\`          (define-syntax z\`
\`            (syntax-rules ()\`
\`              [(_ e) (+ y e)])))))\`
\`   'replace)\`
\` (with-output-to-file "B.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (B) (export x w)\`
\`          (import (rnrs) (A))\`
\`          (define w (cons (z 12) x)))))\`
\`   'replace)\`
\` (compile-imported-libraries #t)\`
\` (import (B))\`
\` (library-exports '(A)) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(A (1 2))) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(B)) \`=>\` (x w) ; or (w x)\`
\` (library-version '(A)) \`=>\` (1 2)\`
\` (library-version '(B)) \`=>\` ()\`
\` (library-requirements '(A)) \`=>\` ((rnrs (6)))\`
\` (library-requirements '(B)) \`=>\` ((rnrs (6)) (A (1 2)))\`
\` (library-object-filename '(A)) \`=>\` "A.so"\`
\` (library-object-filename '(B)) \`=>\` "B.so"\`
`
    },
    {
        name: "(library-requirements ",
        endParen: true,
        params: ["libref"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s33"),
        description: `**procedure**: \`(library-version \`*libref*\`)\`
**returns: **the version of the specified library
**procedure**: \`(library-exports \`*libref*\`)\`
**returns: **a list of the exports of the specified library
**procedure**: \`(library-requirements \`*libref*\`)\`
**returns: **a list of libraries required by the specified library
**procedure**: \`(library-requirements \`*libref*\` \`*options*\`)\`
**returns: **a list of libraries required by the specified library, filtered by *options*
**procedure**: \`(library-object-filename \`*libref*\`)\`
**returns: **the name of the object file holding the specified library, if any
**libraries: **\`(chezscheme)\`

Information can be obtained only for built-in libraries or libraries previously loaded into the system. *libref* must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter  of and in the Revised Report.

The \`library-version\` return value is a list of numbers (possibly empty) representing the library's version.

The list of exports returned by \`library-exports\` is a list of symbols, each identifying one of the library's exports. The order in which the elements appear is unspecified.

When the optional *options* argument is supplied, it must be an enumeration set over the symbols constituting valid library-requirements options, as described in the \`library-requirements-options\` entry below. It defaults to a set containing all of the options. Each element of the list of libraries returned by \`library-requirements\` is an s-expression form of a library reference. The library reference includes the actual version of the library that is present in the system (if nonempty), even if a version was not specified when it was imported. The order in which the libraries appear in the list returned by \`library-requirements\` is unspecified.

\`library-object-filename\` returns a string naming the object file if the specified library was loaded from or compiled to an object file. Otherwise, it returns \`#f\`.

\`(with-output-to-file "A.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (A (1 2)) (export x z)\`
\`          (import (rnrs))\`
\`          (define x 'ex)\`
\`          (define y 23)\`
\`          (define-syntax z\`
\`            (syntax-rules ()\`
\`              [(_ e) (+ y e)])))))\`
\`   'replace)\`
\` (with-output-to-file "B.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (B) (export x w)\`
\`          (import (rnrs) (A))\`
\`          (define w (cons (z 12) x)))))\`
\`   'replace)\`
\` (compile-imported-libraries #t)\`
\` (import (B))\`
\` (library-exports '(A)) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(A (1 2))) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(B)) \`=>\` (x w) ; or (w x)\`
\` (library-version '(A)) \`=>\` (1 2)\`
\` (library-version '(B)) \`=>\` ()\`
\` (library-requirements '(A)) \`=>\` ((rnrs (6)))\`
\` (library-requirements '(B)) \`=>\` ((rnrs (6)) (A (1 2)))\`
\` (library-object-filename '(A)) \`=>\` "A.so"\`
\` (library-object-filename '(B)) \`=>\` "B.so"\`
`
    },
    {
        name: "(library-requirements ",
        endParen: true,
        params: ["libref", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s33"),
        description: `**procedure**: \`(library-version \`*libref*\`)\`
**returns: **the version of the specified library
**procedure**: \`(library-exports \`*libref*\`)\`
**returns: **a list of the exports of the specified library
**procedure**: \`(library-requirements \`*libref*\`)\`
**returns: **a list of libraries required by the specified library
**procedure**: \`(library-requirements \`*libref*\` \`*options*\`)\`
**returns: **a list of libraries required by the specified library, filtered by *options*
**procedure**: \`(library-object-filename \`*libref*\`)\`
**returns: **the name of the object file holding the specified library, if any
**libraries: **\`(chezscheme)\`

Information can be obtained only for built-in libraries or libraries previously loaded into the system. *libref* must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter  of and in the Revised Report.

The \`library-version\` return value is a list of numbers (possibly empty) representing the library's version.

The list of exports returned by \`library-exports\` is a list of symbols, each identifying one of the library's exports. The order in which the elements appear is unspecified.

When the optional *options* argument is supplied, it must be an enumeration set over the symbols constituting valid library-requirements options, as described in the \`library-requirements-options\` entry below. It defaults to a set containing all of the options. Each element of the list of libraries returned by \`library-requirements\` is an s-expression form of a library reference. The library reference includes the actual version of the library that is present in the system (if nonempty), even if a version was not specified when it was imported. The order in which the libraries appear in the list returned by \`library-requirements\` is unspecified.

\`library-object-filename\` returns a string naming the object file if the specified library was loaded from or compiled to an object file. Otherwise, it returns \`#f\`.

\`(with-output-to-file "A.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (A (1 2)) (export x z)\`
\`          (import (rnrs))\`
\`          (define x 'ex)\`
\`          (define y 23)\`
\`          (define-syntax z\`
\`            (syntax-rules ()\`
\`              [(_ e) (+ y e)])))))\`
\`   'replace)\`
\` (with-output-to-file "B.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (B) (export x w)\`
\`          (import (rnrs) (A))\`
\`          (define w (cons (z 12) x)))))\`
\`   'replace)\`
\` (compile-imported-libraries #t)\`
\` (import (B))\`
\` (library-exports '(A)) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(A (1 2))) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(B)) \`=>\` (x w) ; or (w x)\`
\` (library-version '(A)) \`=>\` (1 2)\`
\` (library-version '(B)) \`=>\` ()\`
\` (library-requirements '(A)) \`=>\` ((rnrs (6)))\`
\` (library-requirements '(B)) \`=>\` ((rnrs (6)) (A (1 2)))\`
\` (library-object-filename '(A)) \`=>\` "A.so"\`
\` (library-object-filename '(B)) \`=>\` "B.so"\`
`
    },
    {
        name: "(library-requirements-options ",
        endParen: true,
        params: ["symbol", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s34"),
        description: `**syntax**: \`(library-requirements-options \`*symbol*\` ...)\`
**returns: **a library-requirements-options enumeration set
**libraries: **\`(chezscheme)\`

Library-requirements-options enumeration sets are passed to \`library-requirements\` to determine the library requirements to be listed. The available options are described below.

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "library-search-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s30"),
        description: `**thread parameter**: \`library-search-handler\`
**libraries: **\`(chezscheme)\`

The value of parameter must be a procedure that follows the protocol described below for \`default-library-search-handler\`, which is the default value of this parameter.

The value of this parameter is invoked to locate the source or object code for a library during \`import\`, \`compile-whole-program\`, or \`compile-whole-library\`.
`
    },
    {
        name: "(library-version ",
        endParen: true,
        params: ["libref"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s33"),
        description: `**procedure**: \`(library-version \`*libref*\`)\`
**returns: **the version of the specified library
**procedure**: \`(library-exports \`*libref*\`)\`
**returns: **a list of the exports of the specified library
**procedure**: \`(library-requirements \`*libref*\`)\`
**returns: **a list of libraries required by the specified library
**procedure**: \`(library-requirements \`*libref*\` \`*options*\`)\`
**returns: **a list of libraries required by the specified library, filtered by *options*
**procedure**: \`(library-object-filename \`*libref*\`)\`
**returns: **the name of the object file holding the specified library, if any
**libraries: **\`(chezscheme)\`

Information can be obtained only for built-in libraries or libraries previously loaded into the system. *libref* must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter  of and in the Revised Report.

The \`library-version\` return value is a list of numbers (possibly empty) representing the library's version.

The list of exports returned by \`library-exports\` is a list of symbols, each identifying one of the library's exports. The order in which the elements appear is unspecified.

When the optional *options* argument is supplied, it must be an enumeration set over the symbols constituting valid library-requirements options, as described in the \`library-requirements-options\` entry below. It defaults to a set containing all of the options. Each element of the list of libraries returned by \`library-requirements\` is an s-expression form of a library reference. The library reference includes the actual version of the library that is present in the system (if nonempty), even if a version was not specified when it was imported. The order in which the libraries appear in the list returned by \`library-requirements\` is unspecified.

\`library-object-filename\` returns a string naming the object file if the specified library was loaded from or compiled to an object file. Otherwise, it returns \`#f\`.

\`(with-output-to-file "A.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (A (1 2)) (export x z)\`
\`          (import (rnrs))\`
\`          (define x 'ex)\`
\`          (define y 23)\`
\`          (define-syntax z\`
\`            (syntax-rules ()\`
\`              [(_ e) (+ y e)])))))\`
\`   'replace)\`
\` (with-output-to-file "B.ss"\`
\`   (lambda ()\`
\`     (pretty-print\`
\`       '(library (B) (export x w)\`
\`          (import (rnrs) (A))\`
\`          (define w (cons (z 12) x)))))\`
\`   'replace)\`
\` (compile-imported-libraries #t)\`
\` (import (B))\`
\` (library-exports '(A)) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(A (1 2))) \`=>\` (x z) ; or (z x)\`
\` (library-exports '(B)) \`=>\` (x w) ; or (w x)\`
\` (library-version '(A)) \`=>\` (1 2)\`
\` (library-version '(B)) \`=>\` ()\`
\` (library-requirements '(A)) \`=>\` ((rnrs (6)))\`
\` (library-requirements '(B)) \`=>\` ((rnrs (6)) (A (1 2)))\`
\` (library-object-filename '(A)) \`=>\` "A.so"\`
\` (library-object-filename '(B)) \`=>\` "B.so"\`
`
    },
    {
        name: "(list ",
        endParen: true,
        params: ["obj", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s43"),
        description: `**procedure**: \`(list \`*obj*\` ...)\`
**returns: **a list of *obj*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`list\` is equivalent to \`(lambda x x)\`.

\`(list) \`=>\` ()\`
\` (list 1 2 3) \`=>\` (1 2 3)\`
\` (list 3 2 1) \`=>\` (3 2 1)\`
`
    },
    {
        name: "(list* ",
        endParen: true,
        params: ["obj", "final-obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s6"),
        description: `**procedure**: \`(list* \`*obj*\` ... \`*final-obj*\`)\`
**returns: **a list of *obj*\` ...\` terminated by *final-obj*
**libraries: **\`(chezscheme)\`

\`list*\` is identical to the Revised Report \`cons*\`.
`
    },
    {
        name: "(list->fxvector ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s51"),
        description: `**procedure**: \`(list->fxvector \`*list*\`)\`
**returns: **an fxvector of the elements of *list*
**libraries: **\`(chezscheme)\`

*list* must consist entirely of fixnums.

\`(list->fxvector '()) \`=>\` #vfx()\`
\` (list->fxvector '(3 5 7)) \`=>\` #vfx(3 5 7) \`
\` \`
\` (let ([v #vfx(1 2 3 4 5)])\`
\`   (let ([ls (fxvector->list v)])\`
\`     (list->fxvector (map fx* ls ls)))) \`=>\` #vfx(1 4 9 16 25)\`
`
    },
    {
        name: "(list->string ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s229"),
        description: `**procedure**: \`(list->string \`*list*\`)\`
**returns: **a string of the characters in *list*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*list* must consist entirely of characters.

\`list->string\` is the functional inverse of \`string->list\`. A program might use both procedures together, first converting a string into a list, then operating on this list to produce a new list, and finally converting the new list back into a string.

\`list->string\` may be defined without error checks as follows.

\`(define list->string\`
\`   (lambda (ls)\`
\`     (let ([s (make-string (length ls))])\`
\`       (do ([ls ls (cdr ls)] [i 0 (+ i 1)])\`
\`           ((null? ls) s)\`
\`         (string-set! s i (car ls)))))) \`
\` \`
\` (list->string '()) \`=>\` ""\`
\` (list->string '(#\\a #\\b #\\c)) \`=>\` "abc"\`
\` (list->string\`
\`   (map char-upcase\`
\`        (string->list "abc"))) \`=>\` "ABC"\`
`
    },
    {
        name: "(list->vector ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s238"),
        description: `**procedure**: \`(list->vector \`*list*\`)\`
**returns: **a vector of the elements of *list*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`list->vector\` is the functional inverse of \`vector->list\`. The two procedures are often used in combination to take advantage of a list-processing operation. A vector may be converted to a list with \`vector->list\`, this list processed in some manner to produce a new list, and the new list converted back into a vector with \`list->vector\`.

\`list->vector\` may be defined without error checks as follows.

\`(define list->vector\`
\`   (lambda (ls)\`
\`     (let ([s (make-vector (length ls))])\`
\`       (do ([ls ls (cdr ls)] [i 0 (+ i 1)])\`
\`           ((null? ls) s)\`
\`         (vector-set! s i (car ls)))))) \`
\` \`
\` (list->vector '()) \`=>\` #()\`
\` (list->vector '(a b c)) \`=>\` #(a b c) \`
\` \`
\` (let ([v '#(1 2 3 4 5)])\`
\`   (let ([ls (vector->list v)])\`
\`     (list->vector (map * ls ls)))) \`=>\` #(1 4 9 16 25)\`
`
    },
    {
        name: "(list-copy ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s5"),
        description: `**procedure**: \`(list-copy \`*list*\`)\`
**returns: **a copy of *list*
**libraries: **\`(chezscheme)\`

\`list-copy\` returns a list \`equal?\` to *list*, using new pairs to reform the top-level list structure.

\`(list-copy '(a b c)) \`=>\` (a b c) \`
\` \`
\` (let ([ls '(a b c)])\`
\`   (equal? ls (list-copy ls))) \`=>\` #t \`
\` \`
\` (let ([ls '(a b c)])\`
\`   (let ([ls-copy (list-copy ls)])\`
\`     (or (eq? ls-copy ls)\`
\`         (eq? (cdr ls-copy) (cdr ls))\`
\`         (eq? (cddr ls-copy) (cddr ls))))) \`=>\` #f\`
`
    },
    {
        name: "(list-head ",
        endParen: true,
        params: ["list", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s3"),
        description: `**procedure**: \`(list-head \`*list*\` \`*n*\`)\`
**returns: **a list of the first *n* elements of *list*
**libraries: **\`(chezscheme)\`

*n* must be an exact nonnegative integer less than or equal to the length of *list*.

\`list-head\` and the standard Scheme procedure \`list-tail\` may be used together to split a list into two separate lists. While \`list-tail\` performs no allocation but instead returns a sublist of the original list, \`list-head\` always returns a copy of the first portion of the list.

\`list-head\` may be defined as follows.

\`(define list-head\`
\`   (lambda (ls n)\`
\`     (if (= n 0)\`
\`         '()\`
\`         (cons (car ls) (list-head (cdr ls) (- n 1)))))) \`
\` \`
\` (list-head '(a b c) 0) \`=>\` ()\`
\` (list-head '(a b c) 2) \`=>\` (a b)\`
\` (list-head '(a b c) 3) \`=>\` (a b c)\`
\` (list-head '(a b c . d) 2) \`=>\` (a b)\`
\` (list-head '(a b c . d) 3) \`=>\` (a b c)\`
\` (list-head '#1=(a . #1#) 5) \`=>\` (a a a a a)\`
`
    },
    {
        name: "(list-ref ",
        endParen: true,
        params: ["list", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s47"),
        description: `**procedure**: \`(list-ref \`*list*\` \`*n*\`)\`
**returns: **the *n*th element (zero-based) of *list*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *list*. \`list-ref\` may be defined without error checks as follows.
`
    },
    {
        name: "(list-sort ",
        endParen: true,
        params: ["predicate", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s62"),
        description: `**procedure**: \`(list-sort \`*predicate*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* sorted according to *predicate*
**libraries: **\`(rnrs sorting)\`, \`(rnrs)\`

*predicate* should be a procedure that expects two arguments and returns \`#t\` if its first argument must precede its second in the sorted list. That is, if *predicate* is applied to two elements *x* and *y*, where *x* appears after *y* in the input list, it should return true only if *x* should appear before *y* in the output list. If this constraint is met, \`list-sort\` performs a stable sort, i.e., two elements are reordered only when necessary according to *predicate*. Duplicate elements are not removed. This procedure may call predicate up to log times, where is the length of *list*.

\`(list-sort < '(3 4 2 1 2 5)) \`=>\` (1 2 2 3 4 5)\`
\` (list-sort > '(0.5 1/2)) \`=>\` (0.5 1/2)\`
\` (list-sort > '(1/2 0.5)) \`=>\` (1/2 0.5)\`
\` (list->string\`
\`   (list-sort char>?\`
\`     (string->list "hello"))) \`=>\` "ollhe"\`
`
    },
    {
        name: "(list-tail ",
        endParen: true,
        params: ["list", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s48"),
        description: `**procedure**: \`(list-tail \`*list*\` \`*n*\`)\`
**returns: **the *n*th tail (zero-based) of *list*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than or equal to the length of *list*. The result is not a copy; the tail is \`eq?\` to the *n*th cdr of *list* (or to *list* itself, if *n* is zero).

\`list-tail\` may be defined without error checks as follows.
`
    },
    {
        name: "(list? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s45"),
        description: `**procedure**: \`(list? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a proper list, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`list?\` must return \`#f\` for all improper lists, including cyclic lists. A definition of \`list?\` is shown on page .

\`(list? '()) \`=>\` #t\`
\` (list? '(a b c)) \`=>\` #t\`
\` (list? 'a) \`=>\` #f\`
\` (list? '(3 . 4)) \`=>\` #f\`
\` (list? 3) \`=>\` #f\`
\` (let ([x (list 'a 'b 'c)])\`
\`   (set-cdr! (cddr x) x)\`
\`   (list? x)) \`=>\` #f\`
`
    },
    {
        name: "(literal-identifier=? ",
        endParen: true,
        params: ["identifier1", "identifier2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s14"),
        description: `**procedure**: \`(literal-identifier=? \`*identifier1*\` \`*identifier2*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

This procedure is identical to the Revised Report \`free-identifier=?\`, and is provided for backward compatibility only.
`
    },
    {
        name: "(load ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s45"),
        description: `**procedure**: \`(load \`*path*\`)\`
**procedure**: \`(load \`*path*\` \`*eval-proc*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`load\` reads and evaluates the contents of the file specified by *path*. The file may contain source or object code. By default, \`load\` employs \`eval\` to evaluate each source expression found in a source file. If *eval-proc* is specified, \`load\` uses this procedure instead. *eval-proc* must accept one argument, the expression to evaluate. The expression passed to *eval-proc* might be an annotation (Section ) or an unannotated value.

The *eval-proc* argument facilitates the implementation of embedded Scheme-like languages and the use of alternate evaluation mechanisms to be used for Scheme programs. *eval-proc* can be put to other uses as well. For example,

\`(load "myfile.ss"\`
\`   (lambda (x)\`
\`     (pretty-print\`
\`       (if (annotation? x)\`
\`           (annotation-stripped x)\`
\`           x))\`
\`     (newline)\`
\`     (eval x)))\`

pretty-prints each expression before evaluating it.
`
    },
    {
        name: "(load ",
        endParen: true,
        params: ["path", "eval-proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s45"),
        description: `**procedure**: \`(load \`*path*\`)\`
**procedure**: \`(load \`*path*\` \`*eval-proc*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`load\` reads and evaluates the contents of the file specified by *path*. The file may contain source or object code. By default, \`load\` employs \`eval\` to evaluate each source expression found in a source file. If *eval-proc* is specified, \`load\` uses this procedure instead. *eval-proc* must accept one argument, the expression to evaluate. The expression passed to *eval-proc* might be an annotation (Section ) or an unannotated value.

The *eval-proc* argument facilitates the implementation of embedded Scheme-like languages and the use of alternate evaluation mechanisms to be used for Scheme programs. *eval-proc* can be put to other uses as well. For example,

\`(load "myfile.ss"\`
\`   (lambda (x)\`
\`     (pretty-print\`
\`       (if (annotation? x)\`
\`           (annotation-stripped x)\`
\`           x))\`
\`     (newline)\`
\`     (eval x)))\`

pretty-prints each expression before evaluating it.
`
    },
    {
        name: "(load-compiled-from-port ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s56"),
        description: `**procedure**: \`(load-compiled-from-port \`*input-port*\`)\`
**returns: **result of the last compiled expression
**libraries: **\`(chezscheme)\`

\`load-compiled-from-port\` reads and evaluates the object-code contents of *input-port* as previously created by functions like \`compile-file\`, \`compile-script\`, \`compile-library\`, and \`compile-to-port\`.

The return value is the value of the last expression whose compiled form is in *input-port*. If *input-port* is empty, then the result value is unspecified. The port is left at end-of-file but is not closed.
`
    },
    {
        name: "(load-library ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s47"),
        description: `**procedure**: \`(load-library \`*path*\`)\`
**procedure**: \`(load-library \`*path*\` \`*eval-proc*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`load-library\` is identical to \`load\` except that it treats the input file as if it were prefixed by an implicit \`#!r6rs\`. This effectively disables any non-R6RS lexical syntax except where subsequently overridden by \`#!chezscheme\`.
`
    },
    {
        name: "(load-library ",
        endParen: true,
        params: ["path", "eval-proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s47"),
        description: `**procedure**: \`(load-library \`*path*\`)\`
**procedure**: \`(load-library \`*path*\` \`*eval-proc*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`load-library\` is identical to \`load\` except that it treats the input file as if it were prefixed by an implicit \`#!r6rs\`. This effectively disables any non-R6RS lexical syntax except where subsequently overridden by \`#!chezscheme\`.
`
    },
    {
        name: "(load-program ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s48"),
        description: `**procedure**: \`(load-program \`*path*\`)\`
**procedure**: \`(load-program \`*path*\` \`*eval-proc*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`load-program\` reads and evaluates the contents of the file specified by *path*. The file may contain source or object code. If it contains source code, \`load-program\` wraps the code in a \`top-level-program\` form so that the file's content is treated as an RNRS top-level program (Section  of ). By default, \`load-program\` employs \`eval\` to evaluate each source expression found in the file. If *eval-proc* is specified, \`load-program\` uses this procedure instead. *eval-proc* must accept one argument, the expression to evaluate. The expression passed to *eval-proc* might be an annotation (Section ) or an unannotated value.
`
    },
    {
        name: "(load-program ",
        endParen: true,
        params: ["path", "eval-proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s48"),
        description: `**procedure**: \`(load-program \`*path*\`)\`
**procedure**: \`(load-program \`*path*\` \`*eval-proc*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`load-program\` reads and evaluates the contents of the file specified by *path*. The file may contain source or object code. If it contains source code, \`load-program\` wraps the code in a \`top-level-program\` form so that the file's content is treated as an RNRS top-level program (Section  of ). By default, \`load-program\` employs \`eval\` to evaluate each source expression found in the file. If *eval-proc* is specified, \`load-program\` uses this procedure instead. *eval-proc* must accept one argument, the expression to evaluate. The expression passed to *eval-proc* might be an annotation (Section ) or an unannotated value.
`
    },
    {
        name: "(load-shared-object ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s160"),
        description: `**procedure**: \`(load-shared-object \`*path*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`load-shared-object\` loads the shared object named by *path*. Shared objects may be system libraries or files created from ordinary C programs. All external symbols in the shared object, along with external symbols available in other shared objects linked with the shared object, are made available as foreign entries.

This procedure is supported for most platforms upon which runs.

If *path* does not begin with a "." or "/", the shared object is searched for in a default set of directories determined by the system.

On most Unix systems, \`load-shared-object\` is based on the system routine \`dlopen\`. Under Windows, \`load-shared-object\` is based on \`LoadLibrary\`. Refer to the documentation for these routines and for the C compiler and loader for precise rules for locating and building shared objects.

\`load-shared-object\` can be used to access built-in C library functions, such as \`getenv\`. The name of the shared object varies from one system to another. On Linux systems:

\`(load-shared-object "libc.so.6")\`

On Solaris, OpenSolaris, FreeBSD, NetBSD, and OpenBSD systems:

\`(load-shared-object "libc.so")\`

On MacOS X systems:

\`(load-shared-object "libc.dylib")\`

On Windows:

\`(load-shared-object "msvcrt.dll")\`

Once the C library has been loaded, \`getenv\` should be available as a foreign entry.

\`(foreign-entry? "getenv") \`=>\` #t\`

An equivalent Scheme procedure may be defined and invoked as follows.

\`(define getenv\`
\`   (foreign-procedure "getenv"\`
\`     (string)\`
\`     string))\`
\` (getenv "HOME") \`=>\` "/home/elmer/fudd"\`
\` (getenv "home") \`=>\` #f\`
`
    },
    {
        name: "(locate-source ",
        endParen: true,
        params: ["sfd", "pos"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s72"),
        description: `**procedure**: \`(locate-source \`*sfd*\` \`*pos*\`)\`
**procedure**: \`(locate-source \`*sfd*\` \`*pos*\` \`*use-cache?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor, and *pos* must be an exact nonnegative integer.

This procedure either uses cached information from a previous request for *sfd* (only when *use-cache?* is provided as true) or attempts to locate and open the source file identified by *sfd*. If successful, it returns three values: a string *path*, an exact nonnegative integer *line*, and an exact nonnegative integer *char* representing the absolute pathname, line, and character position within the line represented by the specified source-file descriptor and file position. If unsuccessful, it returns zero values. It can fail even if a file with the correct name exists in one of the source directories when the file's checksum does not match the checksum recorded in *sfd*.
`
    },
    {
        name: "(locate-source ",
        endParen: true,
        params: ["sfd", "pos", "use-cache?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s72"),
        description: `**procedure**: \`(locate-source \`*sfd*\` \`*pos*\`)\`
**procedure**: \`(locate-source \`*sfd*\` \`*pos*\` \`*use-cache?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor, and *pos* must be an exact nonnegative integer.

This procedure either uses cached information from a previous request for *sfd* (only when *use-cache?* is provided as true) or attempts to locate and open the source file identified by *sfd*. If successful, it returns three values: a string *path*, an exact nonnegative integer *line*, and an exact nonnegative integer *char* representing the absolute pathname, line, and character position within the line represented by the specified source-file descriptor and file position. If unsuccessful, it returns zero values. It can fail even if a file with the correct name exists in one of the source directories when the file's checksum does not match the checksum recorded in *sfd*.
`
    },
    {
        name: "(locate-source-object-source ",
        endParen: true,
        params: ["source-object", "get-start?", "use-cache?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s73"),
        description: `**procedure**: \`(locate-source-object-source \`*source-object*\` \`*get-start?*\` \`*use-cache?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

This procedure is similar to \`locate-source\`, but instead of taking an sfd and a position, it takes a source object plus a request for either the start or end location.

If *get-start?* is true and *source-object* has a line and column, this procedure returns the path in *source-objects*'s sfd, *source-object*'s line, and *source-objects*'s column.

If *source-object* has no line and column, then this procedure calls \`locate-source\` on *source-object*'s sfd, either *source-object*'s bfp or efp depending on *get-start?*, and *use-cache?*.
`
    },
    {
        name: "(lock-object ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s36"),
        description: `**procedure**: \`(lock-object \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Locking an object prevents the storage manager from reclaiming or relocating the object. Locking should be used sparingly, as it introduces memory fragmentation and increases storage management overhead.
`
    },
    {
        name: "(locked-object? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s39"),
        description: `**procedure**: \`(locked-object? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is locked, immediate, or static
**libraries: **\`(chezscheme)\`

This predicate returns true if *obj* cannot be relocated or reclaimed by the collector, including immediate values, such as fixnums, booleans, and characters, and objects that have been made static.

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(log ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s130"),
        description: `**procedure**: \`(log \`*num*\`)\`
**returns: **the natural logarithm of *num*
**procedure**: \`(log \`*num1*\` \`*num2*\`)\`
**returns: **the base-*num2* logarithm of *num1*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (log 1.0) \`=>\` 0.0\`
\` (log (exp 1.0)) \`=>\` 1.0\`
\` (/ (log 100) (log 10)) \`=>\` 2.0\`
\` (log (make-polar (exp 2.0) 1.0)) \`=>\` 2.0+1.0i \`
\` \`
\` (log 100.0 10.0) \`=>\` 2.0\`
\` (log .125 2.0) \`=>\` -3.0\`
`
    },
    {
        name: "(log ",
        endParen: true,
        params: ["num1", "num2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s130"),
        description: `**procedure**: \`(log \`*num*\`)\`
**returns: **the natural logarithm of *num*
**procedure**: \`(log \`*num1*\` \`*num2*\`)\`
**returns: **the base-*num2* logarithm of *num1*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (log 1.0) \`=>\` 0.0\`
\` (log (exp 1.0)) \`=>\` 1.0\`
\` (/ (log 100) (log 10)) \`=>\` 2.0\`
\` (log (make-polar (exp 2.0) 1.0)) \`=>\` 2.0+1.0i \`
\` \`
\` (log 100.0 10.0) \`=>\` 2.0\`
\` (log .125 2.0) \`=>\` -3.0\`
`
    },
    {
        name: "(logand ",
        endParen: true,
        params: ["int", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s44"),
        description: `**procedure**: \`(logand \`*int*\` ...)\`
**returns: **the logical "and" of the arguments *int*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`logand\` returns -1, i.e., all bits set.

\`(logand) \`=>\` -1\`
\` (logand 15) \`=>\` 15\`
\` (logand -1 -1) \`=>\` -1\`
\` (logand -1 0) \`=>\` 0\`
\` (logand 5 3) \`=>\` 1\`
\` (logand #x173C8D95 7) \`=>\` 5\`
\` (logand #x173C8D95 -8) \`=>\` #x173C8D90\`
\` (logand #b1100 #b1111 #b1101) \`=>\` #b1100\`
`
    },
    {
        name: "(logbit0 ",
        endParen: true,
        params: ["index", "int"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s50"),
        description: `**procedure**: \`(logbit0 \`*index*\` \`*int*\`)\`
**returns: **the result of clearing bit *index* of *int*
**libraries: **\`(chezscheme)\`

*index* must be a nonnegative exact integer. *int* must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation.

The index is zero-based, counting from the lowest-order toward higher-order bits. As with \`logbit?\`, there is no upper limit on the index.

\`logbit0\` is equivalent to

\`(lambda (i n) (logand (lognot (ash 1 i)) n))\`

but more efficient.

\`(logbit0 3 #b10101010) \`=>\` #b10100010\`
\` (logbit0 4 #b10101010) \`=>\` #b10101010\`
\` (logbit0 0 -1) \`=>\` -2\`
`
    },
    {
        name: "(logbit1 ",
        endParen: true,
        params: ["index", "int"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s51"),
        description: `**procedure**: \`(logbit1 \`*index*\` \`*int*\`)\`
**returns: **the result of setting bit *index* of *int*
**libraries: **\`(chezscheme)\`

*index* must be a nonnegative exact integer. *int* must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation.

The index is zero-based, counting from the lowest-order toward higher-order bits. As with \`logbit?\`, there is no upper limit on the index.

\`logbit1\` is equivalent to

\`(lambda (i n) (logor (ash 1 i) n))\`

but more efficient.

\`(logbit1 3 #b10101010) \`=>\` #b10101010\`
\` (logbit1 4 #b10101010) \`=>\` #b10111010\`
\` (logbit1 4 0) \`=>\` #b10000\`
\` (logbit1 0 -2) \`=>\` -1\`
`
    },
    {
        name: "(logbit? ",
        endParen: true,
        params: ["index", "int"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s48"),
        description: `**procedure**: \`(logbit? \`*index*\` \`*int*\`)\`
**returns: **\`#t\` if the specified bit is set, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*index* must be a nonnegative exact integer. *int* must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation.

\`logbit?\` returns \`#t\` if the bit at index *index* of *int* is set (one) and \`#f\` otherwise. The index is zero-based, counting from the lowest-order toward higher-order bits. There is no upper limit on the index; for nonnegative values of *int*, the bits above the highest order set bit are all considered to be zero, and for negative values, the bits above the highest order reset bit are all considered to be one.

\`logbit?\` is equivalent to

\`(lambda (k n) (not (zero? (logand n (ash 1 k)))))\`

but more efficient.

\`(logbit? 0 #b1110) \`=>\` #f\`
\` (logbit? 1 #b1110) \`=>\` #t\`
\` (logbit? 2 #b1110) \`=>\` #t\`
\` (logbit? 3 #b1110) \`=>\` #t\`
\` (logbit? 4 #b1110) \`=>\` #f\`
\` (logbit? 100 #b1110) \`=>\` #f \`
\` \`
\` (logbit? 0 -6) \`=>\` #f  ; \`*the two's complement of*\` -6 \`*is*\` 1...1010\`
\` (logbit? 1 -6) \`=>\` #t\`
\` (logbit? 2 -6) \`=>\` #f\`
\` (logbit? 3 -6) \`=>\` #t\`
\` (logbit? 100 -6) \`=>\` #t \`
\` \`
\` (logbit? (random 1000000) 0) \`=>\` #f\`
\` (logbit? (random 1000000) -1) \`=>\` #t \`
\` \`
\` (logbit? 20000 (ash 1 20000)) \`=>\` #t\`
`
    },
    {
        name: "(logior ",
        endParen: true,
        params: ["int", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s45"),
        description: `**procedure**: \`(logior \`*int*\` ...)\`
**procedure**: \`(logor \`*int*\` ...)\`
**returns: **the logical "or" of the arguments *int*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`logior\` returns 0, i.e., all bits reset.

\`(logior) \`=>\` 0\`
\` (logior 15) \`=>\` 15\`
\` (logior -1 -1) \`=>\` -1\`
\` (logior -1 0) \`=>\` -1\`
\` (logior 5 3) \`=>\` 7\`
\` (logior #b111000 #b101010) \`=>\` #b111010\`
\` (logior #b1000 #b0100 #b0010) \`=>\` #b1110\`
\` (apply logior '(1 2 4 8 16)) \`=>\` 31\`
`
    },
    {
        name: "(lognot ",
        endParen: true,
        params: ["int"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s47"),
        description: `**procedure**: \`(lognot \`*int*\`)\`
**returns: **the logical "not" of *int*
**libraries: **\`(chezscheme)\`

The argument must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation.

\`(lognot -1) \`=>\` 0\`
\` (lognot 0) \`=>\` -1\`
\` (lognot 7) \`=>\` -8\`
\` (lognot -8) \`=>\` 7\`
`
    },
    {
        name: "(logor ",
        endParen: true,
        params: ["int", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s45"),
        description: `**procedure**: \`(logior \`*int*\` ...)\`
**procedure**: \`(logor \`*int*\` ...)\`
**returns: **the logical "or" of the arguments *int*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`logior\` returns 0, i.e., all bits reset.

\`(logior) \`=>\` 0\`
\` (logior 15) \`=>\` 15\`
\` (logior -1 -1) \`=>\` -1\`
\` (logior -1 0) \`=>\` -1\`
\` (logior 5 3) \`=>\` 7\`
\` (logior #b111000 #b101010) \`=>\` #b111010\`
\` (logior #b1000 #b0100 #b0010) \`=>\` #b1110\`
\` (apply logior '(1 2 4 8 16)) \`=>\` 31\`
`
    },
    {
        name: "(logtest ",
        endParen: true,
        params: ["int1", "int2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s49"),
        description: `**procedure**: \`(logtest \`*int1*\` \`*int2*\`)\`
**returns: **\`#t\` if any common bits are set, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation.

\`logtest\` returns \`#t\` if any bit set in one argument is also set in the other. It returns \`#f\` if the two arguments have no set bits in common.

\`logtest\` is equivalent to

\`(lambda (n1 n2) (not (zero? (logand n1 n2))))\`

but more efficient.

\`(logtest #b10001 #b1110) \`=>\` #f\`
\` (logtest #b10101 #b1110) \`=>\` #t\`
\` (logtest #b111000 #b110111) \`=>\` #t \`
\` \`
\` (logtest #b101 -6) \`=>\` #f  ; \`*the two's complement of*\` -6 \`*is*\` 1...1010\`
\` (logtest #b1000 -6) \`=>\` #t\`
\` (logtest 100 -6) \`=>\` #t \`
\` \`
\` (logtest (+ (random 1000000) 1) 0) \`=>\` #f\`
\` (logtest (+ (random 1000000) 1) -1) \`=>\` #t \`
\` \`
\` (logtest (ash #b101 20000) (ash #b111 20000)) \`=>\` #t\`
`
    },
    {
        name: "(logxor ",
        endParen: true,
        params: ["int", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s46"),
        description: `**procedure**: \`(logxor \`*int*\` ...)\`
**returns: **the logical "exclusive or" of the arguments *int*\` ...\`
**libraries: **\`(chezscheme)\`

The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, \`logxor\` returns 0, i.e., all bits reset.

\`(logxor) \`=>\` 0\`
\` (logxor 15) \`=>\` 15\`
\` (logxor -1 -1) \`=>\` 0\`
\` (logxor -1 0) \`=>\` -1\`
\` (logxor 5 3) \`=>\` 6\`
\` (logxor #b111000 #b101010) \`=>\` #b010010\`
\` (logxor #b1100 #b0100 #b0110) \`=>\` #b1110\`
`
    },
    {
        name: "(lookahead-char ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s62"),
        description: `**procedure**: \`(lookahead-char \`*textual-input-port*\`)\`
**returns: **the next character from *textual-input-port*, or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *textual-input-port* is at end of file, the eof object is returned. Otherwise, the next available character is returned. In contrast to \`get-char\`, \`lookahead-char\` does not consume the character it reads from the port, so if the next operation on the port is a call to \`lookahead-char\` or \`get-char\`, the same character is returned.

\`lookahead-char\` is provided for applications requiring one character of lookahead. The procedure \`get-word\` defined below returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since \`get-word\` does not know until it sees one character beyond the word that it has read the entire word, it uses \`lookahead-char\` to determine the next character and \`get-char\` to consume the character.

\`(define get-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ()\`
\`         (let ([c (lookahead-char p)])\`
\`           (cond\`
\`             [(eof-object? c) '()]\`
\`             [(char-alphabetic? c) (get-char p) (cons c (f))]\`
\`             [else '()]))))))\`
`
    },
    {
        name: "(lookahead-u8 ",
        endParen: true,
        params: ["binary-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s56"),
        description: `**procedure**: \`(lookahead-u8 \`*binary-input-port*\`)\`
**returns: **the next byte from *binary-input-port*, or the eof object
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *binary-input-port* is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255. In contrast to \`get-u8\`, \`lookahead-u8\` does not consume the byte it reads from the port, so if the next operation on the port is a call to \`lookahead-u8\` or \`get-u8\`, the same byte is returned.
`
    },
    {
        name: "(machine-type)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s89"),
        description: `**procedure**: \`(machine-type)\`
**returns: **the current machine type
**libraries: **\`(chezscheme)\`

Consult the release notes for the current version of for a list of supported machine types.
`
    },
    {
        name: "(magnitude ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s125"),
        description: `**procedure**: \`(magnitude \`*num*\`)\`
**returns: **the magnitude of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(magnitude-squared ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s75"),
        description: `**procedure**: \`(magnitude-squared \`*num*\`)\`
**returns: **magnitude of *num* squared
**libraries: **\`(chezscheme)\`

The procedure \`magnitude-squared\`, when passed a complex argument + returns its magnitude squared, i.e., + .

\`(magnitude-squared 3.0-4.0i) \`=>\` 25.0\`
\` (magnitude-squared 3.0) \`=>\` 9.0\`
`
    },
    {
        name: "(make-annotation ",
        endParen: true,
        params: ["obj", "source-object", "stripped-obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s49"),
        description: `**procedure**: \`(make-annotation \`*obj*\` \`*source-object*\` \`*stripped-obj*\`)\`
**procedure**: \`(make-annotation \`*obj*\` \`*source-object*\` \`*stripped-obj*\` \`*options*\`)\`
**returns: **an annotation
**libraries: **\`(chezscheme)\`

The annotation is formed with *obj* as its expression component, *source-object* as its source-object component, and *stripped-obj* as its stripped component. *obj* should represent an expression, possibly with embedded annotations. *stripped-obj* should be a stripped version of *obj*, i.e., equivalent to *obj* with each annotation replaced by its expression component. *options*, if present must be an enumeration set over the symbols \`debug\` and \`profile\`, and defaults to an enumeration set containing both \`debug\` and \`profile\`. Annotations marked \`debug\` are used for compile-time error reporting and run-time error reporting and inspection; annotations marked \`profile\` are used for profiling.
`
    },
    {
        name: "(make-annotation ",
        endParen: true,
        params: ["obj", "source-object", "stripped-obj", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s49"),
        description: `**procedure**: \`(make-annotation \`*obj*\` \`*source-object*\` \`*stripped-obj*\`)\`
**procedure**: \`(make-annotation \`*obj*\` \`*source-object*\` \`*stripped-obj*\` \`*options*\`)\`
**returns: **an annotation
**libraries: **\`(chezscheme)\`

The annotation is formed with *obj* as its expression component, *source-object* as its source-object component, and *stripped-obj* as its stripped component. *obj* should represent an expression, possibly with embedded annotations. *stripped-obj* should be a stripped version of *obj*, i.e., equivalent to *obj* with each annotation replaced by its expression component. *options*, if present must be an enumeration set over the symbols \`debug\` and \`profile\`, and defaults to an enumeration set containing both \`debug\` and \`profile\`. Annotations marked \`debug\` are used for compile-time error reporting and run-time error reporting and inspection; annotations marked \`profile\` are used for profiling.
`
    },
    {
        name: "(make-assertion-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s21"),
        description: `**syntax**: \`&assertion\`
**procedure**: \`(make-assertion-violation)\`
**returns: **a condition of type \`&assertion\`
**procedure**: \`(assertion-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&assertion\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

This condition type indicates a specific violation in which the program has passed the wrong number or types of arguments to a procedure. This condition type might be defined as follows.

\`(define-condition-type &assertion &violation\`
\`   make-assertion-violation assertion-violation?)\`
`
    },
    {
        name: "(make-boot-file ",
        endParen: true,
        params: ["output-filename", "base-boot-list", "input-filename", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s83"),
        description: `**procedure**: \`(make-boot-file \`*output-filename*\` \`*base-boot-list*\` \`*input-filename*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*output-filename*, *input-filename*, and the elements of *base-boot-list* must be strings.

\`make-boot-file\` writes a boot header to the file named by *output-filename*, followed by the object code for each *input-filename* in turn. If an input file is not already compiled, \`make-boot-file\` compiles the file as it proceeds.

The boot header identifies the elements of *base-boot-list* as alternative boot files upon which the new boot file depends. If the list of strings naming base boot files is empty, the first named input file should be a base boot file, i.e., petite.boot or some boot file derived from petite.boot.
`
    },
    {
        name: "(make-boot-header ",
        endParen: true,
        params: ["output-filename", "base-boot1", "base-boot2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s86"),
        description: `**procedure**: \`(make-boot-header \`*output-filename*\` \`*base-boot1*\` \`*base-boot2*\`...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure has been subsumed by \`make-boot-file\` and is provided for backward compatibility. The call

\`(make-boot-header \`*output-filename*\` \`*base-boot1*\` \`*base-boot2*\` ...)\`

is equivalent to

\`(make-boot-file \`*output-filename*\` '(\`*base-boot1*\` \`*base-boot2*\` ...))\`
`
    },
    {
        name: "(make-bytevector ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s242"),
        description: `**procedure**: \`(make-bytevector \`*n*\`)\`
**procedure**: \`(make-bytevector \`*n*\` \`*fill*\`)\`
**returns: **a new bytevector of length *n*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

If *fill* is supplied, each element of the bytevector is initialized to *fill*; otherwise, the elements are unspecified. The *fill* value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

\`(make-bytevector 0) \`=>\` #vu8()\`
\` (make-bytevector 0 7) \`=>\` #vu8()\`
\` (make-bytevector 5 7) \`=>\` #vu8(7 7 7 7 7)\`
\` (make-bytevector 5 -7) \`=>\` #vu8(249 249 249 249 249)\`
`
    },
    {
        name: "(make-bytevector ",
        endParen: true,
        params: ["n", "fill"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s242"),
        description: `**procedure**: \`(make-bytevector \`*n*\`)\`
**procedure**: \`(make-bytevector \`*n*\` \`*fill*\`)\`
**returns: **a new bytevector of length *n*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

If *fill* is supplied, each element of the bytevector is initialized to *fill*; otherwise, the elements are unspecified. The *fill* value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

\`(make-bytevector 0) \`=>\` #vu8()\`
\` (make-bytevector 0 7) \`=>\` #vu8()\`
\` (make-bytevector 5 7) \`=>\` #vu8(7 7 7 7 7)\`
\` (make-bytevector 5 -7) \`=>\` #vu8(249 249 249 249 249)\`
`
    },
    {
        name: "(make-compile-time-value ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s15"),
        description: `**procedure**: \`(make-compile-time-value \`*obj*\`)\`
**returns: **a compile-time value
**libraries: **\`(chezscheme)\`

A compile time value is a kind of transformer with which a keyword may be associated by any of the keyword binding constructs, e.g., \`define-syntax\` or \`let-syntax\`. The transformer encapsulates the supplied *obj*. The encapsulated object may be retrieved as described above.

The following example illustrates how this feature might be used to define a simple syntactic record-definition mechanism where the record type descriptor is generated at expansion time.

\`(define-syntax drt\`
\`   (lambda (x)\`
\`     (define construct-name\`
\`       (lambda (template-identifier . args)\`
\`         (datum->syntax template-identifier\`
\`           (string->symbol\`
\`             (apply string-append\`
\`               (map (lambda (x)\`
\`                      (if (string? x)\`
\`                          x\`
\`                          (symbol->string (syntax->datum x))))\`
\`                    args))))))\`
\`     (define do-drt\`
\`       (lambda (rname fname* prtd)\`
\`         (with-syntax ([rname rname]\`
\`                       [rtd (make-record-type-descriptor\`
\`                              (syntax->datum rname) prtd #f #f #f\`
\`                              (list->vector\`
\`                                (map (lambda (fname)\`
\`                                       \`(immutable ,(syntax->datum fname)))\`
\`                                     fname*)))]\`
\`                       [make-rname (construct-name rname "make-" rname)]\`
\`                       [rname? (construct-name rname rname "?")]\`
\`                       [(rname-fname ...)\`
\`                        (map (lambda (fname)\`
\`                               (construct-name fname rname "-" fname))\`
\`                             fname*)]\`
\`                       [(i ...) (enumerate fname*)])\`
\`           #'(begin\`
\`               (define-syntax rname (make-compile-time-value 'rtd))\`
\`               (define rcd (make-record-constructor-descriptor 'rtd #f #f))\`
\`               (define make-rname (record-constructor rcd))\`
\`               (define rname? (record-predicate 'rtd))\`
\`               (define rname-fname (record-accessor 'rtd i))\`
\`               ...))))\`
\`     (syntax-case x (parent)\`
\`       [(_ rname (fname ...))\`
\`        (for-all identifier? #'(rname fname ...))\`
\`        (do-drt #'rname #'(fname ...) #f)]\`
\`       [(_ rname pname (fname ...))\`
\`        (for-all identifier? #'(rname pname fname ...))\`
\`        (lambda (lookup)\`
\`          (let ([prtd (lookup #'pname)])\`
\`            (unless (record-type-descriptor? prtd)\`
\`              (syntax-error #'pname "unrecognized parent record type"))\`
\`            (do-drt #'rname #'(fname ...) prtd)))])))\`

\`(drt prec (x y))\`
\` (drt crec prec (z))\`
\` (define r (make-crec 1 2 3))\`
\` (prec? r) \`=>\` #t\`
\` (prec-x r) \`=>\` 1\`
\` (crec-z r) \`=>\` 3\`
\` prec \`=>\` \`*exception: invalid syntax prec*
`
    },
    {
        name: "(make-condition)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s12"),
        description: `**procedure**: \`(make-condition)\`
**procedure**: \`(make-condition \`*name*\`)\`
**returns: **a new condition object
**libraries: **\`(chezscheme)\`

*name*, if supplied, must be a symbol which identifies the condition object, or \`#f\` for no name. The name is printed every time the condition is printed, which is useful for debugging.
`
    },
    {
        name: "(make-condition ",
        endParen: true,
        params: ["name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s12"),
        description: `**procedure**: \`(make-condition)\`
**procedure**: \`(make-condition \`*name*\`)\`
**returns: **a new condition object
**libraries: **\`(chezscheme)\`

*name*, if supplied, must be a symbol which identifies the condition object, or \`#f\` for no name. The name is printed every time the condition is printed, which is useful for debugging.
`
    },
    {
        name: "(make-continuation-condition ",
        endParen: true,
        params: ["continuation"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s6"),
        description: `**syntax**: \`&continuation\`
**procedure**: \`(make-continuation-condition \`*continuation*\`)\`
**returns: **a condition of type \`&continuation\`
**procedure**: \`(continuation-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&continuation\`, \`#f\` otherwise
**procedure**: \`(condition-continuation \`*condition*\`)\`
**returns: **the contents of *condition*'s \`continuation\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition to indicate the current continuation at the point where the exception described by the condition occurred. The continuation of a failed \`assert\` or a call to \`assertion-violation\`, \`assertion-violationf\`, \`error\`, \`errorf\`, or \`syntax-error\` is now included via this condition type in the conditions passed to \`raise\`. The \`continuation\` argument should be a continuation. This condition type might be defined as follows.

\`(define-condition-type &continuation &condition\`
\`   make-continuation-condition continuation-condition?\`
\`   (continuation condition-continuation))\`
`
    },
    {
        name: "(make-cost-center)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s241"),
        description: `**procedure**: \`(make-cost-center)\`
**returns: **a new cost center
**libraries: **\`(chezscheme)\`

The recorded costs of the new cost center are initialized to zero.
`
    },
    {
        name: "(make-custom-binary-input-port ",
        endParen: true,
        params: ["id", "r!", "gp", "sp!", "close"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s41"),
        description: `**procedure**: \`(make-custom-binary-input-port \`*id*\` \`*r!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary input port
**procedure**: \`(make-custom-binary-output-port \`*id*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary output port
**procedure**: \`(make-custom-binary-input/output-port \`*id*\` \`*r!*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary input/output port
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

These procedures allow programs to create ports from arbitrary byte streams. *id* must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. *r!* and *w!* must be procedures, while *gp*, *sp!*, and *close* must each be a procedure or \`#f\`. These arguments are described below.

If the new port is an input/output port and does not provide either a *gp* or *sp!* procedure, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, due to input buffering that must be done to support \`lookahead-u8\` and is often done anyway for efficiency. For the same reason, a call to \`port-position\` after an input operation may not return an accurate position if the *sp!* procedure is not provided. Thus, programs that create custom binary input/output ports should generally provide both *gp* and *sp!* procedures.
`
    },
    {
        name: "(make-custom-binary-input/output-port ",
        endParen: true,
        params: ["id", "r!", "w!", "gp", "sp!", "close"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s41"),
        description: `**procedure**: \`(make-custom-binary-input-port \`*id*\` \`*r!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary input port
**procedure**: \`(make-custom-binary-output-port \`*id*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary output port
**procedure**: \`(make-custom-binary-input/output-port \`*id*\` \`*r!*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary input/output port
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

These procedures allow programs to create ports from arbitrary byte streams. *id* must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. *r!* and *w!* must be procedures, while *gp*, *sp!*, and *close* must each be a procedure or \`#f\`. These arguments are described below.

If the new port is an input/output port and does not provide either a *gp* or *sp!* procedure, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, due to input buffering that must be done to support \`lookahead-u8\` and is often done anyway for efficiency. For the same reason, a call to \`port-position\` after an input operation may not return an accurate position if the *sp!* procedure is not provided. Thus, programs that create custom binary input/output ports should generally provide both *gp* and *sp!* procedures.
`
    },
    {
        name: "(make-custom-binary-output-port ",
        endParen: true,
        params: ["id", "w!", "gp", "sp!", "close"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s41"),
        description: `**procedure**: \`(make-custom-binary-input-port \`*id*\` \`*r!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary input port
**procedure**: \`(make-custom-binary-output-port \`*id*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary output port
**procedure**: \`(make-custom-binary-input/output-port \`*id*\` \`*r!*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom binary input/output port
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

These procedures allow programs to create ports from arbitrary byte streams. *id* must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. *r!* and *w!* must be procedures, while *gp*, *sp!*, and *close* must each be a procedure or \`#f\`. These arguments are described below.

If the new port is an input/output port and does not provide either a *gp* or *sp!* procedure, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, due to input buffering that must be done to support \`lookahead-u8\` and is often done anyway for efficiency. For the same reason, a call to \`port-position\` after an input operation may not return an accurate position if the *sp!* procedure is not provided. Thus, programs that create custom binary input/output ports should generally provide both *gp* and *sp!* procedures.
`
    },
    {
        name: "(make-custom-textual-input-port ",
        endParen: true,
        params: ["id", "r!", "gp", "sp!", "close"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s42"),
        description: `**procedure**: \`(make-custom-textual-input-port \`*id*\` \`*r!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual input port
**procedure**: \`(make-custom-textual-output-port \`*id*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual output port
**procedure**: \`(make-custom-textual-input/output-port \`*id*\` \`*r!*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual input/output port
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

These procedures allow programs to create ports from arbitrary character streams. *id* must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. *r!* and *w!* must be procedures, while *gp*, *sp!*, and *close* must each be a procedure or \`#f\`. These arguments are described below.

If the new port is an input/output port, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, even if the *gp* and *sp!* procedures are provided, due to input buffering that must be done to support \`lookahead-char\` and is often done anyway for efficiency. Since the representations of port positions are not specified, it is not possible for the implementation to adjust the *gp* return value to account for the number of buffered characters. For the same reason, a call to \`port-position\` after an input operation may not return an accurate position, even if the *sp!* procedure is provided.

It should, however, be possible to perform output reliably after reading if the position is reset to the starting position. Thus, programs that create custom textual input/output ports should generally provide both *gp* and *sp!* procedures, and consumers of these ports should obtain the starting position via \`port-position\` before any input operations and reset the position back to the starting position before doing any output operations.
`
    },
    {
        name: "(make-custom-textual-input/output-port ",
        endParen: true,
        params: ["id", "r!", "w!", "gp", "sp!", "close"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s42"),
        description: `**procedure**: \`(make-custom-textual-input-port \`*id*\` \`*r!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual input port
**procedure**: \`(make-custom-textual-output-port \`*id*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual output port
**procedure**: \`(make-custom-textual-input/output-port \`*id*\` \`*r!*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual input/output port
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

These procedures allow programs to create ports from arbitrary character streams. *id* must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. *r!* and *w!* must be procedures, while *gp*, *sp!*, and *close* must each be a procedure or \`#f\`. These arguments are described below.

If the new port is an input/output port, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, even if the *gp* and *sp!* procedures are provided, due to input buffering that must be done to support \`lookahead-char\` and is often done anyway for efficiency. Since the representations of port positions are not specified, it is not possible for the implementation to adjust the *gp* return value to account for the number of buffered characters. For the same reason, a call to \`port-position\` after an input operation may not return an accurate position, even if the *sp!* procedure is provided.

It should, however, be possible to perform output reliably after reading if the position is reset to the starting position. Thus, programs that create custom textual input/output ports should generally provide both *gp* and *sp!* procedures, and consumers of these ports should obtain the starting position via \`port-position\` before any input operations and reset the position back to the starting position before doing any output operations.
`
    },
    {
        name: "(make-custom-textual-output-port ",
        endParen: true,
        params: ["id", "w!", "gp", "sp!", "close"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s42"),
        description: `**procedure**: \`(make-custom-textual-input-port \`*id*\` \`*r!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual input port
**procedure**: \`(make-custom-textual-output-port \`*id*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual output port
**procedure**: \`(make-custom-textual-input/output-port \`*id*\` \`*r!*\` \`*w!*\` \`*gp*\` \`*sp!*\` \`*close*\`)\`
**returns: **a new custom textual input/output port
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

These procedures allow programs to create ports from arbitrary character streams. *id* must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. *r!* and *w!* must be procedures, while *gp*, *sp!*, and *close* must each be a procedure or \`#f\`. These arguments are described below.

If the new port is an input/output port, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, even if the *gp* and *sp!* procedures are provided, due to input buffering that must be done to support \`lookahead-char\` and is often done anyway for efficiency. Since the representations of port positions are not specified, it is not possible for the implementation to adjust the *gp* return value to account for the number of buffered characters. For the same reason, a call to \`port-position\` after an input operation may not return an accurate position, even if the *sp!* procedure is provided.

It should, however, be possible to perform output reliably after reading if the position is reset to the starting position. Thus, programs that create custom textual input/output ports should generally provide both *gp* and *sp!* procedures, and consumers of these ports should obtain the starting position via \`port-position\` before any input operations and reset the position back to the starting position before doing any output operations.
`
    },
    {
        name: "(make-date ",
        endParen: true,
        params: ["nsec", "sec", "min", "hour", "day", "mon", "year"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s211"),
        description: `**procedure**: \`(make-date \`*nsec*\` \`*sec*\` \`*min*\` \`*hour*\` \`*day*\` \`*mon*\` \`*year*\`)\`
**procedure**: \`(make-date \`*nsec*\` \`*sec*\` \`*min*\` \`*hour*\` \`*day*\` \`*mon*\` \`*year*\` \`*offset*\`)\`
**returns: **a date object
**libraries: **\`(chezscheme)\`

*nsec* represents nanoseconds and must be an exact nonnegative integer less than 10. *sec* represents seconds and must be an exact nonnegative integer less than 62. *min* represents minutes and must be an exact nonnegative integer less than 60. *hour* must be an exact nonnegative integer less than 24. *day* must be an exact integer, 1 ≤ ≤ 31. (The actual upper limit may be less depending on the month and year.) *mon* represents the month must be an exact integer, 1 ≤ ≤ 12. *year* must be an exact integer. It should be at least 1970. *offset* represents the time-zone offset in seconds east of UTC, as described above. It must be an exact integer in the range -86400 to +86400, inclusive. UTC may be specified by passing an offset of zero.

If *offset* is not provided, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

\`(make-date 0 0 0 0 1 1 1970 0) \`=>\` #<date Thu Jan  1 00:00:00 1970>\`
\` (make-date 0 30 7 9 23 9 2007 -14400) \`=>\` #<date Sun Sep 23 09:07:30 2007> \`
\` \`
\` (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) \`=>\` #f\`
\` (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) \`=>\` #t\`
`
    },
    {
        name: "(make-date ",
        endParen: true,
        params: ["nsec", "sec", "min", "hour", "day", "mon", "year", "offset"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s211"),
        description: `**procedure**: \`(make-date \`*nsec*\` \`*sec*\` \`*min*\` \`*hour*\` \`*day*\` \`*mon*\` \`*year*\`)\`
**procedure**: \`(make-date \`*nsec*\` \`*sec*\` \`*min*\` \`*hour*\` \`*day*\` \`*mon*\` \`*year*\` \`*offset*\`)\`
**returns: **a date object
**libraries: **\`(chezscheme)\`

*nsec* represents nanoseconds and must be an exact nonnegative integer less than 10. *sec* represents seconds and must be an exact nonnegative integer less than 62. *min* represents minutes and must be an exact nonnegative integer less than 60. *hour* must be an exact nonnegative integer less than 24. *day* must be an exact integer, 1 ≤ ≤ 31. (The actual upper limit may be less depending on the month and year.) *mon* represents the month must be an exact integer, 1 ≤ ≤ 12. *year* must be an exact integer. It should be at least 1970. *offset* represents the time-zone offset in seconds east of UTC, as described above. It must be an exact integer in the range -86400 to +86400, inclusive. UTC may be specified by passing an offset of zero.

If *offset* is not provided, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

\`(make-date 0 0 0 0 1 1 1970 0) \`=>\` #<date Thu Jan  1 00:00:00 1970>\`
\` (make-date 0 30 7 9 23 9 2007 -14400) \`=>\` #<date Sun Sep 23 09:07:30 2007> \`
\` \`
\` (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) \`=>\` #f\`
\` (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) \`=>\` #t\`
`
    },
    {
        name: "(make-engine ",
        endParen: true,
        params: ["thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s16"),
        description: `**procedure**: \`(make-engine \`*thunk*\`)\`
**returns: **an engine
**libraries: **\`(chezscheme)\`

An engine is created by passing a thunk (no argument procedure) to \`make-engine\`. The body of the thunk is the computation to be performed by the engine. An engine itself is a procedure of three arguments:
`
    },
    {
        name: "(make-enumeration ",
        endParen: true,
        params: ["symbol-list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s291"),
        description: `**procedure**: \`(make-enumeration \`*symbol-list*\`)\`
**returns: **an enumeration set
**libraries: **\`(rnrs enums)\`, \`(rnrs)\`

This procedure creates a new enumeration type whose universe comprises the elements of *symbol-list*, which must be a list of symbols, in the order of their first appearance in the list. It returns the universe of the new enumeration type as an enumeration set.

\`(define positions (make-enumeration '(top bottom above top beside)))\`
\` (enum-set->list positions) \`=>\` (top bottom above beside)\`
`
    },
    {
        name: "(make-ephemeron-eq-hashtable)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s122"),
        description: `**procedure**: \`(make-ephemeron-eq-hashtable)\`
**procedure**: \`(make-ephemeron-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-ephemeron-eqv-hashtable)\`
**procedure**: \`(make-ephemeron-eqv-hashtable \`*size*\`)\`
**returns: **a new ephemeron eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like \`make-weak-eq-hashtable\` and \`make-weak-eqv-hashtable\`, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs.

A copy of an ephemeron eq or eqv hashtable created by \`hashtable-copy\` is also an ephemeron table, and an inaccessible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.

\`(define ht1 (make-ephemeron-eq-hashtable))\`
\` (define ht2 (make-ephemeron-eq-hashtable 32))\`
`
    },
    {
        name: "(make-ephemeron-eq-hashtable ",
        endParen: true,
        params: ["size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s122"),
        description: `**procedure**: \`(make-ephemeron-eq-hashtable)\`
**procedure**: \`(make-ephemeron-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-ephemeron-eqv-hashtable)\`
**procedure**: \`(make-ephemeron-eqv-hashtable \`*size*\`)\`
**returns: **a new ephemeron eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like \`make-weak-eq-hashtable\` and \`make-weak-eqv-hashtable\`, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs.

A copy of an ephemeron eq or eqv hashtable created by \`hashtable-copy\` is also an ephemeron table, and an inaccessible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.

\`(define ht1 (make-ephemeron-eq-hashtable))\`
\` (define ht2 (make-ephemeron-eq-hashtable 32))\`
`
    },
    {
        name: "(make-ephemeron-eqv-hashtable)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s122"),
        description: `**procedure**: \`(make-ephemeron-eq-hashtable)\`
**procedure**: \`(make-ephemeron-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-ephemeron-eqv-hashtable)\`
**procedure**: \`(make-ephemeron-eqv-hashtable \`*size*\`)\`
**returns: **a new ephemeron eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like \`make-weak-eq-hashtable\` and \`make-weak-eqv-hashtable\`, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs.

A copy of an ephemeron eq or eqv hashtable created by \`hashtable-copy\` is also an ephemeron table, and an inaccessible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.

\`(define ht1 (make-ephemeron-eq-hashtable))\`
\` (define ht2 (make-ephemeron-eq-hashtable 32))\`
`
    },
    {
        name: "(make-ephemeron-eqv-hashtable ",
        endParen: true,
        params: ["size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s122"),
        description: `**procedure**: \`(make-ephemeron-eq-hashtable)\`
**procedure**: \`(make-ephemeron-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-ephemeron-eqv-hashtable)\`
**procedure**: \`(make-ephemeron-eqv-hashtable \`*size*\`)\`
**returns: **a new ephemeron eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like \`make-weak-eq-hashtable\` and \`make-weak-eqv-hashtable\`, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs.

A copy of an ephemeron eq or eqv hashtable created by \`hashtable-copy\` is also an ephemeron table, and an inaccessible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.

\`(define ht1 (make-ephemeron-eq-hashtable))\`
\` (define ht2 (make-ephemeron-eq-hashtable 32))\`
`
    },
    {
        name: "(make-eq-hashtable)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s274"),
        description: `**procedure**: \`(make-eq-hashtable)\`
**procedure**: \`(make-eq-hashtable \`*size*\`)\`
**returns: **a new mutable eq hashtable
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

If *size* is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero *size* can help limit the amount of rehashing that must be done as the table is initially populated.

An eq hashtable compares keys using the \`eq?\` (pointer equality) procedure and typically employs a hash function based on object addresses. Its hash and equivalence functions are suitable for any Scheme object.

\`(define ht1 (make-eq-hashtable))\`
\` (define ht2 (make-eq-hashtable 32))\`
`
    },
    {
        name: "(make-eq-hashtable ",
        endParen: true,
        params: ["size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s274"),
        description: `**procedure**: \`(make-eq-hashtable)\`
**procedure**: \`(make-eq-hashtable \`*size*\`)\`
**returns: **a new mutable eq hashtable
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

If *size* is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero *size* can help limit the amount of rehashing that must be done as the table is initially populated.

An eq hashtable compares keys using the \`eq?\` (pointer equality) procedure and typically employs a hash function based on object addresses. Its hash and equivalence functions are suitable for any Scheme object.

\`(define ht1 (make-eq-hashtable))\`
\` (define ht2 (make-eq-hashtable 32))\`
`
    },
    {
        name: "(make-eqv-hashtable)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s275"),
        description: `**procedure**: \`(make-eqv-hashtable)\`
**procedure**: \`(make-eqv-hashtable \`*size*\`)\`
**returns: **a new mutable eqv hashtable
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

If *size* is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero *size* can help limit the amount of rehashing that must be done as the table is initially populated.

An eqv hashtable compares keys using the \`eqv?\` procedure and typically employs a hash function based on object addresses for objects that are identifiable with \`eq?\`. Its hash and equivalence functions are suitable for any Scheme object.
`
    },
    {
        name: "(make-eqv-hashtable ",
        endParen: true,
        params: ["size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s275"),
        description: `**procedure**: \`(make-eqv-hashtable)\`
**procedure**: \`(make-eqv-hashtable \`*size*\`)\`
**returns: **a new mutable eqv hashtable
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

If *size* is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero *size* can help limit the amount of rehashing that must be done as the table is initially populated.

An eqv hashtable compares keys using the \`eqv?\` procedure and typically employs a hash function based on object addresses for objects that are identifiable with \`eq?\`. Its hash and equivalence functions are suitable for any Scheme object.
`
    },
    {
        name: "(make-error)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s22"),
        description: `**syntax**: \`&error\`
**procedure**: \`(make-error)\`
**returns: **a condition of type \`&error\`
**procedure**: \`(error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&error\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that an error has occurred with the program's interaction with its operating environment, such as the failure of an attempt to open a file. It is not used to describe situations in which an error in the program has been detected. This condition type might be defined as follows.

\`(define-condition-type &error &serious\`
\`   make-error error?)\`
`
    },
    {
        name: "(make-format-condition)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s4"),
        description: `**syntax**: \`&format\`
**procedure**: \`(make-format-condition)\`
**returns: **a condition of type \`&format\`
**procedure**: \`(format-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&format\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

Presence of this condition type within a compound condition indicates that the string provided by the \`&message\` condition, if present, is a \`format\` string and the list of objects provided by the \`&irritants\` condition, if present, should be treated as additional \`format\` arguments. This condition type might be defined as follows.

\`(define-condition-type &format &condition\`
\`   make-format-condition format-condition?)\`
`
    },
    {
        name: "(make-ftype-pointer ",
        endParen: true,
        params: ["ftype-name", "expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s143"),
        description: `**syntax**: \`(make-ftype-pointer \`*ftype-name*\` \`*expr*\`)\`
**returns: **an ftype-pointer object
**libraries: **\`(chezscheme)\`

If *ftype-name* does not describe a function ftype, *expr* must evaluate to an *address* represented as an exact integer in the appropriate range for the target machine.

The ftype-pointer object returned by this procedure encapsulates the address and is tagged with a representation of the type identified by *ftype-name* to enable various forms of checking to be done by the access routines described below.

\`(make-ftype-pointer E #x80000000) \`=>\` #<ftype-pointer #x80000000>\`

The address will not typically be a constant, as shown. Instead, it might instead come from a call to \`foreign-alloc\`, e.g.:

\`(make-ftype-pointer E (foreign-alloc (ftype-sizeof E)))\`

It might also come from source outside of Scheme such as from a C routine called from Scheme via the foreign-procedure interface.
`
    },
    {
        name: "(make-fxvector ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s45"),
        description: `**procedure**: \`(make-fxvector \`*n*\`)\`
**procedure**: \`(make-fxvector \`*n*\` \`*fixnum*\`)\`
**returns: **an fxvector of length *n*
**libraries: **\`(chezscheme)\`

*n* must be a fixnum. If *fixnum* is supplied, each element of the fxvector is initialized to *fixnum*; otherwise, the elements are unspecified.

\`(make-fxvector 0) \`=>\` #vfx()\`
\` (make-fxvector 0 7) \`=>\` #vfx()\`
\` (make-fxvector 5 7) \`=>\` #vfx(7 7 7 7 7)\`
`
    },
    {
        name: "(make-fxvector ",
        endParen: true,
        params: ["n", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s45"),
        description: `**procedure**: \`(make-fxvector \`*n*\`)\`
**procedure**: \`(make-fxvector \`*n*\` \`*fixnum*\`)\`
**returns: **an fxvector of length *n*
**libraries: **\`(chezscheme)\`

*n* must be a fixnum. If *fixnum* is supplied, each element of the fxvector is initialized to *fixnum*; otherwise, the elements are unspecified.

\`(make-fxvector 0) \`=>\` #vfx()\`
\` (make-fxvector 0 7) \`=>\` #vfx()\`
\` (make-fxvector 5 7) \`=>\` #vfx(7 7 7 7 7)\`
`
    },
    {
        name: "(make-guardian)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s29"),
        description: `**procedure**: \`(make-guardian)\`
**returns: **a new guardian
**libraries: **\`(chezscheme)\`

Guardians are represented by procedures that encapsulate groups of objects registered for preservation. When a guardian is created, the group of registered objects is empty. An object is registered with a guardian by passing the object as an argument to the guardian:

\`(define G (make-guardian))\`
\` (define x (cons 'aaa 'bbb))\`
\` x \`=>\` (aaa . bbb)\`
\` (G x)\`

It is also possible to specify a "representative" object when registering an object. Continuing the above example:

\`(define y (cons 'ccc 'ddd))\`
\` y \`=>\` (ccc . ddd)\`
\` (G y 'rep)\`

The group of registered objects associated with a guardian is logically subdivided into two disjoint subgroups: a subgroup referred to as "accessible" objects, and one referred to "inaccessible" objects. Inaccessible objects are objects that have been proven to be inaccessible (except through the guardian mechanism itself or through the car field of a weak or ephemeron pair), and accessible objects are objects that have not been proven so. The word "proven" is important here: it may be that some objects in the accessible group are indeed inaccessible but that this has not yet been proven. This proof may not be made in some cases until long after the object actually becomes inaccessible (in the current implementation, until a garbage collection of the generation containing the object occurs).

Objects registered with a guardian are initially placed in the accessible group and are moved into the inaccessible group at some point after they become inaccessible. Objects in the inaccessible group are retrieved by invoking the guardian without arguments. If there are no objects in the inaccessible group, the guardian returns \`#f\`. Continuing the above example:

\`(G) \`=>\` #f\`
\` (set! x #f)\`
\` (set! y #f)\`
\` (collect)\`
\` (G) \`=>\` (aaa . bbb)   ; \`*this might come out second*
\` (G) \`=>\` rep           ; \`*and this first*
\` (G) \`=>\` #f\`

The initial call to \`G\` returns \`#f\`, since the pairs bound to \`x\` and \`y\` are the only object registered with \`G\`, and the pairs are still accessible through those bindings. When \`collect\` is called, the objects shift into the inaccessible group. The two calls to \`G\` therefore return the pair previously bound to \`x\` and the representative of the pair previously bound to \`y\`, though perhaps in the other order from the one shown. (As noted above for weak pairs, the call to collect may not actually be sufficient to prove the object inaccessible, if the object has migrated into an older generation.)

Although an object registered without a representative and returned from a guardian has been proven otherwise inaccessible (except possibly via the car field of a weak or ephemeron pair), it has not yet been reclaimed by the storage management system and will not be reclaimed until after the last nonweak pointer to it within or outside of the guardian system has been dropped. In fact, objects that have been retrieved from a guardian have no special status in this or in any other regard. This feature circumvents the problems that might otherwise arise with shared or cyclic structure. A shared or cyclic structure consisting of inaccessible objects is preserved in its entirety, and each piece registered for preservation with any guardian is placed in the inaccessible set for that guardian. The programmer then has complete control over the order in which pieces of the structure are processed.

An object may be registered with a guardian more than once, in which case it will be retrievable more than once:

\`(define G (make-guardian))\`
\` (define x (cons 'aaa 'bbb))\`
\` (G x)\`
\` (G x)\`
\` (set! x #f)\`
\` (collect)\`
\` (G) \`=>\` (aaa . bbb)\`
\` (G) \`=>\` (aaa . bbb)\`

It may also be registered with more than one guardian, and guardians themselves can be registered with other guardians.

An object that has been registered with a guardian without a representative and placed in the car field of a weak or ephemeron pair remains in the car field of the weak or ephemeron pair until after it has been returned from the guardian and dropped by the program or until the guardian itself is dropped.

\`(define G (make-guardian))\`
\` (define x (cons 'aaa 'bbb))\`
\` (define p (weak-cons x '()))\`
\` (G x)\`
\` (set! x #f)\`
\` (collect)\`
\` (set! y (G))\`
\` y \`=>\` (aaa . bbb)\`
\` (car p) \`=>\` (aaa . bbb)\`
\` (set! y #f)\`
\` (collect 1)\`
\` (car p) \`=>\` #!bwp\`

(The first collector call above would promote the object at least into generation 1, requiring the second collector call to be a generation 1 collection. This can also be forced by invoking \`collect\` several times.)

On the other hand, if a representative (other than the object itself) is specified, the guarded object is dropped from the car field of the weak or ephemeron pair at the same time as the representative becomes available from the guardian.

\`(define G (make-guardian))\`
\` (define x (cons 'aaa 'bbb))\`
\` (define p (weak-cons x '()))\`
\` (G x 'rep)\`
\` (set! x #f)\`
\` (collect)\`
\` (G) \`=>\` rep\`
\` (car p) \`=>\` #!bwp\`

The following example illustrates that the object is deallocated and the car field of the weak pair set to \`#!bwp\` when the guardian itself is dropped:

\`(define G (make-guardian))\`
\` (define x (cons 'aaa 'bbb))\`
\` (define p (weak-cons x '()))\`
\` (G x)\`
\` (set! x #f)\`
\` (set! G #f)\`
\` (collect)\`
\` (car p) \`=>\` #!bwp\`

The example below demonstrates how guardians might be used to deallocate external storage, such as storage managed by the C library "malloc" and "free" operations.

\`(define malloc\`
\`   (let ([malloc-guardian (make-guardian)])\`
\`     (lambda (size)\`
\`       ; first free any storage that has been dropped.  to avoid long\`
\`       ; delays, it might be better to deallocate no more than, say,\`
\`       ; ten objects for each one allocated\`
\`       (let f ()\`
\`         (let ([x (malloc-guardian)])\`
\`           (when x\`
\`             (do-free x)\`
\`             (f))))\`
\`       ; then allocate and register the new storage\`
\`       (let ([x (do-malloc size)])\`
\`         (malloc-guardian x)\`
\`         x))))\`

\`do-malloc\` must return a Scheme object "header" encapsulating a pointer to the external storage (perhaps as an unsigned integer), and all access to the external storage must be made through this header. In particular, care must be taken that no pointers to the external storage exist outside of Scheme after the corresponding header has been dropped. \`do-free\` must deallocate the external storage using the encapsulated pointer. Both primitives can be defined in terms of \`foreign-alloc\` and \`foreign-free\` or the C-library "malloc" and "free" operators, imported as foreign procedures. (See Chapter .)

If it is undesirable to wait until \`malloc\` is called to free dropped storage previously allocated by \`malloc\`, a collect-request handler can be used instead to check for and free dropped storage, as shown below.

\`(define malloc)\`
\` (let ([malloc-guardian (make-guardian)])\`
\`   (set! malloc\`
\`     (lambda (size)\`
\`       ; allocate and register the new storage\`
\`       (let ([x (do-malloc size)])\`
\`         (malloc-guardian x)\`
\`         x)))\`
\`   (collect-request-handler\`
\`     (lambda ()\`
\`       ; first, invoke the collector\`
\`       (collect)\`
\`       ; then free any storage that has been dropped\`
\`       (let f ()\`
\`         (let ([x (malloc-guardian)])\`
\`           (when x\`
\`             (do-free x)\`
\`             (f)))))))\`

With a bit of refactoring, it would be possible to register the encapsulated foreign address as a representative with each header, in which \`do-free\` would take just the foreign address as an argument. This would allow the header to be dropped from the Scheme heap as soon as it becomes inaccessible.
`
    },
    {
        name: "(make-hash-table)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s0"),
        description: `**procedure**: \`(make-hash-table)\`
**procedure**: \`(make-hash-table \`*weak?*\`)\`
**returns: **a new hash table
**libraries: **\`(chezscheme)\`

If *weak?* is provided and is non-false, the hash table is a weak hash table, which means that it does not protect keys from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.
`
    },
    {
        name: "(make-hash-table ",
        endParen: true,
        params: ["weak?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s0"),
        description: `**procedure**: \`(make-hash-table)\`
**procedure**: \`(make-hash-table \`*weak?*\`)\`
**returns: **a new hash table
**libraries: **\`(chezscheme)\`

If *weak?* is provided and is non-false, the hash table is a weak hash table, which means that it does not protect keys from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.
`
    },
    {
        name: "(make-hashtable ",
        endParen: true,
        params: ["hash", "equiv?"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s276"),
        description: `**procedure**: \`(make-hashtable \`*hash*\` \`*equiv?*\`)\`
**procedure**: \`(make-hashtable \`*hash*\` \`*equiv?*\` \`*size*\`)\`
**returns: **a new mutable hashtable
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hash* and *equiv?* must be procedures. If *size* is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero *size* can help limit the amount of rehashing that must be done as the table is initially populated.

The new hashtable computes hash values using *hash* and compares keys using *equiv?*, neither of which should modify the hashtable. *equiv?* should compare two keys and return false only if the two keys should be distinguished. *hash* should accept a key as an argument and return a nonnegative exact integer value that is the same each time it is called with arguments that *equiv?* does not distinguish. The *hash* and *equiv?* procedures need not accept arbitrary inputs as long as the hashtable is used only for keys that they do accept, and both procedures may assume that the keys are immutable as long as the keys are not modified while they have associations stored in the table. The hashtable operation may call *hash* and *equiv?* once, not at all, or multiple times for each hashtable operation.

\`(define ht (make-hashtable string-hash string=?))\`
`
    },
    {
        name: "(make-hashtable ",
        endParen: true,
        params: ["hash", "equiv?", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s276"),
        description: `**procedure**: \`(make-hashtable \`*hash*\` \`*equiv?*\`)\`
**procedure**: \`(make-hashtable \`*hash*\` \`*equiv?*\` \`*size*\`)\`
**returns: **a new mutable hashtable
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

*hash* and *equiv?* must be procedures. If *size* is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero *size* can help limit the amount of rehashing that must be done as the table is initially populated.

The new hashtable computes hash values using *hash* and compares keys using *equiv?*, neither of which should modify the hashtable. *equiv?* should compare two keys and return false only if the two keys should be distinguished. *hash* should accept a key as an argument and return a nonnegative exact integer value that is the same each time it is called with arguments that *equiv?* does not distinguish. The *hash* and *equiv?* procedures need not accept arbitrary inputs as long as the hashtable is used only for keys that they do accept, and both procedures may assume that the keys are immutable as long as the keys are not modified while they have associations stored in the table. The hashtable operation may call *hash* and *equiv?* once, not at all, or multiple times for each hashtable operation.

\`(define ht (make-hashtable string-hash string=?))\`
`
    },
    {
        name: "(make-i/o-decoding-error ",
        endParen: true,
        params: ["pobj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s42"),
        description: `**syntax**: \`&i/o-decoding\`
**procedure**: \`(make-i/o-decoding-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-decoding\`
**procedure**: \`(i/o-decoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-decoding\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that a decoding error has occurred during the transcoding of bytes to characters. The *pobj* argument to the constructor should be the port involved, if any. The port should be positioned past the invalid encoding. This condition type might be defined as follows.

\`(define-condition-type &i/o-decoding &i/o-port\`
\`   make-i/o-decoding-error i/o-decoding-error?)\`
`
    },
    {
        name: "(make-i/o-encoding-error ",
        endParen: true,
        params: ["pobj", "cobj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s43"),
        description: `**syntax**: \`&i/o-encoding\`
**procedure**: \`(make-i/o-encoding-error \`*pobj*\` \`*cobj*\`)\`
**returns: **a condition of type \`&i/o-encoding\`
**procedure**: \`(i/o-encoding-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-encoding\`, \`#f\` otherwise
**procedure**: \`(i/o-encoding-error-char \`*condition*\`)\`
**returns: **the contents of *condition*'s \`cobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A condition of this type indicates that an encoding error has occurred during the transcoding of characters to bytes. The *pobj* argument to the constructor should be the port involved, if any, and the *cobj* argument should be the character for which the encoding failed. This condition type might be defined as follows.

\`(define-condition-type &i/o-encoding &i/o-port\`
\`   make-i/o-encoding-error i/o-encoding-error?\`
\`   (cobj i/o-encoding-error-char))\`

The final two condition types describe conditions that occur when implementations are required to produce a NaN or infinity but have no representations for these values.
`
    },
    {
        name: "(make-i/o-error)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s32"),
        description: `**syntax**: \`&i/o\`
**procedure**: \`(make-i/o-error)\`
**returns: **a condition of type \`&i/o\`
**procedure**: \`(i/o-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of type \`&i/o\` indicates that an input/output error of some sort has occurred. Conditions of this type typically occur as one of the more specific subtypes described below. This condition type might be defined as follows.

\`(define-condition-type &i/o &error\`
\`   make-i/o-error i/o-error?)\`
`
    },
    {
        name: "(make-i/o-file-already-exists-error ",
        endParen: true,
        params: ["filename"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s39"),
        description: `**syntax**: \`&i/o-file-already-exists\`
**procedure**: \`(make-i/o-file-already-exists-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-already-exists\`
**procedure**: \`(i/o-file-already-exists-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-already-exists\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates a situation in which an operation on a file failed because the file already exists, e.g., an attempt is made to open an existing file for output without the \`no-fail\` file option. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-already-exists &i/o-filename\`
\`   make-i/o-file-already-exists-error\`
\`   i/o-file-already-exists-error?)\`
`
    },
    {
        name: "(make-i/o-file-does-not-exist-error ",
        endParen: true,
        params: ["filename"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s40"),
        description: `**syntax**: \`&i/o-file-does-not-exist\`
**procedure**: \`(make-i/o-file-does-not-exist-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-does-not-exist\`
**procedure**: \`(i/o-file-does-not-exist-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-does-not-exist\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates a situation in which an operation on a file failed because the file does not exist, e.g., an attempt is made to open a nonexistent file for input only. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-does-not-exist &i/o-filename\`
\`   make-i/o-file-does-not-exist-error\`
\`   i/o-file-does-not-exist-error?)\`
`
    },
    {
        name: "(make-i/o-file-is-read-only-error ",
        endParen: true,
        params: ["filename"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s38"),
        description: `**syntax**: \`&i/o-file-is-read-only\`
**procedure**: \`(make-i/o-file-is-read-only-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-is-read-only\`
**procedure**: \`(i/o-file-is-read-only-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-is-read-only\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates an attempt to treat as writeable a read-only file. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-is-read-only &i/o-file-protection\`
\`   make-i/o-file-is-read-only-error\`
\`   i/o-file-is-read-only-error?)\`
`
    },
    {
        name: "(make-i/o-file-protection-error ",
        endParen: true,
        params: ["filename"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s37"),
        description: `**syntax**: \`&i/o-file-protection\`
**procedure**: \`(make-i/o-file-protection-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-file-protection\`
**procedure**: \`(i/o-file-protection-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-file-protection\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type indicates that an attempt has been made to perform some input/output operation on a file for which the program does not have the proper permission. This condition type might be defined as follows.

\`(define-condition-type &i/o-file-protection &i/o-filename\`
\`   make-i/o-file-protection-error\`
\`   i/o-file-protection-error?)\`
`
    },
    {
        name: "(make-i/o-filename-error ",
        endParen: true,
        params: ["filename"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s36"),
        description: `**syntax**: \`&i/o-filename\`
**procedure**: \`(make-i/o-filename-error \`*filename*\`)\`
**returns: **a condition of type \`&i/o-filename\`
**procedure**: \`(i/o-filename-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-filename\`, \`#f\` otherwise
**procedure**: \`(i/o-error-filename \`*condition*\`)\`
**returns: **the contents of *condition*'s \`filename\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an input/output error that occurred while operating on a file. The *filename* argument to the constructor should be the name of the file. This condition type might be defined as follows.

\`(define-condition-type &i/o-filename &i/o\`
\`   make-i/o-filename-error i/o-filename-error?\`
\`   (filename i/o-error-filename))\`
`
    },
    {
        name: "(make-i/o-invalid-position-error ",
        endParen: true,
        params: ["position"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s35"),
        description: `**syntax**: \`&i/o-invalid-position\`
**procedure**: \`(make-i/o-invalid-position-error \`*position*\`)\`
**returns: **a condition of type \`&i/o-invalid-position\`
**procedure**: \`(i/o-invalid-position-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-invalid-position\`, \`#f\` otherwise
**procedure**: \`(i/o-error-position \`*condition*\`)\`
**returns: **the contents of *condition*'s \`position\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates an attempt to set a port's position to a position that is out of range for the underlying file or other object. The *position* argument to the constructor should be the invalid position. This condition type might be defined as follows.

\`(define-condition-type &i/o-invalid-position &i/o\`
\`   make-i/o-invalid-position-error\`
\`   i/o-invalid-position-error?\`
\`   (position i/o-error-position))\`
`
    },
    {
        name: "(make-i/o-port-error ",
        endParen: true,
        params: ["pobj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s41"),
        description: `**syntax**: \`&i/o-port\`
**procedure**: \`(make-i/o-port-error \`*pobj*\`)\`
**returns: **a condition of type \`&i/o-port\`
**procedure**: \`(i/o-port-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-port\`, \`#f\` otherwise
**procedure**: \`(i/o-error-port \`*condition*\`)\`
**returns: **the contents of *condition*'s \`pobj\` field
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

A condition of this type is usually included with a condition of one of the other \`&i/o\` subtypes to indicate the port involved in the exceptional situation, if a port is involved. The *pobj* argument to the constructor should be the port. This condition type might be defined as follows.

\`(define-condition-type &i/o-port &i/o\`
\`   make-i/o-port-error i/o-port-error?\`
\`   (pobj i/o-error-port))\`
`
    },
    {
        name: "(make-i/o-read-error)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s33"),
        description: `**syntax**: \`&i/o-read\`
**procedure**: \`(make-i/o-read-error)\`
**returns: **a condition of type \`&i/o-read\`
**procedure**: \`(i/o-read-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-read\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates that an error has occurred while reading from a port. This condition type might be defined as follows.

\`(define-condition-type &i/o-read &i/o\`
\`   make-i/o-read-error i/o-read-error?)\`
`
    },
    {
        name: "(make-i/o-write-error)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s34"),
        description: `**syntax**: \`&i/o-write\`
**procedure**: \`(make-i/o-write-error)\`
**returns: **a condition of type \`&i/o-write\`
**procedure**: \`(i/o-write-error? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&i/o-write\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs files)\`, \`(rnrs)\`

This condition type indicates that an error has occurred while writing to a port. This condition type might be defined as follows.

\`(define-condition-type &i/o-write &i/o\`
\`   make-i/o-write-error i/o-write-error?)\`
`
    },
    {
        name: "(make-implementation-restriction-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s28"),
        description: `**syntax**: \`&implementation-restriction\`
**procedure**: \`(make-implementation-restriction-violation)\`
**returns: **a condition of type \`&implementation-restriction\`
**procedure**: \`(implementation-restriction-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&implementation-restriction\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

An implementation-restriction condition indicates that the program has attempted to exceed some limitation in the implementation, such as when the value of a fixnum addition operation would result in a number that exceeds the implementation's fixnum range. It does not normally indicate a deficiency in the implementation but rather a mismatch between what the program is attempting to do and what the implementation can support. In many cases, implementation restrictions are dictated by the underlying hardware. This condition type might be defined as follows.

\`(define-condition-type &implementation-restriction &violation\`
\`   make-implementation-restriction-violation\`
\`   implementation-restriction-violation?)\`
`
    },
    {
        name: "(make-input-port ",
        endParen: true,
        params: ["handler", "input-buffer"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s13"),
        description: `**procedure**: \`(make-input-port \`*handler*\` \`*input-buffer*\`)\`
**procedure**: \`(make-output-port \`*handler*\` \`*output-buffer*\`)\`
**procedure**: \`(make-input/output-port \`*handler*\` \`*input-buffer*\` \`*output-buffer*\`)\`
**returns: **a new textual port
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(make-input/output-port ",
        endParen: true,
        params: ["handler", "input-buffer", "output-buffer"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s13"),
        description: `**procedure**: \`(make-input-port \`*handler*\` \`*input-buffer*\`)\`
**procedure**: \`(make-output-port \`*handler*\` \`*output-buffer*\`)\`
**procedure**: \`(make-input/output-port \`*handler*\` \`*input-buffer*\` \`*output-buffer*\`)\`
**returns: **a new textual port
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(make-irritants-condition ",
        endParen: true,
        params: ["irritants"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s25"),
        description: `**syntax**: \`&irritants\`
**procedure**: \`(make-irritants-condition \`*irritants*\`)\`
**returns: **a condition of type \`&irritants\`
**procedure**: \`(irritants-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&irritants\`, \`#f\` otherwise
**procedure**: \`(condition-irritants \`*condition*\`)\`
**returns: **the contents of *condition*'s \`irritants\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&message\` condition to provide information about Scheme values that may have caused or been materially involved in the exceptional situation. For example, if a procedure receives the wrong type of argument, it may raise an exception with a compound condition consisting of an assertion condition, a who condition naming the procedure, a message condition stating that the wrong type of argument was received, and an irritants condition listing the argument. The *irritants* argument to the constructor should be a list. This condition type might be defined as follows.

\`(define-condition-type &irritants &condition\`
\`   make-irritants-condition irritants-condition?\`
\`   (irritants condition-irritants))\`
`
    },
    {
        name: "(make-lexical-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s29"),
        description: `**syntax**: \`&lexical\`
**procedure**: \`(make-lexical-violation)\`
**returns: **a condition of type \`&lexical\`
**procedure**: \`(lexical-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&lexical\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a lexical error has occurred in the parsing of a Scheme program or datum, such as mismatched parentheses or an invalid character appearing within a numeric constant. This condition type might be defined as follows.

\`(define-condition-type &lexical &violation\`
\`   make-lexical-violation lexical-violation?)\`
`
    },
    {
        name: "(make-list ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s7"),
        description: `**procedure**: \`(make-list \`*n*\`)\`
**procedure**: \`(make-list \`*n*\` \`*obj*\`)\`
**returns: **a list of *n* *objs*
**libraries: **\`(chezscheme)\`

*n* must be a nonnegative integer. If *obj* is omitted, the elements of the list are unspecified.

\`(make-list 0 '()) \`=>\` ()\`
\` (make-list 3 0) \`=>\` (0 0 0)\`
\` (make-list 2 "hi") \`=>\` ("hi" "hi")\`
`
    },
    {
        name: "(make-list ",
        endParen: true,
        params: ["n", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s7"),
        description: `**procedure**: \`(make-list \`*n*\`)\`
**procedure**: \`(make-list \`*n*\` \`*obj*\`)\`
**returns: **a list of *n* *objs*
**libraries: **\`(chezscheme)\`

*n* must be a nonnegative integer. If *obj* is omitted, the elements of the list are unspecified.

\`(make-list 0 '()) \`=>\` ()\`
\` (make-list 3 0) \`=>\` (0 0 0)\`
\` (make-list 2 "hi") \`=>\` ("hi" "hi")\`
`
    },
    {
        name: "(make-message-condition ",
        endParen: true,
        params: ["message"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s24"),
        description: `**syntax**: \`&message\`
**procedure**: \`(make-message-condition \`*message*\`)\`
**returns: **a condition of type \`&message\`
**procedure**: \`(message-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&message\`, \`#f\` otherwise
**procedure**: \`(condition-message \`*condition*\`)\`
**returns: **the contents of *condition*'s \`message\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&warning\` condition or one of the \`&serious\` condition subtypes to provide a more specific description of the exceptional situation. The *message* argument to the constructor may be any Scheme value but is typically a string. This condition type might be defined as follows.

\`(define-condition-type &message &condition\`
\`   make-message-condition message-condition?\`
\`   (message condition-message))\`
`
    },
    {
        name: "(make-mutex)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s6"),
        description: `**procedure**: \`(make-mutex)\`
**procedure**: \`(make-mutex \`*name*\`)\`
**returns: **a new mutex object
**libraries: **\`(chezscheme)\`

*name*, if supplied, must be a symbol which identifies the mutex, or \`#f\` for no name. The name is printed every time the mutex is printed, which is useful for debugging.
`
    },
    {
        name: "(make-mutex ",
        endParen: true,
        params: ["name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s6"),
        description: `**procedure**: \`(make-mutex)\`
**procedure**: \`(make-mutex \`*name*\`)\`
**returns: **a new mutex object
**libraries: **\`(chezscheme)\`

*name*, if supplied, must be a symbol which identifies the mutex, or \`#f\` for no name. The name is printed every time the mutex is printed, which is useful for debugging.
`
    },
    {
        name: "(make-no-infinities-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s44"),
        description: `**syntax**: \`&no-infinities\`
**procedure**: \`(make-no-infinities-violation)\`
**returns: **a condition of type \`&no-infinities\`
**procedure**: \`(no-infinities-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&no-infinities\`, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

This condition indicates that the implementation has no representation for infinity. This condition type might be defined as follows.

\`(define-condition-type &no-infinities &implementation-restriction\`
\`   make-no-infinities-violation\`
\`   no-infinities-violation?)\`
`
    },
    {
        name: "(make-no-nans-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s45"),
        description: `**syntax**: \`&no-nans\`
**procedure**: \`(make-no-nans-violation)\`
**returns: **a condition of type \`&no-nans\`
**procedure**: \`(no-nans-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&no-nans\`, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

This condition indicates that the implementation has no representation for NaN. This condition type might be defined as follows.

\`(define-condition-type &no-nans &implementation-restriction\`
\`   make-no-nans-violation no-nans-violation?)\`

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(make-non-continuable-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s27"),
        description: `**syntax**: \`&non-continuable\`
**procedure**: \`(make-non-continuable-violation)\`
**returns: **a condition of type \`&non-continuable\`
**procedure**: \`(non-continuable-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&non-continuable\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a non-continuable violation has occurred. \`raise\` raises an exception with this type if the current exception handler returns. This condition type might be defined as follows.

\`(define-condition-type &non-continuable &violation\`
\`   make-non-continuable-violation\`
\`   non-continuable-violation?)\`
`
    },
    {
        name: "(make-object-finder ",
        endParen: true,
        params: ["pred"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s26"),
        description: `**procedure**: \`(make-object-finder \`*pred*\`)\`
**procedure**: \`(make-object-finder \`*pred*\` \`*g*\`)\`
**procedure**: \`(make-object-finder \`*pred*\` \`*x*\` \`*g*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

The procedure \`make-object-finder\` takes a predicate *pred* and two optional arguments: a starting point *x* and a maximum generation *g*. The starting point defaults to the value of the procedure \`oblist\`, and the maximum generation defaults to the value of the parameter \`collect-maximum-generation\`. \`make-object-finder\` returns an object finder *p* that can be used to search for objects satisfying *pred* within the starting-point object *x*. Immediate objects and objects in generations older than *g* are treated as leaves. *p* is a procedure accepting no arguments. If an object *y* satisfying *pred* can be found starting with *x*, *p* returns a list whose first element is *y* and whose remaining elements represent the path of objects from *x* to *y*, listed in reverse order. *p* can be invoked multiple times to find additional objects satisfying the predicate, if any. *p* returns \`#f\` if no more objects matching the predicate can be found.

*p* maintains internal state recording where it has been so it can restart at the point of the last found object and not return the same object twice. The state can be several times the size of the starting-point object *x* and all that is reachable from *x*.

The interactive inspector provides a convenient interface to the object finder in the form of \`find\` and \`find-next\` commands.
`
    },
    {
        name: "(make-object-finder ",
        endParen: true,
        params: ["pred", "g"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s26"),
        description: `**procedure**: \`(make-object-finder \`*pred*\`)\`
**procedure**: \`(make-object-finder \`*pred*\` \`*g*\`)\`
**procedure**: \`(make-object-finder \`*pred*\` \`*x*\` \`*g*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

The procedure \`make-object-finder\` takes a predicate *pred* and two optional arguments: a starting point *x* and a maximum generation *g*. The starting point defaults to the value of the procedure \`oblist\`, and the maximum generation defaults to the value of the parameter \`collect-maximum-generation\`. \`make-object-finder\` returns an object finder *p* that can be used to search for objects satisfying *pred* within the starting-point object *x*. Immediate objects and objects in generations older than *g* are treated as leaves. *p* is a procedure accepting no arguments. If an object *y* satisfying *pred* can be found starting with *x*, *p* returns a list whose first element is *y* and whose remaining elements represent the path of objects from *x* to *y*, listed in reverse order. *p* can be invoked multiple times to find additional objects satisfying the predicate, if any. *p* returns \`#f\` if no more objects matching the predicate can be found.

*p* maintains internal state recording where it has been so it can restart at the point of the last found object and not return the same object twice. The state can be several times the size of the starting-point object *x* and all that is reachable from *x*.

The interactive inspector provides a convenient interface to the object finder in the form of \`find\` and \`find-next\` commands.
`
    },
    {
        name: "(make-object-finder ",
        endParen: true,
        params: ["pred", "x", "g"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s26"),
        description: `**procedure**: \`(make-object-finder \`*pred*\`)\`
**procedure**: \`(make-object-finder \`*pred*\` \`*g*\`)\`
**procedure**: \`(make-object-finder \`*pred*\` \`*x*\` \`*g*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

The procedure \`make-object-finder\` takes a predicate *pred* and two optional arguments: a starting point *x* and a maximum generation *g*. The starting point defaults to the value of the procedure \`oblist\`, and the maximum generation defaults to the value of the parameter \`collect-maximum-generation\`. \`make-object-finder\` returns an object finder *p* that can be used to search for objects satisfying *pred* within the starting-point object *x*. Immediate objects and objects in generations older than *g* are treated as leaves. *p* is a procedure accepting no arguments. If an object *y* satisfying *pred* can be found starting with *x*, *p* returns a list whose first element is *y* and whose remaining elements represent the path of objects from *x* to *y*, listed in reverse order. *p* can be invoked multiple times to find additional objects satisfying the predicate, if any. *p* returns \`#f\` if no more objects matching the predicate can be found.

*p* maintains internal state recording where it has been so it can restart at the point of the last found object and not return the same object twice. The state can be several times the size of the starting-point object *x* and all that is reachable from *x*.

The interactive inspector provides a convenient interface to the object finder in the form of \`find\` and \`find-next\` commands.
`
    },
    {
        name: "(make-output-port ",
        endParen: true,
        params: ["handler", "output-buffer"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s13"),
        description: `**procedure**: \`(make-input-port \`*handler*\` \`*input-buffer*\`)\`
**procedure**: \`(make-output-port \`*handler*\` \`*output-buffer*\`)\`
**procedure**: \`(make-input/output-port \`*handler*\` \`*input-buffer*\` \`*output-buffer*\`)\`
**returns: **a new textual port
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(make-parameter ",
        endParen: true,
        params: ["object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s248"),
        description: `**procedure**: \`(make-parameter \`*object*\`)\`
**procedure**: \`(make-parameter \`*object*\` \`*procedure*\`)\`
**returns: **a parameter (procedure)
**libraries: **\`(chezscheme)\`

\`make-parameter\` accepts one or two arguments. The first argument is the initial value of the internal variable, and the second, if present, is a applied to the initial value and all subsequent values. The filter should accept one argument. If the value is not appropriate, the filter should raise an exception or convert the value into a more appropriate form.

For example, the default value of \`print-length\` is defined as follows:

\`(define print-length\`
\`   (make-parameter\`
\`     #f\`
\`     (lambda (x)\`
\`       (unless (or (not x) (and (fixnum? x) (fx>= x 0)))\`
\`         (assertion-violationf 'print-length\`
\`           "~s is not a positive fixnum or #f"\`
\`           x))\`
\`       x)))\`

\`(print-length)  \`=>\` #f\`
\` (print-length 3)\`
\` (print-length)  \`=>\` 3\`
\` (format "~s" '(1 2 3 4 5 6))  \`=>\` "(1 2 3 ...)"\`
\` (print-length #f)\`
\` (format "~s" '(1 2 3 4 5 6))  \`=>\` "(1 2 3 4 5 6)"\`
`
    },
    {
        name: "(make-parameter ",
        endParen: true,
        params: ["object", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s248"),
        description: `**procedure**: \`(make-parameter \`*object*\`)\`
**procedure**: \`(make-parameter \`*object*\` \`*procedure*\`)\`
**returns: **a parameter (procedure)
**libraries: **\`(chezscheme)\`

\`make-parameter\` accepts one or two arguments. The first argument is the initial value of the internal variable, and the second, if present, is a applied to the initial value and all subsequent values. The filter should accept one argument. If the value is not appropriate, the filter should raise an exception or convert the value into a more appropriate form.

For example, the default value of \`print-length\` is defined as follows:

\`(define print-length\`
\`   (make-parameter\`
\`     #f\`
\`     (lambda (x)\`
\`       (unless (or (not x) (and (fixnum? x) (fx>= x 0)))\`
\`         (assertion-violationf 'print-length\`
\`           "~s is not a positive fixnum or #f"\`
\`           x))\`
\`       x)))\`

\`(print-length)  \`=>\` #f\`
\` (print-length 3)\`
\` (print-length)  \`=>\` 3\`
\` (format "~s" '(1 2 3 4 5 6))  \`=>\` "(1 2 3 ...)"\`
\` (print-length #f)\`
\` (format "~s" '(1 2 3 4 5 6))  \`=>\` "(1 2 3 4 5 6)"\`
`
    },
    {
        name: "(make-polar ",
        endParen: true,
        params: ["real1", "real2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s123"),
        description: `**procedure**: \`(make-polar \`*real1*\` \`*real2*\`)\`
**returns: **a complex number with magnitude *real1* and angle *real2*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (make-polar 2 0) \`=>\` 2\`
\` (make-polar 2.0 0.0) \`=>\` 2.0+0.0i\`
\` (make-polar 1.0 (asin -1.0)) \`=>\` 0.0-1.0i\`
\` (eqv? (make-polar 7.2 -0.588) 7.2@-0.588) \`=>\` #t\`
`
    },
    {
        name: "(make-record-constructor-descriptor ",
        endParen: true,
        params: ["rtd", "parent-rcd", "protocol"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s24"),
        description: `**procedure**: \`(make-record-constructor-descriptor \`*rtd*\` \`*parent-rcd*\` \`*protocol*\`)\`
**returns: **a record-constructor descriptor (rcd)
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`
`
    },
    {
        name: "(make-record-type ",
        endParen: true,
        params: ["type-name", "fields"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s187"),
        description: `**procedure**: \`(make-record-type \`*type-name*\` \`*fields*\`)\`
**procedure**: \`(make-record-type \`*parent-rtd*\` \`*type-name*\` \`*fields*\`)\`
**returns: **a record-type descriptor for a new record type
**libraries: **\`(chezscheme)\`

\`make-record-type\` creates a new data type and returns a record-type descriptor, a value representing the new data type. The new type is disjoint from all others.

If present, *parent-rtd* must be a record-type descriptor.

*type-name* must be a string or gensym. If *type-name* is a string, a new record type is generated. If *type-name* is a gensym, a new record type is generated only if one with the same gensym has not already been defined. If one has already been defined, the parent and fields must be identical to those of the existing record type, and the existing record type is used. If the parent and fields are not identical, an exception is raised with condition-type \`&assertion\`.

*fields* must be a list of field descriptors, each of which describes one field of instances of the new record type. A field descriptor is either a symbol or a list in the following form:

\`(\`*class*\` \`*type*\` \`*field-name*\`)\`

where *class* and *type* are optional. *field-name* must be a symbol. *class*, if present, must be the symbol \`immutable\` or the symbol \`mutable\`. If the \`immutable\` class-specifier is present, the field is immutable; otherwise, the field is mutable. *type*, if present, specifies how the field is represented. The types are the same as those given in the description of \`define-record\` on page .

If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type \`ptr\`, meaning that it can contain any Scheme object.

The behavior of a program that modifies the string *type-name* or the list *fields* or any of its sublists is unspecified.

The record-type descriptor may be passed as an argument to any of the Revised Report procedures

or to the variants

to obtain procedures for creating and manipulating records of the new type.

\`(define marble\`
\`   (make-record-type "marble"\`
\`     '(color quality)\`
\`     (lambda (r p wr)\`
\`       (display "#<" p)\`
\`       (wr (marble-quality r) p)\`
\`       (display " quality " p)\`
\`       (wr (marble-color r) p)\`
\`       (display " marble>" p))))\`
\` (define make-marble\`
\`   (record-constructor marble))\`
\` (define marble?\`
\`   (record-predicate marble))\`
\` (define marble-color\`
\`   (record-field-accessor marble 'color))\`
\` (define marble-quality\`
\`   (record-field-accessor marble 'quality))\`
\` (define set-marble-quality!\`
\`   (record-field-mutator marble 'quality))\`
\` (define x (make-marble 'blue 'high))\`
\` (marble? x) \`=>\` #t\`
\` (marble-quality x) \`=>\` high\`
\` (set-marble-quality! x 'low)\`
\` (marble-quality x) \`=>\` low\`
\` x \`=>\` #<low quality blue marble>\`
`
    },
    {
        name: "(make-record-type ",
        endParen: true,
        params: ["parent-rtd", "type-name", "fields"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s187"),
        description: `**procedure**: \`(make-record-type \`*type-name*\` \`*fields*\`)\`
**procedure**: \`(make-record-type \`*parent-rtd*\` \`*type-name*\` \`*fields*\`)\`
**returns: **a record-type descriptor for a new record type
**libraries: **\`(chezscheme)\`

\`make-record-type\` creates a new data type and returns a record-type descriptor, a value representing the new data type. The new type is disjoint from all others.

If present, *parent-rtd* must be a record-type descriptor.

*type-name* must be a string or gensym. If *type-name* is a string, a new record type is generated. If *type-name* is a gensym, a new record type is generated only if one with the same gensym has not already been defined. If one has already been defined, the parent and fields must be identical to those of the existing record type, and the existing record type is used. If the parent and fields are not identical, an exception is raised with condition-type \`&assertion\`.

*fields* must be a list of field descriptors, each of which describes one field of instances of the new record type. A field descriptor is either a symbol or a list in the following form:

\`(\`*class*\` \`*type*\` \`*field-name*\`)\`

where *class* and *type* are optional. *field-name* must be a symbol. *class*, if present, must be the symbol \`immutable\` or the symbol \`mutable\`. If the \`immutable\` class-specifier is present, the field is immutable; otherwise, the field is mutable. *type*, if present, specifies how the field is represented. The types are the same as those given in the description of \`define-record\` on page .

If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type \`ptr\`, meaning that it can contain any Scheme object.

The behavior of a program that modifies the string *type-name* or the list *fields* or any of its sublists is unspecified.

The record-type descriptor may be passed as an argument to any of the Revised Report procedures

or to the variants

to obtain procedures for creating and manipulating records of the new type.

\`(define marble\`
\`   (make-record-type "marble"\`
\`     '(color quality)\`
\`     (lambda (r p wr)\`
\`       (display "#<" p)\`
\`       (wr (marble-quality r) p)\`
\`       (display " quality " p)\`
\`       (wr (marble-color r) p)\`
\`       (display " marble>" p))))\`
\` (define make-marble\`
\`   (record-constructor marble))\`
\` (define marble?\`
\`   (record-predicate marble))\`
\` (define marble-color\`
\`   (record-field-accessor marble 'color))\`
\` (define marble-quality\`
\`   (record-field-accessor marble 'quality))\`
\` (define set-marble-quality!\`
\`   (record-field-mutator marble 'quality))\`
\` (define x (make-marble 'blue 'high))\`
\` (marble? x) \`=>\` #t\`
\` (marble-quality x) \`=>\` high\`
\` (set-marble-quality! x 'low)\`
\` (marble-quality x) \`=>\` low\`
\` x \`=>\` #<low quality blue marble>\`
`
    },
    {
        name: "(make-record-type-descriptor ",
        endParen: true,
        params: ["name", "parent", "uid", "s?", "o?", "fields"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s20"),
        description: `**procedure**: \`(make-record-type-descriptor \`*name*\` \`*parent*\` \`*uid*\` \`*s?*\` \`*o?*\` \`*fields*\`)\`
**returns: **a record-type descriptor (rtd) for a new or existing record type
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`
`
    },
    {
        name: "(make-rectangular ",
        endParen: true,
        params: ["real1", "real2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s122"),
        description: `**procedure**: \`(make-rectangular \`*real1*\` \`*real2*\`)\`
**returns: **a complex number with real component *real1* and imaginary component *real2*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (make-rectangular -2 7) \`=>\` -2+7i\`
\` (make-rectangular 2/3 -1/2) \`=>\` 2/3-1/2i\`
\` (make-rectangular 3.2 5.3) \`=>\` 3.2+5.3i\`
`
    },
    {
        name: "(make-serious-condition)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s19"),
        description: `**syntax**: \`&serious\`
**procedure**: \`(make-serious-condition)\`
**returns: **a condition of type \`&serious\`
**procedure**: \`(serious-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&serious\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate situations of a serious nature that, if uncaught, generally result in termination of the program's execution. Conditions of this type typically occur as one of the more specific subtypes \`&error\` or \`&violation\`. This condition type might be defined as follows.

\`(define-condition-type &serious &condition\`
\`   make-serious-condition serious-condition?)\`
`
    },
    {
        name: "(make-source-condition ",
        endParen: true,
        params: ["form"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s5"),
        description: `**syntax**: \`&source\`
**procedure**: \`(make-source-condition \`*form*\`)\`
**returns: **a condition of type \`&source\`
**procedure**: \`(source-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&source\`, \`#f\` otherwise
**procedure**: \`(source-condition-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition when a source expression can be identified in situations in which a \`&syntax\` condition would be inappropriate, such as when a run-time assertion violation is detected. The \`form\` argument should be an s-expression or syntax object representing the source expression. This condition type might be defined as follows.

\`(define-condition-type &source &condition\`
\`   make-source-condition source-condition?\`
\`   (form source-condition-form))\`
`
    },
    {
        name: "(make-source-file-descriptor ",
        endParen: true,
        params: ["string", "binary-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s63"),
        description: `**procedure**: \`(make-source-file-descriptor \`*string*\` \`*binary-input-port*\`)\`
**procedure**: \`(make-source-file-descriptor \`*string*\` \`*binary-input-port*\` \`*reset?*\`)\`
**returns: **a source-file descriptor
**libraries: **\`(chezscheme)\`

To compute the checksum encapsulated in the source-file descriptor, this procedure must read all of the data from *binary-input-port*. If *reset?* is present and \`#t\`, the port is reset to its original position, as if via \`port-position\`. Otherwise, it is left pointing at end-of-file.
`
    },
    {
        name: "(make-source-file-descriptor ",
        endParen: true,
        params: ["string", "binary-input-port", "reset?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s63"),
        description: `**procedure**: \`(make-source-file-descriptor \`*string*\` \`*binary-input-port*\`)\`
**procedure**: \`(make-source-file-descriptor \`*string*\` \`*binary-input-port*\` \`*reset?*\`)\`
**returns: **a source-file descriptor
**libraries: **\`(chezscheme)\`

To compute the checksum encapsulated in the source-file descriptor, this procedure must read all of the data from *binary-input-port*. If *reset?* is present and \`#t\`, the port is reset to its original position, as if via \`port-position\`. Otherwise, it is left pointing at end-of-file.
`
    },
    {
        name: "(make-source-object ",
        endParen: true,
        params: ["sfd", "bfp", "efp"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s55"),
        description: `**procedure**: \`(make-source-object \`*sfd*\` \`*bfp*\` \`*efp*\`)\`
**procedure**: \`(make-source-object \`*sfd*\` \`*bfp*\` \`*efp*\` \`*line*\` \`*column*\`)\`
**returns: **a source object
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. *bfp* and *efp* must be exact nonnegative integers, and *bfp* should not be greater than *efp*. *line* and *column* must be exact positive integers.
`
    },
    {
        name: "(make-source-object ",
        endParen: true,
        params: ["sfd", "bfp", "efp", "line", "column"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s55"),
        description: `**procedure**: \`(make-source-object \`*sfd*\` \`*bfp*\` \`*efp*\`)\`
**procedure**: \`(make-source-object \`*sfd*\` \`*bfp*\` \`*efp*\` \`*line*\` \`*column*\`)\`
**returns: **a source object
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. *bfp* and *efp* must be exact nonnegative integers, and *bfp* should not be greater than *efp*. *line* and *column* must be exact positive integers.
`
    },
    {
        name: "(make-source-table)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s81"),
        description: `**procedure**: \`(make-source-table)\`
**returns: **a source table
**libraries: **\`(chezscheme)\`

A source table contains associations between source objects and arbitrary values. For purposes of the source-table operations described below, two source objects are the same if they have the same source-file descriptor, equal beginning file positions and equal ending file positions. Two source-file descriptors are the same if they have the same path and checksum.
`
    },
    {
        name: "(make-sstats ",
        endParen: true,
        params: ["cpu", "real", "bytes", "gc-count", "gc-cpu", "gc-real", "gc-bytes"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s231"),
        description: `**procedure**: \`(make-sstats \`*cpu*\` \`*real*\` \`*bytes*\` \`*gc-count*\` \`*gc-cpu*\` \`*gc-real*\` \`*gc-bytes*\`)\`
**returns: **a sstats record
**libraries: **\`(chezscheme)\`

The time arguments (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects. The other arguments must be exact integers.
`
    },
    {
        name: "(make-string ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s218"),
        description: `**procedure**: \`(make-string \`*n*\`)\`
**procedure**: \`(make-string \`*n*\` \`*char*\`)\`
**returns: **a string of length *n*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. If *char* is supplied, the string is filled with *n* occurrences of *char*, otherwise the characters contained in the string are unspecified.

\`(make-string 0) \`=>\` ""\`
\` (make-string 0 #\\x) \`=>\` ""\`
\` (make-string 5 #\\x) \`=>\` "xxxxx"\`
`
    },
    {
        name: "(make-string ",
        endParen: true,
        params: ["n", "char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s218"),
        description: `**procedure**: \`(make-string \`*n*\`)\`
**procedure**: \`(make-string \`*n*\` \`*char*\`)\`
**returns: **a string of length *n*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. If *char* is supplied, the string is filled with *n* occurrences of *char*, otherwise the characters contained in the string are unspecified.

\`(make-string 0) \`=>\` ""\`
\` (make-string 0 #\\x) \`=>\` ""\`
\` (make-string 5 #\\x) \`=>\` "xxxxx"\`
`
    },
    {
        name: "(make-syntax-violation ",
        endParen: true,
        params: ["form", "subform"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s30"),
        description: `**syntax**: \`&syntax\`
**procedure**: \`(make-syntax-violation \`*form*\` \`*subform*\`)\`
**returns: **a condition of type \`&syntax\`
**procedure**: \`(syntax-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&syntax\`, \`#f\` otherwise
**procedure**: \`(syntax-violation-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**procedure**: \`(syntax-violation-subform \`*condition*\`)\`
**returns: **the contents of *condition*'s \`subform\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the *form* and *subform* arguments to \`make-syntax-violation\` should be a syntax object (Section ) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter. If there is no need to identify a subform, *subform* should be \`#f\`. This condition type might be defined as follows.

\`(define-condition-type &syntax &violation\`
\`   make-syntax-violation syntax-violation?\`
\`   (form syntax-violation-form)\`
\`   (subform syntax-violation-subform))\`
`
    },
    {
        name: "(make-thread-parameter ",
        endParen: true,
        params: ["object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s30"),
        description: `**procedure**: \`(make-thread-parameter \`*object*\`)\`
**procedure**: \`(make-thread-parameter \`*object*\` \`*procedure*\`)\`
**returns: **a new thread parameter
**libraries: **\`(chezscheme)\`

See Section  for a general discussion of parameters and the use of the optional second argument.

When a thread parameter is created, a separate location is set aside in each current and future thread to hold the value of the parameter's internal state variable. (This location may be eliminated by the storage manager when the parameter becomes inaccessible.) Changes to the thread parameter in one thread are not seen by any other thread.

When a new thread is created (see \`fork-thread\`), the current value (not location) of each thread parameter is inherited from the forking thread by the new thread. Similarly, when a thread created by some other means is activated for the first time (see \`Sactivate_thread\` in Section ), the current value (not location) of each thread parameter is inherited from the main (original) thread by the new thread.

Most built-in parameters are thread parameters, but some are global. All are marked as global or thread where they are defined. There is no distinction between built-in global and thread parameters in the nonthreaded versions of the system.
`
    },
    {
        name: "(make-thread-parameter ",
        endParen: true,
        params: ["object", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s30"),
        description: `**procedure**: \`(make-thread-parameter \`*object*\`)\`
**procedure**: \`(make-thread-parameter \`*object*\` \`*procedure*\`)\`
**returns: **a new thread parameter
**libraries: **\`(chezscheme)\`

See Section  for a general discussion of parameters and the use of the optional second argument.

When a thread parameter is created, a separate location is set aside in each current and future thread to hold the value of the parameter's internal state variable. (This location may be eliminated by the storage manager when the parameter becomes inaccessible.) Changes to the thread parameter in one thread are not seen by any other thread.

When a new thread is created (see \`fork-thread\`), the current value (not location) of each thread parameter is inherited from the forking thread by the new thread. Similarly, when a thread created by some other means is activated for the first time (see \`Sactivate_thread\` in Section ), the current value (not location) of each thread parameter is inherited from the main (original) thread by the new thread.

Most built-in parameters are thread parameters, but some are global. All are marked as global or thread where they are defined. There is no distinction between built-in global and thread parameters in the nonthreaded versions of the system.
`
    },
    {
        name: "(make-time ",
        endParen: true,
        params: ["type", "nsec", "sec"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s203"),
        description: `**procedure**: \`(make-time \`*type*\` \`*nsec*\` \`*sec*\`)\`
**returns: **a time object
**libraries: **\`(chezscheme)\`

*type* must be one of the time-type symbols listed above. *nsec* represents nanoseconds and must be an exact nonnegative integer less than 10. *sec* represents seconds and must be an exact integer.

\`(make-time 'time-utc 787511000 1198783214)\`
\` (make-time 'time-duration 10 5)\`
\` (make-time 'time-duration 10 -5)\`
`
    },
    {
        name: "(make-transcoder ",
        endParen: true,
        params: ["codec"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s19"),
        description: `**procedure**: \`(make-transcoder \`*codec*\`)\`
**procedure**: \`(make-transcoder \`*codec*\` \`*eol-style*\`)\`
**procedure**: \`(make-transcoder \`*codec*\` \`*eol-style*\` \`*error-handling-mode*\`)\`
**returns: **a transcoder encapsulating *codec*, *eol-style*, and *error-handling-mode*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*eol-style* must be a valid eol-style symbol (\`lf\`, \`cr\`, \`nel\`, \`ls\`, \`crlf\`, \`crnel\`, or \`none\`); it defaults to the native eol-style for the platform. *error-handling-mode* must be a valid error-handling-mode symbol (\`ignore\`, \`raise\`, or \`replace\`) and defaults to \`replace\`.
`
    },
    {
        name: "(make-transcoder ",
        endParen: true,
        params: ["codec", "eol-style"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s19"),
        description: `**procedure**: \`(make-transcoder \`*codec*\`)\`
**procedure**: \`(make-transcoder \`*codec*\` \`*eol-style*\`)\`
**procedure**: \`(make-transcoder \`*codec*\` \`*eol-style*\` \`*error-handling-mode*\`)\`
**returns: **a transcoder encapsulating *codec*, *eol-style*, and *error-handling-mode*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*eol-style* must be a valid eol-style symbol (\`lf\`, \`cr\`, \`nel\`, \`ls\`, \`crlf\`, \`crnel\`, or \`none\`); it defaults to the native eol-style for the platform. *error-handling-mode* must be a valid error-handling-mode symbol (\`ignore\`, \`raise\`, or \`replace\`) and defaults to \`replace\`.
`
    },
    {
        name: "(make-transcoder ",
        endParen: true,
        params: ["codec", "eol-style", "error-handling-mode"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s19"),
        description: `**procedure**: \`(make-transcoder \`*codec*\`)\`
**procedure**: \`(make-transcoder \`*codec*\` \`*eol-style*\`)\`
**procedure**: \`(make-transcoder \`*codec*\` \`*eol-style*\` \`*error-handling-mode*\`)\`
**returns: **a transcoder encapsulating *codec*, *eol-style*, and *error-handling-mode*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*eol-style* must be a valid eol-style symbol (\`lf\`, \`cr\`, \`nel\`, \`ls\`, \`crlf\`, \`crnel\`, or \`none\`); it defaults to the native eol-style for the platform. *error-handling-mode* must be a valid error-handling-mode symbol (\`ignore\`, \`raise\`, or \`replace\`) and defaults to \`replace\`.
`
    },
    {
        name: "(make-undefined-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s31"),
        description: `**syntax**: \`&undefined\`
**procedure**: \`(make-undefined-violation)\`
**returns: **a condition of type \`&undefined\`
**procedure**: \`(undefined-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&undefined\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

An undefined condition indicates an attempt to reference an unbound variable. This condition type might be defined as follows.

\`(define-condition-type &undefined &violation\`
\`   make-undefined-violation undefined-violation?)\`

The next several condition types describe conditions that occur when input or output operations fail in some manner.
`
    },
    {
        name: "(make-variable-transformer ",
        endParen: true,
        params: ["procedure"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s42"),
        description: `**procedure**: \`(make-variable-transformer \`*procedure*\`)\`
**returns: **a variable transformer
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

As described in the lead-in to this section, transformers may simply be procedures that accept one argument, a syntax object representing the input form, and return a new syntax object representing the output form. The form passed to a transformer usually represents a parenthesized form whose first subform is the keyword bound to the transformer or just the keyword itself. \`make-variable-transformer\` may be used to convert a procedure into a special kind of transformer to which the expander also passes \`set!\` forms in which the keyword appears just after the \`set!\` keyword, as if it were a variable to be assigned. This allows the programmer to control what happens when the keyword appears in such contexts. The argument, *procedure*, should accept one argument.

\`(let ([ls (list 0)])\`
\`   (define-syntax a\`
\`     (make-variable-transformer\`
\`       (lambda (x)\`
\`         (syntax-case x ()\`
\`           [id (identifier? #'id) #'(car ls)]\`
\`           [(set! _ e) #'(set-car! ls e)]\`
\`           [(_ e ...) #'((car ls) e ...)]))))\`
\`   (let ([before a])\`
\`     (set! a 1)\`
\`     (list before a ls))) \`=>\` (0 1 (1))\`
`
    },
    {
        name: "(make-vector ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s232"),
        description: `**procedure**: \`(make-vector \`*n*\`)\`
**procedure**: \`(make-vector \`*n*\` \`*obj*\`)\`
**returns: **a vector of length *n*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. If *obj* is supplied, each element of the vector is filled with *obj*; otherwise, the elements are unspecified.

\`(make-vector 0) \`=>\` #()\`
\` (make-vector 0 '#(a)) \`=>\` #()\`
\` (make-vector 5 '#(a)) \`=>\` #(#(a) #(a) #(a) #(a) #(a))\`
`
    },
    {
        name: "(make-vector ",
        endParen: true,
        params: ["n", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s232"),
        description: `**procedure**: \`(make-vector \`*n*\`)\`
**procedure**: \`(make-vector \`*n*\` \`*obj*\`)\`
**returns: **a vector of length *n*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer. If *obj* is supplied, each element of the vector is filled with *obj*; otherwise, the elements are unspecified.

\`(make-vector 0) \`=>\` #()\`
\` (make-vector 0 '#(a)) \`=>\` #()\`
\` (make-vector 5 '#(a)) \`=>\` #(#(a) #(a) #(a) #(a) #(a))\`
`
    },
    {
        name: "(make-violation)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s20"),
        description: `**syntax**: \`&violation\`
**procedure**: \`(make-violation)\`
**returns: **a condition of type \`&violation\`
**procedure**: \`(violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&violation\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that the program has violated some requirement, usually due to a bug in the program. This condition type might be defined as follows.

\`(define-condition-type &violation &serious\`
\`   make-violation violation?)\`
`
    },
    {
        name: "(make-warning)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s23"),
        description: `**syntax**: \`&warning\`
**procedure**: \`(make-warning)\`
**returns: **a condition of type \`&warning\`
**procedure**: \`(warning? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&warning\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Warning conditions indicate situations that do not prevent the program from continuing its execution but, in some cases, might result in a more serious problem at some later point. For example, a compiler might use a condition of this type to indicate that it has processed a call to a standard procedure with the wrong number of arguments; this will not become a serious problem unless the call is actually evaluated at some later point. This condition type might be defined as follows.

\`(define-condition-type &warning &condition\`
\`   make-warning warning?)\`
`
    },
    {
        name: "(make-weak-eq-hashtable)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s121"),
        description: `**procedure**: \`(make-weak-eq-hashtable)\`
**procedure**: \`(make-weak-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-weak-eqv-hashtable)\`
**procedure**: \`(make-weak-eqv-hashtable \`*size*\`)\`
**returns: **a new weak eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like the Revised Report procedures \`make-eq-hashtable\` and \`make-eqv-hashtable\` except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.

Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See \`make-ephemeron-eq-hashtable\` and \`make-ephemeron-eqv-hashtable\`.

A copy of a weak eq or eqv hashtable created by \`hashtable-copy\` is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via \`hashtable-keys\` and \`hashtable-entries\`.

\`(define ht1 (make-weak-eq-hashtable))\`
\` (define ht2 (make-weak-eq-hashtable 32))\`
`
    },
    {
        name: "(make-weak-eq-hashtable ",
        endParen: true,
        params: ["size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s121"),
        description: `**procedure**: \`(make-weak-eq-hashtable)\`
**procedure**: \`(make-weak-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-weak-eqv-hashtable)\`
**procedure**: \`(make-weak-eqv-hashtable \`*size*\`)\`
**returns: **a new weak eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like the Revised Report procedures \`make-eq-hashtable\` and \`make-eqv-hashtable\` except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.

Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See \`make-ephemeron-eq-hashtable\` and \`make-ephemeron-eqv-hashtable\`.

A copy of a weak eq or eqv hashtable created by \`hashtable-copy\` is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via \`hashtable-keys\` and \`hashtable-entries\`.

\`(define ht1 (make-weak-eq-hashtable))\`
\` (define ht2 (make-weak-eq-hashtable 32))\`
`
    },
    {
        name: "(make-weak-eqv-hashtable)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s121"),
        description: `**procedure**: \`(make-weak-eq-hashtable)\`
**procedure**: \`(make-weak-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-weak-eqv-hashtable)\`
**procedure**: \`(make-weak-eqv-hashtable \`*size*\`)\`
**returns: **a new weak eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like the Revised Report procedures \`make-eq-hashtable\` and \`make-eqv-hashtable\` except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.

Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See \`make-ephemeron-eq-hashtable\` and \`make-ephemeron-eqv-hashtable\`.

A copy of a weak eq or eqv hashtable created by \`hashtable-copy\` is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via \`hashtable-keys\` and \`hashtable-entries\`.

\`(define ht1 (make-weak-eq-hashtable))\`
\` (define ht2 (make-weak-eq-hashtable 32))\`
`
    },
    {
        name: "(make-weak-eqv-hashtable ",
        endParen: true,
        params: ["size"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s121"),
        description: `**procedure**: \`(make-weak-eq-hashtable)\`
**procedure**: \`(make-weak-eq-hashtable \`*size*\`)\`
**procedure**: \`(make-weak-eqv-hashtable)\`
**procedure**: \`(make-weak-eqv-hashtable \`*size*\`)\`
**returns: **a new weak eq hashtable
**libraries: **\`(chezscheme)\`

These procedures are like the Revised Report procedures \`make-eq-hashtable\` and \`make-eqv-hashtable\` except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.

Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See \`make-ephemeron-eq-hashtable\` and \`make-ephemeron-eqv-hashtable\`.

A copy of a weak eq or eqv hashtable created by \`hashtable-copy\` is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via \`hashtable-keys\` and \`hashtable-entries\`.

\`(define ht1 (make-weak-eq-hashtable))\`
\` (define ht2 (make-weak-eq-hashtable 32))\`
`
    },
    {
        name: "(make-who-condition ",
        endParen: true,
        params: ["who"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s26"),
        description: `**syntax**: \`&who\`
**procedure**: \`(make-who-condition \`*who*\`)\`
**returns: **a condition of type \`&who\`
**procedure**: \`(who-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&who\`, \`#f\` otherwise
**procedure**: \`(condition-who \`*condition*\`)\`
**returns: **the contents of *condition*'s \`who\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are often included with a \`&message\` condition to identify the syntactic form or procedure that detected the error. The *who* argument to the constructor should be a symbol or string. This condition type might be defined as follows.

\`(define-condition-type &who &condition\`
\`   make-who-condition who-condition?\`
\`   (who condition-who))\`
`
    },
    {
        name: "(map ",
        endParen: true,
        params: ["procedure", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s30"),
        description: `**procedure**: \`(map \`*procedure*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **list of results
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(mark-port-closed! ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s24"),
        description: `**procedure**: \`(mark-port-closed! \`*port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure directly marks the port closed so that no further input or output operations are allowed on it. It is typically used by handlers upon receipt of a \`close-port\` message.
`
    },
    {
        name: "(max ",
        endParen: true,
        params: ["real1", "real2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s107"),
        description: `**procedure**: \`(max \`*real1*\` \`*real2*\` ...)\`
**returns: **the maximum of *real1*\` \`*real2*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (max 4 -7 2 0 -6) \`=>\` 4\`
\` (max 1/2 3/4 4/5 5/6 6/7) \`=>\` 6/7\`
\` (max 1.5 1.3 -0.3 0.4 2.0 1.8) \`=>\` 2.0\`
\` (max 5 2.0) \`=>\` 5.0\`
\` (max -5 -2.0) \`=>\` -2.0\`
\` (let ([ls '(7 3 5 2 9 8)])\`
\`   (apply max ls)) \`=>\` 9\`
`
    },
    {
        name: "(maximum-memory-bytes)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s227"),
        description: `**procedure**: \`(maximum-memory-bytes)\`
**returns: **the maximum number of bytes ever allocated, including overhead
**libraries: **\`(chezscheme)\`

\`maximum-memory-bytes\` returns the maximum size of the heap in bytes, i.e., the maximum value that \`current-memory-bytes\` returned or could have returned, since the last call to \`reset-maximum-memory-bytes!\` or, if there has been no such call, since the process started.
`
    },
    {
        name: "(maybe-compile-file ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s71"),
        description: `**procedure**: \`(maybe-compile-file \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-file \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures are like their non-\`maybe\` counterparts but compile the source file only if the object file is out-of-date. An object file *X* is considered out-of-date if it does not exist or if it is older than the source file or any files included (via \`include\`) when *X* was created. When the value of the parameter \`compile-imported-libraries\` is \`#t\`, *X* is also considered out-of-date if the object file for any library imported when *X* was compiled is out-of-date. If \`maybe-compile-file\` determines that compilation is necessary, it compiles the source file by passing \`compile-file\` the input and output filenames. \`compile-library\` does so by similarly invoking the value of the \`compile-library-handler\` parameter, and \`compile-program\` does so by similarly invoking the value of the \`compile-program-handler\` parameter.

When *output-filename* is not specified, the input and output filenames are determined in the same manner as for \`compile-file\`.
`
    },
    {
        name: "(maybe-compile-file ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s71"),
        description: `**procedure**: \`(maybe-compile-file \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-file \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures are like their non-\`maybe\` counterparts but compile the source file only if the object file is out-of-date. An object file *X* is considered out-of-date if it does not exist or if it is older than the source file or any files included (via \`include\`) when *X* was created. When the value of the parameter \`compile-imported-libraries\` is \`#t\`, *X* is also considered out-of-date if the object file for any library imported when *X* was compiled is out-of-date. If \`maybe-compile-file\` determines that compilation is necessary, it compiles the source file by passing \`compile-file\` the input and output filenames. \`compile-library\` does so by similarly invoking the value of the \`compile-library-handler\` parameter, and \`compile-program\` does so by similarly invoking the value of the \`compile-program-handler\` parameter.

When *output-filename* is not specified, the input and output filenames are determined in the same manner as for \`compile-file\`.
`
    },
    {
        name: "(maybe-compile-library ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s71"),
        description: `**procedure**: \`(maybe-compile-file \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-file \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures are like their non-\`maybe\` counterparts but compile the source file only if the object file is out-of-date. An object file *X* is considered out-of-date if it does not exist or if it is older than the source file or any files included (via \`include\`) when *X* was created. When the value of the parameter \`compile-imported-libraries\` is \`#t\`, *X* is also considered out-of-date if the object file for any library imported when *X* was compiled is out-of-date. If \`maybe-compile-file\` determines that compilation is necessary, it compiles the source file by passing \`compile-file\` the input and output filenames. \`compile-library\` does so by similarly invoking the value of the \`compile-library-handler\` parameter, and \`compile-program\` does so by similarly invoking the value of the \`compile-program-handler\` parameter.

When *output-filename* is not specified, the input and output filenames are determined in the same manner as for \`compile-file\`.
`
    },
    {
        name: "(maybe-compile-library ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s71"),
        description: `**procedure**: \`(maybe-compile-file \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-file \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures are like their non-\`maybe\` counterparts but compile the source file only if the object file is out-of-date. An object file *X* is considered out-of-date if it does not exist or if it is older than the source file or any files included (via \`include\`) when *X* was created. When the value of the parameter \`compile-imported-libraries\` is \`#t\`, *X* is also considered out-of-date if the object file for any library imported when *X* was compiled is out-of-date. If \`maybe-compile-file\` determines that compilation is necessary, it compiles the source file by passing \`compile-file\` the input and output filenames. \`compile-library\` does so by similarly invoking the value of the \`compile-library-handler\` parameter, and \`compile-program\` does so by similarly invoking the value of the \`compile-program-handler\` parameter.

When *output-filename* is not specified, the input and output filenames are determined in the same manner as for \`compile-file\`.
`
    },
    {
        name: "(maybe-compile-program ",
        endParen: true,
        params: ["input-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s71"),
        description: `**procedure**: \`(maybe-compile-file \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-file \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures are like their non-\`maybe\` counterparts but compile the source file only if the object file is out-of-date. An object file *X* is considered out-of-date if it does not exist or if it is older than the source file or any files included (via \`include\`) when *X* was created. When the value of the parameter \`compile-imported-libraries\` is \`#t\`, *X* is also considered out-of-date if the object file for any library imported when *X* was compiled is out-of-date. If \`maybe-compile-file\` determines that compilation is necessary, it compiles the source file by passing \`compile-file\` the input and output filenames. \`compile-library\` does so by similarly invoking the value of the \`compile-library-handler\` parameter, and \`compile-program\` does so by similarly invoking the value of the \`compile-program-handler\` parameter.

When *output-filename* is not specified, the input and output filenames are determined in the same manner as for \`compile-file\`.
`
    },
    {
        name: "(maybe-compile-program ",
        endParen: true,
        params: ["input-filename", "output-filename"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s71"),
        description: `**procedure**: \`(maybe-compile-file \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-file \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-library \`*input-filename*\` \`*output-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\`)\`
**procedure**: \`(maybe-compile-program \`*input-filename*\` \`*output-filename*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures are like their non-\`maybe\` counterparts but compile the source file only if the object file is out-of-date. An object file *X* is considered out-of-date if it does not exist or if it is older than the source file or any files included (via \`include\`) when *X* was created. When the value of the parameter \`compile-imported-libraries\` is \`#t\`, *X* is also considered out-of-date if the object file for any library imported when *X* was compiled is out-of-date. If \`maybe-compile-file\` determines that compilation is necessary, it compiles the source file by passing \`compile-file\` the input and output filenames. \`compile-library\` does so by similarly invoking the value of the \`compile-library-handler\` parameter, and \`compile-program\` does so by similarly invoking the value of the \`compile-program-handler\` parameter.

When *output-filename* is not specified, the input and output filenames are determined in the same manner as for \`compile-file\`.
`
    },
    {
        name: "(member ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s51"),
        description: `**procedure**: \`(memq \`*obj*\` \`*list*\`)\`
**procedure**: \`(memv \`*obj*\` \`*list*\`)\`
**procedure**: \`(member \`*obj*\` \`*list*\`)\`
**returns: **the first tail of *list* whose car is equivalent to *obj*, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

These procedures traverse the argument *list* in order, comparing the elements of *list* against *obj*. If an object equivalent to *obj* is found, the tail of the list whose first element is that object is returned. If the list contains more than one object equivalent to *obj*, the first tail whose first element is equivalent to *obj* is returned. If no object equivalent to *obj* is found, \`#f\` is returned. The equivalence test for \`memq\` is \`eq?\`, for \`memv\` is \`eqv?\`, and for \`member\` is \`equal?\`.

These procedures are most often used as predicates, but their names do not end with a question mark because they return a useful true value in place of \`#t\`. \`memq\` may be defined without error checks as follows.

\`(define memq\`
\`   (lambda (x ls)\`
\`     (cond\`
\`       [(null? ls) #f]\`
\`       [(eq? (car ls) x) ls]\`
\`       [else (memq x (cdr ls))])))\`

\`memv\` and \`member\` may be defined similarly, with \`eqv?\` and \`equal?\` in place of \`eq?\`.

\`(memq 'a '(b c a d e)) \`=>\` (a d e)\`
\` (memq 'a '(b c d e g)) \`=>\` #f\`
\` (memq 'a '(b a c a d a)) \`=>\` (a c a d a) \`
\` \`
\` (memv 3.4 '(1.2 2.3 3.4 4.5)) \`=>\` (3.4 4.5)\`
\` (memv 3.4 '(1.3 2.5 3.7 4.9)) \`=>\` #f\`
\` (let ([ls (list 'a 'b 'c)])\`
\`   (set-car! (memv 'b ls) 'z)\`
\`   ls) \`=>\` (a z c) \`
\` \`
\` (member '(b) '((a) (b) (c))) \`=>\` ((b) (c))\`
\` (member '(d) '((a) (b) (c))) \`=>\` #f\`
\` (member "b" '("a" "b" "c")) \`=>\` ("b" "c") \`
\` \`
\` (let ()\`
\`   (define member?\`
\`     (lambda (x ls)\`
\`       (and (member x ls) #t)))\`
\`   (member? '(b) '((a) (b) (c)))) \`=>\` #t \`
\` \`
\` (define count-occurrences\`
\`   (lambda (x ls)\`
\`     (cond\`
\`       [(memq x ls) =>\`
\`        (lambda (ls)\`
\`          (+ (count-occurrences x (cdr ls)) 1))]\`
\`       [else 0]))) \`
\` \`
\` (count-occurrences 'a '(a b c d a)) \`=>\` 2\`
`
    },
    {
        name: "(memp ",
        endParen: true,
        params: ["procedure", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s52"),
        description: `**procedure**: \`(memp \`*procedure*\` \`*list*\`)\`
**returns: **the first tail of *list* for whose car *procedure* returns true, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

*procedure* should accept one argument and return a single value. It should not modify *list*.

\`(memp odd? '(1 2 3 4)) \`=>\` (1 2 3 4)\`
\` (memp even? '(1 2 3 4)) \`=>\` (2 3 4)\`
\` (let ([ls (list 1 2 3 4)])\`
\`   (eq? (memp odd? ls) ls)) \`=>\` #t\`
\` (let ([ls (list 1 2 3 4)])\`
\`   (eq? (memp even? ls) (cdr ls))) \`=>\` #t\`
\` (memp odd? '(2 4 6 8)) \`=>\` #f\`
`
    },
    {
        name: "(memq ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s51"),
        description: `**procedure**: \`(memq \`*obj*\` \`*list*\`)\`
**procedure**: \`(memv \`*obj*\` \`*list*\`)\`
**procedure**: \`(member \`*obj*\` \`*list*\`)\`
**returns: **the first tail of *list* whose car is equivalent to *obj*, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

These procedures traverse the argument *list* in order, comparing the elements of *list* against *obj*. If an object equivalent to *obj* is found, the tail of the list whose first element is that object is returned. If the list contains more than one object equivalent to *obj*, the first tail whose first element is equivalent to *obj* is returned. If no object equivalent to *obj* is found, \`#f\` is returned. The equivalence test for \`memq\` is \`eq?\`, for \`memv\` is \`eqv?\`, and for \`member\` is \`equal?\`.

These procedures are most often used as predicates, but their names do not end with a question mark because they return a useful true value in place of \`#t\`. \`memq\` may be defined without error checks as follows.

\`(define memq\`
\`   (lambda (x ls)\`
\`     (cond\`
\`       [(null? ls) #f]\`
\`       [(eq? (car ls) x) ls]\`
\`       [else (memq x (cdr ls))])))\`

\`memv\` and \`member\` may be defined similarly, with \`eqv?\` and \`equal?\` in place of \`eq?\`.

\`(memq 'a '(b c a d e)) \`=>\` (a d e)\`
\` (memq 'a '(b c d e g)) \`=>\` #f\`
\` (memq 'a '(b a c a d a)) \`=>\` (a c a d a) \`
\` \`
\` (memv 3.4 '(1.2 2.3 3.4 4.5)) \`=>\` (3.4 4.5)\`
\` (memv 3.4 '(1.3 2.5 3.7 4.9)) \`=>\` #f\`
\` (let ([ls (list 'a 'b 'c)])\`
\`   (set-car! (memv 'b ls) 'z)\`
\`   ls) \`=>\` (a z c) \`
\` \`
\` (member '(b) '((a) (b) (c))) \`=>\` ((b) (c))\`
\` (member '(d) '((a) (b) (c))) \`=>\` #f\`
\` (member "b" '("a" "b" "c")) \`=>\` ("b" "c") \`
\` \`
\` (let ()\`
\`   (define member?\`
\`     (lambda (x ls)\`
\`       (and (member x ls) #t)))\`
\`   (member? '(b) '((a) (b) (c)))) \`=>\` #t \`
\` \`
\` (define count-occurrences\`
\`   (lambda (x ls)\`
\`     (cond\`
\`       [(memq x ls) =>\`
\`        (lambda (ls)\`
\`          (+ (count-occurrences x (cdr ls)) 1))]\`
\`       [else 0]))) \`
\` \`
\` (count-occurrences 'a '(a b c d a)) \`=>\` 2\`
`
    },
    {
        name: "(memv ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s51"),
        description: `**procedure**: \`(memq \`*obj*\` \`*list*\`)\`
**procedure**: \`(memv \`*obj*\` \`*list*\`)\`
**procedure**: \`(member \`*obj*\` \`*list*\`)\`
**returns: **the first tail of *list* whose car is equivalent to *obj*, or \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

These procedures traverse the argument *list* in order, comparing the elements of *list* against *obj*. If an object equivalent to *obj* is found, the tail of the list whose first element is that object is returned. If the list contains more than one object equivalent to *obj*, the first tail whose first element is equivalent to *obj* is returned. If no object equivalent to *obj* is found, \`#f\` is returned. The equivalence test for \`memq\` is \`eq?\`, for \`memv\` is \`eqv?\`, and for \`member\` is \`equal?\`.

These procedures are most often used as predicates, but their names do not end with a question mark because they return a useful true value in place of \`#t\`. \`memq\` may be defined without error checks as follows.

\`(define memq\`
\`   (lambda (x ls)\`
\`     (cond\`
\`       [(null? ls) #f]\`
\`       [(eq? (car ls) x) ls]\`
\`       [else (memq x (cdr ls))])))\`

\`memv\` and \`member\` may be defined similarly, with \`eqv?\` and \`equal?\` in place of \`eq?\`.

\`(memq 'a '(b c a d e)) \`=>\` (a d e)\`
\` (memq 'a '(b c d e g)) \`=>\` #f\`
\` (memq 'a '(b a c a d a)) \`=>\` (a c a d a) \`
\` \`
\` (memv 3.4 '(1.2 2.3 3.4 4.5)) \`=>\` (3.4 4.5)\`
\` (memv 3.4 '(1.3 2.5 3.7 4.9)) \`=>\` #f\`
\` (let ([ls (list 'a 'b 'c)])\`
\`   (set-car! (memv 'b ls) 'z)\`
\`   ls) \`=>\` (a z c) \`
\` \`
\` (member '(b) '((a) (b) (c))) \`=>\` ((b) (c))\`
\` (member '(d) '((a) (b) (c))) \`=>\` #f\`
\` (member "b" '("a" "b" "c")) \`=>\` ("b" "c") \`
\` \`
\` (let ()\`
\`   (define member?\`
\`     (lambda (x ls)\`
\`       (and (member x ls) #t)))\`
\`   (member? '(b) '((a) (b) (c)))) \`=>\` #t \`
\` \`
\` (define count-occurrences\`
\`   (lambda (x ls)\`
\`     (cond\`
\`       [(memq x ls) =>\`
\`        (lambda (ls)\`
\`          (+ (count-occurrences x (cdr ls)) 1))]\`
\`       [else 0]))) \`
\` \`
\` (count-occurrences 'a '(a b c d a)) \`=>\` 2\`
`
    },
    {
        name: "(merge ",
        endParen: true,
        params: ["predicate", "list1", "list2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s115"),
        description: `**procedure**: \`(merge \`*predicate*\` \`*list1*\` \`*list2*\`)\`
**procedure**: \`(merge! \`*predicate*\` \`*list1*\` \`*list2*\`)\`
**returns: ***list1* merged with *list2* in the order specified by *predicate*
**libraries: **\`(chezscheme)\`

*predicate* should be a procedure that expects two arguments and returns \`#t\` if its first argument must precede its second in the merged list. It should not have any side effects. That is, if *predicate* is applied to two objects *x* and *y*, where *x* is taken from the second list and *y* is taken from the first list, it should return true only if *x* should appear before *y* in the output list. If this constraint is met, \`merge\` and \`merge!\` are stable, in that items from *list1* are placed in front of equivalent items from *list2* in the output list. Duplicate elements are included in the merged list.

\`merge!\` combines the lists destructively, using pairs from the input lists to form the output list.

\`(merge char<?\`
\`        '(#\\a #\\c)\`
\`        '(#\\b #\\c #\\d)) \`=>\` (#\\a #\\b #\\c #\\c #\\d)\`
\` (merge <\`
\`        '(1/2 2/3 3/4)\`
\`        '(0.5 0.6 0.7)) \`=>\` (1/2 0.5 0.6 2/3 0.7 3/4)\`
`
    },
    {
        name: "(merge! ",
        endParen: true,
        params: ["predicate", "list1", "list2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s115"),
        description: `**procedure**: \`(merge \`*predicate*\` \`*list1*\` \`*list2*\`)\`
**procedure**: \`(merge! \`*predicate*\` \`*list1*\` \`*list2*\`)\`
**returns: ***list1* merged with *list2* in the order specified by *predicate*
**libraries: **\`(chezscheme)\`

*predicate* should be a procedure that expects two arguments and returns \`#t\` if its first argument must precede its second in the merged list. It should not have any side effects. That is, if *predicate* is applied to two objects *x* and *y*, where *x* is taken from the second list and *y* is taken from the first list, it should return true only if *x* should appear before *y* in the output list. If this constraint is met, \`merge\` and \`merge!\` are stable, in that items from *list1* are placed in front of equivalent items from *list2* in the output list. Duplicate elements are included in the merged list.

\`merge!\` combines the lists destructively, using pairs from the input lists to form the output list.

\`(merge char<?\`
\`        '(#\\a #\\c)\`
\`        '(#\\b #\\c #\\d)) \`=>\` (#\\a #\\b #\\c #\\c #\\d)\`
\` (merge <\`
\`        '(1/2 2/3 3/4)\`
\`        '(0.5 0.6 0.7)) \`=>\` (1/2 0.5 0.6 2/3 0.7 3/4)\`
`
    },
    {
        name: "(message-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s24"),
        description: `**syntax**: \`&message\`
**procedure**: \`(make-message-condition \`*message*\`)\`
**returns: **a condition of type \`&message\`
**procedure**: \`(message-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&message\`, \`#f\` otherwise
**procedure**: \`(condition-message \`*condition*\`)\`
**returns: **the contents of *condition*'s \`message\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are usually included with a \`&warning\` condition or one of the \`&serious\` condition subtypes to provide a more specific description of the exceptional situation. The *message* argument to the constructor may be any Scheme value but is typically a string. This condition type might be defined as follows.

\`(define-condition-type &message &condition\`
\`   make-message-condition message-condition?\`
\`   (message condition-message))\`
`
    },
    {
        name: "(meta . ",
        endParen: true,
        params: ["definition"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s36"),
        description: `**syntax**: \`(meta . \`*definition*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The \`meta\` keyword is actually a prefix that can be placed in front of any definition keyword, e.g.,

\`(meta define x 3)\`

It tells the expander that any variable definition resulting from the definition is to be an expand-time definition available only to the right-hand sides of other meta definitions and, most importantly, transformer expressions. It is used to define expand-time helpers and other information for use by one or more \`syntax-case\` transformers.

\`(module M (helper1 a b)\`
\`   (meta define helper1\`
\`     (lambda (---)\`
\`       ---))\`
\`   (meta define helper2\`
\`     (lambda (---)\`
\`       --- (helper2 ---) ---))\`
\`   (define-syntax a\`
\`     (lambda (x)\`
\`       --- (helper1 ---) ---))\`
\`   (define-syntax b\`
\`     (lambda (x)\`
\`       --- (helper1 ---) ---\`
\`       --- (helper2 ---) ---)))\`

The right-hand-side expressions of a syntax definition or meta definition can refer only to identifiers whose values are already available in the compile-time environment. Because of the left-to-right expansion order for \`library\`, \`module\`, \`lambda\`, and similar bodies, this implies a semantics similar to \`let*\` for a sequence of meta definitions, in which each right-hand side can refer only to the variables defined earlier in the sequence. An exception is that the right-hand side of a meta definition can refer to its own name as long as the reference is not evaluated until after the value of the expression has been computed. This permits meta definitions to be self-recursive but not mutually recursive. The right-hand side of a meta definition can, however, build syntax objects containing occurrences of any identifiers defined in the body in which the meta definition appears.

Meta definitions propagate through macro expansion, so one can write, for example:

\`(module (a)\`
\`   (meta define-record foo (x))\`
\`   (define-syntax a\`
\`     (let ([q (make-foo #''q)])\`
\`       (lambda (x) (foo-x q)))))\`
\` a \`=>\` q\`

where define-record is a macro that expands into a set of defines.

It is also sometimes convenient to write

\`(meta begin defn ...)\`

or

\`(meta module {exports} defn ...)\`

or

\`(meta include "\`*path*\`")\`

to create groups of meta bindings.
`
    },
    {
        name: "(meta-cond ",
        endParen: true,
        params: ["clause1", "clause2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s37"),
        description: `**syntax**: \`(meta-cond \`*clause1*\` \`*clause2*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

Each *clause* but the last must take the form:

\`(\`*test*\` \`*expr1*\` \`*expr2*\` ...)\`

The last may take the same form or be an \`else\` clause of the form:

\`(\`*else*\` \`*expr1*\` \`*expr2*\` ...)\`

During expansion, the *test* expressions are evaluated in order until one evaluates to a true value or until all of the tests have been evaluated. If a *test* evaluates to a true value, the \`meta-cond\` form expands to a \`begin\` form containing the corresponding expressions *expr1*\` \`*expr2*\` ...\`. If no *test* evaluates to a true value and an \`else\` clause is present, the \`meta-cond\` form expands to a \`begin\` form containing the expressions *expr1*\` \`*expr2*\` ...\` from the \`else\` clause. Otherwise the \`meta-cond\` expression expands into a call to the \`void\` procedure.

\`meta-cond\` might be defined as follows.

\`(define-syntax meta-cond\`
\`   (syntax-rules ()\`
\`     [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...)\`
\`      (let-syntax ([expr (cond\`
\`                           [a0 (identifier-syntax (begin a1 a2 ...))]\`
\`                           [b0 (identifier-syntax (begin b1 b2 ...))]\`
\`                           ...)])\`
\`        expr)]))\`

\`meta-cond\` is used to choose, at expansion time, from among a set of possible forms. For example, one might have safe (error-checking) and unsafe (non-error-checking) versions of a procedure and decide which to call based on the compile-time optimization level, as shown below.

\`(meta-cond\`
\`   [(= (optimize-level) 3) (unsafe-frob x)]\`
\`   [else (safe-frob x)])\`
`
    },
    {
        name: "(min ",
        endParen: true,
        params: ["real1", "real2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s108"),
        description: `**procedure**: \`(min \`*real1*\` \`*real2*\` ...)\`
**returns: **the minimum of *real1*\` \`*real2*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (min 4 -7 2 0 -6) \`=>\` -7\`
\` (min 1/2 3/4 4/5 5/6 6/7) \`=>\` 1/2\`
\` (min 1.5 1.3 -0.3 0.4 2.0 1.8) \`=>\` -0.3\`
\` (min 5 2.0) \`=>\` 2.0\`
\` (min -5 -2.0) \`=>\` -5.0\`
\` (let ([ls '(7 3 5 2 9 8)])\`
\`   (apply min ls)) \`=>\` 2\`
`
    },
    {
        name: "(mkdir ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s146"),
        description: `**procedure**: \`(mkdir \`*path*\`)\`
**procedure**: \`(mkdir \`*path*\` \`*mode*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. *mode* must be a fixnum.

\`mkdir\` creates a directory with the name given by *path*. All *path* path components leading up to the last must already exist. If the optional *mode* argument is present, it overrides the default permissions for the new directory. Under Windows, the *mode* argument is ignored.

\`mkdir\` raises an exception with condition type \`&i/o-filename\` if the directory cannot be created.
`
    },
    {
        name: "(mkdir ",
        endParen: true,
        params: ["path", "mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s146"),
        description: `**procedure**: \`(mkdir \`*path*\`)\`
**procedure**: \`(mkdir \`*path*\` \`*mode*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. *mode* must be a fixnum.

\`mkdir\` creates a directory with the name given by *path*. All *path* path components leading up to the last must already exist. If the optional *mode* argument is present, it overrides the default permissions for the new directory. Under Windows, the *mode* argument is ignored.

\`mkdir\` raises an exception with condition type \`&i/o-filename\` if the directory cannot be created.
`
    },
    {
        name: "(mod ",
        endParen: true,
        params: ["x1", "x2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s99"),
        description: `**procedure**: \`(div \`*x1*\` \`*x2*\`)\`
**procedure**: \`(mod \`*x1*\` \`*x2*\`)\`
**procedure**: \`(div-and-mod \`*x1*\` \`*x2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *x1* and *x2* are exact, *x2* must not be zero. These procedures implement number-theoretic integer division, with the \`div\` operation being related to \`quotient\` and the \`mod\` operation being related to \`remainder\` or \`modulo\`, but in both cases extended to handle real numbers.

The value *nd* of \`(div \`*x1*\` \`*x2*\`)\` is an integer, and the value *xm* of \`(mod \`*x1*\` \`*x2*\`)\` is a real number such that = · + and 0 ≤ < ||. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, \`div\` and \`mod\` return an unspecified number or raise an exception with condition type \`&implementation-restriction\`.

The \`div-and-mod\` procedure behaves as if defined as follows.

\`(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))\`

That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling \`div\` on the two arguments and the result of calling \`mod\` on the two arguments.

\`(div 17 3) \`=>\` 5\`
\` (mod 17 3) \`=>\` 2\`
\` (div -17 3) \`=>\` -6\`
\` (mod -17 3) \`=>\` 1\`
\` (div 17 -3) \`=>\` -5\`
\` (mod 17 -3) \`=>\` 2\`
\` (div -17 -3) \`=>\` 6\`
\` (mod -17 -3) \`=>\` 1 \`
\` \`
\` (div-and-mod 17.5 3) \`=>\` 5.0\`
\`                      \`\` 2.5\`
`
    },
    {
        name: "(mod0 ",
        endParen: true,
        params: ["x1", "x2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s100"),
        description: `**procedure**: \`(div0 \`*x1*\` \`*x2*\`)\`
**procedure**: \`(mod0 \`*x1*\` \`*x2*\`)\`
**procedure**: \`(div0-and-mod0 \`*x1*\` \`*x2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *x1* and *x2* are exact, *x2* must not be zero. These procedures are similar to \`div\`, \`mod\`, and \`div-and-mod\`, but constrain the "mod" value differently, which also affects the "div" value. The value *nd* of \`(div0 \`*x1*\` \`*x2*\`)\` is an integer, and the value *xm* of \`(mod0 \`*x1*\` \`*x2*\`)\` is a real number such that = · + and -|/2| ≤ < |/2|. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, \`div0\` and \`mod0\` return an unspecified number or raise an exception with condition type \`&implementation-restriction\`.

The \`div0-and-mod0\` procedure behaves as if defined as follows.

\`(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))\`

That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling \`div0\` on the two arguments and the result of calling \`mod0\` on the two arguments.

\`(div0 17 3) \`=>\` 6\`
\` (mod0 17 3) \`=>\` -1\`
\` (div0 -17 3) \`=>\` -6\`
\` (mod0 -17 3) \`=>\` 1\`
\` (div0 17 -3) \`=>\` -6\`
\` (mod0 17 -3) \`=>\` -1\`
\` (div0 -17 -3) \`=>\` 6\`
\` (mod0 -17 -3) \`=>\` 1 \`
\` \`
\` (div0-and-mod0 17.5 3) \`=>\` 6.0\`
\`                        \`\` -0.5\`
`
    },
    {
        name: "(module ",
        endParen: true,
        params: ["name", "interface", "defn", "init", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s21"),
        description: `**syntax**: \`(module \`*name*\` \`*interface*\` \`*defn*\` ... \`*init*\` ...)\`
**syntax**: \`(module \`*interface*\` \`*defn*\` ... \`*init*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* is an identifier, *defn*\` ...\` are definitions, and *init*\` ...\` are expressions. *interface* is a list of exports \`(\`*export*\` ...)\`, where each *export* is either an identifier *identifier* or of the form \`(\`*identifier*\` \`*export*\` ...)\`.

The first syntax for \`module\` establishes a named scope that encapsulates a set of identifier bindings. The exported bindings may be made visible via \`import\` or \`import-only\` (Section ) anywhere the module name is visible. The second syntax for \`module\` introduces an anonymous module whose bindings are implicitly imported (as if by \`import\` of a hidden module name) where the module form appears.

A module consists of a (possibly empty) set of definitions and a (possibly empty) sequence of initialization expressions. The identifiers defined within a module are visible within the body of the module and, if exported, within the scope of an import for the module. Each identifier listed in a module's interface must be defined within or imported into that module. A \`module\` form is a definition and can appear anywhere other definitions can appear, including at the top level of a program, nested within the bodies of \`lambda\` expressions, nested within \`library\` and top-level program forms, and nested within other modules. Also, because module names are scoped like other identifiers, modules and libraries may export module names as well as variables and keywords.

When an interface contains an export of the form \`(\`*identifier*\` \`*export*\` ...)\`, only *identifier* is visible in the importing context. The identifiers within *export*\` ...\` are , as if declared via an \`indirect-export\` form (Section ).

Module names occupy the same namespace as other identifiers and follow the same scoping rules. Unless exported, identifiers defined within a module are visible only within that module.

Expressions within a module can reference identifiers bound outside of the module.

\`(let ([x 3])\`
\`   (module m (plusx)\`
\`     (define plusx (lambda (y) (+ x y))))\`
\`   (import m)\`
\`   (let ([x 4])\`
\`     (plusx 5))) \`=>\` 8\`

Similarly, \`import\` does not prevent access to identifiers that are visible where the import form appears, except for those variables shadowed by the imported identifiers.

\`(module m (y) (define y 'm-y))\`
\` (let ([x 'local-x] [y 'local-y])\`
\`   (import m)\`
\`   (list x y)) \`=>\` (local-x m-y)\`

On the other hand, use of \`import-only\` within a module establishes an isolated scope in which the only visible identifiers are those exported by the imported module.

\`(module m (y) (define y 'm-y))\`
\` (let ([x 'local-x] [y 'local-y])\`
\`   (import-only m)\`
\`   x) \`=>\` Error: x is not visible\`

This is sometimes desirable for static verification that no identifiers are used except those explicitly imported into a module or local scope.

Unless a module imported via \`import-only\` exports \`import\` or \`import-only\` and the name of at least one module, subsequent imports within the scope of the \`import-only\` form are not possible. To create an isolated scope containing the exports of more than one module without making \`import\` or \`import-only\` visible, all of the modules to be imported must be listed in the same \`import-only\` form.

Another solution is to create a single module that contains the exports of each of the other modules.

\`(module m2 (y) (define y 'y))\`
\` (module m1 (x) (define x 'x))\`
\` (module mega-module (cons x y)\`
\`   (import m1)\`
\`   (import m2)\`
\`   (import scheme))\`
\` (let ([y 3])\`
\`   (import-only mega-module)\`
\`   (cons x y)) \`=>\` (x . y)\`

Before it is compiled, a source program is translated into a core language program containing no syntactic abstractions, syntactic definitions, library definitions, module definitions, or import forms. Translation is performed by a that processes the forms in the source program via recursive descent.

A \`define-syntax\` form associates a keyword with a transformer in a translation-time environment. When the expander encounters a keyword, it invokes the associated transformer and reprocesses the resulting form. A \`module\` form associates a module name with an interface. When the expander encounters an \`import\` form, it extracts the corresponding module interface from the translation-time environment and makes the exported bindings visible in the scope where the \`import\` form appears.

Internal definitions and definitions within a \`module\` body are processed from left to right so that a module's definition and import may appear within the same sequence of definitions. Expressions appearing within a body and the right-hand sides of variable definitions, however, are translated only after the entire set of definitions has been processed, allowing full mutual recursion among variable and syntactic definitions.

Module and import forms affect only the visibility of identifiers in the source program, not their meanings. In particular, variables are bound to locations whether defined within or outside of a module, and \`import\` does not introduce new locations. Local variables are renamed as necessary to preserve the scoping relationships established by both modules and syntactic abstractions. Thus, the expression:

\`(let ([x 1])\`
\`   (module m (x setter)\`
\`     (define-syntax x (identifier-syntax z))\`
\`     (define setter (lambda (x) (set! z x)))\`
\`     (define z 5))\`
\`   (let ([y x] [z 0])\`
\`     (import m)\`
\`     (setter 3)\`
\`     (+ x y z))) \`=>\` 4\`

is equivalent to the following program in which identifiers have been consistently renamed as indicated by subscripts.

\`(let ([x\`*0*\` 1])\`
\`   (define-syntax x\`*1*\` (identifier-syntax z\`*1*\`))\`
\`   (define setter\`*1*\` (lambda (x\`*2*\`) (set! z\`*1*\` x\`*2*\`)))\`
\`   (define z\`*1*\` 5)\`
\`   (let ([y\`*3*\` x\`*0*\`] [z\`*3*\` 0])\`
\`     (setter\`*1*\` 3)\`
\`     (+ x\`*1*\` y\`*3*\` z\`*3*\`)))\`

Definitions within a top-level \`begin\`, \`lambda\`, top-level program, \`library\`, or \`module\` body are processed from left to right by the expander at expand time, and the variable definitions are evaluated from left-to-right at run time. Initialization expressions appearing within a \`module\` body are evaluated in sequence after the evaluation of the variable definitions.

Mutually recursive modules can be defined in several ways. In the following program, \`a\` and \`b\` are mutually recursive modules exported by an anonymous module whose local scope is used to statically link the two. For example, the free variable \`y\` within module \`a\` refers to the binding for \`y\`, provided by importing \`b\`, in the enclosing module.

\`(module (a b)\`
\`   (module a (x) (define x (lambda () y)))\`
\`   (module b (y) (define y (lambda () x)))\`
\`   (import a)\`
\`   (import b))\`

The following syntactic abstraction generalizes this pattern to permit the definition of multiple mutually recursive modules.

\`(define-syntax rec-modules\`
\`   (syntax-rules (module)\`
\`     [(_ (module m (id ...) form ...) ...)\`
\`      (module (m ...)\`
\`        (module m (id ...) form ...) ...\`
\`        (import m) ...)]))\`

Because a module can re-export imported bindings, it is quite easy to provide multiple views on a single module, as \`s\` and \`t\` provide for \`r\` below, or to combine several modules into a compound, as \`r\` does.

\`(module p (x y)\`
\`   (define x 1) (define y 2))\`
\` (module q (y z)\`
\`   (define y 3) (define z 4))\`
\` (module r (a b c d)\`
\`   (import* p (a x) (b y))\`
\`   (import* q (c y) (d z)))\`
\` (module s (a c) (import r))\`
\` (module t (b d) (import r))\`

To allow interfaces to be separated from implementations, the following syntactic abstractions support the definition and use of named interfaces.

\`(define-syntax define-interface\`
\`   (syntax-rules ()\`
\`     [(_ name (export ...))\`
\`      (define-syntax name\`
\`        (lambda (x)\`
\`          (syntax-case x ()\`
\`            [(_ n defs)\`
\`             (with-implicit (n export ...)\`
\`               #'(module n (export ...) .\`
\`                   defs))])))])) \`
\` \`
\` (define-syntax define-module\`
\`   (syntax-rules ()\`
\`     [(_ name interface defn ...)\`
\`      (interface name (defn ...))]))\`

\`define-interface\` creates an interface macro that, given a module name and a list of definitions, expands into a module definition with a concrete interface.

\`with-implicit\` is used to ensure that the introduced \`export\` identifiers are visible in the same scope as the name of the module in the \`define-module\` form.

\`define-interface\` and \`define-module\` can be used as follows.

\`(define-interface simple (a b))\`
\` (define-module m simple\`
\`   (define-syntax a (identifier-syntax 1))\`
\`   (define b (lambda () c))\`
\`   (define c 2))\`
\` (let () (import m) (+ a (b))) \`=>\` 3\`

The abstract module facility defined below allows a module interface to be satisfied incrementally when module forms are evaluated. This permits flexibility in the separation between the interface and implementation, supports separate compilation of mutually recursive modules, and permits redefinition of module implementations.

\`(define-syntax abstract-module\`
\`   (syntax-rules ()\`
\`     [(_ name (ex ...) (kwd ...) defn ...)\`
\`      (module name (ex ... kwd ...)\`
\`        (declare ex) ...\`
\`        defn ...)])) \`
\` \`
\` (define-syntax implement\`
\`   (syntax-rules ()\`
\`     [(_ name form ...)\`
\`      (module () (import name) form ...)]))\`

Within an \`abstract-module\` form, each of the exports in the list *ex*\` ...\` must be variables. The values of these variables are supplied by one or more separate \`implement\` forms. Since keyword bindings must be present at compile time, they cannot be satisfied incrementally and are instead listed as separate exports and defined within the abstract module.

Within an \`implement\` form, the sequence of forms *form*\` ...\` is a sequence of zero or more definitions followed by a sequence of zero or more expressions. Since the module used in the expansion of \`implement\` does not export anything, the definitions are all local to the \`implement\` form. The expressions may be arbitrary expressions, but should include one \`satisfy\` form for each variable whose definition is supplied by the \`implement\` form. A \`satisfy\` form has the syntax

\`(satisfy \`*variable*\` \`*expr*\`)\`

\`declare\` and \`satisfy\` may simply be the equivalents of \`define\` and \`set!\`.

\`(define-syntax declare (identifier-syntax define))\`
\` (define-syntax satisfy (identifier-syntax set!))\`

Alternatively, \`declare\` can initialize the declared variable to the value of a flag known only to \`declare\` and \`satisfy\`, and \`satisfy\` can verify that this flag is still present to insure that only one attempt to satisfy the value of a given identifier is made.

\`(module ((declare cookie) (satisfy cookie))\`
\`   (define cookie "chocolate chip")\`
\`   (define-syntax declare\`
\`     (syntax-rules () [(_ var) (define var cookie)]))\`
\`   (define-syntax satisfy\`
\`     (syntax-rules ()\`
\`       [(_ var exp)\`
\`        (if (eq? var cookie)\`
\`            (set! var exp)\`
\`            (assertion-violationf 'satisfy\`
\`              "value of variable ~s has already been satisfied"\`
\`              'var))])))\`

Using \`abstract-module\` and \`implement\`, we can define mutually recursive and separately compilable modules as follows.

\`(abstract-module e (even?) (pred)\`
\`   (define-syntax pred\`
\`     (syntax-rules () [(_ exp) (- exp 1)]))) \`
\` \`
\` (abstract-module o (odd?) ()) \`
\` \`
\` (implement e\`
\`   (import o)\`
\`   (satisfy even?\`
\`     (lambda (x)\`
\`       (or (zero? x) (odd? (pred x)))))) \`
\` \`
\` (implement o\`
\`   (import e)\`
\`   (satisfy odd?\`
\`     (lambda (x) (not (even? x))))) \`
\` \`
\` (let () (import-only e) (even? 38)) \`=>\` #t\`
`
    },
    {
        name: "(module ",
        endParen: true,
        params: ["interface", "defn", "init", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s21"),
        description: `**syntax**: \`(module \`*name*\` \`*interface*\` \`*defn*\` ... \`*init*\` ...)\`
**syntax**: \`(module \`*interface*\` \`*defn*\` ... \`*init*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* is an identifier, *defn*\` ...\` are definitions, and *init*\` ...\` are expressions. *interface* is a list of exports \`(\`*export*\` ...)\`, where each *export* is either an identifier *identifier* or of the form \`(\`*identifier*\` \`*export*\` ...)\`.

The first syntax for \`module\` establishes a named scope that encapsulates a set of identifier bindings. The exported bindings may be made visible via \`import\` or \`import-only\` (Section ) anywhere the module name is visible. The second syntax for \`module\` introduces an anonymous module whose bindings are implicitly imported (as if by \`import\` of a hidden module name) where the module form appears.

A module consists of a (possibly empty) set of definitions and a (possibly empty) sequence of initialization expressions. The identifiers defined within a module are visible within the body of the module and, if exported, within the scope of an import for the module. Each identifier listed in a module's interface must be defined within or imported into that module. A \`module\` form is a definition and can appear anywhere other definitions can appear, including at the top level of a program, nested within the bodies of \`lambda\` expressions, nested within \`library\` and top-level program forms, and nested within other modules. Also, because module names are scoped like other identifiers, modules and libraries may export module names as well as variables and keywords.

When an interface contains an export of the form \`(\`*identifier*\` \`*export*\` ...)\`, only *identifier* is visible in the importing context. The identifiers within *export*\` ...\` are , as if declared via an \`indirect-export\` form (Section ).

Module names occupy the same namespace as other identifiers and follow the same scoping rules. Unless exported, identifiers defined within a module are visible only within that module.

Expressions within a module can reference identifiers bound outside of the module.

\`(let ([x 3])\`
\`   (module m (plusx)\`
\`     (define plusx (lambda (y) (+ x y))))\`
\`   (import m)\`
\`   (let ([x 4])\`
\`     (plusx 5))) \`=>\` 8\`

Similarly, \`import\` does not prevent access to identifiers that are visible where the import form appears, except for those variables shadowed by the imported identifiers.

\`(module m (y) (define y 'm-y))\`
\` (let ([x 'local-x] [y 'local-y])\`
\`   (import m)\`
\`   (list x y)) \`=>\` (local-x m-y)\`

On the other hand, use of \`import-only\` within a module establishes an isolated scope in which the only visible identifiers are those exported by the imported module.

\`(module m (y) (define y 'm-y))\`
\` (let ([x 'local-x] [y 'local-y])\`
\`   (import-only m)\`
\`   x) \`=>\` Error: x is not visible\`

This is sometimes desirable for static verification that no identifiers are used except those explicitly imported into a module or local scope.

Unless a module imported via \`import-only\` exports \`import\` or \`import-only\` and the name of at least one module, subsequent imports within the scope of the \`import-only\` form are not possible. To create an isolated scope containing the exports of more than one module without making \`import\` or \`import-only\` visible, all of the modules to be imported must be listed in the same \`import-only\` form.

Another solution is to create a single module that contains the exports of each of the other modules.

\`(module m2 (y) (define y 'y))\`
\` (module m1 (x) (define x 'x))\`
\` (module mega-module (cons x y)\`
\`   (import m1)\`
\`   (import m2)\`
\`   (import scheme))\`
\` (let ([y 3])\`
\`   (import-only mega-module)\`
\`   (cons x y)) \`=>\` (x . y)\`

Before it is compiled, a source program is translated into a core language program containing no syntactic abstractions, syntactic definitions, library definitions, module definitions, or import forms. Translation is performed by a that processes the forms in the source program via recursive descent.

A \`define-syntax\` form associates a keyword with a transformer in a translation-time environment. When the expander encounters a keyword, it invokes the associated transformer and reprocesses the resulting form. A \`module\` form associates a module name with an interface. When the expander encounters an \`import\` form, it extracts the corresponding module interface from the translation-time environment and makes the exported bindings visible in the scope where the \`import\` form appears.

Internal definitions and definitions within a \`module\` body are processed from left to right so that a module's definition and import may appear within the same sequence of definitions. Expressions appearing within a body and the right-hand sides of variable definitions, however, are translated only after the entire set of definitions has been processed, allowing full mutual recursion among variable and syntactic definitions.

Module and import forms affect only the visibility of identifiers in the source program, not their meanings. In particular, variables are bound to locations whether defined within or outside of a module, and \`import\` does not introduce new locations. Local variables are renamed as necessary to preserve the scoping relationships established by both modules and syntactic abstractions. Thus, the expression:

\`(let ([x 1])\`
\`   (module m (x setter)\`
\`     (define-syntax x (identifier-syntax z))\`
\`     (define setter (lambda (x) (set! z x)))\`
\`     (define z 5))\`
\`   (let ([y x] [z 0])\`
\`     (import m)\`
\`     (setter 3)\`
\`     (+ x y z))) \`=>\` 4\`

is equivalent to the following program in which identifiers have been consistently renamed as indicated by subscripts.

\`(let ([x\`*0*\` 1])\`
\`   (define-syntax x\`*1*\` (identifier-syntax z\`*1*\`))\`
\`   (define setter\`*1*\` (lambda (x\`*2*\`) (set! z\`*1*\` x\`*2*\`)))\`
\`   (define z\`*1*\` 5)\`
\`   (let ([y\`*3*\` x\`*0*\`] [z\`*3*\` 0])\`
\`     (setter\`*1*\` 3)\`
\`     (+ x\`*1*\` y\`*3*\` z\`*3*\`)))\`

Definitions within a top-level \`begin\`, \`lambda\`, top-level program, \`library\`, or \`module\` body are processed from left to right by the expander at expand time, and the variable definitions are evaluated from left-to-right at run time. Initialization expressions appearing within a \`module\` body are evaluated in sequence after the evaluation of the variable definitions.

Mutually recursive modules can be defined in several ways. In the following program, \`a\` and \`b\` are mutually recursive modules exported by an anonymous module whose local scope is used to statically link the two. For example, the free variable \`y\` within module \`a\` refers to the binding for \`y\`, provided by importing \`b\`, in the enclosing module.

\`(module (a b)\`
\`   (module a (x) (define x (lambda () y)))\`
\`   (module b (y) (define y (lambda () x)))\`
\`   (import a)\`
\`   (import b))\`

The following syntactic abstraction generalizes this pattern to permit the definition of multiple mutually recursive modules.

\`(define-syntax rec-modules\`
\`   (syntax-rules (module)\`
\`     [(_ (module m (id ...) form ...) ...)\`
\`      (module (m ...)\`
\`        (module m (id ...) form ...) ...\`
\`        (import m) ...)]))\`

Because a module can re-export imported bindings, it is quite easy to provide multiple views on a single module, as \`s\` and \`t\` provide for \`r\` below, or to combine several modules into a compound, as \`r\` does.

\`(module p (x y)\`
\`   (define x 1) (define y 2))\`
\` (module q (y z)\`
\`   (define y 3) (define z 4))\`
\` (module r (a b c d)\`
\`   (import* p (a x) (b y))\`
\`   (import* q (c y) (d z)))\`
\` (module s (a c) (import r))\`
\` (module t (b d) (import r))\`

To allow interfaces to be separated from implementations, the following syntactic abstractions support the definition and use of named interfaces.

\`(define-syntax define-interface\`
\`   (syntax-rules ()\`
\`     [(_ name (export ...))\`
\`      (define-syntax name\`
\`        (lambda (x)\`
\`          (syntax-case x ()\`
\`            [(_ n defs)\`
\`             (with-implicit (n export ...)\`
\`               #'(module n (export ...) .\`
\`                   defs))])))])) \`
\` \`
\` (define-syntax define-module\`
\`   (syntax-rules ()\`
\`     [(_ name interface defn ...)\`
\`      (interface name (defn ...))]))\`

\`define-interface\` creates an interface macro that, given a module name and a list of definitions, expands into a module definition with a concrete interface.

\`with-implicit\` is used to ensure that the introduced \`export\` identifiers are visible in the same scope as the name of the module in the \`define-module\` form.

\`define-interface\` and \`define-module\` can be used as follows.

\`(define-interface simple (a b))\`
\` (define-module m simple\`
\`   (define-syntax a (identifier-syntax 1))\`
\`   (define b (lambda () c))\`
\`   (define c 2))\`
\` (let () (import m) (+ a (b))) \`=>\` 3\`

The abstract module facility defined below allows a module interface to be satisfied incrementally when module forms are evaluated. This permits flexibility in the separation between the interface and implementation, supports separate compilation of mutually recursive modules, and permits redefinition of module implementations.

\`(define-syntax abstract-module\`
\`   (syntax-rules ()\`
\`     [(_ name (ex ...) (kwd ...) defn ...)\`
\`      (module name (ex ... kwd ...)\`
\`        (declare ex) ...\`
\`        defn ...)])) \`
\` \`
\` (define-syntax implement\`
\`   (syntax-rules ()\`
\`     [(_ name form ...)\`
\`      (module () (import name) form ...)]))\`

Within an \`abstract-module\` form, each of the exports in the list *ex*\` ...\` must be variables. The values of these variables are supplied by one or more separate \`implement\` forms. Since keyword bindings must be present at compile time, they cannot be satisfied incrementally and are instead listed as separate exports and defined within the abstract module.

Within an \`implement\` form, the sequence of forms *form*\` ...\` is a sequence of zero or more definitions followed by a sequence of zero or more expressions. Since the module used in the expansion of \`implement\` does not export anything, the definitions are all local to the \`implement\` form. The expressions may be arbitrary expressions, but should include one \`satisfy\` form for each variable whose definition is supplied by the \`implement\` form. A \`satisfy\` form has the syntax

\`(satisfy \`*variable*\` \`*expr*\`)\`

\`declare\` and \`satisfy\` may simply be the equivalents of \`define\` and \`set!\`.

\`(define-syntax declare (identifier-syntax define))\`
\` (define-syntax satisfy (identifier-syntax set!))\`

Alternatively, \`declare\` can initialize the declared variable to the value of a flag known only to \`declare\` and \`satisfy\`, and \`satisfy\` can verify that this flag is still present to insure that only one attempt to satisfy the value of a given identifier is made.

\`(module ((declare cookie) (satisfy cookie))\`
\`   (define cookie "chocolate chip")\`
\`   (define-syntax declare\`
\`     (syntax-rules () [(_ var) (define var cookie)]))\`
\`   (define-syntax satisfy\`
\`     (syntax-rules ()\`
\`       [(_ var exp)\`
\`        (if (eq? var cookie)\`
\`            (set! var exp)\`
\`            (assertion-violationf 'satisfy\`
\`              "value of variable ~s has already been satisfied"\`
\`              'var))])))\`

Using \`abstract-module\` and \`implement\`, we can define mutually recursive and separately compilable modules as follows.

\`(abstract-module e (even?) (pred)\`
\`   (define-syntax pred\`
\`     (syntax-rules () [(_ exp) (- exp 1)]))) \`
\` \`
\` (abstract-module o (odd?) ()) \`
\` \`
\` (implement e\`
\`   (import o)\`
\`   (satisfy even?\`
\`     (lambda (x)\`
\`       (or (zero? x) (odd? (pred x)))))) \`
\` \`
\` (implement o\`
\`   (import e)\`
\`   (satisfy odd?\`
\`     (lambda (x) (not (even? x))))) \`
\` \`
\` (let () (import-only e) (even? 38)) \`=>\` #t\`
`
    },
    {
        name: "(modulo ",
        endParen: true,
        params: ["int1", "int2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s98"),
        description: `**procedure**: \`(quotient \`*int1*\` \`*int2*\`)\`
**returns: **the integer quotient of *int1* and *int2*
**procedure**: \`(remainder \`*int1*\` \`*int2*\`)\`
**returns: **the integer remainder of *int1* and *int2*
**procedure**: \`(modulo \`*int1*\` \`*int2*\`)\`
**returns: **the integer modulus of *int1* and *int2*
**libraries: **\`(rnrs r5rs)\`

The result of \`remainder\` has the same sign as *int1*, while the result of \`modulo\` has the same sign as *int2*.

\`(quotient 45 6) \`=>\` 7\`
\` (quotient 6.0 2.0) \`=>\` 3.0\`
\` (quotient 3.0 -2) \`=>\` -1.0 \`
\` \`
\` (remainder 16 4) \`=>\` 0\`
\` (remainder 5 2) \`=>\` 1\`
\` (remainder -45.0 7) \`=>\` -3.0\`
\` (remainder 10.0 -3.0) \`=>\` 1.0\`
\` (remainder -17 -9) \`=>\` -8 \`
\` \`
\` (modulo 16 4) \`=>\` 0\`
\` (modulo 5 2) \`=>\` 1\`
\` (modulo -45.0 7) \`=>\` 4.0\`
\` (modulo 10.0 -3.0) \`=>\` -2.0\`
\` (modulo -17 -9) \`=>\` -8\`
`
    },
    {
        name: "(most-negative-fixnum)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s14"),
        description: `**procedure**: \`(most-positive-fixnum)\`
**returns: **the most positive fixnum supported by the system
**procedure**: \`(most-negative-fixnum)\`
**returns: **the most negative fixnum supported by the system
**libraries: **\`(chezscheme)\`

These procedures are identical to the Revised Report \`greatest-fixnum\` and \`least-fixnum\` procedures.
`
    },
    {
        name: "(most-positive-fixnum)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s14"),
        description: `**procedure**: \`(most-positive-fixnum)\`
**returns: **the most positive fixnum supported by the system
**procedure**: \`(most-negative-fixnum)\`
**returns: **the most negative fixnum supported by the system
**libraries: **\`(chezscheme)\`

These procedures are identical to the Revised Report \`greatest-fixnum\` and \`least-fixnum\` procedures.
`
    },
    {
        name: "(multibyte->string ",
        endParen: true,
        params: ["code-page", "bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s92"),
        description: `**procedure**: \`(multibyte->string \`*code-page*\` \`*bytevector*\`)\`
**returns: **a string containing the characters encoded in *bytevector*
**procedure**: \`(string->multibyte \`*code-page*\` \`*string*\`)\`
**returns: **a bytevector containing the encodings of the characters in *string*
**libraries: **\`(chezscheme)\`

These procedures are available only under Windows. The procedure \`multibyte->string\` is a wrapper for the Windows API \`MultiByteToWideChar\` function, and \`string->multibyte\` is a wrapper for the Windows API \`WideCharToMultiByte\` function.

*code-page* declares the encoding of the byte sequences in the input or output bytevectors. It must be an exact nonnegative integer identifying a code page or one of the symbols \`cp-acp\`, \`cp-maccp\`, \`cp-oemcp\`, \`cp-symbol\`, \`cp-thread-acp\`, \`cp-utf7\`, or \`cp-utf8\`, which have the same meanings as the API function meanings for the like-named constants.
`
    },
    {
        name: "mutable",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(mutable-box? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s87"),
        description: `**procedure**: \`(mutable-box? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable box, \`#f\` otherwise
**procedure**: \`(immutable-box? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable box, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-box? (box 1)) \`=>\` #t\`
\` (mutable-box? (box-immutable 1)) \`=>\` #f\`
\` (immutable-box? (box 1)) \`=>\` #f\`
\` (immutable-box? (box-immutable 1)) \`=>\` #t\`
\` (mutable-box? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(mutable-bytevector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s66"),
        description: `**procedure**: \`(mutable-bytevector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable bytevector, \`#f\` otherwise
**procedure**: \`(immutable-bytevector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable bytevector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-bytevector? (bytevector 1 2 3)) \`=>\` #t\`
\` (mutable-bytevector?\`
\`   (bytevector->immutable-bytevector (bytevector 1 2 3))) \`=>\` #f\`
\` (immutable-bytevector? (bytevector 1 2 3)) \`=>\` #f\`
\` (immutable-bytevector?\`
\`   (bytevector->immutable-bytevector (bytevector 1 2 3))) \`=>\` #t\`
\` (immutable-bytevector? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(mutable-fxvector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s53"),
        description: `**procedure**: \`(mutable-fxvector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable fxvector, \`#f\` otherwise
**procedure**: \`(immutable-fxvector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable fxvector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-fxvector? (fxvector 1 2 3)) \`=>\` #t\`
\` (mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) \`=>\` #f\`
\` (immutable-fxvector? (fxvector 1 2 3)) \`=>\` #f\`
\` (immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) \`=>\` #t\`
\` (immutable-fxvector? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(mutable-string? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s24"),
        description: `**procedure**: \`(mutable-string? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable string, \`#f\` otherwise
**procedure**: \`(immutable-string? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable string, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-string? (string #\\a #\\b #\\c)) \`=>\` #t\`
\` (mutable-string? (string->immutable-string "abc")) \`=>\` #f\`
\` (immutable-string? (string #\\a #\\b #\\c)) \`=>\` #f\`
\` (immutable-string? (string->immutable-string "abc")) \`=>\` #t\`
\` (immutable-string? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(mutable-vector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s34"),
        description: `**procedure**: \`(mutable-vector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutable vector, \`#f\` otherwise
**procedure**: \`(immutable-vector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an immutable vector, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (mutable-vector? (vector 1 2 3)) \`=>\` #t\`
\` (mutable-vector? (vector->immutable-vector (vector 1 2 3))) \`=>\` #f\`
\` (immutable-vector? (vector 1 2 3)) \`=>\` #f\`
\` (immutable-vector? (vector->immutable-vector (vector 1 2 3))) \`=>\` #t\`
\` (immutable-vector? (cons 3 4)) \`=>\` #f\`
`
    },
    {
        name: "(mutex-acquire ",
        endParen: true,
        params: ["mutex"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s8"),
        description: `**procedure**: \`(mutex-acquire \`*mutex*\`)\`
**procedure**: \`(mutex-acquire \`*mutex*\` \`*block?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*mutex* must be a mutex.

*mutex-acquire* acquires the mutex identified by *mutex*. The optional boolean argument *block?* defaults to \`#t\` and specifies whether the thread should block waiting for the mutex. If *block?* is omitted or is true, the thread blocks until the mutex has been acquired, and an unspecified value is returned.

If \`block?\` is false and the mutex currently belongs to a different thread, the current thread does not block. Instead, \`mutex-acquire\` returns immediately with the value \`#f\` to indicate that the mutex is not available. If *block?* is false and the mutex is successfully acquired, \`mutex-acquire\` returns \`#t\`.

Mutexes are in Posix threads terminology, which means that the calling thread can use \`mutex-acquire\` to (re)acquire a mutex it already has. In this case, an equal number of \`mutex-release\` calls is necessary to release the mutex.
`
    },
    {
        name: "(mutex-acquire ",
        endParen: true,
        params: ["mutex", "block?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s8"),
        description: `**procedure**: \`(mutex-acquire \`*mutex*\`)\`
**procedure**: \`(mutex-acquire \`*mutex*\` \`*block?*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*mutex* must be a mutex.

*mutex-acquire* acquires the mutex identified by *mutex*. The optional boolean argument *block?* defaults to \`#t\` and specifies whether the thread should block waiting for the mutex. If *block?* is omitted or is true, the thread blocks until the mutex has been acquired, and an unspecified value is returned.

If \`block?\` is false and the mutex currently belongs to a different thread, the current thread does not block. Instead, \`mutex-acquire\` returns immediately with the value \`#f\` to indicate that the mutex is not available. If *block?* is false and the mutex is successfully acquired, \`mutex-acquire\` returns \`#t\`.

Mutexes are in Posix threads terminology, which means that the calling thread can use \`mutex-acquire\` to (re)acquire a mutex it already has. In this case, an equal number of \`mutex-release\` calls is necessary to release the mutex.
`
    },
    {
        name: "(mutex-name ",
        endParen: true,
        params: ["mutex"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s11"),
        description: `**procedure**: \`(mutex-name \`*mutex*\`)\`
**returns: **the name associated with *mutex*, if any; otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*mutex* must be a mutex.
`
    },
    {
        name: "(mutex-release ",
        endParen: true,
        params: ["mutex"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s9"),
        description: `**procedure**: \`(mutex-release \`*mutex*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*mutex* must be a mutex.

\`mutex-release\` releases the mutex identified by *mutex*. Unpredictable behavior results if the mutex is not owned by the calling thread.
`
    },
    {
        name: "(mutex? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s7"),
        description: `**procedure**: \`(mutex? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a mutex, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(nan? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s97"),
        description: `**procedure**: \`(finite? \`*real*\`)\`
**returns: **\`#t\` if *real* is finite, \`#f\` otherwise
**procedure**: \`(infinite? \`*real*\`)\`
**returns: **\`#t\` if *real* is infinite, \`#f\` otherwise
**procedure**: \`(nan? \`*real*\`)\`
**returns: **\`#t\` if *real* is a NaN, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (finite? 2/3) \`=>\` #t\`
\` (infinite? 2/3) \`=>\` #f\`
\` (nan? 2/3) \`=>\` #f \`
\` \`
\` (finite? 3.1415) \`=>\` #t\`
\` (infinite? 3.1415) \`=>\` #f\`
\` (nan? 3.1415) \`=>\` #f \`
\` \`
\` (finite? +inf.0) \`=>\` #f\`
\` (infinite? -inf.0) \`=>\` #t\`
\` (nan? -inf.0) \`=>\` #f \`
\` \`
\` (finite? +nan.0) \`=>\` #f\`
\` (infinite? +nan.0) \`=>\` #f\`
\` (nan? +nan.0) \`=>\` #t\`
`
    },
    {
        name: "(native-endianness)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s241"),
        description: `**procedure**: \`(native-endianness)\`
**returns: **a symbol naming the implementation's native endianness
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

The return value is the symbol \`little\`, the symbol \`big\`, or some other endianness symbol recognized by the implementation. It typically reflects the endianness of the underlying hardware.

\`(symbol? (native-endianness)) \`=>\` #t\`
`
    },
    {
        name: "(native-eol-style)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s24"),
        description: `**procedure**: \`(native-eol-style)\`
**returns: **the native eol style
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

The native eol style is implementation-dependent and may vary by platform or locale.
`
    },
    {
        name: "(native-transcoder)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s21"),
        description: `**procedure**: \`(native-transcoder)\`
**returns: **the native transcoder
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

The native transcoder is implementation-dependent and may vary by platform or locale.
`
    },
    {
        name: "(negative? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s95"),
        description: `**procedure**: \`(negative? \`*real*\`)\`
**returns: **\`#t\` if *real* is less than zero, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`negative?\` is equivalent to \`(lambda (x) (< x 0))\`.

\`(negative? -65) \`=>\` #t\`
\` (negative? 0) \`=>\` #f\`
\` (negative? -0.0121) \`=>\` #t\`
\` (negative? 15/16) \`=>\` #f\`
\` (negative? -7.0+0.0i) \`=>\` \`*exception: not a real number*
`
    },
    {
        name: "(new-cafe)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s167"),
        description: `**procedure**: \`(new-cafe)\`
**procedure**: \`(new-cafe \`*eval-proc*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(new-cafe ",
        endParen: true,
        params: ["eval-proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s167"),
        description: `**procedure**: \`(new-cafe)\`
**procedure**: \`(new-cafe \`*eval-proc*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(newline)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s87"),
        description: `**procedure**: \`(newline)\`
**procedure**: \`(newline \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port. \`newline\` sends a line-feed character to the port.
`
    },
    {
        name: "(newline ",
        endParen: true,
        params: ["textual-output-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s87"),
        description: `**procedure**: \`(newline)\`
**procedure**: \`(newline \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port. \`newline\` sends a line-feed character to the port.
`
    },
    {
        name: "(no-infinities-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s44"),
        description: `**syntax**: \`&no-infinities\`
**procedure**: \`(make-no-infinities-violation)\`
**returns: **a condition of type \`&no-infinities\`
**procedure**: \`(no-infinities-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&no-infinities\`, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

This condition indicates that the implementation has no representation for infinity. This condition type might be defined as follows.

\`(define-condition-type &no-infinities &implementation-restriction\`
\`   make-no-infinities-violation\`
\`   no-infinities-violation?)\`
`
    },
    {
        name: "(no-nans-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s45"),
        description: `**syntax**: \`&no-nans\`
**procedure**: \`(make-no-nans-violation)\`
**returns: **a condition of type \`&no-nans\`
**procedure**: \`(no-nans-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&no-nans\`, \`#f\` otherwise
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

This condition indicates that the implementation has no representation for NaN. This condition type might be defined as follows.

\`(define-condition-type &no-nans &implementation-restriction\`
\`   make-no-nans-violation no-nans-violation?)\`

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(non-continuable-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s27"),
        description: `**syntax**: \`&non-continuable\`
**procedure**: \`(make-non-continuable-violation)\`
**returns: **a condition of type \`&non-continuable\`
**procedure**: \`(non-continuable-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&non-continuable\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a non-continuable violation has occurred. \`raise\` raises an exception with this type if the current exception handler returns. This condition type might be defined as follows.

\`(define-condition-type &non-continuable &violation\`
\`   make-non-continuable-violation\`
\`   non-continuable-violation?)\`
`
    },
    {
        name: "nongenerative",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(nonnegative? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s73"),
        description: `**procedure**: \`(nonnegative? \`*real*\`)\`
**returns: **\`#t\` if *real* is not less than zero, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`nonnegative?\` is equivalent to \`(lambda (x) (>= x 0))\`.

\`(nonnegative? -65) \`=>\` #f\`
\` (nonnegative? 0) \`=>\` #t\`
\` (nonnegative? -0.0121) \`=>\` #f\`
\` (nonnegative? 15/16) \`=>\` #t\`
`
    },
    {
        name: "(nonpositive? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s72"),
        description: `**procedure**: \`(nonpositive? \`*real*\`)\`
**returns: **\`#t\` if *real* is not greater than zero, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`nonpositive?\` is equivalent to \`(lambda (x) (<= x 0))\`.

\`(nonpositive? 128) \`=>\` #f\`
\` (nonpositive? 0.0) \`=>\` #t\`
\` (nonpositive? 1.8e-15) \`=>\` #f\`
\` (nonpositive? -2/3) \`=>\` #t\`
`
    },
    {
        name: "(not ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s10"),
        description: `**procedure**: \`(not \`*obj*\`)\`
**returns: **\`#t\` if *obj* is false, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`not\` is equivalent to \`(lambda (x) (if x #f #t))\`.

\`(not #f) \`=>\` #t\`
\` (not #t) \`=>\` #f\`
\` (not '()) \`=>\` #f\`
\` (not (< 4 5)) \`=>\` #f\`
`
    },
    {
        name: "(null-environment ",
        endParen: true,
        params: ["version"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s82"),
        description: `**procedure**: \`(null-environment \`*version*\`)\`
**procedure**: \`(scheme-report-environment \`*version*\`)\`
**returns: **an R5RS compatibility environment
**libraries: **\`(rnrs r5rs)\`

*version* must be the exact integer \`5\`.

\`null-environment\` returns an environment containing bindings for the keywords whose meanings are defined by the Revised Report on Scheme, along with bindings for the auxiliary keywords \`else\`, \`=>\`, \`...\`, and \`_\`.

\`scheme-report-environment\` returns an environment containing the same keyword bindings as the environment returned by \`null-environment\` along with bindings for the variables whose meanings are defined by the Revised Report on Scheme, except those not defined by the Revised Report: \`load\`, \`interaction-environment\`, \`transcript-on\`, \`transcript-off\`, and \`char-ready?\`.

The bindings for each of the identifiers in the environments returned by these procedures are those of the corresponding Revised Report library, so this does not provide full backward compatibility, even if the excepted identifier bindings are not used.

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(null? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s15"),
        description: `**procedure**: \`(null? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is the empty list, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`null?\` is equivalent to \`(lambda (x) (eq? x '()))\`.

\`(null? '()) \`=>\` #t\`
\` (null? '(a)) \`=>\` #f\`
\` (null? (cdr '(a))) \`=>\` #t\`
\` (null? 3) \`=>\` #f\`
\` (null? #f) \`=>\` #f\`
`
    },
    {
        name: "(number->string ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s79"),
        description: `**procedure**: \`(number->string \`*num*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\` \`*precision*\`)\`
**returns: **an external representation of *num* as a string
**libraries: **\`(chezscheme)\`

This procedure is identical to the Revised Report version except that \`radix\` may be any exact integer between 2 and 36, inclusive. The Revised Report version requires radix to be in the set {2,8,10,16}.

\`(number->string 10000 4) \`=>\` "2130100"\`
\` (number->string 10000 27) \`=>\` "DJA"\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(number->string ",
        endParen: true,
        params: ["num", "radix"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s79"),
        description: `**procedure**: \`(number->string \`*num*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\` \`*precision*\`)\`
**returns: **an external representation of *num* as a string
**libraries: **\`(chezscheme)\`

This procedure is identical to the Revised Report version except that \`radix\` may be any exact integer between 2 and 36, inclusive. The Revised Report version requires radix to be in the set {2,8,10,16}.

\`(number->string 10000 4) \`=>\` "2130100"\`
\` (number->string 10000 27) \`=>\` "DJA"\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(number->string ",
        endParen: true,
        params: ["num", "radix", "precision"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s79"),
        description: `**procedure**: \`(number->string \`*num*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\` \`*precision*\`)\`
**returns: **an external representation of *num* as a string
**libraries: **\`(chezscheme)\`

This procedure is identical to the Revised Report version except that \`radix\` may be any exact integer between 2 and 36, inclusive. The Revised Report version requires radix to be in the set {2,8,10,16}.

\`(number->string 10000 4) \`=>\` "2130100"\`
\` (number->string 10000 27) \`=>\` "DJA"\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(number->string ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s148"),
        description: `**procedure**: \`(number->string \`*num*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\` \`*precision*\`)\`
**returns: **an external representation of *num* as a string
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The num is expressed in radix *radix*, which must be an exact integer in the set {2,8,10,16}. If not specified, *radix* defaults to 10. In any case, no radix specifier appears in the resulting string.

The external representation is such that, when converted back into a number using \`string->number\`, the resulting numeric value is equivalent to *num*. That is, for all inputs:

\`(eqv? (string->number\`
\`         (number->string \`*num*\` \`*radix*\`)\`
\`         \`*radix*\`)\`
\`       \`*num*\`)\`

returns \`#t\`. An exception with condition type \`&implementation-restriction\` is raised if this is not possible.

If *precision* is provided, it must be an exact positive integer, *num* must be inexact, and *radix* must be 10. In this case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa width *m*, where *m* is the least possible value greater than or equal to *precision* that makes the expression above true.

If *radix* is 10, inexact values of *num* are expressed using the fewest number of significant digits possible [] without violating the above restriction.

\`(number->string 3.4) \`=>\` "3.4"\`
\` (number->string 1e2) \`=>\` "100.0"\`
\` (number->string 1e-23) \`=>\` "1e-23"\`
\` (number->string -7/2) \`=>\` "-7/2"\`
\` (number->string 220/9 16) \`=>\` "DC/9"\`
`
    },
    {
        name: "(number->string ",
        endParen: true,
        params: ["num", "radix"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s148"),
        description: `**procedure**: \`(number->string \`*num*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\` \`*precision*\`)\`
**returns: **an external representation of *num* as a string
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The num is expressed in radix *radix*, which must be an exact integer in the set {2,8,10,16}. If not specified, *radix* defaults to 10. In any case, no radix specifier appears in the resulting string.

The external representation is such that, when converted back into a number using \`string->number\`, the resulting numeric value is equivalent to *num*. That is, for all inputs:

\`(eqv? (string->number\`
\`         (number->string \`*num*\` \`*radix*\`)\`
\`         \`*radix*\`)\`
\`       \`*num*\`)\`

returns \`#t\`. An exception with condition type \`&implementation-restriction\` is raised if this is not possible.

If *precision* is provided, it must be an exact positive integer, *num* must be inexact, and *radix* must be 10. In this case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa width *m*, where *m* is the least possible value greater than or equal to *precision* that makes the expression above true.

If *radix* is 10, inexact values of *num* are expressed using the fewest number of significant digits possible [] without violating the above restriction.

\`(number->string 3.4) \`=>\` "3.4"\`
\` (number->string 1e2) \`=>\` "100.0"\`
\` (number->string 1e-23) \`=>\` "1e-23"\`
\` (number->string -7/2) \`=>\` "-7/2"\`
\` (number->string 220/9 16) \`=>\` "DC/9"\`
`
    },
    {
        name: "(number->string ",
        endParen: true,
        params: ["num", "radix", "precision"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s148"),
        description: `**procedure**: \`(number->string \`*num*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\`)\`
**procedure**: \`(number->string \`*num*\` \`*radix*\` \`*precision*\`)\`
**returns: **an external representation of *num* as a string
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The num is expressed in radix *radix*, which must be an exact integer in the set {2,8,10,16}. If not specified, *radix* defaults to 10. In any case, no radix specifier appears in the resulting string.

The external representation is such that, when converted back into a number using \`string->number\`, the resulting numeric value is equivalent to *num*. That is, for all inputs:

\`(eqv? (string->number\`
\`         (number->string \`*num*\` \`*radix*\`)\`
\`         \`*radix*\`)\`
\`       \`*num*\`)\`

returns \`#t\`. An exception with condition type \`&implementation-restriction\` is raised if this is not possible.

If *precision* is provided, it must be an exact positive integer, *num* must be inexact, and *radix* must be 10. In this case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa width *m*, where *m* is the least possible value greater than or equal to *precision* that makes the expression above true.

If *radix* is 10, inexact values of *num* are expressed using the fewest number of significant digits possible [] without violating the above restriction.

\`(number->string 3.4) \`=>\` "3.4"\`
\` (number->string 1e2) \`=>\` "100.0"\`
\` (number->string 1e-23) \`=>\` "1e-23"\`
\` (number->string -7/2) \`=>\` "-7/2"\`
\` (number->string 220/9 16) \`=>\` "DC/9"\`
`
    },
    {
        name: "(number? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s17"),
        description: `**procedure**: \`(number? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a number object, \`#f\` otherwise
**procedure**: \`(complex? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a complex number object, \`#f\` otherwise
**procedure**: \`(real? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number object, \`#f\` otherwise
**procedure**: \`(rational? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number object, \`#f\` otherwise
**procedure**: \`(integer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer object, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well.

The \`real?\`, \`rational?\`, and \`integer?\` predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts.

\`(integer? 1901) \`=>\` #t\`
\` (rational? 1901) \`=>\` #t\`
\` (real? 1901) \`=>\` #t\`
\` (complex? 1901) \`=>\` #t\`
\` (number? 1901) \`=>\` #t \`
\` \`
\` (integer? -3.0) \`=>\` #t\`
\` (rational? -3.0) \`=>\` #t\`
\` (real? -3.0) \`=>\` #t\`
\` (complex? -3.0) \`=>\` #t\`
\` (number? -3.0) \`=>\` #t \`
\` \`
\` (integer? 7+0i) \`=>\` #t\`
\` (rational? 7+0i) \`=>\` #t\`
\` (real? 7+0i) \`=>\` #t\`
\` (complex? 7+0i) \`=>\` #t\`
\` (number? 7+0i) \`=>\` #t \`
\` \`
\` (integer? -2/3) \`=>\` #f\`
\` (rational? -2/3) \`=>\` #t\`
\` (real? -2/3) \`=>\` #t\`
\` (complex? -2/3) \`=>\` #t\`
\` (number? -2/3) \`=>\` #t \`
\` \`
\` (integer? -2.345) \`=>\` #f\`
\` (rational? -2.345) \`=>\` #t\`
\` (real? -2.345) \`=>\` #t\`
\` (complex? -2.345) \`=>\` #t\`
\` (number? -2.345) \`=>\` #t \`
\` \`
\` (integer? 7.0+0.0i) \`=>\` #f\`
\` (rational? 7.0+0.0i) \`=>\` #f\`
\` (real? 7.0+0.0i) \`=>\` #f\`
\` (complex? 7.0+0.0i) \`=>\` #t\`
\` (number? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer? 3.2-2.01i) \`=>\` #f\`
\` (rational? 3.2-2.01i) \`=>\` #f\`
\` (real? 3.2-2.01i) \`=>\` #f\`
\` (complex? 3.2-2.01i) \`=>\` #t\`
\` (number? 3.2-2.01i) \`=>\` #t \`
\` \`
\` (integer? 'a) \`=>\` #f\`
\` (rational? '(a b c)) \`=>\` #f\`
\` (real? "3") \`=>\` #f\`
\` (complex? '#(1 2)) \`=>\` #f\`
\` (number? #\\a) \`=>\` #f\`
`
    },
    {
        name: "(numerator ",
        endParen: true,
        params: ["rat"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s118"),
        description: `**procedure**: \`(numerator \`*rat*\`)\`
**returns: **the numerator of *rat*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *rat* is an integer, the numerator is *rat*.

\`(numerator 9) \`=>\` 9\`
\` (numerator 9.0) \`=>\` 9.0\`
\` (numerator 0.0) \`=>\` 0.0\`
\` (numerator 2/3) \`=>\` 2\`
\` (numerator -9/4) \`=>\` -9\`
\` (numerator -2.25) \`=>\` -9.0\`
`
    },
    {
        name: "(object-counts)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s238"),
        description: `**procedure**: \`(object-counts)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

The procedure \`object-counts\` returns a nested association list representing object counts and bytes allocated for each heap-allocated primitive type and record type with at least one live instance in one or more generations. (Heap-allocated primitive types include, e.g., pairs and vectors, but not, e.g., fixnums or characters.) Object counts are gathered by the collector only when \`enable-object-counts\` is \`#t\`. The description of \`enable-object-counts\` details the circumstances under which the counts are accurate.

The association list returned by \`object-counts\` has the following structure:

\`((\`*type*\` (\`*generation*\` \`*count*\` . \`*bytes*\`) ...) ...)\`

*type* is either the name of a primitive type, represented as a symbol, e.g., \`pair\`, or a record-type descriptor (rtd). *generation* is a nonnegative fixnum between 0 and the value of \`(collect-maximum-generation)\`, inclusive, or the symbol \`static\` representing the static generation. *count* and *bytes* are nonnegative fixnums.

\`(collect-request-handler void)\`
\` (enable-object-counts #t)\`
\` (define-record-type frob (fields x))\`
\` (define x (make-frob (make-frob #f)))\`
\` (collect 3 3)\`
\` (cdr (assoc 3\`
\`        (cdr (assoc (record-type-descriptor frob)\`
\`               (object-counts)))))                \`=>\` (2 . 16)\`
`
    },
    {
        name: "(oblist)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s112"),
        description: `**procedure**: \`(oblist)\`
**returns: **a list of interned symbols
**libraries: **\`(chezscheme)\`

The system maintains an internal symbol table used to insure that any two occurrences of the same symbol name resolve to the same symbol object. The \`oblist\` procedure returns a list of the symbols currently in this symbol table.

The list of interned symbols grows when a new symbol is introduced into the system or when the unique name of a gensym (see page ) is requested. It shrinks when the garbage collector determines that it is safe to discard a symbol. It is safe to discard a symbol only if the symbol is not accessible except through the oblist, has no top-level binding, and has no properties on its property list.

\`(if (memq 'tiger (oblist)) 'yes 'no) \`=>\` yes\`
\` (equal? (oblist) (oblist)) \`=>\` #t\`
\` (= (length (oblist)) (length (oblist))) \`=>\` #t \`*or*\` #f\`

The first example above follows from the property that all interned symbols are in the oblist from the time they are read, which happens prior to evaluation. The second example follows from the fact that no symbols can be removed from the oblist while references to those symbols exist, in this case, within the list returned by the first call to \`oblist\` (whichever call is performed first). The expression in the third example can return \`#f\` only if a garbage collection occurs sometime between the two calls to \`oblist\`, and only if one or more symbols are removed from the oblist by that collection.
`
    },
    {
        name: "(odd? ",
        endParen: true,
        params: ["int"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s96"),
        description: `**procedure**: \`(even? \`*int*\`)\`
**returns: **\`#t\` if *int* is even, \`#f\` otherwise
**procedure**: \`(odd? \`*int*\`)\`
**returns: **\`#t\` if *int* is odd, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (even? 0) \`=>\` #t\`
\` (even? 1) \`=>\` #f\`
\` (even? 2.0) \`=>\` #t\`
\` (even? -120762398465) \`=>\` #f\`
\` (even? 2.0+0.0i) \`=>\` \`*exception: not an integer*\` \`
\` \`
\` (odd? 0) \`=>\` #f\`
\` (odd? 1) \`=>\` #t\`
\` (odd? 2.0) \`=>\` #f\`
\` (odd? -120762398465) \`=>\` #t\`
\` (odd? 2.0+0.0i) \`=>\` \`*exception: not an integer*
`
    },
    {
        name: "only",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s22"),
        description: `**syntax**: \`only\`
**syntax**: \`except\`
**syntax**: \`add-prefix\`
**syntax**: \`drop-prefix\`
**syntax**: \`rename\`
**syntax**: \`alias\`
**libraries: **\`(chezscheme)\`

These identifiers are auxiliary keywords for \`import\` and \`import-only\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "opaque",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(open-bytevector-input-port ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s34"),
        description: `**procedure**: \`(open-bytevector-input-port \`*bytevector*\`)\`
**procedure**: \`(open-bytevector-input-port \`*bytevector*\` \`*?transcoder*\`)\`
**returns: **a new input port that draws input from *bytevector*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port.

The effect of modifying *bytevector* after this procedure is called is unspecified.

\`(let ([ip (open-bytevector-input-port #vu8(1 2))])\`
\`   (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])\`
\`     (list x1 x2 (eof-object? x3)))) \`=>\` (1 2 #t)\`

There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.
`
    },
    {
        name: "(open-bytevector-input-port ",
        endParen: true,
        params: ["bytevector", "?transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s34"),
        description: `**procedure**: \`(open-bytevector-input-port \`*bytevector*\`)\`
**procedure**: \`(open-bytevector-input-port \`*bytevector*\` \`*?transcoder*\`)\`
**returns: **a new input port that draws input from *bytevector*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port.

The effect of modifying *bytevector* after this procedure is called is unspecified.

\`(let ([ip (open-bytevector-input-port #vu8(1 2))])\`
\`   (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])\`
\`     (list x1 x2 (eof-object? x3)))) \`=>\` (1 2 #t)\`

There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.
`
    },
    {
        name: "(open-bytevector-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s36"),
        description: `**procedure**: \`(open-bytevector-output-port)\`
**procedure**: \`(open-bytevector-output-port \`*?transcoder*\`)\`
**returns: **two values, a new output port and an extraction procedure
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and the port value is a textual output port whose transcoder is *?transcoder*. Otherwise, the port value is a binary output port.

The extraction procedure is a procedure that, when called without arguments, creates a bytevector containing the accumulated bytes in the port, clears the port of its accumulated bytes, resets its position to zero, and returns the bytevector. The accumulated bytes include any bytes written beyond the end of the current position, if the position has been set back from its maximum extent.

\`(let-values ([(op g) (open-bytevector-output-port)])\`
\`   (put-u8 op 15)\`
\`   (put-u8 op 73)\`
\`   (put-u8 op 115)\`
\`   (set-port-position! op 2)\`
\`   (let ([bv1 (g)])\`
\`     (put-u8 op 27)\`
\`     (list bv1 (g)))) \`=>\` (#vu8(15 73 115) #vu8(27))\`

There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.
`
    },
    {
        name: "(open-bytevector-output-port ",
        endParen: true,
        params: ["?transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s36"),
        description: `**procedure**: \`(open-bytevector-output-port)\`
**procedure**: \`(open-bytevector-output-port \`*?transcoder*\`)\`
**returns: **two values, a new output port and an extraction procedure
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and the port value is a textual output port whose transcoder is *?transcoder*. Otherwise, the port value is a binary output port.

The extraction procedure is a procedure that, when called without arguments, creates a bytevector containing the accumulated bytes in the port, clears the port of its accumulated bytes, resets its position to zero, and returns the bytevector. The accumulated bytes include any bytes written beyond the end of the current position, if the position has been set back from its maximum extent.

\`(let-values ([(op g) (open-bytevector-output-port)])\`
\`   (put-u8 op 15)\`
\`   (put-u8 op 73)\`
\`   (put-u8 op 115)\`
\`   (set-port-position! op 2)\`
\`   (let ([bv1 (g)])\`
\`     (put-u8 op 27)\`
\`     (list bv1 (g)))) \`=>\` (#vu8(15 73 115) #vu8(27))\`

There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.
`
    },
    {
        name: "(open-fd-input-port ",
        endParen: true,
        params: ["fd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s60"),
        description: `**procedure**: \`(open-fd-input-port \`*fd*\`)\`
**procedure**: \`(open-fd-input-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-input-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-input-port ",
        endParen: true,
        params: ["fd", "b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s60"),
        description: `**procedure**: \`(open-fd-input-port \`*fd*\`)\`
**procedure**: \`(open-fd-input-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-input-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-input-port ",
        endParen: true,
        params: ["fd", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s60"),
        description: `**procedure**: \`(open-fd-input-port \`*fd*\`)\`
**procedure**: \`(open-fd-input-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-input-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-input/output-port ",
        endParen: true,
        params: ["fd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s90"),
        description: `**procedure**: \`(open-fd-input/output-port \`*fd*\`)\`
**procedure**: \`(open-fd-input/output-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-input/output-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-input/output-port ",
        endParen: true,
        params: ["fd", "b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s90"),
        description: `**procedure**: \`(open-fd-input/output-port \`*fd*\`)\`
**procedure**: \`(open-fd-input/output-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-input/output-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-input/output-port ",
        endParen: true,
        params: ["fd", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s90"),
        description: `**procedure**: \`(open-fd-input/output-port \`*fd*\`)\`
**procedure**: \`(open-fd-input/output-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-input/output-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-output-port ",
        endParen: true,
        params: ["fd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s80"),
        description: `**procedure**: \`(open-fd-output-port \`*fd*\`)\`
**procedure**: \`(open-fd-output-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-output-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-output-port ",
        endParen: true,
        params: ["fd", "b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s80"),
        description: `**procedure**: \`(open-fd-output-port \`*fd*\`)\`
**procedure**: \`(open-fd-output-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-output-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-fd-output-port ",
        endParen: true,
        params: ["fd", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s80"),
        description: `**procedure**: \`(open-fd-output-port \`*fd*\`)\`
**procedure**: \`(open-fd-output-port \`*fd*\` \`*b-mode*\`)\`
**procedure**: \`(open-fd-output-port \`*fd*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the file descriptor *fd*
**libraries: **\`(chezscheme)\`

*fd* must be a nonnegative exact integer and should be a valid open file descriptor. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The file descriptor is closed when the port is closed.
`
    },
    {
        name: "(open-file-input-port ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s29"),
        description: `**procedure**: \`(open-file-input-port \`*path*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input-port ",
        endParen: true,
        params: ["path", "options"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s29"),
        description: `**procedure**: \`(open-file-input-port \`*path*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input-port ",
        endParen: true,
        params: ["path", "options", "b-mode"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s29"),
        description: `**procedure**: \`(open-file-input-port \`*path*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input-port ",
        endParen: true,
        params: ["path", "options", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s29"),
        description: `**procedure**: \`(open-file-input-port \`*path*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input/output-port ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s31"),
        description: `**procedure**: \`(open-file-input/output-port \`*path*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input/output-port ",
        endParen: true,
        params: ["path", "options"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s31"),
        description: `**procedure**: \`(open-file-input/output-port \`*path*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input/output-port ",
        endParen: true,
        params: ["path", "options", "b-mode"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s31"),
        description: `**procedure**: \`(open-file-input/output-port \`*path*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-input/output-port ",
        endParen: true,
        params: ["path", "options", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s31"),
        description: `**procedure**: \`(open-file-input/output-port \`*path*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-input/output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input/output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-output-port ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s30"),
        description: `**procedure**: \`(open-file-output-port \`*path*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-output-port ",
        endParen: true,
        params: ["path", "options"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s30"),
        description: `**procedure**: \`(open-file-output-port \`*path*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-output-port ",
        endParen: true,
        params: ["path", "options", "b-mode"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s30"),
        description: `**procedure**: \`(open-file-output-port \`*path*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-file-output-port ",
        endParen: true,
        params: ["path", "options", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s30"),
        description: `**procedure**: \`(open-file-output-port \`*path*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\`)\`
**procedure**: \`(open-file-output-port \`*path*\` \`*options*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port for the named file
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.
`
    },
    {
        name: "(open-input-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s57"),
        description: `**procedure**: \`(open-input-file \`*path*\`)\`
**procedure**: \`(open-input-file \`*path*\` \`*options*\`)\`
**returns: **a new input port
**libraries: **\`(chezscheme)\`

*path* must be a string. \`open-input-file\` opens a textual input port for the file named by *path*. An exception is raised with condition type \`&i/o-filename\` if the file does not exist or cannot be opened for input.

*options*, if present, is a symbolic option name or option list. Possible symbolic option names are \`compressed\`, \`uncompressed\`, \`buffered\`, and \`unbuffered\`. An option list is a list containing zero or more symbolic option names.

The mutually exclusive \`compressed\` and \`uncompressed\` options determine whether the input file should be decompressed if it is compressed (where the compression format is inferred). (See \`open-output-file\`.) The default is \`uncompressed\`, so the \`uncompressed\` option is useful only as documentation.

The mutually exclusive \`buffered\` and \`unbuffered\` options determine whether input is buffered. When input is buffered, it is read in large blocks and buffered internally for efficiency to reduce the number of operating system requests. When the \`unbuffered\` option is specified, input is unbuffered, but not fully, since one character of buffering is required to support \`peek-char\` and \`unread-char\`. Input is buffered by default, so the \`buffered\` option is useful only as documentation.

For example, the call

\`(open-input-file "frob" '(compressed))\`

opens the file frob with decompression enabled.

The Revised Report version of \`open-input-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(open-input-file ",
        endParen: true,
        params: ["path", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s57"),
        description: `**procedure**: \`(open-input-file \`*path*\`)\`
**procedure**: \`(open-input-file \`*path*\` \`*options*\`)\`
**returns: **a new input port
**libraries: **\`(chezscheme)\`

*path* must be a string. \`open-input-file\` opens a textual input port for the file named by *path*. An exception is raised with condition type \`&i/o-filename\` if the file does not exist or cannot be opened for input.

*options*, if present, is a symbolic option name or option list. Possible symbolic option names are \`compressed\`, \`uncompressed\`, \`buffered\`, and \`unbuffered\`. An option list is a list containing zero or more symbolic option names.

The mutually exclusive \`compressed\` and \`uncompressed\` options determine whether the input file should be decompressed if it is compressed (where the compression format is inferred). (See \`open-output-file\`.) The default is \`uncompressed\`, so the \`uncompressed\` option is useful only as documentation.

The mutually exclusive \`buffered\` and \`unbuffered\` options determine whether input is buffered. When input is buffered, it is read in large blocks and buffered internally for efficiency to reduce the number of operating system requests. When the \`unbuffered\` option is specified, input is unbuffered, but not fully, since one character of buffering is required to support \`peek-char\` and \`unread-char\`. Input is buffered by default, so the \`buffered\` option is useful only as documentation.

For example, the call

\`(open-input-file "frob" '(compressed))\`

opens the file frob with decompression enabled.

The Revised Report version of \`open-input-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(open-input-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s75"),
        description: `**procedure**: \`(open-input-file \`*path*\`)\`
**returns: **a new input port
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. \`open-input-file\` creates a new textual input port for the file named by *path*, as if by \`open-file-input-port\` with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder.

The following shows the use of \`open-input-file\`, \`read\`, and \`close-port\` in an expression that gathers a list of objects from the file named by "myfile.ss."

\`(let ([p (open-input-file "myfile.ss")])\`
\`   (let f ([x (read p)])\`
\`     (if (eof-object? x)\`
\`         (begin\`
\`           (close-port p)\`
\`           '())\`
\`         (cons x (f (read p))))))\`
`
    },
    {
        name: "(open-input-output-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s89"),
        description: `**procedure**: \`(open-input-output-file \`*path*\`)\`
**procedure**: \`(open-input-output-file \`*path*\` \`*options*\`)\`
**returns: **a new input-output port
**libraries: **\`(chezscheme)\`

*path* must be a string. \`open-input-output-file\` opens a textual input-output port for the file named by *path*.

The port may be used to read from or write to the named file. The file is created if it does not already exist.

*options*, if present, is a symbolic option name or option list. Possible symbolic option names are \`buffered\`, \`unbuffered\`, \`exclusive\`, and \`nonexclusive\`. An option list is a list containing zero or more symbolic option names and possibly the two-element option \`mode \`*mode*. See the description of \`open-output-file\` for an explanation of these options.

Input/output files are usually closed using \`close-port\` but may also be closed with either \`close-input-port\` or \`close-output-port\`.
`
    },
    {
        name: "(open-input-output-file ",
        endParen: true,
        params: ["path", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s89"),
        description: `**procedure**: \`(open-input-output-file \`*path*\`)\`
**procedure**: \`(open-input-output-file \`*path*\` \`*options*\`)\`
**returns: **a new input-output port
**libraries: **\`(chezscheme)\`

*path* must be a string. \`open-input-output-file\` opens a textual input-output port for the file named by *path*.

The port may be used to read from or write to the named file. The file is created if it does not already exist.

*options*, if present, is a symbolic option name or option list. Possible symbolic option names are \`buffered\`, \`unbuffered\`, \`exclusive\`, and \`nonexclusive\`. An option list is a list containing zero or more symbolic option names and possibly the two-element option \`mode \`*mode*. See the description of \`open-output-file\` for an explanation of these options.

Input/output files are usually closed using \`close-port\` but may also be closed with either \`close-input-port\` or \`close-output-port\`.
`
    },
    {
        name: "(open-input-string ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s44"),
        description: `**procedure**: \`(open-input-string \`*string*\`)\`
**returns: **a new string input port
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(open-output-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s75"),
        description: `**procedure**: \`(open-output-file \`*path*\`)\`
**procedure**: \`(open-output-file \`*path*\` \`*options*\`)\`
**returns: **a new output port
**libraries: **\`(chezscheme)\`

*path* must be a string. \`open-output-file\` opens a textual output port for the file named by *path*.

*options*, if present, is a symbolic option name or option list. Possible symbolic option names are \`error\`, \`truncate\`, \`replace\`, \`append\`, \`compressed\`, \`uncompressed\`, \`buffered\`, \`unbuffered\`, \`exclusive\`, and \`nonexclusive\`. An option list is a list containing zero or more symbolic option names and possibly the two-element option \`mode \`*mode*.

The mutually exclusive \`error\`, \`truncate\`, \`replace\`, and \`append\` options are used to direct what happens when the file to be opened already exists.
`
    },
    {
        name: "(open-output-file ",
        endParen: true,
        params: ["path", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s75"),
        description: `**procedure**: \`(open-output-file \`*path*\`)\`
**procedure**: \`(open-output-file \`*path*\` \`*options*\`)\`
**returns: **a new output port
**libraries: **\`(chezscheme)\`

*path* must be a string. \`open-output-file\` opens a textual output port for the file named by *path*.

*options*, if present, is a symbolic option name or option list. Possible symbolic option names are \`error\`, \`truncate\`, \`replace\`, \`append\`, \`compressed\`, \`uncompressed\`, \`buffered\`, \`unbuffered\`, \`exclusive\`, and \`nonexclusive\`. An option list is a list containing zero or more symbolic option names and possibly the two-element option \`mode \`*mode*.

The mutually exclusive \`error\`, \`truncate\`, \`replace\`, and \`append\` options are used to direct what happens when the file to be opened already exists.
`
    },
    {
        name: "(open-output-file ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s76"),
        description: `**procedure**: \`(open-output-file \`*path*\`)\`
**returns: **a new output port
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. \`open-output-file\` creates a new output port for the file named by *path*, as if by \`open-file-output-port\` with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder.

The following shows the use of \`open-output-file\` to write a list of objects (the value of \`list-to-be-printed\`), separated by newlines, to the file named by "myfile.ss."

\`(let ([p (open-output-file "myfile.ss")])\`
\`   (let f ([ls list-to-be-printed])\`
\`     (if (not (null? ls))\`
\`         (begin\`
\`           (write (car ls) p)\`
\`           (newline p)\`
\`           (f (cdr ls)))))\`
\`   (close-port p))\`
`
    },
    {
        name: "(open-output-string)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s47"),
        description: `**procedure**: \`(open-output-string)\`
**returns: **a new string output port
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(open-process-ports ",
        endParen: true,
        params: ["command"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s5"),
        description: `**procedure**: \`(open-process-ports \`*command*\`)\`
**procedure**: \`(open-process-ports \`*command*\` \`*b-mode*\`)\`
**procedure**: \`(open-process-ports \`*command*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*command* must be a string. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure creates textual ports, each of whose transcoder is *?transcoder*. Otherwise, this procedure returns binary ports. *b-mode* specifies the buffer mode used by each of the ports returned by this procedure and defaults to \`block\`. Buffer modes are described in Section  of .

\`open-process-ports\` creates a subprocess to perform the operation specified by *command*. Unlike \`system\`, \`process\` returns immediately after creating the subprocess, i.e., without waiting for the subprocess to terminate. It returns four values:
`
    },
    {
        name: "(open-process-ports ",
        endParen: true,
        params: ["command", "b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s5"),
        description: `**procedure**: \`(open-process-ports \`*command*\`)\`
**procedure**: \`(open-process-ports \`*command*\` \`*b-mode*\`)\`
**procedure**: \`(open-process-ports \`*command*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*command* must be a string. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure creates textual ports, each of whose transcoder is *?transcoder*. Otherwise, this procedure returns binary ports. *b-mode* specifies the buffer mode used by each of the ports returned by this procedure and defaults to \`block\`. Buffer modes are described in Section  of .

\`open-process-ports\` creates a subprocess to perform the operation specified by *command*. Unlike \`system\`, \`process\` returns immediately after creating the subprocess, i.e., without waiting for the subprocess to terminate. It returns four values:
`
    },
    {
        name: "(open-process-ports ",
        endParen: true,
        params: ["command", "b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s5"),
        description: `**procedure**: \`(open-process-ports \`*command*\`)\`
**procedure**: \`(open-process-ports \`*command*\` \`*b-mode*\`)\`
**procedure**: \`(open-process-ports \`*command*\` \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*command* must be a string. If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure creates textual ports, each of whose transcoder is *?transcoder*. Otherwise, this procedure returns binary ports. *b-mode* specifies the buffer mode used by each of the ports returned by this procedure and defaults to \`block\`. Buffer modes are described in Section  of .

\`open-process-ports\` creates a subprocess to perform the operation specified by *command*. Unlike \`system\`, \`process\` returns immediately after creating the subprocess, i.e., without waiting for the subprocess to terminate. It returns four values:
`
    },
    {
        name: "(open-source-file ",
        endParen: true,
        params: ["sfd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s71"),
        description: `**procedure**: \`(open-source-file \`*sfd*\`)\`
**returns: **a port or \`#f\`
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. This procedure attempts to locate and open the source file identified by *sfd*. It returns a textual input port, positioned at the beginning of the file, if successful, and \`#f\` otherwise. It can fail even if a file with the correct name exists in one of the source directories when the file's checksum does not match the checksum recorded in *sfd*.
`
    },
    {
        name: "(open-string-input-port ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s35"),
        description: `**procedure**: \`(open-string-input-port \`*string*\`)\`
**returns: **a new textual input port that draws input from *string*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

The effect of modifying *string* after this procedure is called is unspecified. The new port may or may not have a transcoder, and if it does, the transcoder is implementation-dependent. While not required, implementations are encouraged to support \`port-position\` and \`set-port-position!\` for string ports.

\`(get-line (open-string-input-port "hi.\\nwhat's up?\\n")) \`=>\` "hi."\`

There is no need to close a string port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources.
`
    },
    {
        name: "(open-string-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s37"),
        description: `**procedure**: \`(open-string-output-port)\`
**returns: **two values, a new textual output port and an extraction procedure
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

The extraction procedure is a procedure that, when called without arguments, creates a string containing the accumulated characters in the port, clears the port of its accumulated characters, resets its position to zero, and returns the string. The accumulated characters include any characters written beyond the end of the current position, if the position has been set back from its maximum extent. While not required, implementations are encouraged to support \`port-position\` and \`set-port-position!\` for string ports.

\`(let-values ([(op g) (open-string-output-port)])\`
\`   (put-string op "some data")\`
\`   (let ([str1 (g)])\`
\`     (put-string op "new stuff")\`
\`     (list str1 (g)))) \`=>\` ("some data" "new stuff")\`

There is no need to close a string port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources.
`
    },
    {
        name: "optimize-level",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s104"),
        description: `**thread parameter**: \`optimize-level\`
**libraries: **\`(chezscheme)\`

This parameter can take on one of the four values 0, 1, 2, and 3.

In theory, this parameter controls the amount of optimization performed by the compiler. In practice, it does so only indirectly, and the only difference is between optimize level 3, at which the compiler generates "unsafe" code, and optimize levels 0-2, at which the compiler generates "safe" code. Safe code performs full type and bounds checking so that, for example, an attempt to apply a non-procedure, an attempt to take the car of a non-pair, or an attempt to reference beyond the end of a vector each result in an exception being raised. With unsafe code, the same situations may result in invalid memory references, corruption of the Scheme heap (which may cause seemingly unrelated problems later), system crashes, or other undesirable behaviors. Unsafe code is typically faster, but optimize-level 3 should be used with caution and only on sections of well-tested code that must run as quickly as possible.

While the compiler produces the same code for optimize levels 0-2, user-defined macro transformers can differentiate among the different levels if desired.
`
    },
    {
        name: "(or ",
        endParen: true,
        params: ["expr", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s12"),
        description: `**syntax**: \`(or \`*expr*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If no subexpressions are present, the \`or\` form evaluates to \`#f\`. Otherwise, \`or\` evaluates each subexpression in sequence from left to right until only one subexpression remains or a subexpression returns a value other than \`#f\`. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns a value other than \`#f\`, \`or\` returns that value without evaluating the remaining subexpressions. A syntax definition of \`or\` appears on page .

\`(let ([x 3])\`
\`   (or (< x 2) (> x 4))) \`=>\` #f \`
\` \`
\` (let ([x 5])\`
\`   (or (< x 2) (> x 4))) \`=>\` #t \`
\` \`
\` (or #f '(a b) '(c d)) \`=>\` (a b)\`
`
    },
    {
        name: "(ormap ",
        endParen: true,
        params: ["procedure", "list1", "list2", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s7"),
        description: `**procedure**: \`(ormap \`*procedure*\` \`*list1*\` \`*list2*\` ...)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`

\`ormap\` is identical to the Revised Report \`exists\`.
`
    },
    {
        name: "(output-port-buffer-mode ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s52"),
        description: `**procedure**: \`(output-port-buffer-mode \`*port*\`)\`
**returns: **the symbol representing the buffer mode of *port*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(output-port? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s44"),
        description: `**procedure**: \`(input-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an input or input/output port, \`#f\` otherwise
**procedure**: \`(output-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an output or input/output port, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs io simple)\`, \`(rnrs)\`
`
    },
    {
        name: "(pair? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s16"),
        description: `**procedure**: \`(pair? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a pair, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (pair? '(a b c)) \`=>\` #t\`
\` (pair? '(3 . 4)) \`=>\` #t\`
\` (pair? '()) \`=>\` #f\`
\` (pair? '#(a b)) \`=>\` #f\`
\` (pair? 3) \`=>\` #f\`
`
    },
    {
        name: "(parameterize ((",
        endParen: true,
        params: ["param", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s250"),
        description: `**syntax**: \`(parameterize ((\`*param*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the body *body1*\` \`*body2*\` ...\`
**libraries: **\`(chezscheme)\`

Using the syntactic form \`parameterize\`, the values of parameters can be changed in a manner analogous to \`fluid-let\` for ordinary variables. Each *param* is set to the value of the corresponding *expr* while the body is evaluated. When control leaves the body by normal return or by the invocation of a continuation created outside of the body, the parameters are restored to their original values. If control returns to the body via a continuation created during the execution of the body, the parameters are again set to their temporary values.

\`(define test\`
\`   (make-parameter 0))\`
\` (test)  \`=>\` 0\`
\` (test 1)\`
\` (test)  \`=>\` 1\`
\` (parameterize ([test 2])\`
\`   (test))  \`=>\` 2\`
\` (test)  \`=>\` 1\`
\` (parameterize ([test 2])\`
\`   (test 3)\`
\`   (test))  \`=>\` 3\`
\` (test)  \`=>\` 1\`
\` (define k (lambda (x) x))\`
\` (begin (set! k (call/cc k))\`
\`        'k)  \`=>\` k\`
\` (parameterize ([test 2])\`
\`   (test (call/cc k))\`
\`   (test))  \`=>\` k\`
\` (test)  \`=>\` 1\`
\` (k 3)  \`=>\` 3\`
\` (test)  \`=>\` 1\`

The definition of \`parameterize\` is similar to the definition of \`fluid-let\` (page ):

\`(define-syntax parameterize\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(_ () b1 b2 ...) #'(begin b1 b2 ...)]\`
\`       [(_ ((x e) ...) b1 b2 ...)\`
\`        (with-syntax ([(p ...) (generate-temporaries #'(x ...))]\`
\`                      [(y ...) (generate-temporaries #'(x ...))])\`
\`          #'(let ([p x] ... [y e] ...)\`
\`              (let ([swap (lambda ()\`
\`                            (let ([t (p)]) (p y) (set! y t))\`
\`                            ...)])\`
\`                (dynamic-wind swap (lambda () b1 b2 ...) swap))))])))\`
`
    },
    {
        name: "parent",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "parent-rtd",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(pariah ",
        endParen: true,
        params: ["expr1", "expr2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s127"),
        description: `**syntax**: \`(pariah \`*expr1*\` \`*expr2*\` ...)\`
**returns: **the values of the last subexpression
**libraries: **\`(chezscheme)\`

A \`pariah\` expression is just like a \`begin\` expression except that it informs the compiler that the code is expected to be executed infrequently. The compiler uses this information to optimize code layout, register assignments, and other aspects of the generated code. The \`pariah\` form can be used in performance-critical code to mark the branches of a conditional (e.g., \`if\`, \`cond\`, or \`case\`) that are less likely to be executed than the others.
`
    },
    {
        name: "(partition ",
        endParen: true,
        params: ["procedure", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s56"),
        description: `**procedure**: \`(partition \`*procedure*\` \`*list*\`)\`
**returns: **see below
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

*procedure* should accept one argument and return a single value. It should not modify *list*.

\`partition\` applies *procedure* to each element of *list* and returns two values: a new list containing only the elements for which *procedure* returns true, and a new list containing only the elements for which *procedure* returns \`#f\`. The elements of the returned lists appear in the same order as they appeared in the original list.

\`(partition odd? '(1 2 3 4)) \`=>\` (1 3)\`
\`                             \`\` (2 4)\`
\` (partition\`
\`   (lambda (x) (and (> x 0) (< x 10)))\`
\`   '(-5 15 3 14 -20 6 0 -9)) \`=>\` (3 6)\`
\`                             \`\` (-5 15 14 -20 0 -9)\`

The values returned by \`partition\` can be obtained by calling \`filter\` and \`remp\` separately, but this would require two calls to *procedure* for each element of *list*.
`
    },
    {
        name: "(path-absolute? ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(path-extension ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(path-first ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(path-last ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(path-parent ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(path-rest ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(path-root ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s154"),
        description: `**procedure**: \`(path-first \`*path*\`)\`
**procedure**: \`(path-rest \`*path*\`)\`
**procedure**: \`(path-last \`*path*\`)\`
**procedure**: \`(path-parent \`*path*\`)\`
**procedure**: \`(path-extension \`*path*\`)\`
**procedure**: \`(path-root \`*path*\`)\`
**returns: **the specified component of *path*
**procedure**: \`(path-absolute? \`*path*\`)\`
**returns: **\`#t\` if *path* is absolute, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

*path* must be a string. The return value is also a (possibly empty) string.

The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of *path*. The path parent component is the portion of *path* that does not include the path last component, if any, or the directory separator that separates it from the rest of the path.

If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., \`~/abc\` or \`~user/abc\`), the current directory (\`.\`), or the parent directory (\`..\`), \`path-first\` returns that component. For paths that consist only of such a directory, both \`path-first\` and \`path-parent\` act as identity procedures, while \`path-rest\` and \`path-last\` return the empty string.

The path extension component is the portion of *path* that follows the last dot (period) in the last component of a path name. The path root component is the portion of *path* that does not include the extension, if any, or the dot that precedes it.

If the first component names a root directory (including drives and shares under Windows) or home directory, \`path-absolute?\` returns \`#t\`. Otherwise, \`path-absolute?\` returns \`#f\`.

The tables below identify the components for several example paths, with underscores representing empty strings.

The second table shows the components when Windows drives and shares are involved.

The following procedure can be used to reproduce the tables above.

\`(define print-table\`
\`   (lambda path*\`
\`     (define print-row\`
\`       (lambda (abs? path first rest parent last root extension)\`
\`         (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n"\`
\`           abs? path first rest parent last root extension)))\`
\`     (print-row "path" "abs" "first" "rest" "parent" "last" "root" "ext")\`
\`     (for-each\`
\`       (lambda (path)\`
\`         (define uscore (lambda (s) (if (eqv? s "") "_" s)))\`
\`         (apply print-row path\`
\`           (map (lambda (s) (if (eqv? s "") "_" s))\`
\`                (list (path-absolute? path) (path-first path)\`
\`                  (path-rest path) (path-parent path) (path-last path)\`
\`                  (path-root path) (path-extension path)))))\`
\`       path*)))\`

For example, the first table can be produced with:

\`(print-table "a" "a/" "a/b" "a/b.c" "/" "/a/b.c" "~/a/b.c"\`
\`   "~u/a/b.c" "../..")\`

while the second can be produced (under Windows) with:

\`(print-table "c:" "c:/" "c:a/b" "//s/a/b.c" "//s.com")\`
`
    },
    {
        name: "(peek-char)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s83"),
        description: `**procedure**: \`(peek-char)\`
**procedure**: \`(peek-char \`*textual-input-port*\`)\`
**returns: **the next character from *textual-input-port*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-input-port* is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to \`lookahead-char\`.
`
    },
    {
        name: "(peek-char ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s83"),
        description: `**procedure**: \`(peek-char)\`
**procedure**: \`(peek-char \`*textual-input-port*\`)\`
**returns: **the next character from *textual-input-port*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-input-port* is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to \`lookahead-char\`.
`
    },
    {
        name: "(petite?)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s256"),
        description: `**procedure**: \`(petite?)\`
**returns: **\`#t\` if called in , \`#f\` otherwise
**libraries: **\`(chezscheme)\`

The only difference between and is that the compiler is not available in the former, so this predicate can serve as a way to determine if the compiler is available.
`
    },
    {
        name: "(port-bol? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s27"),
        description: `**procedure**: \`(port-bol? \`*port*\`)\`
**returns: **\`#t\` if *port*'s BOL flag is set, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(port-closed? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s25"),
        description: `**procedure**: \`(port-closed? \`*port*\`)\`
**returns: **\`#t\` if *port* is closed, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(let ([p (open-output-string)])\`
\`   (port-closed? p)) \`=>\` #f \`
\` \`
\` (let ([p (open-output-string)])\`
\`   (close-port p)\`
\`   (port-closed? p)) \`=>\` #t\`
`
    },
    {
        name: "(port-eof? ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s68"),
        description: `**procedure**: \`(port-eof? \`*input-port*\`)\`
**returns: **\`#t\` if *input-port* is at end-of-file, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure is similar to \`lookahead-u8\` on a binary input port or \`lookahead-char\` on a textual input port, except that instead of returning the next byte/character or eof object, it returns a boolean value to indicate whether the value would be the eof object.
`
    },
    {
        name: "(port-file-compressed! ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s39"),
        description: `**procedure**: \`(port-file-compressed! \`*port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(port-file-descriptor ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s53"),
        description: `**procedure**: \`(port-file-descriptor \`*port*\`)\`
**returns: **the file descriptor associated with *port*
**libraries: **\`(chezscheme)\`

*port* must be a file port, i.e., a port for which *file-port?* returns \`#t\`.
`
    },
    {
        name: "(port-handler ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s15"),
        description: `**procedure**: \`(port-handler \`*port*\`)\`
**returns: **a procedure
**libraries: **\`(chezscheme)\`

For generic ports, \`port-handler\` returns the handler passed to one of the generic port creation procedures described above. For ports created by \`open-input-file\` and similar procedures, \`port-handler\` returns an internal handler that may be invoked in the same manner as any other handler.
`
    },
    {
        name: "(port-has-port-length? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s31"),
        description: `**procedure**: \`(port-length \`*port*\`)\`
**procedure**: \`(file-length \`*port*\`)\`
**returns: **the length of the file or other object to which *port* refers
**procedure**: \`(port-has-port-length? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-length\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the length of the underlying stream of characters or bytes to be determined. If so, the procedure \`port-has-port-length?\` returns \`#t\` and \`port-length\` returns the current length. For binary ports, the length is always an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character count. The length may be used at some later time to reset the length if the port supports \`set-port-length!\`. If \`port-length\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

File lengths beyond 2 might not be reported property for compressed files on 32-bit versions of the system.

\`file-length\` is identical to \`port-length\`.
`
    },
    {
        name: "(port-has-port-nonblocking?? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s33"),
        description: `**procedure**: \`(port-nonblocking? \`*port*\`)\`
**returns: **\`#t\` if the port is in nonblocking mode, \`#f\` otherwise
**procedure**: \`(port-has-port-nonblocking?? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-nonblocking?\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the nonblocking status of the port to be determined. If so, the procedure \`port-has-port-nonblocking??\` returns \`#t\` and \`port-nonblocking?\` returns a boolean value reflecting whether the port is in nonblocking mode.
`
    },
    {
        name: "(port-has-port-position? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s49"),
        description: `**procedure**: \`(port-position \`*port*\`)\`
**returns: **the port's current position
**procedure**: \`(port-has-port-position? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-position\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A port may allow queries to determine its current position in the underlying stream of bytes or characters. If so, the procedure \`port-has-port-position?\` returns \`#t\` and \`port-position\` returns the current position. For binary ports, the position is always an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character displacement in the underlying stream. The position may be used at some later time to reset the position if the port supports \`set-port-position!\`. If \`port-position\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(port-has-set-port-length!? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s32"),
        description: `**procedure**: \`(set-port-length! \`*port*\` \`*len*\`)\`
**returns: **unspecified
**procedure**: \`(port-has-set-port-length!? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`set-port-length!\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the length of the underlying stream of characters or bytes to be set, i.e., extended or truncated. If so, the procedure \`port-has-set-port-length!?\` returns \`#t\` and \`set-port-length!\` changes the length. For binary ports, the length *len* must be an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified, as described in the entry for \`port-length\` above, but *len* must be an appropriate length for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to \`port-length\` on the same port. If \`set-port-length!\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

It is not possible to set the length of a port opened with compression to an arbitrary position, and the result of an attempt to set the length of a compressed file beyond 2 on 32-bit versions of the system is undefined.
`
    },
    {
        name: "(port-has-set-port-nonblocking!? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s34"),
        description: `**procedure**: \`(set-port-nonblocking! \`*port*\` \`*obj*\`)\`
**returns: **unspecified
**procedure**: \`(port-has-set-port-nonblocking!? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`set-port-nonblocking!\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow reads or writes to be performed in a "nonblocking" fashion. If so, the procedure \`port-has-set-port-nonblocking!?\` returns \`#t\` and \`set-port-nonblocking!\` sets the port to nonblocking mode (if *obj* is a true value) or blocking mode (if *obj* is \`#f\`). If \`set-port-nonblocking!\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

Ports created by the standard Revised port opening procedures are initially set in blocking mode by default. The same is true for most of the procedures described in this document. A generic port based on a nonblocking source may be nonblocking initially. A port returned by \`open-fd-input-port\`, \`open-fd-output-port\`, or \`open-fd-input/output-port\` is initially in nonblocking mode if the file-descriptor passed in is in nonblocking mode. Similarly, a port returned by \`standard-input-port\`, \`standard-output-port\`, or \`standard-error-port\` is initially in nonblocking mode if the underlying stdin, stdout, or stderr file descriptor is in nonblocking mode.

Although \`get-bytevector-some\` and \`get-string-some\` normally cannot return an empty bytevector or empty string, they can if the port is in nonblocking mode and no input is available. Also, \`get-bytevector-some!\` and \`get-string-some!\` may not read any data if the port is in nonblocking mode and no data is available. Similarly, \`put-bytevector-some\` and \`put-string-some\` may not write any data if the port is in nonblocking mode and no room is available.

Nonblocking mode is not supported under Windows.
`
    },
    {
        name: "(port-has-set-port-position!? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s50"),
        description: `**procedure**: \`(set-port-position! \`*port*\` \`*pos*\`)\`
**returns: **unspecified
**procedure**: \`(port-has-set-port-position!? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`set-port-position!\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A port may allow its current position to be moved directly to a different position in the underlying stream of bytes or characters. If so, the procedure \`port-has-set-port-position!?\` returns \`#t\` and \`set-port-position!\` changes the current position. For binary ports, the position *pos* must be an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified, as described in the entry for \`port-position\` above, but *pos* must be an appropriate position for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to \`port-position\` on the same port. If \`set-port-position!\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

If *port* is a binary output port and the position is set beyond the current end of the data in the underlying stream, the stream is not extended until new data is written at that position. If new data is written at that position, the contents of each intervening position is unspecified. Binary ports created with \`open-file-output-port\` and \`open-file-input/output-port\` can always be extended in this manner within the limits of the underlying operating system. In other cases, attempts to set the port beyond the current end of data in the underlying object may result in an exception with condition type \`&i/o-invalid-position\`.
`
    },
    {
        name: "(port-input-buffer ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(port-input-count ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s18"),
        description: `**procedure**: \`(port-input-count \`*input-port*\`)\`
**procedure**: \`(textual-port-input-count \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-count \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return an exact integer representing the number of characters or bytes left to be read from the port's input buffer, i.e., the difference between the buffer size and index.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart.
`
    },
    {
        name: "(port-input-empty? ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s19"),
        description: `**procedure**: \`(port-input-empty? \`*input-port*\`)\`
**returns: **\`#t\` if the port's input buffer contains no more data, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

This procedure determines whether the port's input count is zero without computing or returning the actual count.
`
    },
    {
        name: "(port-input-index ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(port-input-size ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(port-length ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s31"),
        description: `**procedure**: \`(port-length \`*port*\`)\`
**procedure**: \`(file-length \`*port*\`)\`
**returns: **the length of the file or other object to which *port* refers
**procedure**: \`(port-has-port-length? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-length\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the length of the underlying stream of characters or bytes to be determined. If so, the procedure \`port-has-port-length?\` returns \`#t\` and \`port-length\` returns the current length. For binary ports, the length is always an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character count. The length may be used at some later time to reset the length if the port supports \`set-port-length!\`. If \`port-length\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

File lengths beyond 2 might not be reported property for compressed files on 32-bit versions of the system.

\`file-length\` is identical to \`port-length\`.
`
    },
    {
        name: "(port-name ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s29"),
        description: `**procedure**: \`(port-name \`*port*\`)\`
**returns: **the name associated with *port*
**libraries: **\`(chezscheme)\`

The name may be any object but is usually a string or \`#f\` (denoting no name). For file ports, the name is typically a string naming the file.

\`(let ([p (open-input-file "myfile.ss")])\`
\`   (port-name p)) \`=>\` "myfile.ss" \`
\` \`
\` (let ([p (open-output-string)])\`
\`   (port-name p)) \`=>\` "string"\`
`
    },
    {
        name: "(port-nonblocking? ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s33"),
        description: `**procedure**: \`(port-nonblocking? \`*port*\`)\`
**returns: **\`#t\` if the port is in nonblocking mode, \`#f\` otherwise
**procedure**: \`(port-has-port-nonblocking?? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-nonblocking?\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the nonblocking status of the port to be determined. If so, the procedure \`port-has-port-nonblocking??\` returns \`#t\` and \`port-nonblocking?\` returns a boolean value reflecting whether the port is in nonblocking mode.
`
    },
    {
        name: "(port-output-buffer ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(port-output-count ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s22"),
        description: `**procedure**: \`(port-output-count \`*output-port*\`)\`
**procedure**: \`(textual-port-output-count \`*textual-output-port*\`)\`
**procedure**: \`(binary-port-output-count \`*binary-output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return an exact integer representing the amount of space in characters or bytes available to be written in the port's output buffer, i.e., the difference between the buffer size and index.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart.
`
    },
    {
        name: "(port-output-full? ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s23"),
        description: `**procedure**: \`(port-output-full? \`*output-port*\`)\`
**returns: **\`#t\` if the port's input buffer has no more room, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

This procedure determines whether the port's output count is zero without computing or returning the actual count.
`
    },
    {
        name: "(port-output-index ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(port-output-size ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(port-position ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s49"),
        description: `**procedure**: \`(port-position \`*port*\`)\`
**returns: **the port's current position
**procedure**: \`(port-has-port-position? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`port-position\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A port may allow queries to determine its current position in the underlying stream of bytes or characters. If so, the procedure \`port-has-port-position?\` returns \`#t\` and \`port-position\` returns the current position. For binary ports, the position is always an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character displacement in the underlying stream. The position may be used at some later time to reset the position if the port supports \`set-port-position!\`. If \`port-position\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(port-transcoder ",
        endParen: true,
        params: ["port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s48"),
        description: `**procedure**: \`(port-transcoder \`*port*\`)\`
**returns: **the transcoder associated with *port* if any, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure always returns \`#f\` for binary ports and may return \`#f\` for some textual ports.
`
    },
    {
        name: "(port? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s43"),
        description: `**procedure**: \`(port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a port, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(positive? ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s94"),
        description: `**procedure**: \`(positive? \`*real*\`)\`
**returns: **\`#t\` if *real* is greater than zero, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`positive?\` is equivalent to \`(lambda (x) (> x 0))\`.

\`(positive? 128) \`=>\` #t\`
\` (positive? 0.0) \`=>\` #f\`
\` (positive? 1.8e-15) \`=>\` #t\`
\` (positive? -2/3) \`=>\` #f\`
\` (positive? .001-0.0i) \`=>\` \`*exception: not a real number*
`
    },
    {
        name: "predicate",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s177"),
        description: `**syntax**: \`predicate\`
**syntax**: \`prefix\`
**syntax**: \`constructor\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "prefix",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s177"),
        description: `**syntax**: \`predicate\`
**syntax**: \`prefix\`
**syntax**: \`constructor\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(pretty-file ",
        endParen: true,
        params: ["ifn", "ofn"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s94"),
        description: `**procedure**: \`(pretty-file \`*ifn*\` \`*ofn*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*ifn* and *ofn* must be strings. \`pretty-file\` reads each object in turn from the file named by *ifn* and pretty prints the object to the file named by *ofn*. Comments present in the input are discarded by the reader and so do not appear in the output file. If the file named by *ofn* already exists, it is replaced.
`
    },
    {
        name: "(pretty-format ",
        endParen: true,
        params: ["sym"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s95"),
        description: `**procedure**: \`(pretty-format \`*sym*\`)\`
**returns: **see below
**procedure**: \`(pretty-format \`*sym*\` \`*fmt*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

By default, the pretty printer uses a generic algorithm for printing each form. This procedure is used to override this default and guide the pretty-printers treatment of specific forms. The symbol *sym* names a syntactic form or procedure. With just one argument, \`pretty-format\` returns the current format associated with *sym*, or \`#f\` if no format is associated with *sym*.

In the two-argument case, the format *fmt* is associated with *sym* for future invocations of the pretty printer. *fmt* must be in the formatting language described below.

Some of the format forms are used for matching when there are multiple alternatives, while others are used for matching and control indentation or printing. A description of each *fmt* is given below.
`
    },
    {
        name: "(pretty-format ",
        endParen: true,
        params: ["sym", "fmt"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s95"),
        description: `**procedure**: \`(pretty-format \`*sym*\`)\`
**returns: **see below
**procedure**: \`(pretty-format \`*sym*\` \`*fmt*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

By default, the pretty printer uses a generic algorithm for printing each form. This procedure is used to override this default and guide the pretty-printers treatment of specific forms. The symbol *sym* names a syntactic form or procedure. With just one argument, \`pretty-format\` returns the current format associated with *sym*, or \`#f\` if no format is associated with *sym*.

In the two-argument case, the format *fmt* is associated with *sym* for future invocations of the pretty printer. *fmt* must be in the formatting language described below.

Some of the format forms are used for matching when there are multiple alternatives, while others are used for matching and control indentation or printing. A description of each *fmt* is given below.
`
    },
    {
        name: "pretty-initial-indent",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s100"),
        description: `**thread parameter**: \`pretty-initial-indent\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a nonnegative fixnum.
`
    },
    {
        name: "pretty-line-length",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s98"),
        description: `**thread parameter**: \`pretty-line-length\`
**thread parameter**: \`pretty-one-line-limit\`
**libraries: **\`(chezscheme)\`

The value of each of these parameters must be a positive fixnum.
`
    },
    {
        name: "pretty-maximum-lines",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s103"),
        description: `**thread parameter**: \`pretty-maximum-lines\`
**libraries: **\`(chezscheme)\`

The parameter \`pretty-maximum-lines\` controls how many lines \`pretty-print\` prints when it is called. If set to \`#f\` (the default), no limit is imposed; if set to a nonnegative fixnum *n*, at most *n* lines are printed.
`
    },
    {
        name: "pretty-one-line-limit",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s98"),
        description: `**thread parameter**: \`pretty-line-length\`
**thread parameter**: \`pretty-one-line-limit\`
**libraries: **\`(chezscheme)\`

The value of each of these parameters must be a positive fixnum.
`
    },
    {
        name: "(pretty-print ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s93"),
        description: `**procedure**: \`(pretty-print \`*obj*\`)\`
**procedure**: \`(pretty-print \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *textual-output-port* is not supplied, it defaults to the current output port.

\`pretty-print\` is similar to \`write\` except that it uses any number of spaces and newlines in order to print *obj* in a style that is pleasing to look at and which shows the nesting level via indentation. For example,

\`(pretty-print '(define factorial (lambda (n) (let fact ((i n) (a 1))\`
\`   (if (= i 0) a (fact (- i 1) (* a i)))))))\`

might produce

\`(define factorial\`
\`   (lambda (n)\`
\`     (let fact ([i n] [a 1])\`
\`       (if (= i 0) a (fact (- i 1) (* a i))))))\`
`
    },
    {
        name: "(pretty-print ",
        endParen: true,
        params: ["obj", "textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s93"),
        description: `**procedure**: \`(pretty-print \`*obj*\`)\`
**procedure**: \`(pretty-print \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

If *textual-output-port* is not supplied, it defaults to the current output port.

\`pretty-print\` is similar to \`write\` except that it uses any number of spaces and newlines in order to print *obj* in a style that is pleasing to look at and which shows the nesting level via indentation. For example,

\`(pretty-print '(define factorial (lambda (n) (let fact ((i n) (a 1))\`
\`   (if (= i 0) a (fact (- i 1) (* a i)))))))\`

might produce

\`(define factorial\`
\`   (lambda (n)\`
\`     (let fact ([i n] [a 1])\`
\`       (if (= i 0) a (fact (- i 1) (* a i))))))\`
`
    },
    {
        name: "pretty-standard-indent",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s102"),
        description: `**thread parameter**: \`pretty-standard-indent\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a nonnegative fixnum.

This determines the amount by which \`pretty-print\` indents subexpressions of most forms, such as \`let\` expressions, from the form's keyword or first subexpression.
`
    },
    {
        name: "print-brackets",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s125"),
        description: `**thread parameter**: \`print-brackets\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "print-char-name",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s108"),
        description: `**thread parameter**: \`print-char-name\`
**libraries: **\`(chezscheme)\`

When \`print-char-name\` is set to \`#f\` (the default), associations created by \`char-name\` are ignored by \`write\`, \`put-datum\`, \`pretty-print\`, and the \`format\` "\`~s\`" directive. Otherwise, these procedures use the names established by \`char-name\` when printing character objects.

\`(char-name 'etx #\\x3)\`
\` (format "~s" #\\x3) \`=>\` "#\\\\x3"\`
\` (parameterize ([print-char-name #t])\`
\`   (format "~s" #\\x3)) \`=>\` "#\\\\etx"\`
`
    },
    {
        name: "print-extended-identifiers",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s127"),
        description: `**thread parameter**: \`print-extended-identifiers\`
**libraries: **\`(chezscheme)\`

Chez Scheme extends the syntax of identifiers as described in Section , except within a set of forms prefixed by \`#!r6rs\` (which is implied in a library or top-level program).

When this parameter is set to false (the default), identifiers in the extended set are printed with hex scalar value escapes as necessary to conform to the R6RS syntax for identifiers. When this parameter is set to a true value, identifiers in the extended set are printed without the escapes. Identifiers whose names fall outside of both syntaxes are printed with the escapes regardless of the setting of this parameter.

For example:

\`(parameterize ([print-extended-identifiers #f])\`
\`   (printf "~s\\n~s\\n"\`
\`     '(1+ --- { } .xyz)\`
\`     (string->symbol "123")))\`

prints

\`(\\x31;+ \\x2D;-- \\x7B; \\x7D; \\x2E;xyz)\`
\` \\x31;23\`

while

\`(parameterize ([print-extended-identifiers #t])\`
\`   (printf "~s\\n~s\\n"\`
\`     '(1+ --- { } .xyz)\`
\`     (string->symbol "123")))\`

prints

\`(1+ --- { } .xyz)\`
\` \\x31;23\`
`
    },
    {
        name: "print-gensym",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s120"),
        description: `**thread parameter**: \`print-gensym\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "print-graph",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s110"),
        description: `**thread parameter**: \`print-graph\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "print-length",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s114"),
        description: `**thread parameter**: \`print-level\`
**thread parameter**: \`print-length\`
**libraries: **\`(chezscheme)\`

These parameters can be used to limit the extent to which nested or multiple-element structures are printed. When called without arguments, \`print-level\` returns the current print level and \`print-length\` returns the current print length. When called with one argument, which must be a nonnegative fixnum or \`#f\`, \`print-level\` sets the current print level and \`print-length\` sets the current print length to the argument.
`
    },
    {
        name: "print-level",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s114"),
        description: `**thread parameter**: \`print-level\`
**thread parameter**: \`print-length\`
**libraries: **\`(chezscheme)\`

These parameters can be used to limit the extent to which nested or multiple-element structures are printed. When called without arguments, \`print-level\` returns the current print level and \`print-length\` returns the current print length. When called with one argument, which must be a nonnegative fixnum or \`#f\`, \`print-level\` sets the current print level and \`print-length\` sets the current print length to the argument.
`
    },
    {
        name: "print-precision",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s130"),
        description: `**thread parameter**: \`print-precision\`
**libraries: **\`(chezscheme)\`

When \`print-precision\` is set to \`#f\` (the default), \`write\`, \`put-datum\`, \`pretty-print\`, and the \`format\` "\`~s\`" directive do not include the vertical-bar "mantissa-width" syntax after each floating-point number. When set to a nonnegative exact integer, the mantissa width is included, as per the precision argument to \`number->string\`.
`
    },
    {
        name: "print-radix",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s119"),
        description: `**thread parameter**: \`print-radix\`
**libraries: **\`(chezscheme)\`

The \`print-radix\` parameter determines the radix in which numbers are printed by \`write\`, \`pretty-print\`, and \`display\`. Its value should be an integer between 2 and 36, inclusive. Its default value is 10.

When the value of \`print-radix\` is not 10, \`write\` and \`pretty-print\` print a radix prefix before the number (\`#b\` for radix 2, \`#o\` for radix 8, \`#x\` for radix 16, and \`#\`*n*\`r\` for any other radix *n*).

Since objects printed through the \`~s\` and \`~a\` options in the format control strings of \`format\`, \`printf\`, and \`fprintf\` are printed as with \`write\` and \`display\`, the printing of such objects is also affected by \`print-radix\`.

\`(format "~s" 11242957) \`=>\` "11242957" \`
\` \`
\` (parameterize ([print-radix 16])\`
\`   (format "~s" 11242957)) \`=>\` "#xAB8DCD" \`
\` \`
\` (parameterize ([print-radix 16])\`
\`   (format "~a" 11242957)) \`=>\` "AB8DCD"\`
`
    },
    {
        name: "print-record",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s186"),
        description: `**thread parameter**: \`print-record\`
**libraries: **\`(chezscheme)\`

This parameter controls the printing of records. If set to true (the default) the record writer associated with a record type is used to print records of that type. If set to false, all records are printed with the syntax \`#<record of type \`*name*\`>\`, where *name* is the name of the record type as returned by \`record-type-name\`.
`
    },
    {
        name: "print-unicode",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s131"),
        description: `**thread parameter**: \`print-unicode\`
**libraries: **\`(chezscheme)\`

When \`print-unicode\` is set to \`#f\`, \`write\`, \`put-datum\`, \`pretty-print\`, and the \`format\` "\`~s\`" directive display Unicode characters with encodings 80 (128) and above that appear within character objects, symbols, and strings using hexadecimal character escapes. When set to a true value (the default), they are displayed like other printing characters, as if by \`put-char\`.

\`(format "~s" #\\x3bb) \`=>\` "#\\\\\`\`"\`
\` (parameterize ([print-unicode #f])\`
\`   (format "~s" #\\x3bb)) \`=>\` "#\\\\x3BB"\`
`
    },
    {
        name: "print-vector-length",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s128"),
        description: `**thread parameter**: \`print-vector-length\`
**libraries: **\`(chezscheme)\`

When \`print-vector-length\` is set to a true value, \`write\`, \`put-datum\`, and \`pretty-print\` includes the length for all vectors between the "\`#\`" and open parenthesis, all bytevectors between the "\`#vu8\`" and open parenthesis, and all fxvectors between the "\`#vfx\`" and open parenthesis. This parameter is set to \`#f\` by default.
`
    },
    {
        name: "(printf ",
        endParen: true,
        params: ["format-string", "obj", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s106"),
        description: `**procedure**: \`(printf \`*format-string*\` \`*obj*\` ...)\`
**procedure**: \`(fprintf \`*textual-output-port*\` \`*format-string*\` \`*obj*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

These procedures are simple wrappers for \`format\`. \`printf\` prints the formatted output to the current output, as with a first-argument of \`#t\` to \`format\`, and \`fprintf\` prints the formatted output to the *textual-output-port*, as when the first argument to \`format\` is a port.
`
    },
    {
        name: "(",
        endParen: true,
        params: ["expr0", "expr1", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s1"),
        description: `**syntax**: \`(\`*expr0*\` \`*expr1*\` ...)\`
**returns: **values of applying the value of *expr0* to the values of *expr1*\` ...\`

Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application. The expressions *expr0* and *expr1*\` ...\` are evaluated; each should evaluate to a single value. After each of these expressions has been evaluated, the value of *expr0* is applied to the values of *expr1*\` ...\`. If *expr0* does not evaluate to a procedure, or if the procedure does not accept the number of arguments provided, an exception with condition type \`&assertion\` is raised.
`
    },
    {
        name: "(procedure-arity-mask ",
        endParen: true,
        params: ["proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s201"),
        description: `**procedure**: \`(procedure-arity-mask \`*proc*\`)\`
**returns: **an exact integer bitmask identifying the accepted argument counts of *proc*
**libraries: **\`(chezscheme)\`

The bitmask is represented as two's complement number with the bit at each index *n* set if and only if *proc* accepts *n* arguments.

The two's complement encoding implies that if *proc* accepts *n* or more arguments, the encoding is a negative number, since all the bits from *n* and up are set. For example, if *proc* accepts any number of arguments, the two's complement encoding of all bits set is \`-1\`.

\`(procedure-arity-mask (lambda () 'none)) \`=>\` 1\`
\` (procedure-arity-mask car) \`=>\` 2\`
\` (procedure-arity-mask (case-lambda [() 'none] [(x) x])) \`=>\` 3\`
\` (procedure-arity-mask (lambda x x)) \`=>\` -1\`
\` (procedure-arity-mask (case-lambda [() 'none] [(x y . z) x])) \`=>\` -3\`
\` (procedure-arity-mask (case-lambda)) \`=>\` 0\`
\` (logbit? 1 (procedure-arity-mask pair?)) \`=>\` #t\`
\` (logbit? 2 (procedure-arity-mask pair?)) \`=>\` #f\`
\` (logbit? 2 (procedure-arity-mask cons)) \`=>\` #t\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(procedure? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s23"),
        description: `**procedure**: \`(procedure? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a procedure, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (procedure? car) \`=>\` #t\`
\` (procedure? 'car) \`=>\` #f\`
\` (procedure? (lambda (x) x)) \`=>\` #t\`
\` (procedure? '(lambda (x) x)) \`=>\` #f\`
\` (call/cc procedure?) \`=>\` #t\`
`
    },
    {
        name: "(process ",
        endParen: true,
        params: ["command"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s7"),
        description: `**procedure**: \`(process \`*command*\`)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`

*command* must be a string.

\`process\` is similar to \`open-process-ports\`, but less general. It does not return a port from which the subprocess's standard error output can be read, and it always creates textual ports. It returns a list of three values rather than the four separate values of \`open-process-ports\`. The returned list contains, in order: *from-stdout*, *to-stdin*, and *process-id*, which correspond to the second, first, and fourth return values of \`open-process-ports\`.
`
    },
    {
        name: "(profile ",
        endParen: true,
        params: ["source-object"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s144"),
        description: `**syntax**: \`(profile \`*source-object*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

A \`profile\` form has the effect of accounting to the source position identified by *source-object* the number of times the \`profile\` form is executed. Profile forms are generated implicitly by the expander for source expressions in annotated input, e.g., input read by the compiler or interpreter from a Scheme source file, so this form is typically useful only when unannotated source code is produced by the front end for some language that targets Scheme.
`
    },
    {
        name: "(profile-clear)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s146"),
        description: `**procedure**: \`(profile-clear)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Calling this procedure causes profile information to be cleared, i.e., the counts associated with each section of code are set to zero.
`
    },
    {
        name: "(profile-clear-database)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s166"),
        description: `**procedure**: \`(profile-clear-database)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure clears the compiler's profile database. It has no impact on the counts associated with individual sections of instrumented code; \`profile-clear\` can be used to reset those counts.
`
    },
    {
        name: "(profile-dump)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s148"),
        description: `**procedure**: \`(profile-dump)\`
**returns: **a list of pairs of source-object and count
**libraries: **\`(chezscheme)\`

This procedure produces a dump of all profile information gathered since startup or the last call to \`profile-clear\`. It returns a list of pairs, where the car of each pair is a source object (Section ) and the cdr is an exact nonnegative integer count.

The list might contain more than one entry per source object due to macro expansion and procedure inlining, and it might contain more than one (non-eq) source object per file and source position due to separate compilation. In such cases, the counts are not overlapping and can be summed together to obtain the full count.

The advantage of \`profile-dump\` over \`profile-dump-list\` is that \`profile-dump\` performs only minimal processing and preserves complete source objects, including their embedded source-file descriptors. It might be used, for example, to dump profile information to a fasl file on one machine for subsequent processing on another.
`
    },
    {
        name: "(profile-dump-data ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s163"),
        description: `**procedure**: \`(profile-dump-data \`*path*\`)\`
**procedure**: \`(profile-dump-data \`*path*\` \`*dump*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string.

This procedure writes, in a machine-readable form consumable by \`profile-load-data\`, profile counts represented by *dump* to the file named by *path*, replacing the file if it already exists. *dump* defaults to the value returned by \`profile-dump\`.
`
    },
    {
        name: "(profile-dump-data ",
        endParen: true,
        params: ["path", "dump"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s163"),
        description: `**procedure**: \`(profile-dump-data \`*path*\`)\`
**procedure**: \`(profile-dump-data \`*path*\` \`*dump*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string.

This procedure writes, in a machine-readable form consumable by \`profile-load-data\`, profile counts represented by *dump* to the file named by *path*, replacing the file if it already exists. *dump* defaults to the value returned by \`profile-dump\`.
`
    },
    {
        name: "(profile-dump-html)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s159"),
        description: `**procedure**: \`(profile-dump-html)\`
**procedure**: \`(profile-dump-html \`*prefix*\`)\`
**procedure**: \`(profile-dump-html \`*prefix*\` \`*dump*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure produces one or more HTML files, including profile.html, which contains color-coded summary information, and one file *source*.html for each source file *source* containing a color-coded copy of the source code, as described in the lead-in to this section. If *prefix* is specified, it must be a string and is prepended to the names of the generated HTML files. For example, if *prefix* is \`"/tmp/"\`, the generated files are placed in the directory /tmp. The raw profile information is obtained from *dump*, which defaults to the value returned by \`profile-dump\`.
`
    },
    {
        name: "(profile-dump-html ",
        endParen: true,
        params: ["prefix"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s159"),
        description: `**procedure**: \`(profile-dump-html)\`
**procedure**: \`(profile-dump-html \`*prefix*\`)\`
**procedure**: \`(profile-dump-html \`*prefix*\` \`*dump*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure produces one or more HTML files, including profile.html, which contains color-coded summary information, and one file *source*.html for each source file *source* containing a color-coded copy of the source code, as described in the lead-in to this section. If *prefix* is specified, it must be a string and is prepended to the names of the generated HTML files. For example, if *prefix* is \`"/tmp/"\`, the generated files are placed in the directory /tmp. The raw profile information is obtained from *dump*, which defaults to the value returned by \`profile-dump\`.
`
    },
    {
        name: "(profile-dump-html ",
        endParen: true,
        params: ["prefix", "dump"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s159"),
        description: `**procedure**: \`(profile-dump-html)\`
**procedure**: \`(profile-dump-html \`*prefix*\`)\`
**procedure**: \`(profile-dump-html \`*prefix*\` \`*dump*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure produces one or more HTML files, including profile.html, which contains color-coded summary information, and one file *source*.html for each source file *source* containing a color-coded copy of the source code, as described in the lead-in to this section. If *prefix* is specified, it must be a string and is prepended to the names of the generated HTML files. For example, if *prefix* is \`"/tmp/"\`, the generated files are placed in the directory /tmp. The raw profile information is obtained from *dump*, which defaults to the value returned by \`profile-dump\`.
`
    },
    {
        name: "(profile-dump-list)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s162"),
        description: `**procedure**: \`(profile-dump-list)\`
**procedure**: \`(profile-dump-list \`*warn?*\`)\`
**procedure**: \`(profile-dump-list \`*warn?*\` \`*dump*\`)\`
**returns: **a list of profile entries (see below)
**libraries: **\`(chezscheme)\`

This procedure produces a dump of all profile information present in *dump*, which defaults to the value returned by \`profile-dump\`. It returns a list of entries, each of which is itself a list containing the following elements identifying one block of code and how many times it has been executed.

\`profile-dump-list\` may be unable to locate an unmodified copy of the file in the current source directories or at the absolute address, if an absolute address was used when the file was compiled or loaded. If this happens, the line number and character position of the beginning file position are \`#f\` and the pathname is the pathname originally used. A warning is also issued (an exception with condition type \`&warning\` is raised) unless the \`warn?\` argument is provided and is false.

Otherwise, the pathname is the path to an unmodified copy of the source and the line and character positions are set to exact nonnegative integers.

In either case, the execution count, beginning file position, and ending file position are all exact nonnegative integers, and the pathname is a string.

For source positions in files that cannot be found, the list might contain more than one entry per position due to macro expansion, procedure inlining, and separate compilation. In such cases, the counts are not overlapping and can be summed together to obtain the full count.

The information returned by \`profile-dump-list\` can be used to implement a custom viewer or used as input for offline analysis of profile information.

The advantage of \`profile-dump-list\` over \`profile-dump\` is that it attempts to determine the line number and character position for each source point and, if successful, aggregates multiple counts for the source point into a single entry.
`
    },
    {
        name: "(profile-dump-list ",
        endParen: true,
        params: ["warn?"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s162"),
        description: `**procedure**: \`(profile-dump-list)\`
**procedure**: \`(profile-dump-list \`*warn?*\`)\`
**procedure**: \`(profile-dump-list \`*warn?*\` \`*dump*\`)\`
**returns: **a list of profile entries (see below)
**libraries: **\`(chezscheme)\`

This procedure produces a dump of all profile information present in *dump*, which defaults to the value returned by \`profile-dump\`. It returns a list of entries, each of which is itself a list containing the following elements identifying one block of code and how many times it has been executed.

\`profile-dump-list\` may be unable to locate an unmodified copy of the file in the current source directories or at the absolute address, if an absolute address was used when the file was compiled or loaded. If this happens, the line number and character position of the beginning file position are \`#f\` and the pathname is the pathname originally used. A warning is also issued (an exception with condition type \`&warning\` is raised) unless the \`warn?\` argument is provided and is false.

Otherwise, the pathname is the path to an unmodified copy of the source and the line and character positions are set to exact nonnegative integers.

In either case, the execution count, beginning file position, and ending file position are all exact nonnegative integers, and the pathname is a string.

For source positions in files that cannot be found, the list might contain more than one entry per position due to macro expansion, procedure inlining, and separate compilation. In such cases, the counts are not overlapping and can be summed together to obtain the full count.

The information returned by \`profile-dump-list\` can be used to implement a custom viewer or used as input for offline analysis of profile information.

The advantage of \`profile-dump-list\` over \`profile-dump\` is that it attempts to determine the line number and character position for each source point and, if successful, aggregates multiple counts for the source point into a single entry.
`
    },
    {
        name: "(profile-dump-list ",
        endParen: true,
        params: ["warn?", "dump"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s162"),
        description: `**procedure**: \`(profile-dump-list)\`
**procedure**: \`(profile-dump-list \`*warn?*\`)\`
**procedure**: \`(profile-dump-list \`*warn?*\` \`*dump*\`)\`
**returns: **a list of profile entries (see below)
**libraries: **\`(chezscheme)\`

This procedure produces a dump of all profile information present in *dump*, which defaults to the value returned by \`profile-dump\`. It returns a list of entries, each of which is itself a list containing the following elements identifying one block of code and how many times it has been executed.

\`profile-dump-list\` may be unable to locate an unmodified copy of the file in the current source directories or at the absolute address, if an absolute address was used when the file was compiled or loaded. If this happens, the line number and character position of the beginning file position are \`#f\` and the pathname is the pathname originally used. A warning is also issued (an exception with condition type \`&warning\` is raised) unless the \`warn?\` argument is provided and is false.

Otherwise, the pathname is the path to an unmodified copy of the source and the line and character positions are set to exact nonnegative integers.

In either case, the execution count, beginning file position, and ending file position are all exact nonnegative integers, and the pathname is a string.

For source positions in files that cannot be found, the list might contain more than one entry per position due to macro expansion, procedure inlining, and separate compilation. In such cases, the counts are not overlapping and can be summed together to obtain the full count.

The information returned by \`profile-dump-list\` can be used to implement a custom viewer or used as input for offline analysis of profile information.

The advantage of \`profile-dump-list\` over \`profile-dump\` is that it attempts to determine the line number and character position for each source point and, if successful, aggregates multiple counts for the source point into a single entry.
`
    },
    {
        name: "(profile-line-number-color)",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s161"),
        description: `**thread parameter**: \`(profile-line-number-color)\`
**libraries: **\`(chezscheme)\`

This value of this parameter must be a string or \`#f\`. If it is a string, the string should contain an HTML cascading style sheet (CSS) color specifier. If the parameter is set to a string, \`profile-dump-html\` includes line numbers in its html rendering of each source file, using the specified color. If the parameter is set to \`#f\`, no line numbers are included.
`
    },
    {
        name: "(profile-load-data ",
        endParen: true,
        params: ["path", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s164"),
        description: `**procedure**: \`(profile-load-data \`*path*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Each *path* must be a string.

This procedure reads profile information from the files named by *path*\` ...\` and stores it in the compiler's internal database of profile information. The contents of the files must have been created originally by \`profile-dump-data\` using the same version of .

The database stores a weight for each source expression or block rather than the actual count. When a single file is loaded into the database, the weight is the proportion of the actual count over the maximum count for all expressions or blocks represented in the file. When more than one file is loaded, either by one or multiple calls to \`profile-load-data\`, the weights are averaged.
`
    },
    {
        name: "(profile-palette)",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s160"),
        description: `**thread parameter**: \`(profile-palette)\`
**libraries: **\`(chezscheme)\`

This value of this parameter must be a nonempty vector of at least three pairs. The car of each pair is a background color and the cdr is a foreground (text) color. Each color must be a string, and each string should contain an HTML cascading style sheet (CSS) color specifier. The first pair is used for unprofiled code, and the second is used for unexecuted profiled code. The third is used for code that is executed least frequently, the fourth for code executed next-least frequently, and so on, with the last being used for code that is executed most frequently. Programmers may wish to supply their own palette to enhance visibility or to change the number of colors used.

By default, a black background is used for unprofiled code, and a gray background is used for unexecuted profiled code. Background colors ranging from purple to red are used for executed profiled code, depending on frequency of execution, with red for the most frequently executed code.

\`(profile-palette) \`=>
\`   #(("#111111" . "white") ("#607D8B" . "white")\`
\`     ("#9C27B0" . "black") ("#673AB7" . "white")\`
\`     ("#3F51B5" . "white") ("#2196F3" . "black")\`
\`     ("#00BCD4" . "black") ("#4CAF50" . "black")\`
\`     ("#CDDC39" . "black") ("#FFEB3B" . "black")\`
\`     ("#FFC107" . "black") ("#FF9800" . "black")\`
\`     ("#F44336" . "white"))\`
\` (profile-palette\`
\`  ; set palette with rainbow colors and black text\`
\`  ; for all but unprofiled or unexecuted code\`
\`   '#(("#000000" . "white")    ; black\`
\`      ("#666666" . "white")    ; gray\`
\`      ("#8B00FF" . "black")    ; violet\`
\`      ("#6600FF" . "black")    ; indigo\`
\`      ("#0000FF" . "black")    ; blue\`
\`      ("#00FF00" . "black")    ; green\`
\`      ("#FFFF00" . "black")    ; yellow\`
\`      ("#FF7F00" . "black")    ; orange\`
\`      ("#FF0000" . "black")))  ; red\`
`
    },
    {
        name: "(profile-query-weight ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s165"),
        description: `**procedure**: \`(profile-query-weight \`*obj*\`)\`
**returns: ***obj*'s profile weight, or \`#f\` if *obj* is not in the database
**libraries: **\`(chezscheme)\`

The compiler's profile database maps source objects (Section ) to weights. If *obj* is a source object, the \`profile-query-weight\` returns the weight associated with the source object or \`#f\` if the database does not have a weight recorded for the source object. *obj* can also be an annotation or syntax object, in which case \`profile-query-weight\` first extracts the source object, if any, using \`syntax->annotation\` and \`annotation-source\`, returning \`#f\` if no source-object is found.

A weight is a flonum in the range 0.0 to 1.0, inclusive, and denotes the ratio of the actual count to the maximum count as described in the description of \`profile-load-data\`.

\`profile-query-weight\` can be used by a macro to determine the relative frequency with which its subexpressions were executed in the run or runs that generated the information in the database. This information can be used to guide the generation of code that is likely to be more efficient. For example, the \`case\` macro uses profile information, when available, to order the clauses so that those whose keys matched more frequently are tested before those whose keys matched less frequently.
`
    },
    {
        name: "(profile-release-counters)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s147"),
        description: `**procedure**: \`(profile-release-counters)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

Calling this procedure causes profile information associated with reclaimed code objects to be dropped.
`
    },
    {
        name: "(property-list ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s111"),
        description: `**procedure**: \`(property-list \`*symbol*\`)\`
**returns: **a copy of the internal property list for *symbol*
**libraries: **\`(chezscheme)\`

A property list is a list of alternating keys and values, i.e., \`(\`*key*\` \`*value*\` ...)\`.

\`(putprop 'fred 'species 'snurd)\`
\` (putprop 'fred 'colors '(black white))\`
\` (property-list 'fred) \`=>\` (colors (black white) species snurd)\`
`
    },
    {
        name: "protocol",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(put-bytevector ",
        endParen: true,
        params: ["binary-output-port", "bytevector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s70"),
        description: `**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\`)\`
**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\` \`*start*\`)\`
**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *bytevector*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *bytevector* and *start*.

This procedure writes the *n* bytes of *bytevector* starting at *start* to the port and advances the its position past the end of the bytes written.
`
    },
    {
        name: "(put-bytevector ",
        endParen: true,
        params: ["binary-output-port", "bytevector", "start"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s70"),
        description: `**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\`)\`
**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\` \`*start*\`)\`
**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *bytevector*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *bytevector* and *start*.

This procedure writes the *n* bytes of *bytevector* starting at *start* to the port and advances the its position past the end of the bytes written.
`
    },
    {
        name: "(put-bytevector ",
        endParen: true,
        params: ["binary-output-port", "bytevector", "start", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s70"),
        description: `**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\`)\`
**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\` \`*start*\`)\`
**procedure**: \`(put-bytevector \`*binary-output-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *bytevector*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *bytevector* and *start*.

This procedure writes the *n* bytes of *bytevector* starting at *start* to the port and advances the its position past the end of the bytes written.
`
    },
    {
        name: "(put-bytevector-some ",
        endParen: true,
        params: ["binary-output-port", "bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s83"),
        description: `**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\`)\`
**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\` \`*start*\`)\`
**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **the number of bytes written
**libraries: **\`(chezscheme)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *bytevector*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *bytevector* and *start*.

This procedure normally writes the *n* bytes of *bytevector* starting at *start* to the port and advances the its position past the end of the bytes written. If the port is in nonblocking mode (see \`set-port-nonblocking!\`), however, the number of bytes written may be less than *n*, if the system would have to block to write more bytes.
`
    },
    {
        name: "(put-bytevector-some ",
        endParen: true,
        params: ["binary-output-port", "bytevector", "start"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s83"),
        description: `**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\`)\`
**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\` \`*start*\`)\`
**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **the number of bytes written
**libraries: **\`(chezscheme)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *bytevector*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *bytevector* and *start*.

This procedure normally writes the *n* bytes of *bytevector* starting at *start* to the port and advances the its position past the end of the bytes written. If the port is in nonblocking mode (see \`set-port-nonblocking!\`), however, the number of bytes written may be less than *n*, if the system would have to block to write more bytes.
`
    },
    {
        name: "(put-bytevector-some ",
        endParen: true,
        params: ["binary-output-port", "bytevector", "start", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s83"),
        description: `**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\`)\`
**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\` \`*start*\`)\`
**procedure**: \`(put-bytevector-some \`*binary-output-port*\` \`*bytevector*\` \`*start*\` \`*n*\`)\`
**returns: **the number of bytes written
**libraries: **\`(chezscheme)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *bytevector*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *bytevector* and *start*.

This procedure normally writes the *n* bytes of *bytevector* starting at *start* to the port and advances the its position past the end of the bytes written. If the port is in nonblocking mode (see \`set-port-nonblocking!\`), however, the number of bytes written may be less than *n*, if the system would have to block to write more bytes.
`
    },
    {
        name: "(put-char ",
        endParen: true,
        params: ["textual-output-port", "char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s71"),
        description: `**procedure**: \`(put-char \`*textual-output-port*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure writes *char* to *textual-output-port*, advancing the port's position by one character. If *textual-output-port* is a transcoded port, the position in the underlying byte stream may advance by more than one byte.
`
    },
    {
        name: "(put-datum ",
        endParen: true,
        params: ["textual-output-port", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s73"),
        description: `**procedure**: \`(put-datum \`*textual-output-port*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure writes an external representation of *obj* to *textual-output-port*. If *obj* does not have an external representation as a datum, the behavior is unspecified. The precise external representation is implementation-dependent, but when *obj* does have an external representation as a datum, \`put-datum\` should produce a sequence of characters that can later be read by \`get-datum\` as an object equivalent (in the sense of \`equal?\`) to *obj*. See Section  for an implementation of \`put-datum\`, \`write\`, and \`display\`.
`
    },
    {
        name: "(put-hash-table! ",
        endParen: true,
        params: ["ht", "k", "v"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s2"),
        description: `**procedure**: \`(put-hash-table! \`*ht*\` \`*k*\` \`*v*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*ht* must be a hash table. *k* and *v* may be any Scheme values.

\`put-hash-table!\` associates the value *v* with the key *k* in *ht*.
`
    },
    {
        name: "(put-registry! ",
        endParen: true,
        params: ["key", "val"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s262"),
        description: `**procedure**: \`(get-registry \`*key*\`)\`
**returns: **registry value of *key* or \`#f\`
**procedure**: \`(put-registry! \`*key*\` \`*val*\`)\`
**procedure**: \`(remove-registry! \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*key* and *val* must be strings.

\`get-registry\` returns a string containing the registry value of *key* if the value exists. If no registry value for *key* exists, \`get-registry\` returns \`#f\`.

\`put-registry!\` sets the registry value of *key* to *val*. It raises an exception with condition type \`&assertion\` if the value cannot be set, which may happen if the user has insufficient access.

\`remove-registry!\` removes the registry key or value named by *key*. It raises an exception with condition type \`&assertion\` if the value cannot be removed. Reasons for failure include the key not being present, the user having insufficient access, or *key* being a key with subkeys.

These routines are defined for Windows only.

\`(get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` #f\`
\` (put-registry! "hkey_local_machine\\\\Software\\\\North\\\\South" "east")\`
\` (get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` "east"\`
\` (remove-registry! "hkey_local_machine\\\\Software\\\\North")\`
\` (get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` #f\`
`
    },
    {
        name: "(put-source-table ",
        endParen: true,
        params: ["textual-output-port", "source-table"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s89"),
        description: `**procedure**: \`(put-source-table \`*textual-output-port*\` \`*source-table*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure writes a representation of the information stored in *source-table* to the port.
`
    },
    {
        name: "(put-string ",
        endParen: true,
        params: ["textual-output-port", "string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s72"),
        description: `**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\` \`*start*\`)\`
**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *string*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *string* and *start*.

This procedure writes the *n* characters of *string* starting at *start* to the port and advances the its position past the end of the characters written.
`
    },
    {
        name: "(put-string ",
        endParen: true,
        params: ["textual-output-port", "string", "start"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s72"),
        description: `**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\` \`*start*\`)\`
**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *string*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *string* and *start*.

This procedure writes the *n* characters of *string* starting at *start* to the port and advances the its position past the end of the characters written.
`
    },
    {
        name: "(put-string ",
        endParen: true,
        params: ["textual-output-port", "string", "start", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s72"),
        description: `**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\` \`*start*\`)\`
**procedure**: \`(put-string \`*textual-output-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *string*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *string* and *start*.

This procedure writes the *n* characters of *string* starting at *start* to the port and advances the its position past the end of the characters written.
`
    },
    {
        name: "(put-string-some ",
        endParen: true,
        params: ["textual-output-port", "string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s84"),
        description: `**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\` \`*start*\`)\`
**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **the number of characters written
**libraries: **\`(chezscheme)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *string*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *string* and *start*.

This procedure normally writes the *n* characters of *string* starting at *start* to the port and advances the its position past the end of the characters written. If the port is in nonblocking mode (see \`set-port-nonblocking!\`), however, the number of characters written may be less than *n*, if the system would have to block to write more characters.
`
    },
    {
        name: "(put-string-some ",
        endParen: true,
        params: ["textual-output-port", "string", "start"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s84"),
        description: `**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\` \`*start*\`)\`
**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **the number of characters written
**libraries: **\`(chezscheme)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *string*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *string* and *start*.

This procedure normally writes the *n* characters of *string* starting at *start* to the port and advances the its position past the end of the characters written. If the port is in nonblocking mode (see \`set-port-nonblocking!\`), however, the number of characters written may be less than *n*, if the system would have to block to write more characters.
`
    },
    {
        name: "(put-string-some ",
        endParen: true,
        params: ["textual-output-port", "string", "start", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s84"),
        description: `**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\` \`*start*\`)\`
**procedure**: \`(put-string-some \`*textual-output-port*\` \`*string*\` \`*start*\` \`*n*\`)\`
**returns: **the number of characters written
**libraries: **\`(chezscheme)\`

*start* and *n* must be nonnegative exact integers, and the sum of *start* and *n* must not exceed the length of *string*. If not supplied, *start* defaults to zero and *n* defaults to the difference between the length of *string* and *start*.

This procedure normally writes the *n* characters of *string* starting at *start* to the port and advances the its position past the end of the characters written. If the port is in nonblocking mode (see \`set-port-nonblocking!\`), however, the number of characters written may be less than *n*, if the system would have to block to write more characters.
`
    },
    {
        name: "(put-u8 ",
        endParen: true,
        params: ["binary-output-port", "octet"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s69"),
        description: `**procedure**: \`(put-u8 \`*binary-output-port*\` \`*octet*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

*octet* must be an exact nonnegative integer less than or equal to 255. This procedure writes *octet* to *binary-output-port*, advancing the port's position by one byte.
`
    },
    {
        name: "(putenv ",
        endParen: true,
        params: ["key", "value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s261"),
        description: `**procedure**: \`(putenv \`*key*\` \`*value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*key* and *value* must be strings.

\`putenv\` stores the *key*, *value* pair in the environment of the process, where it is available to the current process (e.g., via *getenv*) and any spawned processes.

\`(putenv "SCHEME" "rocks!")\`
\` (getenv "SCHEME") \`=>\` "rocks!"\`
`
    },
    {
        name: "(putprop ",
        endParen: true,
        params: ["symbol", "key", "value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s105"),
        description: `**procedure**: \`(putprop \`*symbol*\` \`*key*\` \`*value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(quasiquote ",
        endParen: true,
        params: ["obj", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s5"),
        description: `**syntax**: \`(quasiquote \`*obj*\` ...)\`
**syntax**: \`\`\`*obj*
**syntax**: \`(unquote \`*obj*\` ...)\`
**syntax**: \`,\`*obj*
**syntax**: \`(unquote-splicing \`*obj*\` ...)\`
**syntax**: \`,@\`*obj*
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`\`\`*obj* is equivalent to \`(quasiquote \`*obj*\`)\`, \`,\`*obj* is equivalent to \`(unquote \`*obj*\`)\`, and \`,@\`*obj* is equivalent to \`(unquote-splicing \`*obj*\`)\`. The abbreviated forms are converted into the longer forms by the Scheme reader (see \`read\`).

\`quasiquote\` is similar to \`quote\`, but it allows parts of the quoted text to be "unquoted." Within a \`quasiquote\` expression, \`unquote\` and \`unquote-splicing\` subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each \`unquote\` subform is inserted into the output in place of the \`unquote\` form, while the value of each \`unquote-splicing\` subform is spliced into the surrounding list or vector structure. \`unquote\` and \`unquote-splicing\` are valid only within \`quasiquote\` expressions.

\`quasiquote\` expressions may be nested, with each \`quasiquote\` introducing a new level of quotation and each \`unquote\` or \`unquote-splicing\` taking away a level of quotation. An expression nested within \`quasiquote\` expressions must be within \`unquote\` or \`unquote-splicing\` expressions to be evaluated.

\`\`(+ 2 3) \`=>\` (+ 2 3) \`
\` \`
\` \`(+ 2 ,(* 3 4)) \`=>\` (+ 2 12)\`
\` \`(a b (,(+ 2 3) c) d) \`=>\` (a b (5 c) d)\`
\` \`(a b ,(reverse '(c d e)) f g) \`=>\` (a b (e d c) f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a . ,b)) \`=>\` (1 . 2) \`
\` \`
\` \`(+ ,@(cdr '(* 2 3))) \`=>\` (+ 2 3)\`
\` \`(a b ,@(reverse '(c d e)) f g) \`=>\` (a b e d c f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a ,@b)) \`=>\` (1 . 2)\`
\` \`#(,@(list 1 2 3)) \`=>\` #(1 2 3) \`
\` \`
\` '\`,(cons 'a 'b) \`=>\` \`,(cons 'a 'b)\`
\` \`',(cons 'a 'b) \`=>\` '(a . b)\`

\`unquote\` and \`unquote-splicing\` forms with zero or more than one subform are valid only in splicing (list or vector) contexts. \`(unquote \`*obj*\` ...)\` is equivalent to \`(unquote \`*obj*\`) ...\`, and \`(unquote-splicing \`*obj*\` ...)\` is equivalent to \`(unquote-splicing \`*obj*\`) ...\`. These forms are primarily useful as intermediate forms in the output of the \`quasiquote\` expander. They support certain useful nested quasiquotation idioms [], such as \`,@,@\`, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated \`quasiquote\` expression.

\`\`(a (unquote) b) \`=>\` (a b)\`
\` \`(a (unquote (+ 3 3)) b) \`=>\` (a 6 b)\`
\` \`(a (unquote (+ 3 3) (* 3 3)) b) \`=>\` (a 6 9 b) \`
\` \`
\` (let ([x '(m n)]) \`\`(a ,@,@x f)) \`=>\` \`(a (unquote-splicing m n) f)\`
\` (let ([x '(m n)])\`
\`   (eval \`(let ([m '(b c)] [n '(d e)]) \`(a ,@,@x f))\`
\`         (environment '(rnrs)))) \`=>\` (a b c d e f)\`

\`unquote\` and \`unquote-splicing\` are auxiliary keywords for \`quasiquote\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(quasisyntax ",
        endParen: true,
        params: ["template", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s40"),
        description: `**syntax**: \`(quasisyntax \`*template*\` ...)\`
**syntax**: \`#\`\`*template*
**syntax**: \`(unsyntax \`*template*\` ...)\`
**syntax**: \`#,\`*template*
**syntax**: \`(unsyntax-splicing \`*template*\` ...)\`
**syntax**: \`#,@\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#\`\`*template* is equivalent to \`(quasisyntax \`*template*\`)\`, while \`#,\`*template* is equivalent to \`(unsyntax \`*template*\`)\`, and \`#,@\`*template* to \`(unsyntax-splicing \`*template*\`)\`. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.

\`quasisyntax\` is similar to \`syntax\`, but it allows parts of the quoted text to be evaluated, in a manner similar to \`quasiquote\` (Section ).

Within a \`quasisyntax\` *template*, subforms of \`unsyntax\` and \`unsyntax-splicing\` forms are evaluated, and everything else is treated as ordinary template material, as with \`syntax\`. The value of each \`unsyntax\` subform is inserted into the output in place of the \`unsyntax\` form, while the value of each \`unsyntax-splicing\` subform is spliced into the surrounding list or vector structure. \`unsyntax\` and \`unsyntax-splicing\` are valid only within \`quasisyntax\` expressions.

\`quasisyntax\` expressions may be nested, with each \`quasisyntax\` introducing a new level of syntax quotation and each \`unsyntax\` or \`unsyntax-splicing\` taking away a level of quotation. An expression nested within \`quasisyntax\` expressions must be within \`unsyntax\` or \`unsyntax-splicing\` expressions to be evaluated.
`
    },
    {
        name: "(quote ",
        endParen: true,
        params: ["obj"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s2"),
        description: `**syntax**: \`(quote \`*obj*\`)\`
**syntax**: \`'\`*obj*
**returns: ***obj*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`'\`*obj* is equivalent to \`(quote \`*obj*\`)\`. The abbreviated form is converted into the longer form by the Scheme reader (see \`read\`).
`
    },
    {
        name: "(quotient ",
        endParen: true,
        params: ["int1", "int2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s98"),
        description: `**procedure**: \`(quotient \`*int1*\` \`*int2*\`)\`
**returns: **the integer quotient of *int1* and *int2*
**procedure**: \`(remainder \`*int1*\` \`*int2*\`)\`
**returns: **the integer remainder of *int1* and *int2*
**procedure**: \`(modulo \`*int1*\` \`*int2*\`)\`
**returns: **the integer modulus of *int1* and *int2*
**libraries: **\`(rnrs r5rs)\`

The result of \`remainder\` has the same sign as *int1*, while the result of \`modulo\` has the same sign as *int2*.

\`(quotient 45 6) \`=>\` 7\`
\` (quotient 6.0 2.0) \`=>\` 3.0\`
\` (quotient 3.0 -2) \`=>\` -1.0 \`
\` \`
\` (remainder 16 4) \`=>\` 0\`
\` (remainder 5 2) \`=>\` 1\`
\` (remainder -45.0 7) \`=>\` -3.0\`
\` (remainder 10.0 -3.0) \`=>\` 1.0\`
\` (remainder -17 -9) \`=>\` -8 \`
\` \`
\` (modulo 16 4) \`=>\` 0\`
\` (modulo 5 2) \`=>\` 1\`
\` (modulo -45.0 7) \`=>\` 4.0\`
\` (modulo 10.0 -3.0) \`=>\` -2.0\`
\` (modulo -17 -9) \`=>\` -8\`
`
    },
    {
        name: "r5rs",
        endParen: false,
        params: [""],
        type: "module",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s29"),
        description: `**module**: \`r5rs\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "r5rs-syntax",
        endParen: false,
        params: [""],
        type: "module",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s31"),
        description: `**module**: \`r5rs-syntax\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(raise ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s3"),
        description: `**procedure**: \`(raise \`*obj*\`)\`
**procedure**: \`(raise-continuable \`*obj*\`)\`
**returns: **see below
**libraries: **\`(rnrs exceptions)\`, \`(rnrs)\`

Both of these procedures raise an exception, effectively invoking the current exception handler, passing *obj* as the only argument. For \`raise\`, the exception is , while for \`raise-continuable\`, the exception is . An exception handler may return (with zero or more values) to the continuation of a continuable exception. If an exception handler attempts to return to the continuation of a non-continuable exception, however, a new exception with condition type \`&non-continuable\` is raised. Thus, \`raise\` never returns, while \`raise-continuable\` may return zero or more values, depending upon the exception handler.

If the current exception handler, *p*, was established via a \`guard\` form or call to \`with-exception-handler\`, the current exception handler is reset to the handler that was current when *p* was established before \`raise\` or \`raise-continuable\` invokes *p*. This allows *p* to defer to the preexisting exception handler simply by reraising the exception, and it helps prevent infinite regression when an exception handler inadvertently causes a different exception to be raised. If *p* returns and the exception is continuable, *p* is reinstated as the current exception handler.

\`(raise\`
\`   (condition\`
\`     (make-error)\`
\`     (make-message-condition "no go"))) \`=>\` \`*error: no go*
\` (raise-continuable\`
\`   (condition\`
\`     (make-violation)\`
\`     (make-message-condition "oops"))) \`=>\` \`*violation: oops*
\` (list\`
\`   (call/cc\`
\`     (lambda (k)\`
\`       (vector\`
\`         (with-exception-handler\`
\`           (lambda (x) (k (+ x 5)))\`
\`           (lambda () (+ (raise 17) 8))))))) \`=>\` (22)\`
\` (list\`
\`   (vector\`
\`     (with-exception-handler\`
\`       (lambda (x) (+ x 5))\`
\`       (lambda () (+ (raise-continuable 17) 8))))) \`=>\` (#(30))\`
\` (list\`
\`   (vector\`
\`     (with-exception-handler\`
\`       (lambda (x) (+ x 5))\`
\`       (lambda () (+ (raise 17) 8))))) \`=>\` \`*violation: non-continuable*
`
    },
    {
        name: "(raise-continuable ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s3"),
        description: `**procedure**: \`(raise \`*obj*\`)\`
**procedure**: \`(raise-continuable \`*obj*\`)\`
**returns: **see below
**libraries: **\`(rnrs exceptions)\`, \`(rnrs)\`

Both of these procedures raise an exception, effectively invoking the current exception handler, passing *obj* as the only argument. For \`raise\`, the exception is , while for \`raise-continuable\`, the exception is . An exception handler may return (with zero or more values) to the continuation of a continuable exception. If an exception handler attempts to return to the continuation of a non-continuable exception, however, a new exception with condition type \`&non-continuable\` is raised. Thus, \`raise\` never returns, while \`raise-continuable\` may return zero or more values, depending upon the exception handler.

If the current exception handler, *p*, was established via a \`guard\` form or call to \`with-exception-handler\`, the current exception handler is reset to the handler that was current when *p* was established before \`raise\` or \`raise-continuable\` invokes *p*. This allows *p* to defer to the preexisting exception handler simply by reraising the exception, and it helps prevent infinite regression when an exception handler inadvertently causes a different exception to be raised. If *p* returns and the exception is continuable, *p* is reinstated as the current exception handler.

\`(raise\`
\`   (condition\`
\`     (make-error)\`
\`     (make-message-condition "no go"))) \`=>\` \`*error: no go*
\` (raise-continuable\`
\`   (condition\`
\`     (make-violation)\`
\`     (make-message-condition "oops"))) \`=>\` \`*violation: oops*
\` (list\`
\`   (call/cc\`
\`     (lambda (k)\`
\`       (vector\`
\`         (with-exception-handler\`
\`           (lambda (x) (k (+ x 5)))\`
\`           (lambda () (+ (raise 17) 8))))))) \`=>\` (22)\`
\` (list\`
\`   (vector\`
\`     (with-exception-handler\`
\`       (lambda (x) (+ x 5))\`
\`       (lambda () (+ (raise-continuable 17) 8))))) \`=>\` (#(30))\`
\` (list\`
\`   (vector\`
\`     (with-exception-handler\`
\`       (lambda (x) (+ x 5))\`
\`       (lambda () (+ (raise 17) 8))))) \`=>\` \`*violation: non-continuable*
`
    },
    {
        name: "(random ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s64"),
        description: `**procedure**: \`(random \`*real*\`)\`
**returns: **a nonnegative pseudo-random number less than *real*
**libraries: **\`(chezscheme)\`

*real* must be a positive integer or positive inexact real number.

\`(random 1) \`=>\` 0\`
\` (random 1029384535235) \`=>\` 1029384535001, \`*every*\` \`*now*\` \`*and*\` \`*then*
\` (random 1.0) \`=>\` 0.5, \`*every*\` \`*now*\` \`*and*\` \`*then*
`
    },
    {
        name: "random-seed",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s65"),
        description: `**thread parameter**: \`random-seed\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(rational-valued? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s18"),
        description: `**procedure**: \`(real-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number, \`#f\` otherwise
**procedure**: \`(rational-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number, \`#f\` otherwise
**procedure**: \`(integer-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates are similar to \`real?\`, \`rational?\`, and \`integer?\`, but treat as real, rational, or integral complex numbers with inexact zero imaginary parts.

\`(integer-valued? 1901) \`=>\` #t\`
\` (rational-valued? 1901) \`=>\` #t\`
\` (real-valued? 1901) \`=>\` #t \`
\` \`
\` (integer-valued? -3.0) \`=>\` #t\`
\` (rational-valued? -3.0) \`=>\` #t\`
\` (real-valued? -3.0) \`=>\` #t \`
\` \`
\` (integer-valued? 7+0i) \`=>\` #t\`
\` (rational-valued? 7+0i) \`=>\` #t\`
\` (real-valued? 7+0i) \`=>\` #t \`
\` \`
\` (integer-valued? -2/3) \`=>\` #f\`
\` (rational-valued? -2/3) \`=>\` #t\`
\` (real-valued? -2/3) \`=>\` #t \`
\` \`
\` (integer-valued? -2.345) \`=>\` #f\`
\` (rational-valued? -2.345) \`=>\` #t\`
\` (real-valued? -2.345) \`=>\` #t \`
\` \`
\` (integer-valued? 7.0+0.0i) \`=>\` #t\`
\` (rational-valued? 7.0+0.0i) \`=>\` #t\`
\` (real-valued? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer-valued? 3.2-2.01i) \`=>\` #f\`
\` (rational-valued? 3.2-2.01i) \`=>\` #f\`
\` (real-valued? 3.2-2.01i) \`=>\` #f\`

As with \`real?\`, \`rational?\`, and \`integer?\`, these predicates return \`#f\` for all non-numeric values.

\`(integer-valued? 'a) \`=>\` #f\`
\` (rational-valued? '(a b c)) \`=>\` #f\`
\` (real-valued? "3") \`=>\` #f\`
`
    },
    {
        name: "(rational? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s17"),
        description: `**procedure**: \`(number? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a number object, \`#f\` otherwise
**procedure**: \`(complex? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a complex number object, \`#f\` otherwise
**procedure**: \`(real? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number object, \`#f\` otherwise
**procedure**: \`(rational? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number object, \`#f\` otherwise
**procedure**: \`(integer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer object, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well.

The \`real?\`, \`rational?\`, and \`integer?\` predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts.

\`(integer? 1901) \`=>\` #t\`
\` (rational? 1901) \`=>\` #t\`
\` (real? 1901) \`=>\` #t\`
\` (complex? 1901) \`=>\` #t\`
\` (number? 1901) \`=>\` #t \`
\` \`
\` (integer? -3.0) \`=>\` #t\`
\` (rational? -3.0) \`=>\` #t\`
\` (real? -3.0) \`=>\` #t\`
\` (complex? -3.0) \`=>\` #t\`
\` (number? -3.0) \`=>\` #t \`
\` \`
\` (integer? 7+0i) \`=>\` #t\`
\` (rational? 7+0i) \`=>\` #t\`
\` (real? 7+0i) \`=>\` #t\`
\` (complex? 7+0i) \`=>\` #t\`
\` (number? 7+0i) \`=>\` #t \`
\` \`
\` (integer? -2/3) \`=>\` #f\`
\` (rational? -2/3) \`=>\` #t\`
\` (real? -2/3) \`=>\` #t\`
\` (complex? -2/3) \`=>\` #t\`
\` (number? -2/3) \`=>\` #t \`
\` \`
\` (integer? -2.345) \`=>\` #f\`
\` (rational? -2.345) \`=>\` #t\`
\` (real? -2.345) \`=>\` #t\`
\` (complex? -2.345) \`=>\` #t\`
\` (number? -2.345) \`=>\` #t \`
\` \`
\` (integer? 7.0+0.0i) \`=>\` #f\`
\` (rational? 7.0+0.0i) \`=>\` #f\`
\` (real? 7.0+0.0i) \`=>\` #f\`
\` (complex? 7.0+0.0i) \`=>\` #t\`
\` (number? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer? 3.2-2.01i) \`=>\` #f\`
\` (rational? 3.2-2.01i) \`=>\` #f\`
\` (real? 3.2-2.01i) \`=>\` #f\`
\` (complex? 3.2-2.01i) \`=>\` #t\`
\` (number? 3.2-2.01i) \`=>\` #t \`
\` \`
\` (integer? 'a) \`=>\` #f\`
\` (rational? '(a b c)) \`=>\` #f\`
\` (real? "3") \`=>\` #f\`
\` (complex? '#(1 2)) \`=>\` #f\`
\` (number? #\\a) \`=>\` #f\`
`
    },
    {
        name: "(rationalize ",
        endParen: true,
        params: ["real1", "real2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s117"),
        description: `**procedure**: \`(rationalize \`*real1*\` \`*real2*\`)\`
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`rationalize\` returns the simplest rational number that differs from *real1* by no more than *real2*. A rational number = / is simpler than another rational number = / if || ≤ || and || ≤ || and either || < || or || < ||.

\`(rationalize 3/10 1/10) \`=>\` 1/3\`
\` (rationalize .3 1/10) \`=>\` 0.3333333333333333\`
\` (eqv? (rationalize .3 1/10) #i1/3) \`=>\` #t\`
`
    },
    {
        name: "(ratnum? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s12"),
        description: `**procedure**: \`(ratnum? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a ratnum, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\` (ratnum? 0) \`=>\` #f\`
\` (ratnum? (* (most-positive-fixnum) 2)) \`=>\` #f\`
\` (ratnum? 3/4) \`=>\` #t\`
\` (ratnum? -10/2) \`=>\` #f\`
\` (ratnum? -11/2) \`=>\` #t\`
\` (ratnum? 'a) \`=>\` #f\`
`
    },
    {
        name: "(read)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s81"),
        description: `**procedure**: \`(read)\`
**procedure**: \`(read \`*textual-input-port*\`)\`
**returns: **a Scheme datum object or the eof object
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-input-port* is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to \`get-datum\`.
`
    },
    {
        name: "(read ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s81"),
        description: `**procedure**: \`(read)\`
**procedure**: \`(read \`*textual-input-port*\`)\`
**returns: **a Scheme datum object or the eof object
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-input-port* is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to \`get-datum\`.
`
    },
    {
        name: "(read-char)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s82"),
        description: `**procedure**: \`(read-char)\`
**procedure**: \`(read-char \`*textual-input-port*\`)\`
**returns: **the next character from *textual-input-port*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-input-port* is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to \`get-char\`.
`
    },
    {
        name: "(read-char ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s82"),
        description: `**procedure**: \`(read-char)\`
**procedure**: \`(read-char \`*textual-input-port*\`)\`
**returns: **the next character from *textual-input-port*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-input-port* is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to \`get-char\`.
`
    },
    {
        name: "(read-token)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s70"),
        description: `**procedure**: \`(read-token)\`
**procedure**: \`(read-token \`*textual-input-port*\`)\`
**procedure**: \`(read-token \`*textual-input-port*\` \`*sfd*\` \`*bfp*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. *bfp* must be an exact nonnegative integer and should be the character position of the next character to be read from *textual-input-port*.

Parsing of a Scheme datum is conceptually performed in two steps. First, the sequence of characters that form the datum are grouped into \`tokens\`, such as symbols, numbers, left parentheses, and double quotes. During this first step, whitespace and comments are discarded. Second, these tokens are grouped into data.

\`read\` performs both of these steps and creates an internal representation of each datum it parses. \`read-token\` may be used to perform the first step only, one token at a time. \`read-token\` is intended to be used by editors and program formatters that must be able to parse a program or datum without actually reading it.

If *textual-input-port* is not supplied, it defaults to the current input port. One token is read from the input port and returned as four values:

The input port is left pointing to the first character position beyond the token.

When the token type fully specifies the token, \`read-token\` returns \`#f\` for the value. The token types are listed below with the corresponding *value* in parentheses.

The set of token types is likely to change in future releases of the system; check the release notes for details on such changes.

Specifying *sfd* and *bfp* improves the quality of error messages, guarantees *start* and *end* can be determined, and eliminates the overhead of asking for a file position on each call to \`read-token\`. In most cases, *bfp* should be 0 for the first call to \`read-token\` at the start of a file, and it should be the fourth return value (*end*) of the preceding call to \`read-token\` for each subsequent call. This protocol is necessary to handle files containing multiple-byte characters, since file positions do not necessarily correspond to character positions.

\`(define s (open-input-string "(a b c)"))\`
\` (read-token s) \`=>\` lparen\`
\`                    #f\`
\`                    0\`
\`                    1\`
\` (define s (open-input-string "abc 123"))\`
\` (read-token s) \`=>\` atomic\`
\`                    abc\`
\`                    0\`
\`                    3\`
\` (define s (open-input-string ""))\`
\` (read-token s) \`=>\` eof\`
\`                    #!eof\`
\`                    0\`
\`                    0\`
\` (define s (open-input-string "#7=#7#"))\`
\` (read-token s) \`=>\` mark\`
\`                    7\`
\`                    0\`
\`                    3\`
\` (read-token s) \`=>\` insert\`
\`                    7\`
\`                    3\`
\`                    6\`

The information \`read-token\` returns is not always sufficient for reconstituting the exact sequence of characters that make up a token. For example, \`1.0\` and \`1e0\` both return *type* \`atomic\` with *value* \`1.0\`. The exact sequence of characters may be obtained only by repositioning the port and reading a block of characters of the appropriate length, using the relative positions given by *start* and *end*.
`
    },
    {
        name: "(read-token ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s70"),
        description: `**procedure**: \`(read-token)\`
**procedure**: \`(read-token \`*textual-input-port*\`)\`
**procedure**: \`(read-token \`*textual-input-port*\` \`*sfd*\` \`*bfp*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. *bfp* must be an exact nonnegative integer and should be the character position of the next character to be read from *textual-input-port*.

Parsing of a Scheme datum is conceptually performed in two steps. First, the sequence of characters that form the datum are grouped into \`tokens\`, such as symbols, numbers, left parentheses, and double quotes. During this first step, whitespace and comments are discarded. Second, these tokens are grouped into data.

\`read\` performs both of these steps and creates an internal representation of each datum it parses. \`read-token\` may be used to perform the first step only, one token at a time. \`read-token\` is intended to be used by editors and program formatters that must be able to parse a program or datum without actually reading it.

If *textual-input-port* is not supplied, it defaults to the current input port. One token is read from the input port and returned as four values:

The input port is left pointing to the first character position beyond the token.

When the token type fully specifies the token, \`read-token\` returns \`#f\` for the value. The token types are listed below with the corresponding *value* in parentheses.

The set of token types is likely to change in future releases of the system; check the release notes for details on such changes.

Specifying *sfd* and *bfp* improves the quality of error messages, guarantees *start* and *end* can be determined, and eliminates the overhead of asking for a file position on each call to \`read-token\`. In most cases, *bfp* should be 0 for the first call to \`read-token\` at the start of a file, and it should be the fourth return value (*end*) of the preceding call to \`read-token\` for each subsequent call. This protocol is necessary to handle files containing multiple-byte characters, since file positions do not necessarily correspond to character positions.

\`(define s (open-input-string "(a b c)"))\`
\` (read-token s) \`=>\` lparen\`
\`                    #f\`
\`                    0\`
\`                    1\`
\` (define s (open-input-string "abc 123"))\`
\` (read-token s) \`=>\` atomic\`
\`                    abc\`
\`                    0\`
\`                    3\`
\` (define s (open-input-string ""))\`
\` (read-token s) \`=>\` eof\`
\`                    #!eof\`
\`                    0\`
\`                    0\`
\` (define s (open-input-string "#7=#7#"))\`
\` (read-token s) \`=>\` mark\`
\`                    7\`
\`                    0\`
\`                    3\`
\` (read-token s) \`=>\` insert\`
\`                    7\`
\`                    3\`
\`                    6\`

The information \`read-token\` returns is not always sufficient for reconstituting the exact sequence of characters that make up a token. For example, \`1.0\` and \`1e0\` both return *type* \`atomic\` with *value* \`1.0\`. The exact sequence of characters may be obtained only by repositioning the port and reading a block of characters of the appropriate length, using the relative positions given by *start* and *end*.
`
    },
    {
        name: "(read-token ",
        endParen: true,
        params: ["textual-input-port", "sfd", "bfp"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s70"),
        description: `**procedure**: \`(read-token)\`
**procedure**: \`(read-token \`*textual-input-port*\`)\`
**procedure**: \`(read-token \`*textual-input-port*\` \`*sfd*\` \`*bfp*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor. *bfp* must be an exact nonnegative integer and should be the character position of the next character to be read from *textual-input-port*.

Parsing of a Scheme datum is conceptually performed in two steps. First, the sequence of characters that form the datum are grouped into \`tokens\`, such as symbols, numbers, left parentheses, and double quotes. During this first step, whitespace and comments are discarded. Second, these tokens are grouped into data.

\`read\` performs both of these steps and creates an internal representation of each datum it parses. \`read-token\` may be used to perform the first step only, one token at a time. \`read-token\` is intended to be used by editors and program formatters that must be able to parse a program or datum without actually reading it.

If *textual-input-port* is not supplied, it defaults to the current input port. One token is read from the input port and returned as four values:

The input port is left pointing to the first character position beyond the token.

When the token type fully specifies the token, \`read-token\` returns \`#f\` for the value. The token types are listed below with the corresponding *value* in parentheses.

The set of token types is likely to change in future releases of the system; check the release notes for details on such changes.

Specifying *sfd* and *bfp* improves the quality of error messages, guarantees *start* and *end* can be determined, and eliminates the overhead of asking for a file position on each call to \`read-token\`. In most cases, *bfp* should be 0 for the first call to \`read-token\` at the start of a file, and it should be the fourth return value (*end*) of the preceding call to \`read-token\` for each subsequent call. This protocol is necessary to handle files containing multiple-byte characters, since file positions do not necessarily correspond to character positions.

\`(define s (open-input-string "(a b c)"))\`
\` (read-token s) \`=>\` lparen\`
\`                    #f\`
\`                    0\`
\`                    1\`
\` (define s (open-input-string "abc 123"))\`
\` (read-token s) \`=>\` atomic\`
\`                    abc\`
\`                    0\`
\`                    3\`
\` (define s (open-input-string ""))\`
\` (read-token s) \`=>\` eof\`
\`                    #!eof\`
\`                    0\`
\`                    0\`
\` (define s (open-input-string "#7=#7#"))\`
\` (read-token s) \`=>\` mark\`
\`                    7\`
\`                    0\`
\`                    3\`
\` (read-token s) \`=>\` insert\`
\`                    7\`
\`                    3\`
\`                    6\`

The information \`read-token\` returns is not always sufficient for reconstituting the exact sequence of characters that make up a token. For example, \`1.0\` and \`1e0\` both return *type* \`atomic\` with *value* \`1.0\`. The exact sequence of characters may be obtained only by repositioning the port and reading a block of characters of the appropriate length, using the relative positions given by *start* and *end*.
`
    },
    {
        name: "(real->flonum ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s198"),
        description: `**procedure**: \`(fixnum->flonum \`*fx*\`)\`
**returns: **the flonum representation closest to *fx*
**procedure**: \`(real->flonum \`*real*\`)\`
**returns: **the flonum representation closest to *real*
**libraries: **\`(rnrs arithmetic flonums)\`, \`(rnrs)\`

\`fixnum->flonum\` is a restricted variant of \`inexact\`. \`real->flonum\` is a restricted variant of \`inexact\` when the input is an exact real; when it is an inexact non-flonum real, it coverts the inexact non-flonum real into the closest flonum.

\`(fixnum->flonum 0) \`=>\` 0.0\`
\` (fixnum->flonum 13) \`=>\` 13.0 \`
\` \`
\` (real->flonum -1/2) \`=>\` -0.5\`
\` (real->flonum 1s3) \`=>\` 1000.0\`
`
    },
    {
        name: "(real-part ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s120"),
        description: `**procedure**: \`(real-part \`*num*\`)\`
**returns: **the real component of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *num* is real, \`real-part\` returns *num*.

\`(real-part 3+4i) \`=>\` 3\`
\` (real-part -2.3+0.7i) \`=>\` -2.3\`
\` (real-part -i) \`=>\` 0\`
\` (real-part 17.2) \`=>\` 17.2\`
\` (real-part -17/100) \`=>\` -17/100\`
`
    },
    {
        name: "(real-time)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s222"),
        description: `**procedure**: \`(real-time)\`
**returns: **the amount of real time that has elapsed since system start-up
**libraries: **\`(chezscheme)\`

The amount is in milliseconds.

See also \`current-time\`, which returns more precise information.
`
    },
    {
        name: "(real-valued? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s18"),
        description: `**procedure**: \`(real-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number, \`#f\` otherwise
**procedure**: \`(rational-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number, \`#f\` otherwise
**procedure**: \`(integer-valued? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates are similar to \`real?\`, \`rational?\`, and \`integer?\`, but treat as real, rational, or integral complex numbers with inexact zero imaginary parts.

\`(integer-valued? 1901) \`=>\` #t\`
\` (rational-valued? 1901) \`=>\` #t\`
\` (real-valued? 1901) \`=>\` #t \`
\` \`
\` (integer-valued? -3.0) \`=>\` #t\`
\` (rational-valued? -3.0) \`=>\` #t\`
\` (real-valued? -3.0) \`=>\` #t \`
\` \`
\` (integer-valued? 7+0i) \`=>\` #t\`
\` (rational-valued? 7+0i) \`=>\` #t\`
\` (real-valued? 7+0i) \`=>\` #t \`
\` \`
\` (integer-valued? -2/3) \`=>\` #f\`
\` (rational-valued? -2/3) \`=>\` #t\`
\` (real-valued? -2/3) \`=>\` #t \`
\` \`
\` (integer-valued? -2.345) \`=>\` #f\`
\` (rational-valued? -2.345) \`=>\` #t\`
\` (real-valued? -2.345) \`=>\` #t \`
\` \`
\` (integer-valued? 7.0+0.0i) \`=>\` #t\`
\` (rational-valued? 7.0+0.0i) \`=>\` #t\`
\` (real-valued? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer-valued? 3.2-2.01i) \`=>\` #f\`
\` (rational-valued? 3.2-2.01i) \`=>\` #f\`
\` (real-valued? 3.2-2.01i) \`=>\` #f\`

As with \`real?\`, \`rational?\`, and \`integer?\`, these predicates return \`#f\` for all non-numeric values.

\`(integer-valued? 'a) \`=>\` #f\`
\` (rational-valued? '(a b c)) \`=>\` #f\`
\` (real-valued? "3") \`=>\` #f\`
`
    },
    {
        name: "(real? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s17"),
        description: `**procedure**: \`(number? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a number object, \`#f\` otherwise
**procedure**: \`(complex? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a complex number object, \`#f\` otherwise
**procedure**: \`(real? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a real number object, \`#f\` otherwise
**procedure**: \`(rational? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a rational number object, \`#f\` otherwise
**procedure**: \`(integer? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an integer object, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well.

The \`real?\`, \`rational?\`, and \`integer?\` predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts.

\`(integer? 1901) \`=>\` #t\`
\` (rational? 1901) \`=>\` #t\`
\` (real? 1901) \`=>\` #t\`
\` (complex? 1901) \`=>\` #t\`
\` (number? 1901) \`=>\` #t \`
\` \`
\` (integer? -3.0) \`=>\` #t\`
\` (rational? -3.0) \`=>\` #t\`
\` (real? -3.0) \`=>\` #t\`
\` (complex? -3.0) \`=>\` #t\`
\` (number? -3.0) \`=>\` #t \`
\` \`
\` (integer? 7+0i) \`=>\` #t\`
\` (rational? 7+0i) \`=>\` #t\`
\` (real? 7+0i) \`=>\` #t\`
\` (complex? 7+0i) \`=>\` #t\`
\` (number? 7+0i) \`=>\` #t \`
\` \`
\` (integer? -2/3) \`=>\` #f\`
\` (rational? -2/3) \`=>\` #t\`
\` (real? -2/3) \`=>\` #t\`
\` (complex? -2/3) \`=>\` #t\`
\` (number? -2/3) \`=>\` #t \`
\` \`
\` (integer? -2.345) \`=>\` #f\`
\` (rational? -2.345) \`=>\` #t\`
\` (real? -2.345) \`=>\` #t\`
\` (complex? -2.345) \`=>\` #t\`
\` (number? -2.345) \`=>\` #t \`
\` \`
\` (integer? 7.0+0.0i) \`=>\` #f\`
\` (rational? 7.0+0.0i) \`=>\` #f\`
\` (real? 7.0+0.0i) \`=>\` #f\`
\` (complex? 7.0+0.0i) \`=>\` #t\`
\` (number? 7.0+0.0i) \`=>\` #t \`
\` \`
\` (integer? 3.2-2.01i) \`=>\` #f\`
\` (rational? 3.2-2.01i) \`=>\` #f\`
\` (real? 3.2-2.01i) \`=>\` #f\`
\` (complex? 3.2-2.01i) \`=>\` #t\`
\` (number? 3.2-2.01i) \`=>\` #t \`
\` \`
\` (integer? 'a) \`=>\` #f\`
\` (rational? '(a b c)) \`=>\` #f\`
\` (real? "3") \`=>\` #f\`
\` (complex? '#(1 2)) \`=>\` #f\`
\` (number? #\\a) \`=>\` #f\`
`
    },
    {
        name: "(rec ",
        endParen: true,
        params: ["var", "expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s17"),
        description: `**syntax**: \`(rec \`*var*\` \`*expr*\`)\`
**returns: **value of *expr*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(record-accessor ",
        endParen: true,
        params: ["rtd", "idx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s31"),
        description: `**procedure**: \`(record-accessor \`*rtd*\` \`*idx*\`)\`
**returns: **an accessor for the field of *rtd* specified by *idx*
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`

*idx* must be a nonnegative integer less than the number of fields of *rtd*, not counting parent fields. An *idx* value of 0 specifies the first field given in the \`define-record-type\` form or \`make-record-type-descriptor\` call that created the record type, 1 specifies the second, and so on.

A child rtd cannot be used directly to create accessors for parent fields. To create an accessor for a parent field, the record-type descriptor of the parent must be used instead.

See the examples given at the end of this section.
`
    },
    {
        name: "(record-case ",
        endParen: true,
        params: ["expr", "clause1", "clause2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:s3"),
        description: `**syntax**: \`(record-case \`*expr*\` \`*clause1*\` \`*clause2*\` ...)\`
**returns: **see explanation
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(record-constructor ",
        endParen: true,
        params: ["rcd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s190"),
        description: `**procedure**: \`(record-constructor \`*rcd*\`)\`
**procedure**: \`(record-constructor \`*rtd*\`)\`
**returns: **a constructor for records of the type represented by *rtd*
**libraries: **\`(chezscheme)\`

Like the Revised Report version of this procedure, this procedure may be passed a record-constructor descriptor, *rcd*, which determines the behavior of the constructor. It may also be passed a record-type descriptor, *rtd*, in which case the constructor accepts as many arguments as there are fields in the record; these arguments are the initial values of the fields in the order given when the record-type descriptor was created.
`
    },
    {
        name: "(record-constructor ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s190"),
        description: `**procedure**: \`(record-constructor \`*rcd*\`)\`
**procedure**: \`(record-constructor \`*rtd*\`)\`
**returns: **a constructor for records of the type represented by *rtd*
**libraries: **\`(chezscheme)\`

Like the Revised Report version of this procedure, this procedure may be passed a record-constructor descriptor, *rcd*, which determines the behavior of the constructor. It may also be passed a record-type descriptor, *rtd*, in which case the constructor accepts as many arguments as there are fields in the record; these arguments are the initial values of the fields in the order given when the record-type descriptor was created.
`
    },
    {
        name: "(record-constructor ",
        endParen: true,
        params: ["rcd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s29"),
        description: `**procedure**: \`(record-constructor \`*rcd*\`)\`
**returns: **a record constructor for the record type encapsulated within *rcd*
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`

The behavior of the record constructor is determined by the protocol and parent rcd (if any) also encapsulated within *rcd*.

See the examples given at the end of this section.
`
    },
    {
        name: "(record-constructor-descriptor ",
        endParen: true,
        params: ["record-name"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s28"),
        description: `**syntax**: \`(record-type-descriptor \`*record-name*\`)\`
**returns: **the rtd for the record type identified by \`record-name\`
**syntax**: \`(record-constructor-descriptor \`*record-name*\`)\`
**returns: **the rcd for the record type identified by \`record-name\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

Each record definition creates, behind the scenes, an rtd and rcd for the defined record type. These procedures allow the rtd and rcd to be obtained and used like any other rtd or rcd. *record-name* must be the name of a record previously defined via \`define-record-type\`.
`
    },
    {
        name: "(record-constructor-descriptor? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s1"),
        description: `**procedure**: \`(record-constructor-descriptor? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a record constructor descriptor, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

This predicate is not defined by the Revised Report, but should be.
`
    },
    {
        name: "(record-equal-procedure ",
        endParen: true,
        params: ["record1", "record2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s158"),
        description: `**procedure**: \`(record-equal-procedure \`*record1*\` \`*record2*\`)\`
**returns: **the shared equality procedure for *record1* and *record2*, if there is one, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\`record-equal-procedure\` traverses the inheritance chains for both record instances in an attempt to find the most specific type for each that is associated with an equality procedure, if any. If such type is found and is the same for both instances, the equality procedure associated with the type is returned. Otherwise, \`#f\` is returned.
`
    },
    {
        name: "(record-field-accessible? ",
        endParen: true,
        params: ["rtd", "field-id"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s192"),
        description: `**procedure**: \`(record-field-accessible? \`*rtd*\` \`*field-id*\`)\`
**returns: **\`#t\` if the specified field is accessible, otherwise \`#f\`
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor, *field-id* must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

The compiler is free to eliminate a record field if it can prove that the field is not accessed. In making this determination, the compiler is free to ignore the possibility that an accessor might be created from a record-type descriptor obtained by calling \`record-type-descriptor\` on an instance of the record type.
`
    },
    {
        name: "(record-field-accessor ",
        endParen: true,
        params: ["rtd", "field-id"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s191"),
        description: `**procedure**: \`(record-field-accessor \`*rtd*\` \`*field-id*\`)\`
**returns: **an accessor for the identified field
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor, *field-id* must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be accessible.

The generated accessor expects one argument, which must be a record of the type represented by *rtd*. It returns the contents of the specified field of the record.
`
    },
    {
        name: "(record-field-mutable? ",
        endParen: true,
        params: ["rtd", "field-id"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s194"),
        description: `**procedure**: \`(record-field-mutable? \`*rtd*\` \`*field-id*\`)\`
**returns: **\`#t\` if the specified field is mutable, otherwise \`#f\`
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor, *field-id* must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

Any field declared immutable is immutable. In addition, the compiler is free to treat a field as immutable if it can prove that the field is never assigned. In making this determination, the compiler is free to ignore the possibility that a mutator might be created from a record-type descriptor obtained by calling \`record-type-descriptor\` on an instance of the record type.
`
    },
    {
        name: "(record-field-mutable? ",
        endParen: true,
        params: ["rtd", "idx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s39"),
        description: `**procedure**: \`(record-field-mutable? \`*rtd*\` \`*idx*\`)\`
**returns: **\`#t if the specified field of \`*rtd* is mutable, \`#f\` otherwise
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

*idx* must be a nonnegative integer less than the number of fields of *rtd*, not counting parent fields. An *idx* value of 0 specifies the first field given in the \`define-record-type\` form or \`make-record-type-descriptor\` call that created the record type, 1 specifies the second, and so on.

\`(define-record-type point (fields (mutable x) (mutable y)))\`
\` (define-record-type cpoint (parent point) (fields color)) \`
\` \`
\` (record-field-mutable? (record-type-descriptor point) 0) \`=>\` #t\`
\` (record-field-mutable? (record-type-descriptor cpoint) 0) \`=>\` #f\`
`
    },
    {
        name: "(record-field-mutator ",
        endParen: true,
        params: ["rtd", "field-id"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s193"),
        description: `**procedure**: \`(record-field-mutator \`*rtd*\` \`*field-id*\`)\`
**returns: **a mutator for the identified field
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor, *field-id* must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be mutable.

The mutator expects two arguments, *r* and *obj*. *r* must be a record of the type represented by *rtd*. *obj* must be a value that is compatible with the type declared for the specified field when the record-type descriptor was created. *obj* is stored in the specified field of the record.
`
    },
    {
        name: "(record-hash-procedure ",
        endParen: true,
        params: ["record"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s160"),
        description: `**procedure**: \`(record-hash-procedure \`*record*\`)\`
**returns: **the hash procedure for *record*, if there is one, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

\`record-hash-procedure\` traverses the inheritance chain for the record instance in an attempt to find the most specific type that is associated with a hash procedure, if any. If such type is found, the hash procedure associated with the type is returned. Otherwise, \`#f\` is returned.
`
    },
    {
        name: "(record-mutator ",
        endParen: true,
        params: ["rtd", "idx"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s32"),
        description: `**procedure**: \`(record-mutator \`*rtd*\` \`*idx*\`)\`
**returns: **a mutator for the field of *rtd* specified by *idx*
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`

*idx* must be a nonnegative integer less than the number of fields of *rtd*, not counting parent fields. An *idx* value of 0 specifies the first field given in the \`define-record-type\` form or \`make-record-type-descriptor\` call that created the record type, 1 specifies the second, and so on. The indicated field must be mutable; otherwise, an exception with condition type \`&assertion\` is raised.

A child rtd cannot be used directly to create mutators for parent fields. To create a mutator for a parent field, the record-type descriptor of the parent must be used instead.

The following example illustrates the creation of parent and child record types, predicates, accessors, mutators, and constructors using the procedures described in this section.

\`(define rtd/parent\`
\`   (make-record-type-descriptor 'parent #f #f #f #f\`
\`     '#((mutable x)))) \`
\` \`
\` (record-type-descriptor? rtd/parent) \`=>\` #t\`
\` (define parent? (record-predicate rtd/parent))\`
\` (define parent-x (record-accessor rtd/parent 0))\`
\` (define set-parent-x! (record-mutator rtd/parent 0)) \`
\` \`
\` (define rtd/child\`
\`   (make-record-type-descriptor 'child rtd/parent #f #f #f\`
\`     '#((mutable x) (immutable y)))) \`
\` \`
\` (define child? (record-predicate rtd/child))\`
\` (define child-x (record-accessor rtd/child 0))\`
\` (define set-child-x! (record-mutator rtd/child 0))\`
\` (define child-y (record-accessor rtd/child 1)) \`
\` \`
\` (record-mutator rtd/child 1) \`=>\` \`*exception: immutable field*\` \`
\` \`
\` (define rcd/parent\`
\`   (make-record-constructor-descriptor rtd/parent #f\`
\`     (lambda (new) (lambda (x) (new (* x x)))))) \`
\` \`
\` (record-type-descriptor? rcd/parent) \`=>\` #f \`
\` \`
\` (define make-parent (record-constructor rcd/parent)) \`
\` \`
\` (define p (make-parent 10))\`
\` (parent? p) \`=>\` #t\`
\` (parent-x p) \`=>\` 100\`
\` (set-parent-x! p 150)\`
\` (parent-x p) \`=>\` 150 \`
\` \`
\` (define rcd/child\`
\`   (make-record-constructor-descriptor rtd/child rcd/parent\`
\`     (lambda (pargs->new)\`
\`       (lambda (x y)\`
\`         ((pargs->new x) (+ x 5) y))))) \`
\` \`
\` (define make-child (record-constructor rcd/child))\`
\` (define c (make-child 10 'cc))\`
\` (parent? c) \`=>\` #t\`
\` (child? c) \`=>\` #t\`
\` (child? p) \`=>\` #f \`
\` \`
\` (parent-x c) \`=>\` 100\`
\` (child-x c) \`=>\` 15\`
\` (child-y c) \`=>\` cc \`
\` \`
\` (child-x p) \`=>\` \`*exception: invalid argument type*
`
    },
    {
        name: "(record-predicate ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s30"),
        description: `**procedure**: \`(record-predicate \`*rtd*\`)\`
**returns: **a predicate for *rtd*
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`

This procedure returns a predicate that accepts one argument and returns \`#t\` if the argument is an instance of the record-type described by *rtd*, \`#f\` otherwise.

See the examples given at the end of this section.
`
    },
    {
        name: "(record-reader ",
        endParen: true,
        params: ["name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s181"),
        description: `**procedure**: \`(record-reader \`*name*\`)\`
**returns: **the record-type descriptor associated with *name*
**procedure**: \`(record-reader \`*rtd*\`)\`
**returns: **the first name associated with *rtd*
**procedure**: \`(record-reader \`*name*\` \`*rtd*\`)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*name*\` #f)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*rtd*\` #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* must be a symbol, and *rtd* must be a record-type descriptor.

With one argument, \`record-reader\` is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, \`record-reader\` returns \`#f\`

With arguments *name* and *rtd*, \`record-reader\` registers *rtd* as the record-type descriptor to be used whenever the \`read\` procedure encounters a record named by *name* and printed in the default record syntax.

With arguments *name* and \`#f\`, \`record-reader\` removes any association for *name* to a record-type descriptor. Similarly, with arguments *rtd* and \`#f\`, \`record-reader\` removes any association for *rtd* to a name.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'perfect))\`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-c} blue perfect] \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (marble-color '#[marble red miserable]) \`=>\` red \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` marble\`
\` (record-reader 'marble) \`=>\` #<record type marble> \`
\` \`
\` (record-reader (type-descriptor marble) #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (record-reader 'marble #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f\`

The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

\`(record-reader 'marble (type-descriptor marble))\`
\` (make-marble 'pink 'splendid) \`=>\` #[marble pink splendid]\`
`
    },
    {
        name: "(record-reader ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s181"),
        description: `**procedure**: \`(record-reader \`*name*\`)\`
**returns: **the record-type descriptor associated with *name*
**procedure**: \`(record-reader \`*rtd*\`)\`
**returns: **the first name associated with *rtd*
**procedure**: \`(record-reader \`*name*\` \`*rtd*\`)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*name*\` #f)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*rtd*\` #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* must be a symbol, and *rtd* must be a record-type descriptor.

With one argument, \`record-reader\` is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, \`record-reader\` returns \`#f\`

With arguments *name* and *rtd*, \`record-reader\` registers *rtd* as the record-type descriptor to be used whenever the \`read\` procedure encounters a record named by *name* and printed in the default record syntax.

With arguments *name* and \`#f\`, \`record-reader\` removes any association for *name* to a record-type descriptor. Similarly, with arguments *rtd* and \`#f\`, \`record-reader\` removes any association for *rtd* to a name.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'perfect))\`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-c} blue perfect] \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (marble-color '#[marble red miserable]) \`=>\` red \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` marble\`
\` (record-reader 'marble) \`=>\` #<record type marble> \`
\` \`
\` (record-reader (type-descriptor marble) #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (record-reader 'marble #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f\`

The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

\`(record-reader 'marble (type-descriptor marble))\`
\` (make-marble 'pink 'splendid) \`=>\` #[marble pink splendid]\`
`
    },
    {
        name: "(record-reader ",
        endParen: true,
        params: ["name", "rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s181"),
        description: `**procedure**: \`(record-reader \`*name*\`)\`
**returns: **the record-type descriptor associated with *name*
**procedure**: \`(record-reader \`*rtd*\`)\`
**returns: **the first name associated with *rtd*
**procedure**: \`(record-reader \`*name*\` \`*rtd*\`)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*name*\` #f)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*rtd*\` #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* must be a symbol, and *rtd* must be a record-type descriptor.

With one argument, \`record-reader\` is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, \`record-reader\` returns \`#f\`

With arguments *name* and *rtd*, \`record-reader\` registers *rtd* as the record-type descriptor to be used whenever the \`read\` procedure encounters a record named by *name* and printed in the default record syntax.

With arguments *name* and \`#f\`, \`record-reader\` removes any association for *name* to a record-type descriptor. Similarly, with arguments *rtd* and \`#f\`, \`record-reader\` removes any association for *rtd* to a name.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'perfect))\`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-c} blue perfect] \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (marble-color '#[marble red miserable]) \`=>\` red \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` marble\`
\` (record-reader 'marble) \`=>\` #<record type marble> \`
\` \`
\` (record-reader (type-descriptor marble) #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (record-reader 'marble #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f\`

The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

\`(record-reader 'marble (type-descriptor marble))\`
\` (make-marble 'pink 'splendid) \`=>\` #[marble pink splendid]\`
`
    },
    {
        name: "(record-reader ",
        endParen: true,
        params: ["name", "#f"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s181"),
        description: `**procedure**: \`(record-reader \`*name*\`)\`
**returns: **the record-type descriptor associated with *name*
**procedure**: \`(record-reader \`*rtd*\`)\`
**returns: **the first name associated with *rtd*
**procedure**: \`(record-reader \`*name*\` \`*rtd*\`)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*name*\` #f)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*rtd*\` #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* must be a symbol, and *rtd* must be a record-type descriptor.

With one argument, \`record-reader\` is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, \`record-reader\` returns \`#f\`

With arguments *name* and *rtd*, \`record-reader\` registers *rtd* as the record-type descriptor to be used whenever the \`read\` procedure encounters a record named by *name* and printed in the default record syntax.

With arguments *name* and \`#f\`, \`record-reader\` removes any association for *name* to a record-type descriptor. Similarly, with arguments *rtd* and \`#f\`, \`record-reader\` removes any association for *rtd* to a name.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'perfect))\`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-c} blue perfect] \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (marble-color '#[marble red miserable]) \`=>\` red \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` marble\`
\` (record-reader 'marble) \`=>\` #<record type marble> \`
\` \`
\` (record-reader (type-descriptor marble) #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (record-reader 'marble #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f\`

The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

\`(record-reader 'marble (type-descriptor marble))\`
\` (make-marble 'pink 'splendid) \`=>\` #[marble pink splendid]\`
`
    },
    {
        name: "(record-reader ",
        endParen: true,
        params: ["rtd", "#f"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s181"),
        description: `**procedure**: \`(record-reader \`*name*\`)\`
**returns: **the record-type descriptor associated with *name*
**procedure**: \`(record-reader \`*rtd*\`)\`
**returns: **the first name associated with *rtd*
**procedure**: \`(record-reader \`*name*\` \`*rtd*\`)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*name*\` #f)\`
**returns: **unspecified
**procedure**: \`(record-reader \`*rtd*\` #f)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*name* must be a symbol, and *rtd* must be a record-type descriptor.

With one argument, \`record-reader\` is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, \`record-reader\` returns \`#f\`

With arguments *name* and *rtd*, \`record-reader\` registers *rtd* as the record-type descriptor to be used whenever the \`read\` procedure encounters a record named by *name* and printed in the default record syntax.

With arguments *name* and \`#f\`, \`record-reader\` removes any association for *name* to a record-type descriptor. Similarly, with arguments *rtd* and \`#f\`, \`record-reader\` removes any association for *rtd* to a name.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'perfect))\`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-c} blue perfect] \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (marble-color '#[marble red miserable]) \`=>\` red \`
\` \`
\` (record-reader (type-descriptor marble)) \`=>\` marble\`
\` (record-reader 'marble) \`=>\` #<record type marble> \`
\` \`
\` (record-reader (type-descriptor marble) #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f \`
\` \`
\` (record-reader 'marble (type-descriptor marble))\`
\` (record-reader 'marble #f)\`
\` (record-reader (type-descriptor marble)) \`=>\` #f\`
\` (record-reader 'marble) \`=>\` #f\`

The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

\`(record-reader 'marble (type-descriptor marble))\`
\` (make-marble 'pink 'splendid) \`=>\` #[marble pink splendid]\`
`
    },
    {
        name: "(record-rtd ",
        endParen: true,
        params: ["record"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s41"),
        description: `**procedure**: \`(record-rtd \`*record*\`)\`
**returns: **the record-type descriptor (rtd) of *record*
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

The argument must be an instance of a non-opaque record type. In combination with some of the other procedures described in this section and Section , \`record-rtd\` allows the inspection or mutation of record instances, even if the type of the instance is unknown to the inspector. This capability is illustrated by the procedure \`print-fields\` below, which accepts a record argument and writes the name and value of each field of the record.

\`(define print-fields\`
\`   (lambda (r)\`
\`     (unless (record? r)\`
\`       (assertion-violation 'print-fields "not a record" r))\`
\`     (let loop ([rtd (record-rtd r)])\`
\`       (let ([prtd (record-type-parent rtd)])\`
\`         (when prtd (loop prtd)))\`
\`       (let* ([v (record-type-field-names rtd)]\`
\`              [n (vector-length v)])\`
\`         (do ([i 0 (+ i 1)])\`
\`             ((= i n))\`
\`           (write (vector-ref v i))\`
\`           (display "=")\`
\`           (write ((record-accessor rtd i) r))\`
\`           (newline))))))\`

With the familiar definitions of \`point\` and \`cpoint\`:

\`(define-record-type point (fields x y))\`
\` (define-record-type cpoint (parent point) (fields color))\`

the expression \`(print-fields (make-cpoint -3 7 'blue))\` displays the following three lines.

\`x=-3\`
\` y=7\`
\` color=blue\`

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(record-type-descriptor ",
        endParen: true,
        params: ["rec"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s200"),
        description: `**procedure**: \`(record-type-descriptor \`*rec*\`)\`
**returns: **the record-type descriptor of *rec*
**libraries: **\`(chezscheme csv7)\`

*rec* must be a record. This procedure is intended for use in the definition of portable printers and debuggers. For records created with \`make-record-type\`, it may not be the same as the descriptor returned by \`make-record-type\`. See the comments about field accessibility and mutability under \`record-field-accessible?\` and \`record-field-mutable?\` above.

This procedure is equivalent to the Revised Report \`record-rtd\` procedure.

\`(define rtd (make-record-type "frob" '(blit blat)))\`
\` rtd \`=>\` #<record type frob>\`
\` (define x ((record-constructor rtd) 1 2))\`
\` (record-type-descriptor x) \`=>\` #<record type frob>\`
\` (eq? (record-type-descriptor x) rtd) \`=>\` \`*unspecified*
`
    },
    {
        name: "(record-type-descriptor ",
        endParen: true,
        params: ["record-name"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s28"),
        description: `**syntax**: \`(record-type-descriptor \`*record-name*\`)\`
**returns: **the rtd for the record type identified by \`record-name\`
**syntax**: \`(record-constructor-descriptor \`*record-name*\`)\`
**returns: **the rcd for the record type identified by \`record-name\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

Each record definition creates, behind the scenes, an rtd and rcd for the defined record type. These procedures allow the rtd and rcd to be obtained and used like any other rtd or rcd. *record-name* must be the name of a record previously defined via \`define-record-type\`.
`
    },
    {
        name: "(record-type-descriptor? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s23"),
        description: `**procedure**: \`(record-type-descriptor? \`*obj*\`)\`
**returns: **\`#f\` if *obj* is a record-type descriptor, otherwise \`#f\`
**libraries: **\`(rnrs records procedural)\`, \`(rnrs)\`

See the examples given at the end of this section.
`
    },
    {
        name: "(record-type-equal-procedure ",
        endParen: true,
        params: ["rtd", "equal-proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s157"),
        description: `**procedure**: \`(record-type-equal-procedure \`*rtd*\` \`*equal-proc*\`)\`
**returns: **unspecified
**procedure**: \`(record-type-equal-procedure \`*rtd*\`)\`
**returns: **equality procedure associated with *rtd*, if any, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

In the first form, *equal-proc* must be a procedure or \`#f\`. If *equal-proc* is a procedure, a new association between *rtd* and *equal-proc* is established, replacing any existing such association. If *equal-proc* is \`#f\`, any existing association between *rtd* and an equality procedure is dropped.

In the second form, \`record-type-equal-procedure\` returns the equality procedure associated with *rtd*, if any, otherwise \`#f\`.

When changing a record type's equality procedure, the record type's hash procedure, if any, should be updated if necessary to maintain the property that it produces the same hash value for any two instances the equality procedure considers equal.
`
    },
    {
        name: "(record-type-equal-procedure ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s157"),
        description: `**procedure**: \`(record-type-equal-procedure \`*rtd*\` \`*equal-proc*\`)\`
**returns: **unspecified
**procedure**: \`(record-type-equal-procedure \`*rtd*\`)\`
**returns: **equality procedure associated with *rtd*, if any, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

In the first form, *equal-proc* must be a procedure or \`#f\`. If *equal-proc* is a procedure, a new association between *rtd* and *equal-proc* is established, replacing any existing such association. If *equal-proc* is \`#f\`, any existing association between *rtd* and an equality procedure is dropped.

In the second form, \`record-type-equal-procedure\` returns the equality procedure associated with *rtd*, if any, otherwise \`#f\`.

When changing a record type's equality procedure, the record type's hash procedure, if any, should be updated if necessary to maintain the property that it produces the same hash value for any two instances the equality procedure considers equal.
`
    },
    {
        name: "(record-type-field-decls ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s198"),
        description: `**procedure**: \`(record-type-field-decls \`*rtd*\`)\`
**returns: **a list of field declarations of the type represented by *rtd*
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor. Each field declaration has the following form:

\`(\`*class*\` \`*type*\` \`*field-name*\`)\`

where *class*, *type*, and *field-name* are as described under \`make-record-type\`.

\`(define-record shape (x y))\`
\` (define-record circle shape (radius)) \`
\` \`
\` (record-type-field-decls\`
\`   (type-descriptor circle)) \`=>\` ((mutable ptr x)\`
\`                             \`\`  (mutable ptr y)\`
\`                             \`\`  (mutable ptr radius))\`
`
    },
    {
        name: "(record-type-field-names ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s197"),
        description: `**procedure**: \`(record-type-field-names \`*rtd*\`)\`
**returns: **a list of field names of the type represented by *rtd*
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor. The field names are symbols.

\`(define-record triple ((immutable x1) (mutable x2) (immutable x3)))\`
\` (record-type-field-names (type-descriptor triple)) \`=>\` (x1 x2 x3)\`
`
    },
    {
        name: "(record-type-field-names ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s38"),
        description: `**procedure**: \`(record-type-field-names \`*rtd*\`)\`
**returns: **a vector containing the names of the fields of the type described by *rtd*
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

The vector returned by this procedure is immutable: the effect on *rtd* of modifying it is unspecified. The vector does not include parent field names. The order of the names in the vector is the same as the order in which the fields were specified in the \`define-record-type\` form or \`make-record-type-descriptor\` call that created the record type.

\`(define-record-type point (fields x y))\`
\` (define-record-type cpoint (parent point) (fields color))\`
\` (record-type-field-names\`
\`   (record-type-descriptor point)) \`=>\` #(x y)\`
\` (record-type-field-names\`
\`   (record-type-descriptor cpoint)) \`=>\` #(color)\`
`
    },
    {
        name: "(record-type-generative? ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s37"),
        description: `**procedure**: \`(record-type-generative? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is generative, \`#f\` otherwise
**procedure**: \`(record-type-sealed? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is sealed, \`#f\` otherwise
**procedure**: \`(record-type-opaque? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is opaque, \`#f\` otherwise
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

\` (define-record-type table\`
\`   (fields keys vals)\`
\`   (opaque #t))\`
\` (define rtd (record-type-descriptor table))\`
\` (record-type-generative? rtd) \`=>\` #t\`
\` (record-type-sealed? rtd) \`=>\` #f\`
\` (record-type-opaque? rtd) \`=>\` #t \`
\` \`
\` (define-record-type cache-table\`
\`   (parent table)\`
\`   (fields key val)\`
\`   (nongenerative))\`
\` (define rtd (record-type-descriptor cache-table))\`
\` (record-type-generative? rtd) \`=>\` #f\`
\` (record-type-sealed? rtd) \`=>\` #f\`
\` (record-type-opaque? rtd) \`=>\` #t\`
`
    },
    {
        name: "(record-type-hash-procedure ",
        endParen: true,
        params: ["rtd", "hash-proc"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s159"),
        description: `**procedure**: \`(record-type-hash-procedure \`*rtd*\` \`*hash-proc*\`)\`
**returns: **unspecified
**procedure**: \`(record-type-hash-procedure \`*rtd*\`)\`
**returns: **hash procedure associated with *rtd*, if any, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

In the first form, *hash-proc* must be a procedure or \`#f\`. If *hash-proc* is a procedure, a new association between *rtd* and *hash-proc* is established, replacing any existing such association. If *hash-proc* is \`#f\`, any existing association between *rtd* and a hash procedure is dropped.

In the second form, \`record-type-hash-procedure\` returns the hash procedure associated with *rtd*, if any, otherwise \`#f\`.

The procedure *hash-proc* should accept two arguments, the instance for which it should compute a hash value and a hash procedure to use to compute hash values for arbitrary fields of the instance, and it returns a nonnegative exact integer. A record type's hash procedure should produce the same hash value for any two instances the record type's equality procedure considers equal.
`
    },
    {
        name: "(record-type-hash-procedure ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s159"),
        description: `**procedure**: \`(record-type-hash-procedure \`*rtd*\` \`*hash-proc*\`)\`
**returns: **unspecified
**procedure**: \`(record-type-hash-procedure \`*rtd*\`)\`
**returns: **hash procedure associated with *rtd*, if any, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

In the first form, *hash-proc* must be a procedure or \`#f\`. If *hash-proc* is a procedure, a new association between *rtd* and *hash-proc* is established, replacing any existing such association. If *hash-proc* is \`#f\`, any existing association between *rtd* and a hash procedure is dropped.

In the second form, \`record-type-hash-procedure\` returns the hash procedure associated with *rtd*, if any, otherwise \`#f\`.

The procedure *hash-proc* should accept two arguments, the instance for which it should compute a hash value and a hash procedure to use to compute hash values for arbitrary fields of the instance, and it returns a nonnegative exact integer. A record type's hash procedure should produce the same hash value for any two instances the record type's equality procedure considers equal.
`
    },
    {
        name: "(record-type-name ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s195"),
        description: `**procedure**: \`(record-type-name \`*rtd*\`)\`
**returns: **the name of the record-type represented by *rtd*
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor.

The name is a always a string. If a gensym is provided as the record-type name in a \`define-record\` form or \`make-record-type\` call, the result is the "pretty" name of the gensym (see ).

\`(record-type-name (make-record-type "empty" '())) \`=>\` "empty" \`
\` \`
\` (define-record #{point bdhavk1bwafxyss1-b} (x y))\`
\` (define p (type-descriptor #{point bdhavk1bwafxyss1-b}))\`
\` (record-type-name p) \`=>\` "point"\`
`
    },
    {
        name: "(record-type-name ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s34"),
        description: `**procedure**: \`(record-type-name \`*rtd*\`)\`
**returns: **the name associated with *rtd*
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

\` (define record->name\`
\`   (lambda (x)\`
\`     (and (record? x) (record-type-name (record-rtd x))))) \`
\` \`
\` (define-record-type dim (fields w l h))\`
\` (record->name (make-dim 10 15 6)) \`=>\` dim \`
\` \`
\` (define-record-type dim (fields w l h) (opaque #t))\`
\` (record->name (make-dim 10 15 6)) \`=>\` #f\`
`
    },
    {
        name: "(record-type-opaque? ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s37"),
        description: `**procedure**: \`(record-type-generative? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is generative, \`#f\` otherwise
**procedure**: \`(record-type-sealed? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is sealed, \`#f\` otherwise
**procedure**: \`(record-type-opaque? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is opaque, \`#f\` otherwise
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

\` (define-record-type table\`
\`   (fields keys vals)\`
\`   (opaque #t))\`
\` (define rtd (record-type-descriptor table))\`
\` (record-type-generative? rtd) \`=>\` #t\`
\` (record-type-sealed? rtd) \`=>\` #f\`
\` (record-type-opaque? rtd) \`=>\` #t \`
\` \`
\` (define-record-type cache-table\`
\`   (parent table)\`
\`   (fields key val)\`
\`   (nongenerative))\`
\` (define rtd (record-type-descriptor cache-table))\`
\` (record-type-generative? rtd) \`=>\` #f\`
\` (record-type-sealed? rtd) \`=>\` #f\`
\` (record-type-opaque? rtd) \`=>\` #t\`
`
    },
    {
        name: "(record-type-parent ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s35"),
        description: `**procedure**: \`(record-type-parent \`*rtd*\`)\`
**returns: **the parent of *rtd*, or \`#f\` if it has no parent
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

\` (define-record-type point (fields x y))\`
\` (define-record-type cpoint (parent point) (fields color))\`
\` (record-type-parent (record-type-descriptor point)) \`=>\` #f\`
\` (record-type-parent (record-type-descriptor cpoint)) \`=>\` #<rtd>\`
`
    },
    {
        name: "(record-type-sealed? ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s37"),
        description: `**procedure**: \`(record-type-generative? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is generative, \`#f\` otherwise
**procedure**: \`(record-type-sealed? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is sealed, \`#f\` otherwise
**procedure**: \`(record-type-opaque? \`*rtd*\`)\`
**returns: **\`#t\` if the record type described by *rtd* is opaque, \`#f\` otherwise
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

\` (define-record-type table\`
\`   (fields keys vals)\`
\`   (opaque #t))\`
\` (define rtd (record-type-descriptor table))\`
\` (record-type-generative? rtd) \`=>\` #t\`
\` (record-type-sealed? rtd) \`=>\` #f\`
\` (record-type-opaque? rtd) \`=>\` #t \`
\` \`
\` (define-record-type cache-table\`
\`   (parent table)\`
\`   (fields key val)\`
\`   (nongenerative))\`
\` (define rtd (record-type-descriptor cache-table))\`
\` (record-type-generative? rtd) \`=>\` #f\`
\` (record-type-sealed? rtd) \`=>\` #f\`
\` (record-type-opaque? rtd) \`=>\` #t\`
`
    },
    {
        name: "(record-type-symbol ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s196"),
        description: `**procedure**: \`(record-type-symbol \`*rtd*\`)\`
**returns: **the generated symbol associated with *rtd*
**libraries: **\`(chezscheme csv7)\`

*rtd* must be a record-type descriptor.

\`(define e (make-record-type "empty" '()))\`
\` (record-type-symbol e) \`=>\` #{empty bdhavk1bwafxyss1-e} \`
\` \`
\` (define-record #{point bdhavk1bwafxyss1-b} (x y))\`
\` (define p (type-descriptor #{point bdhavk1bwafxyss1-b}))\`
\` (record-type-symbol p) \`=>\` #{point bdhavk1bwafxyss1-b}\`
`
    },
    {
        name: "(record-type-uid ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s36"),
        description: `**procedure**: \`(record-type-uid \`*rtd*\`)\`
**returns: **the uid of *rtd*, or \`#f\` if it has no uid
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

Whether a record type created without a programmer-supplied uid actually has one anyway is left up to the implementation, so this procedure is never guaranteed to return \`#f\`.

\`(define-record-type point (fields x y))\`
\` (define-record-type cpoint\`
\`   (parent point)\`
\`   (fields color)\`
\`   (nongenerative e40cc926-8cf4-4559-a47c-cac636630314))\`
\` (record-type-uid (record-type-descriptor point)) \`=>\` \`*unspecified*
\` (record-type-uid (record-type-descriptor cpoint)) \`=>
\`                              e40cc926-8cf4-4559-a47c-cac636630314\`
`
    },
    {
        name: "(record-writer ",
        endParen: true,
        params: ["rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s182"),
        description: `**procedure**: \`(record-writer \`*rtd*\`)\`
**returns: **the record writer associated with *rtd*
**procedure**: \`(record-writer \`*rtd*\` \`*procedure*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*rtd* must be a record-type descriptor, and *procedure* should accept three arguments, as described below.

When passed only one argument, \`record-writer\` returns the record writer associated with *rtd*, which is initially the default record writer for all records. The default print method prints all records in a uniform syntax that includes the generated name for the record and the values of each of the fields, as described in the introduction to this section.

When passed two arguments, \`record-writer\` establishes a new association between *rtd* and *procedure* so that *procedure* will be used by the printer in place of the default printer for records of the given type. The printer passes *procedure* three arguments: the record *r*, a port *p*, and a procedure *wr* that should be used to write out the values of arbitrary Scheme objects that the print method chooses to include in the printed representation of the record, e.g., values of the record's fields.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'medium)) \`
\` \`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-d} blue medium] \`
\` \`
\` (record-writer (type-descriptor marble)\`
\`   (lambda (r p wr)\`
\`     (display "#<" p)\`
\`     (wr (marble-quality r) p)\`
\`     (display " quality " p)\`
\`     (wr (marble-color r) p)\`
\`     (display " marble>" p))) \`
\` \`
\` m \`=>\` #<medium quality blue marble>\`

The record writer is used only when \`print-record\` is true (the default). When the parameter \`print-record\` is set to \`#f\`, records are printed using a compressed syntax that identifies only the type of record.

\`(parameterize ([print-record #f])\`
\`   (format "~s" m)) \`=>\` "#<record of type marble>"\`
`
    },
    {
        name: "(record-writer ",
        endParen: true,
        params: ["rtd", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s182"),
        description: `**procedure**: \`(record-writer \`*rtd*\`)\`
**returns: **the record writer associated with *rtd*
**procedure**: \`(record-writer \`*rtd*\` \`*procedure*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*rtd* must be a record-type descriptor, and *procedure* should accept three arguments, as described below.

When passed only one argument, \`record-writer\` returns the record writer associated with *rtd*, which is initially the default record writer for all records. The default print method prints all records in a uniform syntax that includes the generated name for the record and the values of each of the fields, as described in the introduction to this section.

When passed two arguments, \`record-writer\` establishes a new association between *rtd* and *procedure* so that *procedure* will be used by the printer in place of the default printer for records of the given type. The printer passes *procedure* three arguments: the record *r*, a port *p*, and a procedure *wr* that should be used to write out the values of arbitrary Scheme objects that the print method chooses to include in the printed representation of the record, e.g., values of the record's fields.

\`(define-record marble (color quality))\`
\` (define m (make-marble 'blue 'medium)) \`
\` \`
\` m \`=>\` #[#{marble bdhavk1bwafxyss1-d} blue medium] \`
\` \`
\` (record-writer (type-descriptor marble)\`
\`   (lambda (r p wr)\`
\`     (display "#<" p)\`
\`     (wr (marble-quality r) p)\`
\`     (display " quality " p)\`
\`     (wr (marble-color r) p)\`
\`     (display " marble>" p))) \`
\` \`
\` m \`=>\` #<medium quality blue marble>\`

The record writer is used only when \`print-record\` is true (the default). When the parameter \`print-record\` is set to \`#f\`, records are printed using a compressed syntax that identifies only the type of record.

\`(parameterize ([print-record #f])\`
\`   (format "~s" m)) \`=>\` "#<record of type marble>"\`
`
    },
    {
        name: "(record? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s199"),
        description: `**procedure**: \`(record? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a record, otherwise \`#f\`
**procedure**: \`(record? \`*obj*\` \`*rtd*\`)\`
**returns: **\`#t\` if *obj* is a record of the given type, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

If present, *rtd* must be a record-type descriptor.

A record is "of the given type" if it is an instance of the record type or one of its ancestors. The predicate generated by \`record-predicate\` for a record-type descriptor *rtd* is equivalent to the following.

\`(lambda (x) (record? x \`*rtd*\`))\`
`
    },
    {
        name: "(record? ",
        endParen: true,
        params: ["obj", "rtd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s199"),
        description: `**procedure**: \`(record? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a record, otherwise \`#f\`
**procedure**: \`(record? \`*obj*\` \`*rtd*\`)\`
**returns: **\`#t\` if *obj* is a record of the given type, otherwise \`#f\`
**libraries: **\`(chezscheme)\`

If present, *rtd* must be a record-type descriptor.

A record is "of the given type" if it is an instance of the record type or one of its ancestors. The predicate generated by \`record-predicate\` for a record-type descriptor *rtd* is equivalent to the following.

\`(lambda (x) (record? x \`*rtd*\`))\`
`
    },
    {
        name: "(record? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s40"),
        description: `**procedure**: \`(record? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a non-opaque record instance, \`#f\` otherwise
**libraries: **\`(rnrs records inspection)\`, \`(rnrs)\`

When passed an instance of an opaque record type, \`record?\` returns \`#f\`. While an instance of an opaque record type is, in essence, a record, the point of opacity is to hide all representation information from the parts of a program that should not have access to the information, and this includes whether an object is a record. Furthermore, the primary purpose of this predicate is to allow programs to check whether it is possible to obtain from the argument an rtd via the \`record-rtd\` procedure described below.

\`(define-record-type statement (fields str))\`
\` (define q (make-statement "He's dead, Jim"))\`
\` (statement? q) \`=>\` #t\`
\` (record? q) \`=>\` #t \`
\` \`
\` (define-record-type opaque-statement (fields str) (opaque #t))\`
\` (define q (make-opaque-statement "He's moved on, Jim"))\`
\` (opaque-statement? q) \`=>\` #t\`
\` (record? q) \`=>\` #f\`
`
    },
    {
        name: "(register-signal-handler ",
        endParen: true,
        params: ["sig", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s28"),
        description: `**procedure**: \`(register-signal-handler \`*sig*\` \`*procedure*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`register-signal-handler\` is used to establish a signal handler for a given low-level signal. *sig* must be an exact integer identifying a valid signal, and *procedure* should accept one argument. See your host system's \`<signal.h>\` or documentation for a list of valid signals and their numbers. After a signal handler for a given signal has been registered, receipt of the specified signal results in a call to the handler. The handler is passed the signal number, allowing the same handler to be used for different signals while differentiating among them.

Signals handled in this fashion are treated like keyboard interrupts in that the handler is not called immediately when the signal is delivered to the process, but rather at some procedure call boundary after the signal is delivered. It is generally not a good idea, therefore, to establish handlers for memory faults, illegal instructions, and the like, since the code that causes the fault or illegal instruction will continue to execute (presumably erroneously) for some time before the handler is invoked. A finite amount of storage is used to buffer as-yet unhandled signals, after which additional signals are dropped.

\`register-signal-handler\` is supported only on Unix-based systems.
`
    },
    {
        name: "release-minimum-generation",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s18"),
        description: `**global parameter**: \`release-minimum-generation\`
**libraries: **\`(chezscheme)\`

This parameter's value must be between 0 and the value of \`collect-maximum-generation\`, inclusive, and defaults to the value of \`collect-maximum-generation\`.

As new data is allocated and collections occur, the storage-management system automatically requests additional virtual memory address space from the operating system. Correspondingly, in the event the heap shrinks significantly, the system attempts to return some of the virtual-memory previously obtained from the operating system back to the operating system. By default, the system attempts to do so only after a collection that targets the maximum nonstatic generation. The system can be asked to do so after collections targeting younger generations as well by altering the value \`release-minimum-generation\` to something less than the value of \`collect-maximum-generation\`. When the generation to which the parameter is set, or any older generation, is the target generation of a collection, the storage management system attempts to return unneeded virtual memory to the operating system following the collection.

When \`collect-maximum-generation\` is set to a new value *g*, \`release-minimum-generation\` is implicitly set to *g* as well if (a) the two parameters have the same value before the change, or (b) \`release-minimum-generation\` has a value greater than *g*.
`
    },
    {
        name: "(remainder ",
        endParen: true,
        params: ["int1", "int2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s98"),
        description: `**procedure**: \`(quotient \`*int1*\` \`*int2*\`)\`
**returns: **the integer quotient of *int1* and *int2*
**procedure**: \`(remainder \`*int1*\` \`*int2*\`)\`
**returns: **the integer remainder of *int1* and *int2*
**procedure**: \`(modulo \`*int1*\` \`*int2*\`)\`
**returns: **the integer modulus of *int1* and *int2*
**libraries: **\`(rnrs r5rs)\`

The result of \`remainder\` has the same sign as *int1*, while the result of \`modulo\` has the same sign as *int2*.

\`(quotient 45 6) \`=>\` 7\`
\` (quotient 6.0 2.0) \`=>\` 3.0\`
\` (quotient 3.0 -2) \`=>\` -1.0 \`
\` \`
\` (remainder 16 4) \`=>\` 0\`
\` (remainder 5 2) \`=>\` 1\`
\` (remainder -45.0 7) \`=>\` -3.0\`
\` (remainder 10.0 -3.0) \`=>\` 1.0\`
\` (remainder -17 -9) \`=>\` -8 \`
\` \`
\` (modulo 16 4) \`=>\` 0\`
\` (modulo 5 2) \`=>\` 1\`
\` (modulo -45.0 7) \`=>\` 4.0\`
\` (modulo 10.0 -3.0) \`=>\` -2.0\`
\` (modulo -17 -9) \`=>\` -8\`
`
    },
    {
        name: "(remove ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s53"),
        description: `**procedure**: \`(remq \`*obj*\` \`*list*\`)\`
**procedure**: \`(remv \`*obj*\` \`*list*\`)\`
**procedure**: \`(remove \`*obj*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* with all occurrences of *obj* removed
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

These procedures traverse the argument *list*, removing any objects that are equivalent to *obj*. The elements remaining in the output list are in the same order as they appear in the input list. If a tail of *list* (including *list* itself) contains no occurrences of *obj*, the corresponding tail of the result list may be the same (by \`eq?\`) as the tail of the input list.

The equivalence test for \`remq\` is \`eq?\`, for \`remv\` is \`eqv?\`, and for \`remove\` is \`equal?\`.

\`(remq 'a '(a b a c a d)) \`=>\` (b c d)\`
\` (remq 'a '(b c d)) \`=>\` (b c d) \`
\` \`
\` (remv 1/2 '(1.2 1/2 0.5 3/2 4)) \`=>\` (1.2 0.5 3/2 4) \`
\` \`
\` (remove '(b) '((a) (b) (c))) \`=>\` ((a) (c))\`
`
    },
    {
        name: "(remove! ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s10"),
        description: `**procedure**: \`(remq! \`*obj*\` \`*list*\`)\`
**procedure**: \`(remv! \`*obj*\` \`*list*\`)\`
**procedure**: \`(remove! \`*obj*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* with all occurrences of *obj* removed
**libraries: **\`(chezscheme)\`

These procedures are similar to the Revised Report \`remq\`, \`remv\`, and \`remove\` procedures, except \`remq!\`, \`remv!\` and \`remove!\` use pairs from the input list to build the output list. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(remq! 'a '(a b a c a d)) \`=>\` (b c d) \`
\` \`
\` (remv! #\\a '(#\\a #\\b #\\c)) \`=>\` (#\\b #\\c) \`
\` \`
\` (remove! '(c) '((a) (b) (c))) \`=>\` ((a) (b))\`
`
    },
    {
        name: "(remove-foreign-entry ",
        endParen: true,
        params: ["entry-name"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s162"),
        description: `**procedure**: \`(remove-foreign-entry \`*entry-name*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`remove-foreign-entry\` blocks further access to the entry specified by the string *entry-name*. An exception is raised with condition type \`&assertion\` if the entry does not exist. Since access previously established by \`foreign-procedure\` is not affected, \`remove-foreign-entry\` may be used to clean up after the desired interface to a group of foreign procedures has been established.

\`remove-foreign-entry\` can be used to remove entries registered using \`Sforeign_symbol\` and \`Sregister_symbol\` but not entries created as a result of a call to \`load-shared-object\`.
`
    },
    {
        name: "(remove-hash-table! ",
        endParen: true,
        params: ["ht", "k"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s4"),
        description: `**procedure**: \`(remove-hash-table! \`*ht*\` \`*k*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`remove-hash-table!\` drops any association for *k* from *ht*.
`
    },
    {
        name: "(remove-registry! ",
        endParen: true,
        params: ["key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s262"),
        description: `**procedure**: \`(get-registry \`*key*\`)\`
**returns: **registry value of *key* or \`#f\`
**procedure**: \`(put-registry! \`*key*\` \`*val*\`)\`
**procedure**: \`(remove-registry! \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*key* and *val* must be strings.

\`get-registry\` returns a string containing the registry value of *key* if the value exists. If no registry value for *key* exists, \`get-registry\` returns \`#f\`.

\`put-registry!\` sets the registry value of *key* to *val*. It raises an exception with condition type \`&assertion\` if the value cannot be set, which may happen if the user has insufficient access.

\`remove-registry!\` removes the registry key or value named by *key*. It raises an exception with condition type \`&assertion\` if the value cannot be removed. Reasons for failure include the key not being present, the user having insufficient access, or *key* being a key with subkeys.

These routines are defined for Windows only.

\`(get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` #f\`
\` (put-registry! "hkey_local_machine\\\\Software\\\\North\\\\South" "east")\`
\` (get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` "east"\`
\` (remove-registry! "hkey_local_machine\\\\Software\\\\North")\`
\` (get-registry "hkey_local_machine\\\\Software\\\\North\\\\South") \`=>\` #f\`
`
    },
    {
        name: "(remp ",
        endParen: true,
        params: ["procedure", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s54"),
        description: `**procedure**: \`(remp \`*procedure*\` \`*list*\`)\`
**returns: **a list of the elements of *list* for which *procedure* returns \`#f\`
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

*procedure* should accept one argument and return a single value. It should not modify *list*.

\`remp\` applies *procedure* to each element of *list* and returns a list containing only the elements for which *procedure* returns \`#f\`. The elements of the returned list appear in the same order as they appeared in the original list.

\`(remp odd? '(1 2 3 4)) \`=>\` (2 4)\`
\` (remp\`
\`   (lambda (x) (and (> x 0) (< x 10)))\`
\`   '(-5 15 3 14 -20 6 0 -9)) \`=>\` (-5 15 14 -20 0 -9)\`
`
    },
    {
        name: "(remprop ",
        endParen: true,
        params: ["symbol", "key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s109"),
        description: `**procedure**: \`(remprop \`*symbol*\` \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(remq ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s53"),
        description: `**procedure**: \`(remq \`*obj*\` \`*list*\`)\`
**procedure**: \`(remv \`*obj*\` \`*list*\`)\`
**procedure**: \`(remove \`*obj*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* with all occurrences of *obj* removed
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

These procedures traverse the argument *list*, removing any objects that are equivalent to *obj*. The elements remaining in the output list are in the same order as they appear in the input list. If a tail of *list* (including *list* itself) contains no occurrences of *obj*, the corresponding tail of the result list may be the same (by \`eq?\`) as the tail of the input list.

The equivalence test for \`remq\` is \`eq?\`, for \`remv\` is \`eqv?\`, and for \`remove\` is \`equal?\`.

\`(remq 'a '(a b a c a d)) \`=>\` (b c d)\`
\` (remq 'a '(b c d)) \`=>\` (b c d) \`
\` \`
\` (remv 1/2 '(1.2 1/2 0.5 3/2 4)) \`=>\` (1.2 0.5 3/2 4) \`
\` \`
\` (remove '(b) '((a) (b) (c))) \`=>\` ((a) (c))\`
`
    },
    {
        name: "(remq! ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s10"),
        description: `**procedure**: \`(remq! \`*obj*\` \`*list*\`)\`
**procedure**: \`(remv! \`*obj*\` \`*list*\`)\`
**procedure**: \`(remove! \`*obj*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* with all occurrences of *obj* removed
**libraries: **\`(chezscheme)\`

These procedures are similar to the Revised Report \`remq\`, \`remv\`, and \`remove\` procedures, except \`remq!\`, \`remv!\` and \`remove!\` use pairs from the input list to build the output list. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(remq! 'a '(a b a c a d)) \`=>\` (b c d) \`
\` \`
\` (remv! #\\a '(#\\a #\\b #\\c)) \`=>\` (#\\b #\\c) \`
\` \`
\` (remove! '(c) '((a) (b) (c))) \`=>\` ((a) (b))\`
`
    },
    {
        name: "(remv ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s53"),
        description: `**procedure**: \`(remq \`*obj*\` \`*list*\`)\`
**procedure**: \`(remv \`*obj*\` \`*list*\`)\`
**procedure**: \`(remove \`*obj*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* with all occurrences of *obj* removed
**libraries: **\`(rnrs lists)\`, \`(rnrs)\`

These procedures traverse the argument *list*, removing any objects that are equivalent to *obj*. The elements remaining in the output list are in the same order as they appear in the input list. If a tail of *list* (including *list* itself) contains no occurrences of *obj*, the corresponding tail of the result list may be the same (by \`eq?\`) as the tail of the input list.

The equivalence test for \`remq\` is \`eq?\`, for \`remv\` is \`eqv?\`, and for \`remove\` is \`equal?\`.

\`(remq 'a '(a b a c a d)) \`=>\` (b c d)\`
\` (remq 'a '(b c d)) \`=>\` (b c d) \`
\` \`
\` (remv 1/2 '(1.2 1/2 0.5 3/2 4)) \`=>\` (1.2 0.5 3/2 4) \`
\` \`
\` (remove '(b) '((a) (b) (c))) \`=>\` ((a) (c))\`
`
    },
    {
        name: "(remv! ",
        endParen: true,
        params: ["obj", "list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s10"),
        description: `**procedure**: \`(remq! \`*obj*\` \`*list*\`)\`
**procedure**: \`(remv! \`*obj*\` \`*list*\`)\`
**procedure**: \`(remove! \`*obj*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* with all occurrences of *obj* removed
**libraries: **\`(chezscheme)\`

These procedures are similar to the Revised Report \`remq\`, \`remv\`, and \`remove\` procedures, except \`remq!\`, \`remv!\` and \`remove!\` use pairs from the input list to build the output list. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(remq! 'a '(a b a c a d)) \`=>\` (b c d) \`
\` \`
\` (remv! #\\a '(#\\a #\\b #\\c)) \`=>\` (#\\b #\\c) \`
\` \`
\` (remove! '(c) '((a) (b) (c))) \`=>\` ((a) (b))\`
`
    },
    {
        name: "rename",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s22"),
        description: `**syntax**: \`only\`
**syntax**: \`except\`
**syntax**: \`add-prefix\`
**syntax**: \`drop-prefix\`
**syntax**: \`rename\`
**syntax**: \`alias\`
**libraries: **\`(chezscheme)\`

These identifiers are auxiliary keywords for \`import\` and \`import-only\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(rename-file ",
        endParen: true,
        params: ["old-pathname", "new-pathname"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s149"),
        description: `**procedure**: \`(rename-file \`*old-pathname*\` \`*new-pathname*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*old-pathname* and *new-pathname* must be strings. \`rename-file\` changes the name of the file named by *old-pathname* to *new-pathname*. If the file does not exist or cannot be renamed, an exception is raised with condition type \`&i/o-filename\`.
`
    },
    {
        name: "require-nongenerative-clause",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s143"),
        description: `**thread parameter**: \`require-nongenerative-clause\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(reset)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s178"),
        description: `**procedure**: \`(reset)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

\`reset\` invokes the current reset handler (see \`reset-handler\`) without arguments.
`
    },
    {
        name: "(reset-cost-center! ",
        endParen: true,
        params: ["cost-center"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s247"),
        description: `**procedure**: \`(reset-cost-center! \`*cost-center*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure resets the costs recorded by *cost-center* to zero.
`
    },
    {
        name: "reset-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s179"),
        description: `**thread parameter**: \`reset-handler\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be a procedure and should accept zero arguments. The current reset handler is called by \`reset\`. The default reset handler resets to the current café.
`
    },
    {
        name: "(reset-maximum-memory-bytes!)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s228"),
        description: `**procedure**: \`(reset-maximum-memory-bytes!)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`reset-maximum-memory-bytes!\` resets the maximum recorded size of the heap to the current size of the heap.
`
    },
    {
        name: "(reverse ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s50"),
        description: `**procedure**: \`(reverse \`*list*\`)\`
**returns: **a new list containing the elements of *list* in reverse order
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`reverse\` may be defined without error checks as follows.

\`(define reverse\`
\`   (lambda (ls)\`
\`     (let rev ([ls ls] [new '()])\`
\`       (if (null? ls)\`
\`           new\`
\`           (rev (cdr ls) (cons (car ls) new)))))) \`
\` \`
\` (reverse '()) \`=>\` ()\`
\` (reverse '(a b c)) \`=>\` (c b a)\`
`
    },
    {
        name: "(reverse! ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s12"),
        description: `**procedure**: \`(reverse! \`*list*\`)\`
**returns: **a list containing the elements of *list* in reverse order
**libraries: **\`(chezscheme)\`

\`reverse!\` destructively reverses *list* by reversing its links. Using \`reverse!\` in place of \`reverse\` reduces allocation but is not necessarily faster than \`reverse\`. Its use can easily lead to confusing or incorrect results if used indiscriminately.

\`(reverse! '()) \`=>\` ()\`
\` (reverse! '(a b c)) \`=>\` (c b a) \`
\` \`
\` (let ([x '(a b c)])\`
\`     (reverse! x)\`
\`     x) \`=>\` (a) \`
\` \`
\` (let ([x '(a b c)])\`
\`     (set! x (reverse! x))\`
\`     x) \`=>\` (c b a)\`
`
    },
    {
        name: "(revisit ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s61"),
        description: `**procedure**: \`(revisit \`*path*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`revisit\` reads the named file, which must contain compiled object code compatible with the current machine type and version, and it runs those portions of the compiled object code that compute run-time values or correspond to expressions identified as "revisit" time by \`eval-when\` forms contained in the original source file.

Continuing the example given for \`visit\` above, applying \`revisit\` to the object file, \`t1.so\`, has the effect of establishing the values of the variable \`x\` exported from \`m\` and the top-level variable \`y\`, without installing either the interface for \`m\` or the transformer for \`a\`.

\`revisit\` is useful for loading compiled application code without loading unnecessary compile-time information. Care must be taken when using this feature if the application calls \`eval\` or uses \`top-level-value\`, \`set-top-level-value!\`, or \`top-level-syntax\` to access top-level bindings at run-time, since these procedures use compile-time information to resolve top-level bindings.
`
    },
    {
        name: "(revisit-compiled-from-port ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s58"),
        description: `**procedure**: \`(revisit-compiled-from-port \`*input-port*\`)\`
**returns: **result of the last compiled expression processed
**libraries: **\`(chezscheme)\`

\`revisit-compiled-from-port\` reads and evaluates the object-code contents of *input-port* as previously created by functions like \`compile-file\`, \`compile-script\`, \`compile-library\`, and \`compile-to-port\`. In the process, it skips any visit (compile-time-only) code.

The return value is the value of the last expression whose last non-visit compiled form is in *input-port*. If there are no such forms, then the result value is unspecified. The port is left at end-of-file but is not closed.
`
    },
    {
        name: "(round ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s104"),
        description: `**procedure**: \`(round \`*real*\`)\`
**returns: **the integer closest to *real*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *real* is exactly between two integers, the closest even integer is returned. If *real* is an infinity or NaN, \`round\` returns *real*.

\`(round 19) \`=>\` 19\`
\` (round 2/3) \`=>\` 1\`
\` (round -2/3) \`=>\` -1\`
\` (round 17.3) \`=>\` 17.0\`
\` (round -17/2) \`=>\` -8\`
\` (round 2.5) \`=>\` 2.0\`
\` (round 3.5) \`=>\` 4.0\`
`
    },
    {
        name: "run-cp0",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s120"),
        description: `**thread parameter**: \`run-cp0\`
**thread parameter**: \`cp0-effort-limit\`
**thread parameter**: \`cp0-score-limit\`
**thread parameter**: \`cp0-outer-unroll-limit\`
**libraries: **\`(chezscheme)\`

These parameters control the operation of \`cp0\`, a source optimization pass that runs after macro expansion and prior to most other compiler passes. \`cp0\` performs procedure inlining, in which the code of one procedure is inlined at points where it is called by other procedures, as well as copy propagation, constant folding, useless code elimination, and several related optimizations. The algorithm used by the optimizer is described in detail in the paper "Fast and effective procedure inlining" [].

When \`cp0\` is enabled, the programmer can count on the compiler to fold constants, eliminate unnecessary \`let\` bindings, and eliminate unnecessary and inaccessible code. This is particularly useful when writing macros, since the programmer can usually handle only the general case and let the compiler simplify the code when possible. For example, the programmer can define \`case\` as follows:

\`(define-syntax case\`
\`   (syntax-rules ()\`
\`     [(_ e [(k ...) a1 a2 ...] ... [else b1 b2 ...])\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...\`
\`          [else b1 b2 ...]))]\`
\`     [(_ e [(k ...) a1 a2 ...] ...)\`
\`      (let ([t e])\`
\`        (cond\`
\`          [(memv t '(k ...)) a1 a2 ...]\`
\`          ...))]))\`

and count on the introduce \`let\` expression to be eliminated if \`e\` turns out to be an unassigned variable, and count on the entire \`case\` expression to be folded if \`e\` turns out to be a constant.
`
    },
    {
        name: "(s8-list->bytevector ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s62"),
        description: `**procedure**: \`(s8-list->bytevector \`*list*\`)\`
**returns: **a new bytevector of the elements of *list*
**libraries: **\`(chezscheme)\`

*list* must consist entirely of exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. \`s8-list->bytevector\` is similar to the Revised Report procedure \`u8-list->bytevector\`, except the elements of the input list are signed rather than unsigned.

\`(s8-list->bytevector '()) \`=>\` #vu8()\`
\` (s8-list->bytevector '(1 127 -128 -1)) \`=>\` #vu8(1 127 128 255) \`
\` \`
\` (let ([v #vu8(1 2 3 4 5)])\`
\`   (let ([ls (bytevector->s8-list v)])\`
\`     (s8-list->bytevector (map - ls)))) \`=>\` #vu8(255 254 253 252 251)\`
`
    },
    {
        name: "(sc-expand ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s95"),
        description: `**procedure**: \`(sc-expand \`*obj*\`)\`
**procedure**: \`(sc-expand \`*obj*\` \`*env*\`)\`
**returns: **the expanded form of *obj*
**libraries: **\`(chezscheme)\`

The procedure \`sc-expand\` is used to expand programs written using \`syntax-case\` macros. \`sc-expand\` is the default expander, i.e., the initial value of \`current-expand\`. *obj* represents the program to be expanded, and *env* must be an environment. *obj* can be an annotation (Section ) or unannotated value. If not provided, *env* defaults to the environment returned by \`interaction-environment\`.
`
    },
    {
        name: "(sc-expand ",
        endParen: true,
        params: ["obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s95"),
        description: `**procedure**: \`(sc-expand \`*obj*\`)\`
**procedure**: \`(sc-expand \`*obj*\` \`*env*\`)\`
**returns: **the expanded form of *obj*
**libraries: **\`(chezscheme)\`

The procedure \`sc-expand\` is used to expand programs written using \`syntax-case\` macros. \`sc-expand\` is the default expander, i.e., the initial value of \`current-expand\`. *obj* represents the program to be expanded, and *env* must be an environment. *obj* can be an annotation (Section ) or unannotated value. If not provided, *env* defaults to the environment returned by \`interaction-environment\`.
`
    },
    {
        name: "scheme",
        endParen: false,
        params: [""],
        type: "module",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s28"),
        description: `**module**: \`scheme\`
**libraries: **\`(chezscheme)\`

\`scheme\` contains all user-visible top-level bindings (variables, keywords, and module names) built into .
`
    },
    {
        name: "(scheme-environment)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s31"),
        description: `**procedure**: \`(scheme-environment)\`
**returns: **an environment
**libraries: **\`(chezscheme)\`

\`scheme-environment\` returns an environment containing the initial top-level bindings. This environment corresponds to the \`scheme\` module.

The environment returned by this procedure is immutable.

\`(define cons 3)\`
\` (top-level-value 'cons (scheme-environment)) \`=>\` #<procedure cons>\`
\` (set-top-level-value! 'cons 3 (scheme-environment)) \`=>\` \`*exception*
`
    },
    {
        name: "scheme-program",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s189"),
        description: `**global parameter**: \`scheme-program\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(scheme-report-environment ",
        endParen: true,
        params: ["version"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s82"),
        description: `**procedure**: \`(null-environment \`*version*\`)\`
**procedure**: \`(scheme-report-environment \`*version*\`)\`
**returns: **an R5RS compatibility environment
**libraries: **\`(rnrs r5rs)\`

*version* must be the exact integer \`5\`.

\`null-environment\` returns an environment containing bindings for the keywords whose meanings are defined by the Revised Report on Scheme, along with bindings for the auxiliary keywords \`else\`, \`=>\`, \`...\`, and \`_\`.

\`scheme-report-environment\` returns an environment containing the same keyword bindings as the environment returned by \`null-environment\` along with bindings for the variables whose meanings are defined by the Revised Report on Scheme, except those not defined by the Revised Report: \`load\`, \`interaction-environment\`, \`transcript-on\`, \`transcript-off\`, and \`char-ready?\`.

The bindings for each of the identifiers in the environments returned by these procedures are those of the corresponding Revised Report library, so this does not provide full backward compatibility, even if the excepted identifier bindings are not used.

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "scheme-script",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s185"),
        description: `**global parameter**: \`scheme-script\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "scheme-start",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s184"),
        description: `**global parameter**: \`scheme-start\`
**libraries: **\`(chezscheme)\`

The value of \`scheme-start\` is a procedure that determines the system's action upon start-up. The procedure receives zero or more arguments, which are strings representing the file names (or command-line arguments not recognized by the Scheme executable) after given on the command line. The default value first loads the files named by the arguments, then starts up the initial café:

\`(lambda fns\`
\`   (for-each load fns)\`
\`   (new-cafe))\`

\`scheme-start\` may be altered to start up an application or to perform customization prior to normal system start-up.

To have any effect, this parameter must be set within a boot file. (See Chapter .)
`
    },
    {
        name: "(scheme-version)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s254"),
        description: `**procedure**: \`(scheme-version)\`
**returns: **a version string
**libraries: **\`(chezscheme)\`

The version string is in the form

\`"Chez Scheme Version \`*version*\`"\`

for , and

\`"Petite Chez Scheme Version \`*version*\`"\`

for .
`
    },
    {
        name: "(scheme-version-number)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s255"),
        description: `**procedure**: \`(scheme-version-number)\`
**returns: **three values: the major, minor, and sub-minor version numbers
**libraries: **\`(chezscheme)\`

Each of the three return values is a nonnegative fixnum.

In Version 7.9.4:

\`(scheme-version-number) \`=>\` 7\`
\`                         \`\` 9\`
\`                         \`\` 4\`
`
    },
    {
        name: "sealed",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/records.html#./records:s16"),
        description: `**syntax**: \`fields\`
**syntax**: \`mutable\`
**syntax**: \`immutable\`
**syntax**: \`parent\`
**syntax**: \`protocol\`
**syntax**: \`sealed\`
**syntax**: \`opaque\`
**syntax**: \`nongenerative\`
**syntax**: \`parent-rtd\`
**libraries: **\`(rnrs records syntactic)\`, \`(rnrs)\`

These identifiers are auxiliary keywords for \`define-record-type\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "self-evaluating-vectors",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s38"),
        description: `**thread parameter**: \`self-evaluating-vectors\`
**libraries: **\`(chezscheme)\`

The default value of this parameter is \`#f\`, meaning that vector literals must be quoted, as required by the Revised Report. Setting \`self-evaluating-vectors\` to a true value may be useful to provide compatibility with RRS, as the latter states that vectors are self-evaluating.

\`#(a b c) \`=>\` \`*exception: invalid syntax*\` \`
\` \`
\` (self-evaluating-vectors #t)\`
\` #(a b c) \`=>\` #(a b c)\`
`
    },
    {
        name: "(serious-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s19"),
        description: `**syntax**: \`&serious\`
**procedure**: \`(make-serious-condition)\`
**returns: **a condition of type \`&serious\`
**procedure**: \`(serious-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&serious\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate situations of a serious nature that, if uncaught, generally result in termination of the program's execution. Conditions of this type typically occur as one of the more specific subtypes \`&error\` or \`&violation\`. This condition type might be defined as follows.

\`(define-condition-type &serious &condition\`
\`   make-serious-condition serious-condition?)\`
`
    },
    {
        name: "(set! ",
        endParen: true,
        params: ["var", "expr"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s28"),
        description: `**syntax**: \`(set! \`*var*\` \`*expr*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(set-binary-port-input-buffer! ",
        endParen: true,
        params: ["binary-input-port", "bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-binary-port-input-index! ",
        endParen: true,
        params: ["binary-input-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-binary-port-input-size! ",
        endParen: true,
        params: ["binary-input-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-binary-port-output-buffer! ",
        endParen: true,
        params: ["binary-output-port", "bytevector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-binary-port-output-index! ",
        endParen: true,
        params: ["output-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-binary-port-output-size! ",
        endParen: true,
        params: ["output-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-box! ",
        endParen: true,
        params: ["box", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s85"),
        description: `**procedure**: \`(set-box! \`*box*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*box* must be mutable. \`set-box!\` sets the contents of *box* to *obj*.

\`(let ([b (box 'x)])\`
\`   (set-box! b 'y)\`
\`   b) \`=>\` #&y \`
\` \`
\` (let ([incr!\`
\`        (lambda (x)\`
\`          (set-box! x (+ (unbox x) 1)))])\`
\`   (let ([b (box 3)])\`
\`     (incr! b)\`
\`     (unbox b))) \`=>\` 4\`
`
    },
    {
        name: "(set-car! ",
        endParen: true,
        params: ["pair", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s40"),
        description: `**procedure**: \`(set-car! \`*pair*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs mutable-pairs)\`

\`set-car!\` changes the car of *pair* to *obj*.

\`(let ([x (list 'a 'b 'c)])\`
\`   (set-car! x 1)\`
\`   x) \`=>\` (1 b c)\`
`
    },
    {
        name: "(set-cdr! ",
        endParen: true,
        params: ["pair", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s41"),
        description: `**procedure**: \`(set-cdr! \`*pair*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs mutable-pairs)\`

\`set-cdr!\` changes the cdr of *pair* to *obj*.

\`(let ([x (list 'a 'b 'c)])\`
\`   (set-cdr! x 1)\`
\`   x) \`=>\` (a . 1)\`
`
    },
    {
        name: "(set-port-bol! ",
        endParen: true,
        params: ["output-port", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s26"),
        description: `**procedure**: \`(set-port-bol! \`*output-port*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

When *obj* is \`#f\`, the port's beginning-of-line (BOL) flag is cleared; otherwise, the port's BOL flag is set.

The BOL flag is consulted by \`fresh-line\` (page ) to determine if it needs to emit a newline. This flag is maintained automatically for file output ports, string output ports, and transcript ports. The flag is set for newly created file and string output ports, except for file output ports created with the \`append\` option, for which the flag is reset. The BOL flag is clear for newly created generic ports and never set automatically, but may be set explicitly using \`set-port-bol!\`. The port is always flushed immediately before the flag is consulted, so it need not be maintained on a per-character basis for buffered ports.
`
    },
    {
        name: "(set-port-eof! ",
        endParen: true,
        params: ["input-port", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s28"),
        description: `**procedure**: \`(set-port-eof! \`*input-port*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

When *obj* is not \`#f\`, \`set-port-eof!\` marks *input-port* so that, once its buffer is empty, the port is treated as if it were at eof even if more data is available in the underlying byte or character stream. Once this artificial eof has been read, the eof mark is cleared, making any additional data in the stream available beyond the eof. This feature can be used by a generic port to simulate a stream consisting of multiple input files.

When *obj* is \`#f\`, the eof mark is cleared.

The following example assumes /dev/zero provides an infinite stream of zero bytes.

\`(define p\`
\`   (parameterize ([file-buffer-size 3])\`
\`     (open-file-input-port "/dev/zero")))\`
\` (set-port-eof! p #t)\`
\` (get-u8 p) \`=>\` #!eof\`
\` (get-u8 p) \`=>\` 0\`
\` (set-port-eof! p #t)\`
\` (get-u8 p) \`=>\` 0\`
\` (get-u8 p) \`=>\` 0\`
\` (get-u8 p) \`=>\` #!eof\`
\` (get-u8 p) \`=>\` 0\`
`
    },
    {
        name: "(set-port-input-buffer! ",
        endParen: true,
        params: ["input-port", "x"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-port-input-index! ",
        endParen: true,
        params: ["input-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-port-input-size! ",
        endParen: true,
        params: ["input-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-port-length! ",
        endParen: true,
        params: ["port", "len"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s32"),
        description: `**procedure**: \`(set-port-length! \`*port*\` \`*len*\`)\`
**returns: **unspecified
**procedure**: \`(port-has-set-port-length!? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`set-port-length!\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow the length of the underlying stream of characters or bytes to be set, i.e., extended or truncated. If so, the procedure \`port-has-set-port-length!?\` returns \`#t\` and \`set-port-length!\` changes the length. For binary ports, the length *len* must be an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified, as described in the entry for \`port-length\` above, but *len* must be an appropriate length for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to \`port-length\` on the same port. If \`set-port-length!\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

It is not possible to set the length of a port opened with compression to an arbitrary position, and the result of an attempt to set the length of a compressed file beyond 2 on 32-bit versions of the system is undefined.
`
    },
    {
        name: "(set-port-name! ",
        endParen: true,
        params: ["port", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s30"),
        description: `**procedure**: \`(set-port-name! \`*port*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedure sets *port*'s name to *obj*, which should be a string or \`#f\` (denoting no name).
`
    },
    {
        name: "(set-port-nonblocking! ",
        endParen: true,
        params: ["port", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s34"),
        description: `**procedure**: \`(set-port-nonblocking! \`*port*\` \`*obj*\`)\`
**returns: **unspecified
**procedure**: \`(port-has-set-port-nonblocking!? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`set-port-nonblocking!\`, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

A port may allow reads or writes to be performed in a "nonblocking" fashion. If so, the procedure \`port-has-set-port-nonblocking!?\` returns \`#t\` and \`set-port-nonblocking!\` sets the port to nonblocking mode (if *obj* is a true value) or blocking mode (if *obj* is \`#f\`). If \`set-port-nonblocking!\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

Ports created by the standard Revised port opening procedures are initially set in blocking mode by default. The same is true for most of the procedures described in this document. A generic port based on a nonblocking source may be nonblocking initially. A port returned by \`open-fd-input-port\`, \`open-fd-output-port\`, or \`open-fd-input/output-port\` is initially in nonblocking mode if the file-descriptor passed in is in nonblocking mode. Similarly, a port returned by \`standard-input-port\`, \`standard-output-port\`, or \`standard-error-port\` is initially in nonblocking mode if the underlying stdin, stdout, or stderr file descriptor is in nonblocking mode.

Although \`get-bytevector-some\` and \`get-string-some\` normally cannot return an empty bytevector or empty string, they can if the port is in nonblocking mode and no input is available. Also, \`get-bytevector-some!\` and \`get-string-some!\` may not read any data if the port is in nonblocking mode and no data is available. Similarly, \`put-bytevector-some\` and \`put-string-some\` may not write any data if the port is in nonblocking mode and no room is available.

Nonblocking mode is not supported under Windows.
`
    },
    {
        name: "(set-port-output-buffer! ",
        endParen: true,
        params: ["output-port", "x"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-port-output-index! ",
        endParen: true,
        params: ["output-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-port-output-size! ",
        endParen: true,
        params: ["output-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-port-position! ",
        endParen: true,
        params: ["port", "pos"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s50"),
        description: `**procedure**: \`(set-port-position! \`*port*\` \`*pos*\`)\`
**returns: **unspecified
**procedure**: \`(port-has-set-port-position!? \`*port*\`)\`
**returns: **\`#t\` if the port supports \`set-port-position!\`, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

A port may allow its current position to be moved directly to a different position in the underlying stream of bytes or characters. If so, the procedure \`port-has-set-port-position!?\` returns \`#t\` and \`set-port-position!\` changes the current position. For binary ports, the position *pos* must be an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified, as described in the entry for \`port-position\` above, but *pos* must be an appropriate position for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to \`port-position\` on the same port. If \`set-port-position!\` is called on a port that does not support it, an exception with condition type \`&assertion\` is raised.

If *port* is a binary output port and the position is set beyond the current end of the data in the underlying stream, the stream is not extended until new data is written at that position. If new data is written at that position, the contents of each intervening position is unspecified. Binary ports created with \`open-file-output-port\` and \`open-file-input/output-port\` can always be extended in this manner within the limits of the underlying operating system. In other cases, attempts to set the port beyond the current end of data in the underlying object may result in an exception with condition type \`&i/o-invalid-position\`.
`
    },
    {
        name: "(set-sstats-bytes! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-sstats-cpu! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-sstats-gc-bytes! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-sstats-gc-count! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-sstats-gc-cpu! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-sstats-gc-real! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-sstats-real! ",
        endParen: true,
        params: ["s", "new-value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s234"),
        description: `**procedure**: \`(set-sstats-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-bytes! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-count! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-cpu! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-real! \`*s*\` \`*new-value*\`)\`
**procedure**: \`(set-sstats-gc-bytes! \`*s*\` \`*new-value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a sstats record, the *new-value* arguments for the time fields (*cpu*, *real*, *gc-cpu*, and *gc-real*) must be time objects, and the other *new-value* arguments must be exact integers. Each procedure sets the value of the corresponding field of *s* to *new-value*.
`
    },
    {
        name: "(set-textual-port-input-buffer! ",
        endParen: true,
        params: ["textual-input-port", "string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-textual-port-input-index! ",
        endParen: true,
        params: ["textual-input-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-textual-port-input-size! ",
        endParen: true,
        params: ["textual-input-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s17"),
        description: `**procedure**: \`(set-port-input-index! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-size! \`*input-port*\` \`*n*\`)\`
**procedure**: \`(set-port-input-buffer! \`*input-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-input-index! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-size! \`*textual-input-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-input-buffer! \`*textual-input-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-input-index! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-size! \`*binary-input-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-input-buffer! \`*binary-input-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-input-index!\` sets the input index field of *input-port* to , which must be a nonnegative integer less than or equal to the port's input size.

The procedure \`set-port-input-size!\` sets the input size field of *input-port* to , which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0.

The procedure \`set-port-input-buffer!\` sets the input buffer field of *input-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-textual-port-output-buffer! ",
        endParen: true,
        params: ["textual-output-port", "string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-textual-port-output-index! ",
        endParen: true,
        params: ["textual-output-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-textual-port-output-size! ",
        endParen: true,
        params: ["textual-output-port", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s21"),
        description: `**procedure**: \`(set-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-port-output-buffer! \`*output-port*\` \`*x*\`)\`
**procedure**: \`(set-textual-port-output-index! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-size! \`*textual-output-port*\` \`*n*\`)\`
**procedure**: \`(set-textual-port-output-buffer! \`*textual-output-port*\` \`*string*\`)\`
**procedure**: \`(set-binary-port-output-index! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-size! \`*output-port*\` \`*n*\`)\`
**procedure**: \`(set-binary-port-output-buffer! \`*binary-output-port*\` \`*bytevector*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

The procedure \`set-port-output-index!\` sets the output index field of the output port to , which must be a nonnegative integer less than or equal to the port's output size.

The procedure \`set-port-output-size!\` sets the output size field of the output port to , which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0.

The procedure \`set-port-output-buffer!\` sets the output buffer field of *output-port* to , which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(set-time-nanosecond! ",
        endParen: true,
        params: ["time", "nsec"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s206"),
        description: `**procedure**: \`(set-time-type! \`*time*\` \`*type*\`)\`
**returns: **unspecified
**procedure**: \`(set-time-nanosecond! \`*time*\` \`*nsec*\`)\`
**returns: **unspecified
**procedure**: \`(set-time-second! \`*time*\` \`*sec*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*time* must be a time object. *type* must be one of the time-type symbols listed above. *nsec* represents nanoseconds and must be an exact nonnegative integer less than 10. *sec* represents seconds and must be an exact integer.

Each of these procedures modifies the time object, changing one aspect while leaving the others unaffected. For example, \`set-time-nanosecond!\` changes the nanosecond of *time* without changing the second or type. In particular, no conversion of values is performed when the type of a time object is changed.
`
    },
    {
        name: "(set-time-second! ",
        endParen: true,
        params: ["time", "sec"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s206"),
        description: `**procedure**: \`(set-time-type! \`*time*\` \`*type*\`)\`
**returns: **unspecified
**procedure**: \`(set-time-nanosecond! \`*time*\` \`*nsec*\`)\`
**returns: **unspecified
**procedure**: \`(set-time-second! \`*time*\` \`*sec*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*time* must be a time object. *type* must be one of the time-type symbols listed above. *nsec* represents nanoseconds and must be an exact nonnegative integer less than 10. *sec* represents seconds and must be an exact integer.

Each of these procedures modifies the time object, changing one aspect while leaving the others unaffected. For example, \`set-time-nanosecond!\` changes the nanosecond of *time* without changing the second or type. In particular, no conversion of values is performed when the type of a time object is changed.
`
    },
    {
        name: "(set-time-type! ",
        endParen: true,
        params: ["time", "type"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s206"),
        description: `**procedure**: \`(set-time-type! \`*time*\` \`*type*\`)\`
**returns: **unspecified
**procedure**: \`(set-time-nanosecond! \`*time*\` \`*nsec*\`)\`
**returns: **unspecified
**procedure**: \`(set-time-second! \`*time*\` \`*sec*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*time* must be a time object. *type* must be one of the time-type symbols listed above. *nsec* represents nanoseconds and must be an exact nonnegative integer less than 10. *sec* represents seconds and must be an exact integer.

Each of these procedures modifies the time object, changing one aspect while leaving the others unaffected. For example, \`set-time-nanosecond!\` changes the nanosecond of *time* without changing the second or type. In particular, no conversion of values is performed when the type of a time object is changed.
`
    },
    {
        name: "(set-timer ",
        endParen: true,
        params: ["n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s22"),
        description: `**procedure**: \`(set-timer \`*n*\`)\`
**returns: **previous current timer value
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(set-top-level-value! ",
        endParen: true,
        params: ["symbol", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s26"),
        description: `**procedure**: \`(set-top-level-value! \`*symbol*\` \`*obj*\`)\`
**procedure**: \`(set-top-level-value! \`*symbol*\` \`*obj*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(set-top-level-value! ",
        endParen: true,
        params: ["symbol", "obj", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s26"),
        description: `**procedure**: \`(set-top-level-value! \`*symbol*\` \`*obj*\`)\`
**procedure**: \`(set-top-level-value! \`*symbol*\` \`*obj*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(set-virtual-register! ",
        endParen: true,
        params: ["k", "x"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s252"),
        description: `**procedure**: \`(set-virtual-register! \`*k*\` \`*x*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`set-virtual-register!\` stores *x* in virtual register *k*. *k* must be a nonnegative fixnum less than the value of \`(virtual-register-count)\`.
`
    },
    {
        name: "(simple-conditions ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s16"),
        description: `**procedure**: \`(simple-conditions \`*condition*\`)\`
**returns: **a list of the simple conditions of *condition*
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

\` (simple-conditions (condition)) \`=>\` '()\`
\` (simple-conditions (make-error)) \`=>\` (#<condition &error>)\`
\` (simple-conditions (condition (make-error))) \`=>\` (#<condition &error>)\`
\` (simple-conditions\`
\`   (condition\`
\`     (make-error)\`
\`     (make-message-condition\`
\`       "oops"))) \`=>\` (#<condition &error> #<condition &message>) \`
\` \`
\` (let ([c1 (make-error)]\`
\`       [c2 (make-who-condition "f")]\`
\`       [c3 (make-message-condition "invalid argument")]\`
\`       [c4 (make-message-condition\`
\`             "error occurred while reading from file")]\`
\`       [c5 (make-irritants-condition '("a.ss"))])\`
\`   (equal?\`
\`     (simple-conditions\`
\`       (condition\`
\`         (condition (condition c1 c2) c3)\`
\`         (condition c4 (condition c5))))\`
\`     (list c1 c2 c3 c4 c5))) \`=>\` #t\`
`
    },
    {
        name: "(sin ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s131"),
        description: `**procedure**: \`(sin \`*num*\`)\`
**procedure**: \`(cos \`*num*\`)\`
**procedure**: \`(tan \`*num*\`)\`
**returns: **the sine, cosine, or tangent of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The argument is specified in radians.

\`(sin 0.0) \`=>\` 0.0\`
\` (cos 0.0) \`=>\` 1.0\`
\` (tan 0.0) \`=>\` 0.0\`
`
    },
    {
        name: "(sinh ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s76"),
        description: `**procedure**: \`(sinh \`*num*\`)\`
**procedure**: \`(cosh \`*num*\`)\`
**procedure**: \`(tanh \`*num*\`)\`
**returns: **the hyperbolic sine, cosine, or tangent of *num*
**libraries: **\`(chezscheme)\`

\`(sinh 0.0) \`=>\` 0.0\`
\` (cosh 0.0) \`=>\` 1.0\`
\` (tanh -0.0) \`=>\` -0.0\`
`
    },
    {
        name: "(sint-list->bytevector ",
        endParen: true,
        params: ["list", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s261"),
        description: `**procedure**: \`(uint-list->bytevector \`*list*\` \`*eness*\` \`*size*\`)\`
**procedure**: \`(sint-list->bytevector \`*list*\` \`*eness*\` \`*size*\`)\`
**returns: **a new bytevector of the elements of *list*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*eness* must be a valid endianness symbol naming the endianness. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. For \`uint-list->bytevector\`, *list* must consist entirely of *size*-byte exact unsigned integers, i.e., values in the range 0 to 2 - 1 inclusive. For \`sint-list->bytevector\`, *list* must consist entirely of *size*-byte exact signed integers, i.e., values in the range -2 to 2 - 1 inclusive. Each value occupies *size* bytes in the resulting bytevector, whose length is thus *size* times the length of *list*.

\`(uint-list->bytevector '() 'big 25) \`=>\` #vu8()\`
\` (sint-list->bytevector '(0 -1) 'big 3) \`=>\` #vu8(0 0 0 #xff #xff #xff) \`
\` \`
\` (define (f size)\`
\`   (let ([ls (list (- (expt 2 (- (* 8 size) 1)))\`
\`                   (- (expt 2 (- (* 8 size) 1)) 1))])\`
\`     (sint-list->bytevector ls 'little size)))\`
\` (f 6) \`=>\` #vu8(#x00 #x00 #x00 #x00 #x00 #x80\`
\`       \`\`      #xff #xff #xff #xff #xff #x7f)\`
`
    },
    {
        name: "(sleep ",
        endParen: true,
        params: ["time"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s218"),
        description: `**procedure**: \`(sleep \`*time*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*time* must be a time object with type \`time-duration\`. *sleep* causes the invoking thread to suspend operation for approximately the amount of time indicated by the time object, unless the process receives a signal that interrupts the sleep operation. The actual time slept depends on the granularity of the system clock and how busy the system is running other threads and processes.
`
    },
    {
        name: "(sort ",
        endParen: true,
        params: ["predicate", "list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s114"),
        description: `**procedure**: \`(sort \`*predicate*\` \`*list*\`)\`
**procedure**: \`(sort! \`*predicate*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* sorted according to *predicate*
**libraries: **\`(chezscheme)\`

\`sort\` is identical to the Revised Report \`list-sort\`, and \`sort!\` is a destructive version of \`sort\`, i.e., it reuses pairs from the input list to form the output list.

\`(sort < '(3 4 2 1 2 5)) \`=>\` (1 2 2 3 4 5)\`
\` (sort! < '(3 4 2 1 2 5)) \`=>\` (1 2 2 3 4 5)\`
`
    },
    {
        name: "(sort! ",
        endParen: true,
        params: ["predicate", "list"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s114"),
        description: `**procedure**: \`(sort \`*predicate*\` \`*list*\`)\`
**procedure**: \`(sort! \`*predicate*\` \`*list*\`)\`
**returns: **a list containing the elements of *list* sorted according to *predicate*
**libraries: **\`(chezscheme)\`

\`sort\` is identical to the Revised Report \`list-sort\`, and \`sort!\` is a destructive version of \`sort\`, i.e., it reuses pairs from the input list to form the output list.

\`(sort < '(3 4 2 1 2 5)) \`=>\` (1 2 2 3 4 5)\`
\` (sort! < '(3 4 2 1 2 5)) \`=>\` (1 2 2 3 4 5)\`
`
    },
    {
        name: "(source-condition-form ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s5"),
        description: `**syntax**: \`&source\`
**procedure**: \`(make-source-condition \`*form*\`)\`
**returns: **a condition of type \`&source\`
**procedure**: \`(source-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&source\`, \`#f\` otherwise
**procedure**: \`(source-condition-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition when a source expression can be identified in situations in which a \`&syntax\` condition would be inappropriate, such as when a run-time assertion violation is detected. The \`form\` argument should be an s-expression or syntax object representing the source expression. This condition type might be defined as follows.

\`(define-condition-type &source &condition\`
\`   make-source-condition source-condition?\`
\`   (form source-condition-form))\`
`
    },
    {
        name: "(source-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s5"),
        description: `**syntax**: \`&source\`
**procedure**: \`(make-source-condition \`*form*\`)\`
**returns: **a condition of type \`&source\`
**procedure**: \`(source-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&source\`, \`#f\` otherwise
**procedure**: \`(source-condition-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**libraries: **\`(chezscheme)\`

This condition type can be included within a compound condition when a source expression can be identified in situations in which a \`&syntax\` condition would be inappropriate, such as when a run-time assertion violation is detected. The \`form\` argument should be an s-expression or syntax object representing the source expression. This condition type might be defined as follows.

\`(define-condition-type &source &condition\`
\`   make-source-condition source-condition?\`
\`   (form source-condition-form))\`
`
    },
    {
        name: "source-directories",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s102"),
        description: `**global parameter**: \`source-directories\`
**libraries: **\`(chezscheme)\`

The value of \`source-directories\` must be a list of strings, each of which names a directory path. \`source-directories\` determines the set of directories searched for source or object files when a file is loaded via \`load\`, \`load-library\`, \`load-program\`, \`include\`, \`visit\`, or \`revisit\`, when a syntax error occurs, or when a source file is opened in the interactive inspector.

The default value is the list \`(".")\`, which means source files will be found only in or relative to the current directory, unless named with an absolute path.

This parameter is never altered by the system, with one exception. The expander temporarily adds (via \`parameterize\`) the directory in which a library file resides to the front of the \`source-directories\` list when it compiles (when \`compile-imported-libraries\` is true) or loads the library from source, which it does only if the library is not already defined.
`
    },
    {
        name: "(source-file-descriptor ",
        endParen: true,
        params: ["path", "checksum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s67"),
        description: `**procedure**: \`(source-file-descriptor \`*path*\` \`*checksum*\`)\`
**returns: **a new source-file-descriptor
**libraries: **\`(chezscheme)\`

*path* must be a string, and *checksum* must be an exact nonnegative integer. This procedure can be used to construct custom source-file descriptors or to reconstitute source-file descriptors from the *path* and *checksum* components.
`
    },
    {
        name: "(source-file-descriptor-checksum ",
        endParen: true,
        params: ["sfd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s65"),
        description: `**procedure**: \`(source-file-descriptor-checksum \`*sfd*\`)\`
**returns: **the checksum component of *sfd*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-file-descriptor-path ",
        endParen: true,
        params: ["sfd"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s66"),
        description: `**procedure**: \`(source-file-descriptor-path \`*sfd*\`)\`
**returns: **the path component of *sfd*
**libraries: **\`(chezscheme)\`

*sfd* must be a source-file descriptor.
`
    },
    {
        name: "(source-file-descriptor? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s64"),
        description: `**procedure**: \`(source-file-descriptor? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a source-file descriptor, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-object-bfp ",
        endParen: true,
        params: ["source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s58"),
        description: `**procedure**: \`(source-object-bfp \`*source-object*\`)\`
**returns: **the bfp component of *source-object*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-object-column ",
        endParen: true,
        params: ["source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s61"),
        description: `**procedure**: \`(source-object-column \`*source-object*\`)\`
**returns: **the column component of *source-object* if present, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-object-efp ",
        endParen: true,
        params: ["source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s59"),
        description: `**procedure**: \`(source-object-efp \`*source-object*\`)\`
**returns: **the efp component of *source-object*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-object-line ",
        endParen: true,
        params: ["source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s60"),
        description: `**procedure**: \`(source-object-line \`*source-object*\`)\`
**returns: **the line component of *source-object* if present, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-object-sfd ",
        endParen: true,
        params: ["source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s57"),
        description: `**procedure**: \`(source-object-sfd \`*source-object*\`)\`
**returns: **the sfd component of *source-object*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-object? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s56"),
        description: `**procedure**: \`(source-object? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a source object, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-table-cell ",
        endParen: true,
        params: ["source-table", "source-object", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s86"),
        description: `**procedure**: \`(source-table-cell \`*source-table*\` \`*source-object*\` \`*default*\`)\`
**returns: **a pair (see below)
**libraries: **\`(chezscheme)\`

*default* may be any Scheme value.

If no value is associated with *source-object* in *source-table*, \`source-table-cell\` modifies *source-table* to associate *source-object* with *default*. Regardless, it returns a pair whose car is *source-object* and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate *source-object* with a new value. The car field of the pair should not be modified.
`
    },
    {
        name: "(source-table-contains? ",
        endParen: true,
        params: ["source-table", "source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s85"),
        description: `**procedure**: \`(source-table-contains? \`*source-table*\` \`*source-object*\`)\`
**returns: **\`#t\` if an association for *source-object* exists in *source-table*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-table-delete! ",
        endParen: true,
        params: ["source-table", "source-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s87"),
        description: `**procedure**: \`(source-table-delete! \`*source-table*\` \`*source-object*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`source-table-delete!\` drops the association for *source-object* from *source-table*, if one exists.
`
    },
    {
        name: "(source-table-dump ",
        endParen: true,
        params: ["source-table"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s153"),
        description: `**procedure**: \`(source-table-dump \`*source-table*\`)\`
**returns: **a list of pairs of source objects and their associated values in *source-table*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-table-ref ",
        endParen: true,
        params: ["source-table", "source-object", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s84"),
        description: `**procedure**: \`(source-table-ref \`*source-table*\` \`*source-object*\` \`*default*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*default* may be any Scheme value.

\`source-table-ref\` returns the value associated with *source-object* in *source-table*. If no value is associated with *source-object* in *source-table*, \`source-table-ref\` returns *default*.
`
    },
    {
        name: "(source-table-set! ",
        endParen: true,
        params: ["source-table", "source-object", "obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s83"),
        description: `**procedure**: \`(source-table-set! \`*source-table*\` \`*source-object*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`source-table-set!\` associates *source-object* with *obj* in *source-table*, replacing the existing association, if any.
`
    },
    {
        name: "(source-table-size ",
        endParen: true,
        params: ["source-table"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s88"),
        description: `**procedure**: \`(source-table-size \`*source-table*\`)\`
**returns: **the number of entries in *source-table*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(source-table? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s82"),
        description: `**procedure**: \`(source-table? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a source-table; \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(sqrt ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s127"),
        description: `**procedure**: \`(sqrt \`*num*\`)\`
**returns: **the principal square root of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

Implementations are encouraged, but not required, to return exact results for exact inputs to \`sqrt\` whenever feasible.

\`(sqrt 16) \`=>\` 4\`
\` (sqrt 1/4) \`=>\` 1/2\`
\` (sqrt 4.84) \`=>\` 2.2\`
\` (sqrt -4.84) \`=>\` 0.0+2.2i\`
\` (sqrt 3+4i) \`=>\` 2+1i\`
\` (sqrt -3.0-4.0i) \`=>\` 1.0-2.0i\`
`
    },
    {
        name: "(sstats-bytes ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats-cpu ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats-difference ",
        endParen: true,
        params: ["s1", "s2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s235"),
        description: `**procedure**: \`(sstats-difference \`*s1*\` \`*s2*\`)\`
**returns: **a sstats record representing the difference between *s1* and *s2*
**libraries: **\`(chezscheme)\`

*s1* and *s2* must be sstats records. \`sstats-difference\` subtracts each field of *s2* from the corresponding field of *s1* to produce the resulting \`sstats\` record.
`
    },
    {
        name: "(sstats-gc-bytes ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats-gc-count ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats-gc-cpu ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats-gc-real ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats-print ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s236"),
        description: `**procedure**: \`(sstats-print \`*s*\`)\`
**procedure**: \`(sstats-print \`*s*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a \`sstats\` record. If *textual-output-port* is not supplied, it defaults to the current output port. \`sstats-print\` displays the fields of \`s\` in a manner similar to \`display-statistics\` and \`time\`.
`
    },
    {
        name: "(sstats-print ",
        endParen: true,
        params: ["s", "textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s236"),
        description: `**procedure**: \`(sstats-print \`*s*\`)\`
**procedure**: \`(sstats-print \`*s*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*s* must be a \`sstats\` record. If *textual-output-port* is not supplied, it defaults to the current output port. \`sstats-print\` displays the fields of \`s\` in a manner similar to \`display-statistics\` and \`time\`.
`
    },
    {
        name: "(sstats-real ",
        endParen: true,
        params: ["s"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s233"),
        description: `**procedure**: \`(sstats-cpu \`*s*\`)\`
**procedure**: \`(sstats-real \`*s*\`)\`
**procedure**: \`(sstats-bytes \`*s*\`)\`
**procedure**: \`(sstats-gc-count \`*s*\`)\`
**procedure**: \`(sstats-gc-cpu \`*s*\`)\`
**procedure**: \`(sstats-gc-real \`*s*\`)\`
**procedure**: \`(sstats-gc-bytes \`*s*\`)\`
**returns: **the value of the corresponding field of *s*
**libraries: **\`(chezscheme)\`

*s* must be a sstats record.
`
    },
    {
        name: "(sstats? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s232"),
        description: `**procedure**: \`(sstats? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a sstats record, otherwise \`#f\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(standard-error-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s82"),
        description: `**procedure**: \`(standard-error-port)\`
**procedure**: \`(standard-error-port \`*b-mode*\`)\`
**procedure**: \`(standard-error-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port connected to the process's standard error
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. The buffer mode *b-mode* defaults to \`none\`. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`none\` in ) and binary output.
`
    },
    {
        name: "(standard-error-port ",
        endParen: true,
        params: ["b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s82"),
        description: `**procedure**: \`(standard-error-port)\`
**procedure**: \`(standard-error-port \`*b-mode*\`)\`
**procedure**: \`(standard-error-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port connected to the process's standard error
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. The buffer mode *b-mode* defaults to \`none\`. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`none\` in ) and binary output.
`
    },
    {
        name: "(standard-error-port ",
        endParen: true,
        params: ["b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s82"),
        description: `**procedure**: \`(standard-error-port)\`
**procedure**: \`(standard-error-port \`*b-mode*\`)\`
**procedure**: \`(standard-error-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port connected to the process's standard error
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. The buffer mode *b-mode* defaults to \`none\`. See the lead-in to Section  of for a description of the constraints on and effects of the other arguments.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`none\` in ) and binary output.
`
    },
    {
        name: "(standard-error-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s33"),
        description: `**procedure**: \`(standard-input-port)\`
**returns: **a fresh binary input port connected to the standard input stream
**procedure**: \`(standard-output-port)\`
**returns: **a fresh binary output port connected to the standard output stream
**procedure**: \`(standard-error-port)\`
**returns: **a fresh binary output port connected to the standard error stream
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

Because ports may be buffered, confusion can result if operations on more than one port attached to one of a process's standard streams are interleaved. Thus, these procedures are typically appropriate only when a program no longer needs to use any existing ports attached to the standard streams.
`
    },
    {
        name: "(standard-input-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s61"),
        description: `**procedure**: \`(standard-input-port)\`
**procedure**: \`(standard-input-port \`*b-mode*\`)\`
**procedure**: \`(standard-input-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port connected to the process's standard input
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. The buffer mode *b-mode* defaults to \`block\`.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`block\` in ) and binary output.
`
    },
    {
        name: "(standard-input-port ",
        endParen: true,
        params: ["b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s61"),
        description: `**procedure**: \`(standard-input-port)\`
**procedure**: \`(standard-input-port \`*b-mode*\`)\`
**procedure**: \`(standard-input-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port connected to the process's standard input
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. The buffer mode *b-mode* defaults to \`block\`.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`block\` in ) and binary output.
`
    },
    {
        name: "(standard-input-port ",
        endParen: true,
        params: ["b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s61"),
        description: `**procedure**: \`(standard-input-port)\`
**procedure**: \`(standard-input-port \`*b-mode*\`)\`
**procedure**: \`(standard-input-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new input port connected to the process's standard input
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual input port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary input port. The buffer mode *b-mode* defaults to \`block\`.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`block\` in ) and binary output.
`
    },
    {
        name: "(standard-input-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s33"),
        description: `**procedure**: \`(standard-input-port)\`
**returns: **a fresh binary input port connected to the standard input stream
**procedure**: \`(standard-output-port)\`
**returns: **a fresh binary output port connected to the standard output stream
**procedure**: \`(standard-error-port)\`
**returns: **a fresh binary output port connected to the standard error stream
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

Because ports may be buffered, confusion can result if operations on more than one port attached to one of a process's standard streams are interleaved. Thus, these procedures are typically appropriate only when a program no longer needs to use any existing ports attached to the standard streams.
`
    },
    {
        name: "(standard-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s81"),
        description: `**procedure**: \`(standard-output-port)\`
**procedure**: \`(standard-output-port \`*b-mode*\`)\`
**procedure**: \`(standard-output-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port connected to the process's standard output
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. The buffer mode *b-mode* defaults to \`line\`, which differs from \`block\` in only for textual output ports.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`line\` in ) and binary output.
`
    },
    {
        name: "(standard-output-port ",
        endParen: true,
        params: ["b-mode"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s81"),
        description: `**procedure**: \`(standard-output-port)\`
**procedure**: \`(standard-output-port \`*b-mode*\`)\`
**procedure**: \`(standard-output-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port connected to the process's standard output
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. The buffer mode *b-mode* defaults to \`line\`, which differs from \`block\` in only for textual output ports.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`line\` in ) and binary output.
`
    },
    {
        name: "(standard-output-port ",
        endParen: true,
        params: ["b-mode", "?transcoder"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s81"),
        description: `**procedure**: \`(standard-output-port)\`
**procedure**: \`(standard-output-port \`*b-mode*\`)\`
**procedure**: \`(standard-output-port \`*b-mode*\` \`*?transcoder*\`)\`
**returns: **a new output port connected to the process's standard output
**libraries: **\`(chezscheme)\`

If *?transcoder* is present and not \`#f\`, it must be a transcoder, and this procedure returns a textual output port whose transcoder is *?transcoder*. Otherwise, this procedure returns a binary output port. The buffer mode *b-mode* defaults to \`line\`, which differs from \`block\` in only for textual output ports.

The Revised Report version of this procedure does not accept the optional *b-mode* and *?transcoder* arguments, which limits it to an implementation-dependent buffering mode (\`line\` in ) and binary output.
`
    },
    {
        name: "(standard-output-port)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s33"),
        description: `**procedure**: \`(standard-input-port)\`
**returns: **a fresh binary input port connected to the standard input stream
**procedure**: \`(standard-output-port)\`
**returns: **a fresh binary output port connected to the standard output stream
**procedure**: \`(standard-error-port)\`
**returns: **a fresh binary output port connected to the standard error stream
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

Because ports may be buffered, confusion can result if operations on more than one port attached to one of a process's standard streams are interleaved. Thus, these procedures are typically appropriate only when a program no longer needs to use any existing ports attached to the standard streams.
`
    },
    {
        name: "(statistics)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s230"),
        description: `**procedure**: \`(statistics)\`
**returns: **a sstats record containing current statistics
**libraries: **\`(chezscheme)\`

\`statistics\` packages together various timing and allocation statistics into a single \`sstats\` record. A \`sstats\` record has the following fields:

All values are computed since system start-up. The time values are time objects (Section ), and the bytes and count values are exact integers.

\`statistics\` might be defined as follows:

\`(define statistics\`
\`   (lambda ()\`
\`     (make-sstats\`
\`       (current-time 'time-thread)\`
\`       (current-time 'time-monotonic)\`
\`       (- (+ (bytes-allocated) (bytes-deallocated))\`
\`          (initial-bytes-allocated))\`
\`       (collections)\`
\`       (current-time 'time-collector-cpu)\`
\`       (current-time 'time-collector-real)\`
\`       (bytes-deallocated))))\`
`
    },
    {
        name: "(string ",
        endParen: true,
        params: ["char", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s217"),
        description: `**procedure**: \`(string \`*char*\` ...)\`
**returns: **a string containing the characters *char*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (string) \`=>\` ""\`
\` (string #\\a #\\b #\\c) \`=>\` "abc"\`
\` (string #\\H #\\E #\\Y #\\!) \`=>\` "HEY!"\`
`
    },
    {
        name: "(string->bytevector ",
        endParen: true,
        params: ["string", "transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s92"),
        description: `**procedure**: \`(string->bytevector \`*string*\` \`*transcoder*\`)\`
**returns: **a bytevector containing the encodings of the characters in *string*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This operation, at least in effect, creates a bytevector output port with the specified *transcoder* to which all of the characters of *string* are written, then extracts a bytevector containing the accumulated bytes.

\`(let ([tx (make-transcoder (utf-8-codec) (eol-style none)\`
\`             (error-handling-mode raise))])\`
\`   (string->bytevector "abc" tx)) \`=>\` #vu8(97 98 99)\`
`
    },
    {
        name: "(string->immutable-string ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s25"),
        description: `**procedure**: \`(string->immutable-string \`*string*\`)\`
**returns: **an immutable string equal to *string*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(string->list ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s228"),
        description: `**procedure**: \`(string->list \`*string*\`)\`
**returns: **a list of the characters in *string*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`string->list\` allows a string to be converted into a list, so that Scheme's list-processing operations may be applied to the processing of strings. \`string->list\` may be defined without error checks as follows.

\`(define string->list\`
\`   (lambda (s)\`
\`     (do ([i (- (string-length s) 1) (- i 1)]\`
\`          [ls '() (cons (string-ref s i) ls)])\`
\`         ((< i 0) ls)))) \`
\` \`
\` (string->list "") \`=>\` ()\`
\` (string->list "abc") \`=>\` (#\\a #\\b #\\c)\`
\` (apply char<? (string->list "abc")) \`=>\` #t\`
\` (map char-upcase (string->list "abc")) \`=>\` (#\\A #\\B #\\C)\`
`
    },
    {
        name: "(string->multibyte ",
        endParen: true,
        params: ["code-page", "string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s92"),
        description: `**procedure**: \`(multibyte->string \`*code-page*\` \`*bytevector*\`)\`
**returns: **a string containing the characters encoded in *bytevector*
**procedure**: \`(string->multibyte \`*code-page*\` \`*string*\`)\`
**returns: **a bytevector containing the encodings of the characters in *string*
**libraries: **\`(chezscheme)\`

These procedures are available only under Windows. The procedure \`multibyte->string\` is a wrapper for the Windows API \`MultiByteToWideChar\` function, and \`string->multibyte\` is a wrapper for the Windows API \`WideCharToMultiByte\` function.

*code-page* declares the encoding of the byte sequences in the input or output bytevectors. It must be an exact nonnegative integer identifying a code page or one of the symbols \`cp-acp\`, \`cp-maccp\`, \`cp-oemcp\`, \`cp-symbol\`, \`cp-thread-acp\`, \`cp-utf7\`, or \`cp-utf8\`, which have the same meanings as the API function meanings for the like-named constants.
`
    },
    {
        name: "(string->number ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s78"),
        description: `**procedure**: \`(string->number \`*string*\`)\`
**procedure**: \`(string->number \`*string*\` \`*radix*\`)\`
**returns: **the number represented by *string*, or \`#f\`
**libraries: **\`(chezscheme)\`

This procedure is identical to the Revised Report version except that \`radix\` may be any exact integer between 2 and 36, inclusive. The Revised Report version requires radix to be in the set {2,8,10,16}.

\`(string->number "211012" 3) \`=>\` 559\`
\` (string->number "tobeornottobe" 36) \`=>\` 140613689159812836698\`
`
    },
    {
        name: "(string->number ",
        endParen: true,
        params: ["string", "radix"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s78"),
        description: `**procedure**: \`(string->number \`*string*\`)\`
**procedure**: \`(string->number \`*string*\` \`*radix*\`)\`
**returns: **the number represented by *string*, or \`#f\`
**libraries: **\`(chezscheme)\`

This procedure is identical to the Revised Report version except that \`radix\` may be any exact integer between 2 and 36, inclusive. The Revised Report version requires radix to be in the set {2,8,10,16}.

\`(string->number "211012" 3) \`=>\` 559\`
\` (string->number "tobeornottobe" 36) \`=>\` 140613689159812836698\`
`
    },
    {
        name: "(string->number ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s147"),
        description: `**procedure**: \`(string->number \`*string*\`)\`
**procedure**: \`(string->number \`*string*\` \`*radix*\`)\`
**returns: **the number represented by *string*, or \`#f\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *string* is a valid representation of a number, that number is returned, otherwise \`#f\` is returned. The number is interpreted in radix *radix*, which must be an exact integer in the set {2,8,10,16}. If not specified, *radix* defaults to 10. Any radix specifier within *string*, e.g., \`#x\`, overrides the *radix* argument.

\`(string->number "0") \`=>\` 0\`
\` (string->number "3.4e3") \`=>\` 3400.0\`
\` (string->number "#x#e-2e2") \`=>\` -738\`
\` (string->number "#e-2e2" 16) \`=>\` -738\`
\` (string->number "#i15/16") \`=>\` 0.9375\`
\` (string->number "10" 16) \`=>\` 16\`
`
    },
    {
        name: "(string->number ",
        endParen: true,
        params: ["string", "radix"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s147"),
        description: `**procedure**: \`(string->number \`*string*\`)\`
**procedure**: \`(string->number \`*string*\` \`*radix*\`)\`
**returns: **the number represented by *string*, or \`#f\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *string* is a valid representation of a number, that number is returned, otherwise \`#f\` is returned. The number is interpreted in radix *radix*, which must be an exact integer in the set {2,8,10,16}. If not specified, *radix* defaults to 10. Any radix specifier within *string*, e.g., \`#x\`, overrides the *radix* argument.

\`(string->number "0") \`=>\` 0\`
\` (string->number "3.4e3") \`=>\` 3400.0\`
\` (string->number "#x#e-2e2") \`=>\` -738\`
\` (string->number "#e-2e2" 16) \`=>\` -738\`
\` (string->number "#i15/16") \`=>\` 0.9375\`
\` (string->number "10" 16) \`=>\` 16\`
`
    },
    {
        name: "(string->symbol ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s269"),
        description: `**procedure**: \`(string->symbol \`*string*\`)\`
**returns: **a symbol whose name is *string*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`string->symbol\` records all symbols it creates in an internal table that it shares with the system reader. If a symbol whose name is equivalent to string (according to the predicate \`string=?\`) already exists in the table, this symbol is returned. Otherwise, a new symbol is created with *string* as its name; this symbol is entered into the table and returned.

The effect of modifying a string after it is used as an argument to \`string->symbol\` is unspecified.

\`(string->symbol "x") \`=>\` x \`
\` \`
\` (eq? (string->symbol "x") 'x) \`=>\` #t\`
\` (eq? (string->symbol "X") 'x) \`=>\` #f \`
\` \`
\` (eq? (string->symbol "x")\`
\`      (string->symbol "x")) \`=>\` #t \`
\` \`
\` (string->symbol "()") \`=>\` \\x28;\\x29;\`
`
    },
    {
        name: "(string->utf16 ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s94"),
        description: `**procedure**: \`(string->utf16 \`*string*\`)\`
**procedure**: \`(string->utf16 \`*string*\` \`*endianness*\`)\`
**procedure**: \`(string->utf32 \`*string*\`)\`
**procedure**: \`(string->utf32 \`*string*\` \`*endianness*\`)\`
**returns: **a bytevector containing the specified encoding of *string*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. If *endianness* is not provided or is the symbol \`big\`, \`string->utf16\` returns the UTF-16BE encoding of *string* and \`string->utf32\` returns the UTF-32BE encoding of *string*. If *endianness* is the symbol \`little\`, \`string->utf16\` returns the UTF-16LE encoding of *string* and \`string->utf32\` returns the UTF-32LE encoding of *string*. No byte-order mark is included in the encoding.
`
    },
    {
        name: "(string->utf16 ",
        endParen: true,
        params: ["string", "endianness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s94"),
        description: `**procedure**: \`(string->utf16 \`*string*\`)\`
**procedure**: \`(string->utf16 \`*string*\` \`*endianness*\`)\`
**procedure**: \`(string->utf32 \`*string*\`)\`
**procedure**: \`(string->utf32 \`*string*\` \`*endianness*\`)\`
**returns: **a bytevector containing the specified encoding of *string*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. If *endianness* is not provided or is the symbol \`big\`, \`string->utf16\` returns the UTF-16BE encoding of *string* and \`string->utf32\` returns the UTF-32BE encoding of *string*. If *endianness* is the symbol \`little\`, \`string->utf16\` returns the UTF-16LE encoding of *string* and \`string->utf32\` returns the UTF-32LE encoding of *string*. No byte-order mark is included in the encoding.
`
    },
    {
        name: "(string->utf32 ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s94"),
        description: `**procedure**: \`(string->utf16 \`*string*\`)\`
**procedure**: \`(string->utf16 \`*string*\` \`*endianness*\`)\`
**procedure**: \`(string->utf32 \`*string*\`)\`
**procedure**: \`(string->utf32 \`*string*\` \`*endianness*\`)\`
**returns: **a bytevector containing the specified encoding of *string*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. If *endianness* is not provided or is the symbol \`big\`, \`string->utf16\` returns the UTF-16BE encoding of *string* and \`string->utf32\` returns the UTF-32BE encoding of *string*. If *endianness* is the symbol \`little\`, \`string->utf16\` returns the UTF-16LE encoding of *string* and \`string->utf32\` returns the UTF-32LE encoding of *string*. No byte-order mark is included in the encoding.
`
    },
    {
        name: "(string->utf32 ",
        endParen: true,
        params: ["string", "endianness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s94"),
        description: `**procedure**: \`(string->utf16 \`*string*\`)\`
**procedure**: \`(string->utf16 \`*string*\` \`*endianness*\`)\`
**procedure**: \`(string->utf32 \`*string*\`)\`
**procedure**: \`(string->utf32 \`*string*\` \`*endianness*\`)\`
**returns: **a bytevector containing the specified encoding of *string*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. If *endianness* is not provided or is the symbol \`big\`, \`string->utf16\` returns the UTF-16BE encoding of *string* and \`string->utf32\` returns the UTF-32BE encoding of *string*. If *endianness* is the symbol \`little\`, \`string->utf16\` returns the UTF-16LE encoding of *string* and \`string->utf32\` returns the UTF-32LE encoding of *string*. No byte-order mark is included in the encoding.
`
    },
    {
        name: "(string->utf8 ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s93"),
        description: `**procedure**: \`(string->utf8 \`*string*\`)\`
**returns: **a bytevector containing the UTF-8 encoding of *string*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`
`
    },
    {
        name: "(string-append ",
        endParen: true,
        params: ["string", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s223"),
        description: `**procedure**: \`(string-append \`*string*\` ...)\`
**returns: **a new string formed by concatenating the strings *string*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (string-append) \`=>\` ""\`
\` (string-append "abc" "def") \`=>\` "abcdef"\`
\` (string-append "Hey " "you " "there!") \`=>\` "Hey you there!"\`

The following implementation of \`string-append\` recurs down the list of strings to compute the total length, then allocates the new string, then fills it up as it unwinds the recursion.

\`(define string-append\`
\`   (lambda args\`
\`     (let f ([ls args] [n 0])\`
\`       (if (null? ls)\`
\`           (make-string n)\`
\`           (let* ([s1 (car ls)]\`
\`                  [m (string-length s1)]\`
\`                  [s2 (f (cdr ls) (+ n m))])\`
\`             (do ([i 0 (+ i 1)] [j n (+ j 1)])\`
\`                 ((= i m) s2)\`
\`               (string-set! s2 j (string-ref s1 i))))))))\`
`
    },
    {
        name: "(string-ci-hash ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s279"),
        description: `**procedure**: \`(equal-hash \`*obj*\`)\`
**procedure**: \`(string-hash \`*string*\`)\`
**procedure**: \`(string-ci-hash \`*string*\`)\`
**procedure**: \`(symbol-hash \`*symbol*\`)\`
**returns: **an exact nonnegative integer hash value
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

These procedures are hash functions suitable for use with the appropriate Scheme predicate: \`equal?\` for \`equal-hash\`, \`string=?\` for \`string-hash\`, \`string-ci=?\` for \`string-ci-hash\`, and \`symbol=?\` (or eq?) for \`symbol-hash\`. The hash values returned by \`equal-hash\`, \`string-hash\`, and \`string-ci-hash\` are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable.
`
    },
    {
        name: "(string-ci<=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string-ci<=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s216"),
        description: `**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to \`string=?\`, \`string<?\`, \`string>?\`, \`string<=?\`, and \`string>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.

\`(string-ci=? "Mom and Dad" "mom and dad") \`=>\` #t\`
\` (string-ci<=? "say what" "Say What!?") \`=>\` #t\`
\` (string-ci>? "N" "m" "L" "k") \`=>\` #t\`
\` (string-ci=? "Straße" "Strasse") \`=>\` #t\`
`
    },
    {
        name: "(string-ci<? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string-ci<? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s216"),
        description: `**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to \`string=?\`, \`string<?\`, \`string>?\`, \`string<=?\`, and \`string>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.

\`(string-ci=? "Mom and Dad" "mom and dad") \`=>\` #t\`
\` (string-ci<=? "say what" "Say What!?") \`=>\` #t\`
\` (string-ci>? "N" "m" "L" "k") \`=>\` #t\`
\` (string-ci=? "Straße" "Strasse") \`=>\` #t\`
`
    },
    {
        name: "(string-ci=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string-ci=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s216"),
        description: `**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to \`string=?\`, \`string<?\`, \`string>?\`, \`string<=?\`, and \`string>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.

\`(string-ci=? "Mom and Dad" "mom and dad") \`=>\` #t\`
\` (string-ci<=? "say what" "Say What!?") \`=>\` #t\`
\` (string-ci>? "N" "m" "L" "k") \`=>\` #t\`
\` (string-ci=? "Straße" "Strasse") \`=>\` #t\`
`
    },
    {
        name: "(string-ci>=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string-ci>=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s216"),
        description: `**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to \`string=?\`, \`string<?\`, \`string>?\`, \`string<=?\`, and \`string>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.

\`(string-ci=? "Mom and Dad" "mom and dad") \`=>\` #t\`
\` (string-ci<=? "say what" "Say What!?") \`=>\` #t\`
\` (string-ci>? "N" "m" "L" "k") \`=>\` #t\`
\` (string-ci=? "Straße" "Strasse") \`=>\` #t\`
`
    },
    {
        name: "(string-ci>? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string-ci>? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s216"),
        description: `**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These predicates are identical to \`string=?\`, \`string<?\`, \`string>?\`, \`string<=?\`, and \`string>=?\` except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.

\`(string-ci=? "Mom and Dad" "mom and dad") \`=>\` #t\`
\` (string-ci<=? "say what" "Say What!?") \`=>\` #t\`
\` (string-ci>? "N" "m" "L" "k") \`=>\` #t\`
\` (string-ci=? "Straße" "Strasse") \`=>\` #t\`
`
    },
    {
        name: "(string-copy ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s222"),
        description: `**procedure**: \`(string-copy \`*string*\`)\`
**returns: **a new copy of *string*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

This procedure creates a new string with the same length and contents as *string*.

\`(string-copy "abc") \`=>\` "abc" \`
\` \`
\` (let ([str "abc"])\`
\`   (eq? str (string-copy str))) \`=>\` #f\`
`
    },
    {
        name: "(string-copy! ",
        endParen: true,
        params: ["src", "src-start", "dst", "dst-start", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s21"),
        description: `**procedure**: \`(string-copy! \`*src*\` \`*src-start*\` \`*dst*\` \`*dst-start*\` \`*n*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*src* and *dst* must be strings, and *dst* must be mutable. *src-start*, *dst-start*, and *n* must be exact nonnegative integers. The sum of *src-start* and *n* must not exceed the length of *src*, and the sum of *dst-start* and *n* must not exceed the length of *dst*.

\`string-copy!\` overwrites the *n* bytes of *dst* starting at *dst-start* with the *n* bytes of *dst* starting at *src-start*. This works even if *dst* is the same string as *src* and the source and destination locations overlap. That is, the destination is filled with the characters that appeared at the source before the operation began.

\`(define s1 "to boldly go")\`
\` (define s2 (make-string 10 #\\-)) \`
\` \`
\` (string-copy! s1 3 s2 1 3)\`
\` s2 \`=>\` "-bol------"\`
\`  \`
\` (string-copy! s1 7 s2 4 2)\`
\` s2 \`=>\` "-bolly----"\`
\`  \`
\` (string-copy! s2 2 s2 5 4)\`
\` s2 \`=>\` "-bollolly-"\`
`
    },
    {
        name: "(string-downcase ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s226"),
        description: `**procedure**: \`(string-upcase \`*string*\`)\`
**returns: **the upper-case equivalent of *string*
**procedure**: \`(string-downcase \`*string*\`)\`
**returns: **the lower-case equivalent of *string*
**procedure**: \`(string-foldcase \`*string*\`)\`
**returns: **the case-folded equivalent of *string*
**procedure**: \`(string-titlecase \`*string*\`)\`
**returns: **the title-case equivalent of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of *string*. If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated. \`string-foldcase\` does not use the special mappings for Turkic languages.

\`string-titlecase\` converts the first cased character of each word in *string* to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [].

\`(string-upcase "Hi") \`=>\` "HI"\`
\` (string-downcase "Hi") \`=>\` "hi"\`
\` (string-foldcase "Hi") \`=>\` "hi" \`
\` \`
\` (string-upcase "Straße") \`=>\` "STRASSE"\`
\` (string-downcase "Straße") \`=>\` "straße"\`
\` (string-foldcase "Straße") \`=>\` "strasse"\`
\` (string-downcase "STRASSE")  \`=>\` "strasse" \`
\` \`
\` (string-downcase "\`\`") \`=>\` "\`\`" \`
\` \`
\` (string-titlecase "kNock KNoCK") \`=>\` "Knock Knock"\`
\` (string-titlecase "who's there?") \`=>\` "Who's There?"\`
\` (string-titlecase "r6rs") \`=>\` "R6rs"\`
\` (string-titlecase "R6RS") \`=>\` "R6rs"\`
`
    },
    {
        name: "(string-fill! ",
        endParen: true,
        params: ["string", "char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s225"),
        description: `**procedure**: \`(string-fill! \`*string*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs mutable-strings)\`

\`string-fill!\` sets every character in *string* to *char*.

\`(let ([str (string-copy "sleepy")])\`
\`   (string-fill! str #\\Z)\`
\`   str) \`=>\` "ZZZZZZ"\`

\`string-fill!\` might be defined as follows:

\`(define string-fill!\`
\`   (lambda (s c)\`
\`     (let ([n (string-length s)])\`
\`       (do ([i 0 (+ i 1)])\`
\`           ((= i n))\`
\`           (string-set! s i c)))))\`

An alternative definition is given on page .
`
    },
    {
        name: "(string-foldcase ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s226"),
        description: `**procedure**: \`(string-upcase \`*string*\`)\`
**returns: **the upper-case equivalent of *string*
**procedure**: \`(string-downcase \`*string*\`)\`
**returns: **the lower-case equivalent of *string*
**procedure**: \`(string-foldcase \`*string*\`)\`
**returns: **the case-folded equivalent of *string*
**procedure**: \`(string-titlecase \`*string*\`)\`
**returns: **the title-case equivalent of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of *string*. If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated. \`string-foldcase\` does not use the special mappings for Turkic languages.

\`string-titlecase\` converts the first cased character of each word in *string* to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [].

\`(string-upcase "Hi") \`=>\` "HI"\`
\` (string-downcase "Hi") \`=>\` "hi"\`
\` (string-foldcase "Hi") \`=>\` "hi" \`
\` \`
\` (string-upcase "Straße") \`=>\` "STRASSE"\`
\` (string-downcase "Straße") \`=>\` "straße"\`
\` (string-foldcase "Straße") \`=>\` "strasse"\`
\` (string-downcase "STRASSE")  \`=>\` "strasse" \`
\` \`
\` (string-downcase "\`\`") \`=>\` "\`\`" \`
\` \`
\` (string-titlecase "kNock KNoCK") \`=>\` "Knock Knock"\`
\` (string-titlecase "who's there?") \`=>\` "Who's There?"\`
\` (string-titlecase "r6rs") \`=>\` "R6rs"\`
\` (string-titlecase "R6RS") \`=>\` "R6rs"\`
`
    },
    {
        name: "(string-for-each ",
        endParen: true,
        params: ["procedure", "string1", "string2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s50"),
        description: `**procedure**: \`(string-for-each \`*procedure*\` \`*string1*\` \`*string2*\` ...)\`
**returns: **unspecified
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(string-hash ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s279"),
        description: `**procedure**: \`(equal-hash \`*obj*\`)\`
**procedure**: \`(string-hash \`*string*\`)\`
**procedure**: \`(string-ci-hash \`*string*\`)\`
**procedure**: \`(symbol-hash \`*symbol*\`)\`
**returns: **an exact nonnegative integer hash value
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

These procedures are hash functions suitable for use with the appropriate Scheme predicate: \`equal?\` for \`equal-hash\`, \`string=?\` for \`string-hash\`, \`string-ci=?\` for \`string-ci-hash\`, and \`symbol=?\` (or eq?) for \`symbol-hash\`. The hash values returned by \`equal-hash\`, \`string-hash\`, and \`string-ci-hash\` are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable.
`
    },
    {
        name: "(string-length ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s219"),
        description: `**procedure**: \`(string-length \`*string*\`)\`
**returns: **the number of characters in *string*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The length of a string is always an exact nonnegative integer.

\`(string-length "abc") \`=>\` 3\`
\` (string-length "") \`=>\` 0\`
\` (string-length "hi there") \`=>\` 8\`
\` (string-length (make-string 1000000)) \`=>\` 1000000\`
`
    },
    {
        name: "(string-normalize-nfc ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s227"),
        description: `**procedure**: \`(string-normalize-nfd \`*string*\`)\`
**returns: **the Unicode normalized form D of *string*
**procedure**: \`(string-normalize-nfkd \`*string*\`)\`
**returns: **the Unicode normalized form KD of *string*
**procedure**: \`(string-normalize-nfc \`*string*\`)\`
**returns: **the Unicode normalized form C of *string*
**procedure**: \`(string-normalize-nfkc \`*string*\`)\`
**returns: **the Unicode normalized form KC of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated.

\`(string-normalize-nfd "\\xE9;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\xE9;") \`=>\` "\\xE9;"\`
\` (string-normalize-nfd "\\x65;\\x301;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\x65;\\x301;") \`=>\` "\\xE9;"\`
`
    },
    {
        name: "(string-normalize-nfd ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s227"),
        description: `**procedure**: \`(string-normalize-nfd \`*string*\`)\`
**returns: **the Unicode normalized form D of *string*
**procedure**: \`(string-normalize-nfkd \`*string*\`)\`
**returns: **the Unicode normalized form KD of *string*
**procedure**: \`(string-normalize-nfc \`*string*\`)\`
**returns: **the Unicode normalized form C of *string*
**procedure**: \`(string-normalize-nfkc \`*string*\`)\`
**returns: **the Unicode normalized form KC of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated.

\`(string-normalize-nfd "\\xE9;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\xE9;") \`=>\` "\\xE9;"\`
\` (string-normalize-nfd "\\x65;\\x301;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\x65;\\x301;") \`=>\` "\\xE9;"\`
`
    },
    {
        name: "(string-normalize-nfkc ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s227"),
        description: `**procedure**: \`(string-normalize-nfd \`*string*\`)\`
**returns: **the Unicode normalized form D of *string*
**procedure**: \`(string-normalize-nfkd \`*string*\`)\`
**returns: **the Unicode normalized form KD of *string*
**procedure**: \`(string-normalize-nfc \`*string*\`)\`
**returns: **the Unicode normalized form C of *string*
**procedure**: \`(string-normalize-nfkc \`*string*\`)\`
**returns: **the Unicode normalized form KC of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated.

\`(string-normalize-nfd "\\xE9;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\xE9;") \`=>\` "\\xE9;"\`
\` (string-normalize-nfd "\\x65;\\x301;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\x65;\\x301;") \`=>\` "\\xE9;"\`
`
    },
    {
        name: "(string-normalize-nfkd ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s227"),
        description: `**procedure**: \`(string-normalize-nfd \`*string*\`)\`
**returns: **the Unicode normalized form D of *string*
**procedure**: \`(string-normalize-nfkd \`*string*\`)\`
**returns: **the Unicode normalized form KD of *string*
**procedure**: \`(string-normalize-nfc \`*string*\`)\`
**returns: **the Unicode normalized form C of *string*
**procedure**: \`(string-normalize-nfkc \`*string*\`)\`
**returns: **the Unicode normalized form KC of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated.

\`(string-normalize-nfd "\\xE9;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\xE9;") \`=>\` "\\xE9;"\`
\` (string-normalize-nfd "\\x65;\\x301;") \`=>\` "e\\x301;"\`
\` (string-normalize-nfc "\\x65;\\x301;") \`=>\` "\\xE9;"\`
`
    },
    {
        name: "(string-ref ",
        endParen: true,
        params: ["string", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s220"),
        description: `**procedure**: \`(string-ref \`*string*\` \`*n*\`)\`
**returns: **the *n*th character (zero-based) of *string*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *string*.

\`(string-ref "hi there" 0) \`=>\` #\\h\`
\` (string-ref "hi there" 5) \`=>\` #\\e\`
`
    },
    {
        name: "(string-set! ",
        endParen: true,
        params: ["string", "n", "char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s221"),
        description: `**procedure**: \`(string-set! \`*string*\` \`*n*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs mutable-strings)\`

*n* must be an exact nonnegative integer less than the length of *string*. \`string-set!\` changes the *n*th element of *string* to *char*.

\`(let ([str (string-copy "hi three")])\`
\`   (string-set! str 5 #\\e)\`
\`   (string-set! str 6 #\\r)\`
\`   str) \`=>\` "hi there"\`
`
    },
    {
        name: "(string-titlecase ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s226"),
        description: `**procedure**: \`(string-upcase \`*string*\`)\`
**returns: **the upper-case equivalent of *string*
**procedure**: \`(string-downcase \`*string*\`)\`
**returns: **the lower-case equivalent of *string*
**procedure**: \`(string-foldcase \`*string*\`)\`
**returns: **the case-folded equivalent of *string*
**procedure**: \`(string-titlecase \`*string*\`)\`
**returns: **the title-case equivalent of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of *string*. If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated. \`string-foldcase\` does not use the special mappings for Turkic languages.

\`string-titlecase\` converts the first cased character of each word in *string* to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [].

\`(string-upcase "Hi") \`=>\` "HI"\`
\` (string-downcase "Hi") \`=>\` "hi"\`
\` (string-foldcase "Hi") \`=>\` "hi" \`
\` \`
\` (string-upcase "Straße") \`=>\` "STRASSE"\`
\` (string-downcase "Straße") \`=>\` "straße"\`
\` (string-foldcase "Straße") \`=>\` "strasse"\`
\` (string-downcase "STRASSE")  \`=>\` "strasse" \`
\` \`
\` (string-downcase "\`\`") \`=>\` "\`\`" \`
\` \`
\` (string-titlecase "kNock KNoCK") \`=>\` "Knock Knock"\`
\` (string-titlecase "who's there?") \`=>\` "Who's There?"\`
\` (string-titlecase "r6rs") \`=>\` "R6rs"\`
\` (string-titlecase "R6RS") \`=>\` "R6rs"\`
`
    },
    {
        name: "(string-truncate! ",
        endParen: true,
        params: ["string", "n"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s23"),
        description: `**procedure**: \`(string-truncate! \`*string*\` \`*n*\`)\`
**returns: ***string* or the empty string
**libraries: **\`(chezscheme)\`

*string* must be mutable. *n* must be an exact nonnegative fixnum not greater than the length of *string*. If *n* is zero, \`string-truncate!\` returns the empty string. Otherwise, *string-truncate!* destructively truncates *string* to its first *n* characters and returns *string*.

\`(define s (make-string 7 #\\$))\`
\` (string-truncate! s 0) \`=>\` ""\`
\` s \`=>\` "$$$$$$$"\`
\` (string-truncate! s 3) \`=>\` "$$$"\`
\` s \`=>\` "$$$"\`
`
    },
    {
        name: "(string-upcase ",
        endParen: true,
        params: ["string"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s226"),
        description: `**procedure**: \`(string-upcase \`*string*\`)\`
**returns: **the upper-case equivalent of *string*
**procedure**: \`(string-downcase \`*string*\`)\`
**returns: **the lower-case equivalent of *string*
**procedure**: \`(string-foldcase \`*string*\`)\`
**returns: **the case-folded equivalent of *string*
**procedure**: \`(string-titlecase \`*string*\`)\`
**returns: **the title-case equivalent of *string*
**libraries: **\`(rnrs unicode)\`, \`(rnrs)\`

These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of *string*. If the result string is the same as *string* (by \`string=?\`), *string* or a copy of *string* may be returned. Otherwise, the result string is newly allocated. \`string-foldcase\` does not use the special mappings for Turkic languages.

\`string-titlecase\` converts the first cased character of each word in *string* to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [].

\`(string-upcase "Hi") \`=>\` "HI"\`
\` (string-downcase "Hi") \`=>\` "hi"\`
\` (string-foldcase "Hi") \`=>\` "hi" \`
\` \`
\` (string-upcase "Straße") \`=>\` "STRASSE"\`
\` (string-downcase "Straße") \`=>\` "straße"\`
\` (string-foldcase "Straße") \`=>\` "strasse"\`
\` (string-downcase "STRASSE")  \`=>\` "strasse" \`
\` \`
\` (string-downcase "\`\`") \`=>\` "\`\`" \`
\` \`
\` (string-titlecase "kNock KNoCK") \`=>\` "Knock Knock"\`
\` (string-titlecase "who's there?") \`=>\` "Who's There?"\`
\` (string-titlecase "r6rs") \`=>\` "R6rs"\`
\` (string-titlecase "R6RS") \`=>\` "R6rs"\`
`
    },
    {
        name: "(string<=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string<=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s215"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

As with \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`, these predicates express relationships among all of the arguments. For example, \`string>?\` determines if the lexicographic ordering of its arguments is monotonically decreasing.

The comparisons are based on the character predicates \`char=?\` and \`char<?\`. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to \`char=?\`. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by \`char=?\`) determines which string is lexicographically less than the other, according to \`char<?\`.

Two-argument \`string=?\` may be defined without error checks as follows.

\`(define string=?\`
\`   (lambda (s1 s2)\`
\`     (let ([n (string-length s1)])\`
\`       (and (= (string-length s2) n)\`
\`            (let loop ([i 0])\`
\`              (or (= i n)\`
\`                  (and (char=? (string-ref s1 i) (string-ref s2 i))\`
\`                       (loop (+ i 1)))))))))\`

Two-argument \`string<?\` may be defined without error checks as follows.

\`(define string<?\`
\`   (lambda (s1 s2)\`
\`     (let ([n1 (string-length s1)] [n2 (string-length s2)])\`
\`       (let loop ([i 0])\`
\`         (and (not (= i n2))\`
\`              (or (= i n1)\`
\`                  (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\`
\`                    (or (char<? c1 c2)\`
\`                        (and (char=? c1 c2)\`
\`                             (loop (+ i 1)))))))))))\`

These definitions may be extended straightforwardly to support three or more arguments. \`string<=?\`, \`string>?\`, and \`string>=?\` may be defined similarly.

\`(string=? "mom" "mom") \`=>\` #t\`
\` (string<? "mom" "mommy") \`=>\` #t\`
\` (string>? "Dad" "Dad") \`=>\` #f\`
\` (string=? "Mom and Dad" "mom and dad") \`=>\` #f\`
\` (string<? "a" "b" "c") \`=>\` #t\`
`
    },
    {
        name: "(string<? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string<? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s215"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

As with \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`, these predicates express relationships among all of the arguments. For example, \`string>?\` determines if the lexicographic ordering of its arguments is monotonically decreasing.

The comparisons are based on the character predicates \`char=?\` and \`char<?\`. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to \`char=?\`. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by \`char=?\`) determines which string is lexicographically less than the other, according to \`char<?\`.

Two-argument \`string=?\` may be defined without error checks as follows.

\`(define string=?\`
\`   (lambda (s1 s2)\`
\`     (let ([n (string-length s1)])\`
\`       (and (= (string-length s2) n)\`
\`            (let loop ([i 0])\`
\`              (or (= i n)\`
\`                  (and (char=? (string-ref s1 i) (string-ref s2 i))\`
\`                       (loop (+ i 1)))))))))\`

Two-argument \`string<?\` may be defined without error checks as follows.

\`(define string<?\`
\`   (lambda (s1 s2)\`
\`     (let ([n1 (string-length s1)] [n2 (string-length s2)])\`
\`       (let loop ([i 0])\`
\`         (and (not (= i n2))\`
\`              (or (= i n1)\`
\`                  (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\`
\`                    (or (char<? c1 c2)\`
\`                        (and (char=? c1 c2)\`
\`                             (loop (+ i 1)))))))))))\`

These definitions may be extended straightforwardly to support three or more arguments. \`string<=?\`, \`string>?\`, and \`string>=?\` may be defined similarly.

\`(string=? "mom" "mom") \`=>\` #t\`
\` (string<? "mom" "mommy") \`=>\` #t\`
\` (string>? "Dad" "Dad") \`=>\` #f\`
\` (string=? "Mom and Dad" "mom and dad") \`=>\` #f\`
\` (string<? "a" "b" "c") \`=>\` #t\`
`
    },
    {
        name: "(string=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s215"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

As with \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`, these predicates express relationships among all of the arguments. For example, \`string>?\` determines if the lexicographic ordering of its arguments is monotonically decreasing.

The comparisons are based on the character predicates \`char=?\` and \`char<?\`. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to \`char=?\`. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by \`char=?\`) determines which string is lexicographically less than the other, according to \`char<?\`.

Two-argument \`string=?\` may be defined without error checks as follows.

\`(define string=?\`
\`   (lambda (s1 s2)\`
\`     (let ([n (string-length s1)])\`
\`       (and (= (string-length s2) n)\`
\`            (let loop ([i 0])\`
\`              (or (= i n)\`
\`                  (and (char=? (string-ref s1 i) (string-ref s2 i))\`
\`                       (loop (+ i 1)))))))))\`

Two-argument \`string<?\` may be defined without error checks as follows.

\`(define string<?\`
\`   (lambda (s1 s2)\`
\`     (let ([n1 (string-length s1)] [n2 (string-length s2)])\`
\`       (let loop ([i 0])\`
\`         (and (not (= i n2))\`
\`              (or (= i n1)\`
\`                  (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\`
\`                    (or (char<? c1 c2)\`
\`                        (and (char=? c1 c2)\`
\`                             (loop (+ i 1)))))))))))\`

These definitions may be extended straightforwardly to support three or more arguments. \`string<=?\`, \`string>?\`, and \`string>=?\` may be defined similarly.

\`(string=? "mom" "mom") \`=>\` #t\`
\` (string<? "mom" "mommy") \`=>\` #t\`
\` (string>? "Dad" "Dad") \`=>\` #f\`
\` (string=? "Mom and Dad" "mom and dad") \`=>\` #f\`
\` (string<? "a" "b" "c") \`=>\` #t\`
`
    },
    {
        name: "(string>=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string>=? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s215"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

As with \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`, these predicates express relationships among all of the arguments. For example, \`string>?\` determines if the lexicographic ordering of its arguments is monotonically decreasing.

The comparisons are based on the character predicates \`char=?\` and \`char<?\`. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to \`char=?\`. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by \`char=?\`) determines which string is lexicographically less than the other, according to \`char<?\`.

Two-argument \`string=?\` may be defined without error checks as follows.

\`(define string=?\`
\`   (lambda (s1 s2)\`
\`     (let ([n (string-length s1)])\`
\`       (and (= (string-length s2) n)\`
\`            (let loop ([i 0])\`
\`              (or (= i n)\`
\`                  (and (char=? (string-ref s1 i) (string-ref s2 i))\`
\`                       (loop (+ i 1)))))))))\`

Two-argument \`string<?\` may be defined without error checks as follows.

\`(define string<?\`
\`   (lambda (s1 s2)\`
\`     (let ([n1 (string-length s1)] [n2 (string-length s2)])\`
\`       (let loop ([i 0])\`
\`         (and (not (= i n2))\`
\`              (or (= i n1)\`
\`                  (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\`
\`                    (or (char<? c1 c2)\`
\`                        (and (char=? c1 c2)\`
\`                             (loop (+ i 1)))))))))))\`

These definitions may be extended straightforwardly to support three or more arguments. \`string<=?\`, \`string>?\`, and \`string>=?\` may be defined similarly.

\`(string=? "mom" "mom") \`=>\` #t\`
\` (string<? "mom" "mommy") \`=>\` #t\`
\` (string>? "Dad" "Dad") \`=>\` #f\`
\` (string=? "Mom and Dad" "mom and dad") \`=>\` #f\`
\` (string<? "a" "b" "c") \`=>\` #t\`
`
    },
    {
        name: "(string>? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s20"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string-ci>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

These predicates are identical to the Revised Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns \`#t\`.

\`(string>? "a") \`=>\` #t\`
\` (string<? "a") \`=>\` #t\`
\` (string-ci=? "a") \`=>\` #t\`
`
    },
    {
        name: "(string>? ",
        endParen: true,
        params: ["string1", "string2", "string3", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s215"),
        description: `**procedure**: \`(string=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string<=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**procedure**: \`(string>=? \`*string1*\` \`*string2*\` \`*string3*\` ...)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

As with \`=\`, \`<\`, \`>\`, \`<=\`, and \`>=\`, these predicates express relationships among all of the arguments. For example, \`string>?\` determines if the lexicographic ordering of its arguments is monotonically decreasing.

The comparisons are based on the character predicates \`char=?\` and \`char<?\`. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to \`char=?\`. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by \`char=?\`) determines which string is lexicographically less than the other, according to \`char<?\`.

Two-argument \`string=?\` may be defined without error checks as follows.

\`(define string=?\`
\`   (lambda (s1 s2)\`
\`     (let ([n (string-length s1)])\`
\`       (and (= (string-length s2) n)\`
\`            (let loop ([i 0])\`
\`              (or (= i n)\`
\`                  (and (char=? (string-ref s1 i) (string-ref s2 i))\`
\`                       (loop (+ i 1)))))))))\`

Two-argument \`string<?\` may be defined without error checks as follows.

\`(define string<?\`
\`   (lambda (s1 s2)\`
\`     (let ([n1 (string-length s1)] [n2 (string-length s2)])\`
\`       (let loop ([i 0])\`
\`         (and (not (= i n2))\`
\`              (or (= i n1)\`
\`                  (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\`
\`                    (or (char<? c1 c2)\`
\`                        (and (char=? c1 c2)\`
\`                             (loop (+ i 1)))))))))))\`

These definitions may be extended straightforwardly to support three or more arguments. \`string<=?\`, \`string>?\`, and \`string>=?\` may be defined similarly.

\`(string=? "mom" "mom") \`=>\` #t\`
\` (string<? "mom" "mommy") \`=>\` #t\`
\` (string>? "Dad" "Dad") \`=>\` #f\`
\` (string=? "Mom and Dad" "mom and dad") \`=>\` #f\`
\` (string<? "a" "b" "c") \`=>\` #t\`
`
    },
    {
        name: "(string? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s20"),
        description: `**procedure**: \`(string? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a string, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (string? "hi") \`=>\` #t\`
\` (string? 'hi) \`=>\` #f\`
\` (string? #\\h) \`=>\` #f\`
`
    },
    {
        name: "(strip-fasl-file ",
        endParen: true,
        params: ["input-path", "output-path", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s87"),
        description: `**procedure**: \`(strip-fasl-file \`*input-path*\` \`*output-path*\` \`*options*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*input-path* and *output-path* must be strings. *input-path* must name an existing, readable file containing object code produced by \`compile-file\`, one of the other file-compiling procedures, or an earlier run of \`strip-fasl-file\`. *options* must be an enumeration set over the symbols constituting valid strip options, as described in the \`fasl-strip-options\` entry below.

The new procedure \`strip-fasl-file\` allows the removal of source information of various sorts from a compiled object (fasl) file produced by \`compile-file\` or one of the other file compiling procedures. It also allows removal of library visit code from object files containing compiled libraries. Visit code is the code for macro transformers and meta definitions required to compile (but not run) dependent libraries.

On most platforms, the input and output paths can be the same, in which case the input file is replaced with a new file containing the stripped object code. Using the same path will likely fail on Windows file systems, which do not generally permit an open file to be removed.

If *options* is empty, the output file is effectively equivalent to the input file, though it will not necessarily be identical.
`
    },
    {
        name: "(sub1 ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s68"),
        description: `**procedure**: \`(1+ \`*num*\`)\`
**procedure**: \`(add1 \`*num*\`)\`
**procedure**: \`(1- \`*num*\`)\`
**procedure**: \`(-1+ \`*num*\`)\`
**procedure**: \`(sub1 \`*num*\`)\`
**returns: ***num* plus 1 or *num* minus 1
**libraries: **\`(chezscheme)\`

\`1+\` and \`add1\` are equivalent to \`(lambda (x) (+ x 1))\`; \`1-\`, \`-1+\`, and \`sub1\` are equivalent to \`(lambda (x) (- x 1))\`.

\`(define plus\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x y)\`
\`     (if (zero? x)\`
\`         y\`
\`         (plus (1- x) (1+ y))))) \`
\` \`
\` (plus 7 8) \`=>\` 15 \`
\` \`
\` (define double\`
\`  ; x should be a nonnegative integer\`
\`   (lambda (x)\`
\`     (if (zero? x)\`
\`         0\`
\`         (add1 (add1 (double (sub1 x))))))) \`
\` \`
\` (double 7) \`=>\` 14\`
`
    },
    {
        name: "subset-mode",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s263"),
        description: `**thread parameter**: \`subset-mode\`
**libraries: **\`(chezscheme)\`

The value of this parameter must be \`#f\` (the default) or the symbol \`system\`. Setting \`subset-mode\` to \`system\` allows the manipulation of various undocumented system variables, data structures, and settings. It is typically used only for system debugging.

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(subst ",
        endParen: true,
        params: ["new", "old", "tree"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s11"),
        description: `**procedure**: \`(substq \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substq! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst! \`*new*\` \`*old*\` \`*tree*\`)\`
**returns: **a tree with *new* substituted for occurrences of *old* in *tree*
**libraries: **\`(chezscheme)\`

These procedures traverse *tree*, replacing all objects equivalent to the object *old* with the object *new*.

The equivalence test for \`substq\` and \`substq!\` is \`eq?\`, for \`substv\` and \`substv!\` is \`eqv?\`, and for \`subst\` and \`subst!\` is \`equal?\`.

\`substq!\`, \`substv!\`, and \`subst!\` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(substq 'a 'b '((b c) b a)) \`=>\` ((a c) a a) \`
\` \`
\` (substv 2 1 '((1 . 2) (1 . 4) . 1)) \`=>\` ((2 . 2) (2 . 4) . 2) \`
\` \`
\` (subst 'a\`
\`        '(a . b)\`
\`        '((a . b) (c a . b) . c)) \`=>\` (a (c . a) . c) \`
\` \`
\` (let ([tr '((b c) b a)])\`
\`   (substq! 'a 'b tr)\`
\`   tr) \`=>\` ((a c) a a)\`
`
    },
    {
        name: "(subst! ",
        endParen: true,
        params: ["new", "old", "tree"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s11"),
        description: `**procedure**: \`(substq \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substq! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst! \`*new*\` \`*old*\` \`*tree*\`)\`
**returns: **a tree with *new* substituted for occurrences of *old* in *tree*
**libraries: **\`(chezscheme)\`

These procedures traverse *tree*, replacing all objects equivalent to the object *old* with the object *new*.

The equivalence test for \`substq\` and \`substq!\` is \`eq?\`, for \`substv\` and \`substv!\` is \`eqv?\`, and for \`subst\` and \`subst!\` is \`equal?\`.

\`substq!\`, \`substv!\`, and \`subst!\` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(substq 'a 'b '((b c) b a)) \`=>\` ((a c) a a) \`
\` \`
\` (substv 2 1 '((1 . 2) (1 . 4) . 1)) \`=>\` ((2 . 2) (2 . 4) . 2) \`
\` \`
\` (subst 'a\`
\`        '(a . b)\`
\`        '((a . b) (c a . b) . c)) \`=>\` (a (c . a) . c) \`
\` \`
\` (let ([tr '((b c) b a)])\`
\`   (substq! 'a 'b tr)\`
\`   tr) \`=>\` ((a c) a a)\`
`
    },
    {
        name: "(substq ",
        endParen: true,
        params: ["new", "old", "tree"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s11"),
        description: `**procedure**: \`(substq \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substq! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst! \`*new*\` \`*old*\` \`*tree*\`)\`
**returns: **a tree with *new* substituted for occurrences of *old* in *tree*
**libraries: **\`(chezscheme)\`

These procedures traverse *tree*, replacing all objects equivalent to the object *old* with the object *new*.

The equivalence test for \`substq\` and \`substq!\` is \`eq?\`, for \`substv\` and \`substv!\` is \`eqv?\`, and for \`subst\` and \`subst!\` is \`equal?\`.

\`substq!\`, \`substv!\`, and \`subst!\` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(substq 'a 'b '((b c) b a)) \`=>\` ((a c) a a) \`
\` \`
\` (substv 2 1 '((1 . 2) (1 . 4) . 1)) \`=>\` ((2 . 2) (2 . 4) . 2) \`
\` \`
\` (subst 'a\`
\`        '(a . b)\`
\`        '((a . b) (c a . b) . c)) \`=>\` (a (c . a) . c) \`
\` \`
\` (let ([tr '((b c) b a)])\`
\`   (substq! 'a 'b tr)\`
\`   tr) \`=>\` ((a c) a a)\`
`
    },
    {
        name: "(substq! ",
        endParen: true,
        params: ["new", "old", "tree"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s11"),
        description: `**procedure**: \`(substq \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substq! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst! \`*new*\` \`*old*\` \`*tree*\`)\`
**returns: **a tree with *new* substituted for occurrences of *old* in *tree*
**libraries: **\`(chezscheme)\`

These procedures traverse *tree*, replacing all objects equivalent to the object *old* with the object *new*.

The equivalence test for \`substq\` and \`substq!\` is \`eq?\`, for \`substv\` and \`substv!\` is \`eqv?\`, and for \`subst\` and \`subst!\` is \`equal?\`.

\`substq!\`, \`substv!\`, and \`subst!\` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(substq 'a 'b '((b c) b a)) \`=>\` ((a c) a a) \`
\` \`
\` (substv 2 1 '((1 . 2) (1 . 4) . 1)) \`=>\` ((2 . 2) (2 . 4) . 2) \`
\` \`
\` (subst 'a\`
\`        '(a . b)\`
\`        '((a . b) (c a . b) . c)) \`=>\` (a (c . a) . c) \`
\` \`
\` (let ([tr '((b c) b a)])\`
\`   (substq! 'a 'b tr)\`
\`   tr) \`=>\` ((a c) a a)\`
`
    },
    {
        name: "(substring ",
        endParen: true,
        params: ["string", "start", "end"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s224"),
        description: `**procedure**: \`(substring \`*string*\` \`*start*\` \`*end*\`)\`
**returns: **a copy of *string* from *start* (inclusive) to *end* (exclusive)
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*start* and *end* must be exact nonnegative integers; *start* must be less than or equal to *end*, while *end* must be less than or equal to the length of *string*. If *end* = *start*, a string of length zero is returned. \`substring\` may be defined without error checks as follows.

\`(define substring\`
\`   (lambda (s1 m n)\`
\`     (let ([s2 (make-string (- n m))])\`
\`       (do ([j 0 (+ j 1)] [i m (+ i 1)])\`
\`           ((= i n) s2)\`
\`         (string-set! s2 j (string-ref s1 i)))))) \`
\` \`
\` (substring "hi there" 0 1) \`=>\` "h"\`
\` (substring "hi there" 3 6) \`=>\` "the"\`
\` (substring "hi there" 5 5) \`=>\` "" \`
\` \`
\` (let ([str "hi there"])\`
\`   (let ([end (string-length str)])\`
\`     (substring str 0 end))) \`=>\` "hi there"\`
`
    },
    {
        name: "(substring-fill! ",
        endParen: true,
        params: ["string", "start", "end", "char"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s22"),
        description: `**procedure**: \`(substring-fill! \`*string*\` \`*start*\` \`*end*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*string* must be mutable. The characters of *string* from *start* (inclusive) to *end* (exclusive) are set to *char*. *start* and *end* must be nonnegative integers; *start* must be strictly less than the length of *string*, while *end* may be less than or equal to the length of *string*. If ≤ , the string is left unchanged.

\`(let ([str (string-copy "a tpyo typo")])\`
\`   (substring-fill! str 2 6 #\\X)\`
\`   str) \`=>\` "a XXXX typo"\`
`
    },
    {
        name: "(substv ",
        endParen: true,
        params: ["new", "old", "tree"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s11"),
        description: `**procedure**: \`(substq \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substq! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst! \`*new*\` \`*old*\` \`*tree*\`)\`
**returns: **a tree with *new* substituted for occurrences of *old* in *tree*
**libraries: **\`(chezscheme)\`

These procedures traverse *tree*, replacing all objects equivalent to the object *old* with the object *new*.

The equivalence test for \`substq\` and \`substq!\` is \`eq?\`, for \`substv\` and \`substv!\` is \`eqv?\`, and for \`subst\` and \`subst!\` is \`equal?\`.

\`substq!\`, \`substv!\`, and \`subst!\` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(substq 'a 'b '((b c) b a)) \`=>\` ((a c) a a) \`
\` \`
\` (substv 2 1 '((1 . 2) (1 . 4) . 1)) \`=>\` ((2 . 2) (2 . 4) . 2) \`
\` \`
\` (subst 'a\`
\`        '(a . b)\`
\`        '((a . b) (c a . b) . c)) \`=>\` (a (c . a) . c) \`
\` \`
\` (let ([tr '((b c) b a)])\`
\`   (substq! 'a 'b tr)\`
\`   tr) \`=>\` ((a c) a a)\`
`
    },
    {
        name: "(substv! ",
        endParen: true,
        params: ["new", "old", "tree"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s11"),
        description: `**procedure**: \`(substq \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substq! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(substv! \`*new*\` \`*old*\` \`*tree*\`)\`
**procedure**: \`(subst! \`*new*\` \`*old*\` \`*tree*\`)\`
**returns: **a tree with *new* substituted for occurrences of *old* in *tree*
**libraries: **\`(chezscheme)\`

These procedures traverse *tree*, replacing all objects equivalent to the object *old* with the object *new*.

The equivalence test for \`substq\` and \`substq!\` is \`eq?\`, for \`substv\` and \`substv!\` is \`eqv?\`, and for \`subst\` and \`subst!\` is \`equal?\`.

\`substq!\`, \`substv!\`, and \`subst!\` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

\`(substq 'a 'b '((b c) b a)) \`=>\` ((a c) a a) \`
\` \`
\` (substv 2 1 '((1 . 2) (1 . 4) . 1)) \`=>\` ((2 . 2) (2 . 4) . 2) \`
\` \`
\` (subst 'a\`
\`        '(a . b)\`
\`        '((a . b) (c a . b) . c)) \`=>\` (a (c . a) . c) \`
\` \`
\` (let ([tr '((b c) b a)])\`
\`   (substq! 'a 'b tr)\`
\`   tr) \`=>\` ((a c) a a)\`
`
    },
    {
        name: "(subtract-duration ",
        endParen: true,
        params: ["time", "timed"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s209"),
        description: `**procedure**: \`(time-difference \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(time-difference! \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(add-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(add-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(subtract-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**procedure**: \`(subtract-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**libraries: **\`(chezscheme)\`

For \`time-difference\`, *time1* and *time2* must have the same time type, and the result is a time object with time type \`time-duration\`. For \`add-duration\`, \`add-duration!\`, \`subtract-duration\`, and \`subtract-duration!\`, *timed* must have time type \`time-duration\`, and the result is a time object with the same time type as *time*. \`time-difference!\`, \`add-duration!\`, and \`subtract-duration!\` are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object.

\`(let ([delay (make-time 'time-duration 0 1)])\`
\`   (let ([t1 (current-time 'time-monotonic)])\`
\`     (sleep delay)\`
\`     (let ([t2 (current-time 'time-monotonic)])\`
\`       (let ([t3 (time-difference t2 t1)])\`
\`         (and\`
\`           (eq? (time-type t3) 'time-duration)\`
\`           (time>=? t3 delay)\`
\`           (time=? (add-duration t1 t3) t2)\`
\`           (time=? (subtract-duration t2 t3) t1)))))) \`=>\` #t\`
`
    },
    {
        name: "(subtract-duration! ",
        endParen: true,
        params: ["time", "timed"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s209"),
        description: `**procedure**: \`(time-difference \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(time-difference! \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(add-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(add-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(subtract-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**procedure**: \`(subtract-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**libraries: **\`(chezscheme)\`

For \`time-difference\`, *time1* and *time2* must have the same time type, and the result is a time object with time type \`time-duration\`. For \`add-duration\`, \`add-duration!\`, \`subtract-duration\`, and \`subtract-duration!\`, *timed* must have time type \`time-duration\`, and the result is a time object with the same time type as *time*. \`time-difference!\`, \`add-duration!\`, and \`subtract-duration!\` are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object.

\`(let ([delay (make-time 'time-duration 0 1)])\`
\`   (let ([t1 (current-time 'time-monotonic)])\`
\`     (sleep delay)\`
\`     (let ([t2 (current-time 'time-monotonic)])\`
\`       (let ([t3 (time-difference t2 t1)])\`
\`         (and\`
\`           (eq? (time-type t3) 'time-duration)\`
\`           (time>=? t3 delay)\`
\`           (time=? (add-duration t1 t3) t2)\`
\`           (time=? (subtract-duration t2 t3) t1)))))) \`=>\` #t\`
`
    },
    {
        name: "suppress-greeting",
        endParen: false,
        params: [""],
        type: "global parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s197"),
        description: `**global parameter**: \`suppress-greeting\`
**libraries: **\`(chezscheme)\`

The value of \`suppress-greeting\` is a boolean value that determines whether prints an identifying banner and copyright notice. The parameter defaults to \`#f\` but may be set to \`#t\` for use in batch processing applications where the banner would be disruptive.

To have any effect, this parameter must be set within a boot file. (See Chapter .)
`
    },
    {
        name: "(symbol->string ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s270"),
        description: `**procedure**: \`(symbol->string \`*symbol*\`)\`
**returns: **a string, the name of *symbol*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The string returned by \`symbol->string\` should be treated as immutable. Unpredictable behavior can result if a string returned from \`symbol->string\` is altered with \`string-set!\` or by any other means.

\`(symbol->string 'xyz) \`=>\` "xyz"\`
\` (symbol->string 'Hi) \`=>\` "Hi"\`
\` (symbol->string (string->symbol "()")) \`=>\` "()"\`
`
    },
    {
        name: "(symbol-hash ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s279"),
        description: `**procedure**: \`(equal-hash \`*obj*\`)\`
**procedure**: \`(string-hash \`*string*\`)\`
**procedure**: \`(string-ci-hash \`*string*\`)\`
**procedure**: \`(symbol-hash \`*symbol*\`)\`
**returns: **an exact nonnegative integer hash value
**libraries: **\`(rnrs hashtables)\`, \`(rnrs)\`

These procedures are hash functions suitable for use with the appropriate Scheme predicate: \`equal?\` for \`equal-hash\`, \`string=?\` for \`string-hash\`, \`string-ci=?\` for \`string-ci-hash\`, and \`symbol=?\` (or eq?) for \`symbol-hash\`. The hash values returned by \`equal-hash\`, \`string-hash\`, and \`string-ci-hash\` are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable.
`
    },
    {
        name: "(symbol-hashtable-cell ",
        endParen: true,
        params: ["hashtable", "key", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s139"),
        description: `**procedure**: \`(symbol-hashtable-cell \`*hashtable*\` \`*key*\` \`*default*\`)\`
**returns: **a pair (see below)
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function \`symbol-hash\` and equivalence function \`eq?\`, \`eqv?\`, \`equal?\`, or \`symbol=?\`.) *key* must be a symbol, and *default* may be any Scheme value.

If no value is associated with *key* in *hashtable*, \`symbol-hashtable-cell\` modifies *hashtable* to associate *key* with *default*. It returns a pair whose car is *key* and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate *key* with a new value. The *key* should not be changed.

\`(define ht (make-hashtable symbol-hash eq?))\`
\` (define k 'a-key)\`
\` (define cell (symbol-hashtable-cell ht k 3))\`
\` cell \`=>\` (a-key . 3)\`
\` (symbol-hashtable-ref ht k 0) \`=>\` 3\`
\` (set-cdr! cell 4)\`
\` (symbol-hashtable-ref ht k 0) \`=>\` 4\`
`
    },
    {
        name: "(symbol-hashtable-contains? ",
        endParen: true,
        params: ["hashtable", "key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s137"),
        description: `**procedure**: \`(symbol-hashtable-contains? \`*hashtable*\` \`*key*\`)\`
**returns: **\`#t\` if an association for *key* exists in *hashtable*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*hashtable* must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function \`symbol-hash\` and equivalence function \`eq?\`, \`eqv?\`, \`equal?\`, or \`symbol=?\`.) *key* must be a symbol.

\`(define ht (make-hashtable symbol-hash eq?))\`
\` (define k1 'abcd)\`
\` (define k2 'not-abcd)\`
\` (symbol-hashtable-set! ht k1 "hi")\`
\` (symbol-hashtable-contains? ht k1) \`=>\` #t\`
\` (symbol-hashtable-contains? ht k2 ) \`=>\` #f\`
`
    },
    {
        name: "(symbol-hashtable-delete! ",
        endParen: true,
        params: ["hashtable", "key"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s140"),
        description: `**procedure**: \`(symbol-hashtable-delete! \`*hashtable*\` \`*key*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function \`symbol-hash\` and equivalence function \`eq?\`, \`eqv?\`, \`equal?\`, or \`symbol=?\`.) *key* must be a symbol.

\`symbol-hashtable-delete!\` drops any association for *key* from *hashtable*.

\`(define ht (make-hashtable symbol-hash eq?))\`
\` (define k1 (gensym))\`
\` (define k2 (gensym))\`
\` (symbol-hashtable-set! ht k1 73)\`
\` (symbol-hashtable-contains? ht k1) \`=>\` #t\`
\` (symbol-hashtable-delete! ht k1)\`
\` (symbol-hashtable-contains? ht k1) \`=>\` #f\`
\` (symbol-hashtable-contains? ht k2) \`=>\` #f\`
\` (symbol-hashtable-delete! ht k2)\`
`
    },
    {
        name: "(symbol-hashtable-ref ",
        endParen: true,
        params: ["hashtable", "key", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s136"),
        description: `**procedure**: \`(symbol-hashtable-ref \`*hashtable*\` \`*key*\` \`*default*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*hashtable* must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function \`symbol-hash\` and equivalence function \`eq?\`, \`eqv?\`, \`equal?\`, or \`symbol=?\`.) *key* must be a symbol, and *default* may be any Scheme value.

\`symbol-hashtable-ref\` returns the value associated with *key* in *hashtable*. If no value is associated with *key* in *hashtable*, \`symbol-hashtable-ref\` returns *default*.

\`(define ht (make-hashtable symbol-hash eq?))\`
\` (define k1 'abcd)\`
\` (define k2 'not-abcd)\`
\` (symbol-hashtable-set! ht k1 "hi")\`
\` (symbol-hashtable-ref ht k1 "bye") \`=>\` "hi"\`
\` (symbol-hashtable-ref ht k2 "bye") \`=>\` "bye"\`
`
    },
    {
        name: "(symbol-hashtable-set! ",
        endParen: true,
        params: ["hashtable", "key", "value"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s135"),
        description: `**procedure**: \`(symbol-hashtable-set! \`*hashtable*\` \`*key*\` \`*value*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function \`symbol-hash\` and equivalence function \`eq?\`, \`eqv?\`, \`equal?\`, or \`symbol=?\`.) *key* must be a symbol, and *value* may be any Scheme value.

\`symbol-hashtable-set!\` associates the value *value* with the key *key* in *hashtable*.

\`(define ht (make-hashtable symbol-hash eq?))\`
\` (symbol-hashtable-ref ht 'a #f) \`=>\` #f\`
\` (symbol-hashtable-set! ht 'a 73)\`
\` (symbol-hashtable-ref ht 'a #f) \`=>\` 73\`
`
    },
    {
        name: "(symbol-hashtable-update! ",
        endParen: true,
        params: ["hashtable", "key", "procedure", "default"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s138"),
        description: `**procedure**: \`(symbol-hashtable-update! \`*hashtable*\` \`*key*\` \`*procedure*\` \`*default*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*hashtable* must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function \`symbol-hash\` and equivalence function \`eq?\`, \`eqv?\`, \`equal?\`, or \`symbol=?\`.) *key* must be a symbol, and *default* may be any Scheme value. *procedure* should accept one argument, should return one value, and should not modify *hashtable*.

\`symbol-hashtable-update!\` applies *procedure* to the value associated with *key* in *hashtable*, or to *default* if no value is associated with *key* in *hashtable*. If *procedure* returns, \`symbol-hashtable-update!\` associates *key* with the value returned by *procedure*, replacing the old association, if any.

A version of \`symbol-hashtable-update!\` that does not verify that it receives arguments of the proper type might be defined as follows.

\`(define symbol-hashtable-update!\`
\`   (lambda (ht key proc value)\`
\`     (symbol-hashtable-set! ht key\`
\`       (proc (symbol-hashtable-ref ht key value)))))\`

An implementation may, however, be able to implement \`symbol-hashtable-update!\` more efficiently by avoiding multiple hash computations and hashtable lookups.

\`(define ht (make-hashtable symbol-hash eq?))\`
\` (symbol-hashtable-update! ht 'a\`
\`   (lambda (x) (* x 2))\`
\`   55)\`
\` (symbol-hashtable-ref ht 'a 0) \`=>\` 110\`
\` (symbol-hashtable-update! ht 'a\`
\`   (lambda (x) (* x 2))\`
\`   0)\`
\` (symbol-hashtable-ref ht 'a 0) \`=>\` 220\`
`
    },
    {
        name: "(symbol-hashtable? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s134"),
        description: `**procedure**: \`(symbol-hashtable? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is an eq hashtable, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (symbol-hashtable? (make-hashtable symbol-hash eq?)) \`=>\` #t\`
\` (symbol-hashtable? (make-eq-hashtable)) \`=>\` #f\`
`
    },
    {
        name: "(symbol=? ",
        endParen: true,
        params: ["symbol1", "symbol2"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s268"),
        description: `**procedure**: \`(symbol=? \`*symbol1*\` \`*symbol2*\`)\`
**returns: **\`#t\` if the two symbols are the same, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

Symbols can also be compared with \`eq?\`, which is typically more efficient than \`symbol=?\`.

\`(symbol=? 'a 'a) \`=>\` #t\`
\` (symbol=? 'a (string->symbol "a")) \`=>\` #t\`
\` (symbol=? 'a 'b) \`=>\` #f\`
`
    },
    {
        name: "(symbol? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s22"),
        description: `**procedure**: \`(symbol? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a symbol, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (symbol? 't) \`=>\` #t\`
\` (symbol? "t") \`=>\` #f\`
\` (symbol? '(t)) \`=>\` #f\`
\` (symbol? #\\t) \`=>\` #f\`
\` (symbol? 3) \`=>\` #f\`
\` (symbol? #t) \`=>\` #f\`
`
    },
    {
        name: "(syntax ",
        endParen: true,
        params: ["template"],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s33"),
        description: `**syntax**: \`(syntax \`*template*\`)\`
**syntax**: \`#'\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#'\`*template* is equivalent to \`(syntax \`*template*\`)\`. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.

A \`syntax\` expression is like a \`quote\` expression except that the values of pattern variables appearing within *template* are inserted into *template*, and contextual information associated both with the input and with the template is retained in the output to support lexical scoping. A \`syntax\` *template* is identical to a \`syntax-rules\` *template* and is treated similarly.

List and vector structures within the template become true lists or vectors (suitable for direct application of list or vector operations, like \`map\` or \`vector-ref\`) to the extent that the list or vector structures must be copied to insert the values of pattern variables, and empty lists are never wrapped. For example, \`#'(x ...)\`, \`#'(a b c)\`, \`#'()\` are all lists if \`x\`, \`a\`, \`b\`, and \`c\` are pattern variables.

The definition of \`or\` below is equivalent to the one given in Section  except that it employs \`syntax-case\` and \`syntax\` in place of \`syntax-rules\`.

\`(define-syntax or\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(_) #'#f]\`
\`       [(_ e) #'e]\`
\`       [(_ e1 e2 e3 ...)\`
\`        #'(let ([t e1]) (if t t (or e2 e3 ...)))])))\`
`
    },
    {
        name: "(syntax->annotation ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s69"),
        description: `**procedure**: \`(syntax->annotation \`*obj*\`)\`
**returns: **an annotation or \`#f\`
**libraries: **\`(chezscheme)\`

If *obj* is an annotation or syntax-object encapsulating an annotation, the annotation is returned.
`
    },
    {
        name: "(syntax->datum ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s44"),
        description: `**procedure**: \`(syntax->datum \`*obj*\`)\`
**returns: ***obj* stripped of syntactic information
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

The procedure \`syntax->datum\` strips all syntactic information from a syntax object and returns the corresponding Scheme "datum." Identifiers stripped in this manner are converted to their symbolic names, which can then be compared with \`eq?\`. Thus, a predicate \`symbolic-identifier=?\` might be defined as follows.

\`(define symbolic-identifier=?\`
\`   (lambda (x y)\`
\`     (eq? (syntax->datum x)\`
\`          (syntax->datum y))))\`

Two identifiers that are \`free-identifier=?\` need not be \`symbolic-identifier=?\`: two identifiers that refer to the same binding usually have the same name, but the \`rename\` and \`prefix\` subforms of the library's \`import\` form (page ) may result in two identifiers with different names but the same binding.
`
    },
    {
        name: "(syntax->list ",
        endParen: true,
        params: ["syntax-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s6"),
        description: `**procedure**: \`(syntax->list \`*syntax-object*\`)\`
**returns: **a list of syntax objects
**libraries: **\`(chezscheme)\`

This procedure takes a syntax object representing a list-structured form and returns a list of syntax objects, each representing the corresponding subform of the input form.

\`syntax->list\` may be defined as follows.

\`(define syntax->list\`
\`   (lambda (ls)\`
\`     (syntax-case ls ()\`
\`       [() '()]\`
\`       [(x . r) (cons #'x (syntax->list #'r))]))) \`
\` \`
\` #'(a b c) \`=>\` #<syntax (a b c)>\`
\` (syntax->list #'(a b c)) \`=>\` (#<syntax a> #<syntax b> #<syntax c>)\`

\`syntax->list\` is not required for list structures constructed from individual pattern variable values or sequences of pattern-variable values, since such structures are already lists. For example:

\`(list? (with-syntax ([x #'a] [y #'b] [z #'c]) #'(x y z)))) \`=>\` #t\`
\` (list? (with-syntax ([(x ...) #'(a b c)]) #'(x ...))) \`=>\` #t\`
`
    },
    {
        name: "(syntax->vector ",
        endParen: true,
        params: ["syntax-object"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s7"),
        description: `**procedure**: \`(syntax->vector \`*syntax-object*\`)\`
**returns: **a vector of syntax objects
**libraries: **\`(chezscheme)\`

This procedure takes a syntax object representing a vector-structured form and returns a vector of syntax objects, each representing the corresponding subform of the input form.

\`syntax->vector\` may be defined as follows.

\`(define syntax->vector\`
\`   (lambda (v)\`
\`     (syntax-case v ()\`
\`       [#(x ...) (apply vector (syntax->list #'(x ...)))]))) \`
\` \`
\` #'#(a b c) \`=>\` #<syntax #(a b c)>\`
\` (syntax->vector #'#(a b c)) \`=>\` #(#<syntax a> #<syntax b> #<syntax c>)\`

\`syntax->vector\` is not required for vector structures constructed from individual pattern variable values or sequences of pattern-variable values, since such structures are already vectors. For example:

\`(vector? (with-syntax ([x #'a] [y #'b] [z #'c]) #'#(x y z)))) \`=>\` #t\`
\` (vector? (with-syntax ([(x ...) #'(a b c)]) #'#(x ...))) \`=>\` #t\`
`
    },
    {
        name: "(syntax-case ",
        endParen: true,
        params: ["expr", "literal", "clause", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s30"),
        description: `**syntax**: \`(syntax-case \`*expr*\` (\`*literal*\` ...) \`*clause*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

Each *literal* must be an identifier. Each *clause* must take one of the following two forms.

\`(\`*pattern*\` \`*output-expression*\`)\`
\` (\`*pattern*\` \`*fender*\` \`*output-expression*\`)\`

\`syntax-case\` patterns may be in any of the forms described in Section .
`
    },
    {
        name: "(syntax-error ",
        endParen: true,
        params: ["obj", "string", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s13"),
        description: `**procedure**: \`(syntax-error \`*obj*\` \`*string*\` ...)\`
**returns: **does not return
**libraries: **\`(chezscheme)\`

Syntax errors may be reported with \`syntax-error\`, which produces a message by concatenating *string*\` ...\` and a printed representation of *obj*. If no string arguments are provided, the string \`"invalid syntax"\` is used instead. When *obj* is a syntax object, the syntax-object wrapper is stripped (as with \`syntax->datum\`) before the printed representation is created. If source file information is present in the syntax-object wrapper, \`syntax-error\` incorporates this information into the error message.

\`syntax-case\` and \`syntax-rules\` call \`syntax-error\` automatically if the input fails to match one of the clauses.

We can use \`syntax-error\` to precisely report the cause of the errors detected in the following definition of (unnamed) \`let\`.

\`(define-syntax let\`
\`   (lambda (x)\`
\`     (define check-ids!\`
\`       (lambda (ls)\`
\`         (unless (null? ls)\`
\`           (unless (identifier? (car ls))\`
\`             (syntax-error (car ls) "let cannot bind non-identifier"))\`
\`           (check-ids! (cdr ls)))))\`
\`     (define check-unique!\`
\`       (lambda (ls)\`
\`         (unless (null? ls)\`
\`           (let ([x (car ls)])\`
\`             (when (let mem? ([ls (cdr ls)])\`
\`                     (and (not (null? ls))\`
\`                          (or (bound-identifier=? x (car ls))\`
\`                              (mem? (cdr ls)))))\`
\`               (syntax-error x "let cannot bind two occurrences of")))\`
\`           (check-unique! (cdr ls)))))\`
\`     (syntax-case x ()\`
\`       [(_ ((i e) ...) b1 b2 ...)\`
\`        (begin\`
\`          (check-ids! #'(i ...))\`
\`          (check-unique! #'(i ...))\`
\`          #'((lambda (i ...) b1 b2 ...) e ...))])))\`

With this change, the expression

\`(let ([a 3] [a 4]) (+ a a))\`

produces the error message "let cannot bind two occurrences of \`a\`."
`
    },
    {
        name: "(syntax-object->datum ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s8"),
        description: `**procedure**: \`(syntax-object->datum \`*obj*\`)\`
**returns: ***obj* stripped of syntactic information
**libraries: **\`(chezscheme)\`

\`syntax-object->datum\` is identical to the Revised Report \`syntax->datum\`.
`
    },
    {
        name: "(syntax-rules (",
        endParen: true,
        params: ["literal", "clause", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s4"),
        description: `**syntax**: \`(syntax-rules (\`*literal*\` ...) \`*clause*\` ...)\`
**returns: **a transformer
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(syntax-rules (",
        endParen: true,
        params: ["literal", "clause", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s14"),
        description: `**syntax**: \`(syntax-rules (\`*literal*\` ...) \`*clause*\` ...)\`
**returns: **a transformer
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(syntax-violation ",
        endParen: true,
        params: ["who", "msg", "form"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s6"),
        description: `**procedure**: \`(syntax-violation \`*who*\` \`*msg*\` \`*form*\`)\`
**procedure**: \`(syntax-violation \`*who*\` \`*msg*\` \`*form*\` \`*subform*\`)\`
**returns: **does not return
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

This procedure raises a non-continuable exception with a condition of type \`&syntax\`. It should be used to report a syntax error detected by the transformer of a syntactic extension. The value of the condition's form field is *form*, and the value of its subform field is *subform*, or \`#f\` if *subform* is not provided.

The continuation object with which the exception is raised also includes a \`&who\` condition whose who field is *who*, if *who* is not \`#f\` or is inferred from *form*, and a \`&message\` condition whose message field is *msg*.

*who* must be a string, a symbol, or \`#f\`. If *who* is \`#f\`, it is inferred to be the symbolic name of *form* if *form* is an identifier or the symbolic name of the first subform of *form* if *form* is a list-structured form whose first subform is an identifier. *message* must be a string. *form* should be the syntax object or datum representation of the syntactic form within which the syntax violation occurred, and *subform*, if not \`#f\`, should be a syntax object or datum representation of a subform more specifically involved in the violation. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter.

Some implementations attach source information to syntax objects, e.g., line, character, and filename for forms originating in a file, in which case this information might also be present as some implementation-dependent condition type within the condition object.
`
    },
    {
        name: "(syntax-violation ",
        endParen: true,
        params: ["who", "msg", "form", "subform"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s6"),
        description: `**procedure**: \`(syntax-violation \`*who*\` \`*msg*\` \`*form*\`)\`
**procedure**: \`(syntax-violation \`*who*\` \`*msg*\` \`*form*\` \`*subform*\`)\`
**returns: **does not return
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

This procedure raises a non-continuable exception with a condition of type \`&syntax\`. It should be used to report a syntax error detected by the transformer of a syntactic extension. The value of the condition's form field is *form*, and the value of its subform field is *subform*, or \`#f\` if *subform* is not provided.

The continuation object with which the exception is raised also includes a \`&who\` condition whose who field is *who*, if *who* is not \`#f\` or is inferred from *form*, and a \`&message\` condition whose message field is *msg*.

*who* must be a string, a symbol, or \`#f\`. If *who* is \`#f\`, it is inferred to be the symbolic name of *form* if *form* is an identifier or the symbolic name of the first subform of *form* if *form* is a list-structured form whose first subform is an identifier. *message* must be a string. *form* should be the syntax object or datum representation of the syntactic form within which the syntax violation occurred, and *subform*, if not \`#f\`, should be a syntax object or datum representation of a subform more specifically involved in the violation. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter.

Some implementations attach source information to syntax objects, e.g., line, character, and filename for forms originating in a file, in which case this information might also be present as some implementation-dependent condition type within the condition object.
`
    },
    {
        name: "(syntax-violation-form ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s30"),
        description: `**syntax**: \`&syntax\`
**procedure**: \`(make-syntax-violation \`*form*\` \`*subform*\`)\`
**returns: **a condition of type \`&syntax\`
**procedure**: \`(syntax-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&syntax\`, \`#f\` otherwise
**procedure**: \`(syntax-violation-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**procedure**: \`(syntax-violation-subform \`*condition*\`)\`
**returns: **the contents of *condition*'s \`subform\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the *form* and *subform* arguments to \`make-syntax-violation\` should be a syntax object (Section ) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter. If there is no need to identify a subform, *subform* should be \`#f\`. This condition type might be defined as follows.

\`(define-condition-type &syntax &violation\`
\`   make-syntax-violation syntax-violation?\`
\`   (form syntax-violation-form)\`
\`   (subform syntax-violation-subform))\`
`
    },
    {
        name: "(syntax-violation-subform ",
        endParen: true,
        params: ["condition"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s30"),
        description: `**syntax**: \`&syntax\`
**procedure**: \`(make-syntax-violation \`*form*\` \`*subform*\`)\`
**returns: **a condition of type \`&syntax\`
**procedure**: \`(syntax-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&syntax\`, \`#f\` otherwise
**procedure**: \`(syntax-violation-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**procedure**: \`(syntax-violation-subform \`*condition*\`)\`
**returns: **the contents of *condition*'s \`subform\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the *form* and *subform* arguments to \`make-syntax-violation\` should be a syntax object (Section ) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter. If there is no need to identify a subform, *subform* should be \`#f\`. This condition type might be defined as follows.

\`(define-condition-type &syntax &violation\`
\`   make-syntax-violation syntax-violation?\`
\`   (form syntax-violation-form)\`
\`   (subform syntax-violation-subform))\`
`
    },
    {
        name: "(syntax-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s30"),
        description: `**syntax**: \`&syntax\`
**procedure**: \`(make-syntax-violation \`*form*\` \`*subform*\`)\`
**returns: **a condition of type \`&syntax\`
**procedure**: \`(syntax-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&syntax\`, \`#f\` otherwise
**procedure**: \`(syntax-violation-form \`*condition*\`)\`
**returns: **the contents of *condition*'s \`form\` field
**procedure**: \`(syntax-violation-subform \`*condition*\`)\`
**returns: **the contents of *condition*'s \`subform\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the *form* and *subform* arguments to \`make-syntax-violation\` should be a syntax object (Section ) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a \`lambda\` expression, *form* might be the \`lambda\` expression and *subform* might be the duplicated parameter. If there is no need to identify a subform, *subform* should be \`#f\`. This condition type might be defined as follows.

\`(define-condition-type &syntax &violation\`
\`   make-syntax-violation syntax-violation?\`
\`   (form syntax-violation-form)\`
\`   (subform syntax-violation-subform))\`
`
    },
    {
        name: "(system ",
        endParen: true,
        params: ["command"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s4"),
        description: `**procedure**: \`(system \`*command*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*command* must be a string.

The \`system\` procedure creates a subprocess to perform the operation specified by *command*. The subprocess may communicate with the user through the same console input and console output files used by the Scheme process. After creating the subprocess, \`system\` waits for the process to exit before returning.

When the subprocess exits, \`system\` returns the exit code for the subprocess, unless (on Unix-based systems) a signal caused the subprocess to terminate, in which case \`system\` returns the negation of the signal that caused the termination, e.g., -1 for \`SIGHUP\`.
`
    },
    {
        name: "(tan ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s131"),
        description: `**procedure**: \`(sin \`*num*\`)\`
**procedure**: \`(cos \`*num*\`)\`
**procedure**: \`(tan \`*num*\`)\`
**returns: **the sine, cosine, or tangent of *num*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The argument is specified in radians.

\`(sin 0.0) \`=>\` 0.0\`
\` (cos 0.0) \`=>\` 1.0\`
\` (tan 0.0) \`=>\` 0.0\`
`
    },
    {
        name: "(tanh ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s76"),
        description: `**procedure**: \`(sinh \`*num*\`)\`
**procedure**: \`(cosh \`*num*\`)\`
**procedure**: \`(tanh \`*num*\`)\`
**returns: **the hyperbolic sine, cosine, or tangent of *num*
**libraries: **\`(chezscheme)\`

\`(sinh 0.0) \`=>\` 0.0\`
\` (cosh 0.0) \`=>\` 1.0\`
\` (tanh -0.0) \`=>\` -0.0\`
`
    },
    {
        name: "(textual-port-input-buffer ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(textual-port-input-count ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s18"),
        description: `**procedure**: \`(port-input-count \`*input-port*\`)\`
**procedure**: \`(textual-port-input-count \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-count \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return an exact integer representing the number of characters or bytes left to be read from the port's input buffer, i.e., the difference between the buffer size and index.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart.
`
    },
    {
        name: "(textual-port-input-index ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(textual-port-input-size ",
        endParen: true,
        params: ["textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s16"),
        description: `**procedure**: \`(port-input-buffer \`*input-port*\`)\`
**procedure**: \`(port-input-size \`*input-port*\`)\`
**procedure**: \`(port-input-index \`*input-port*\`)\`
**procedure**: \`(textual-port-input-buffer \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-size \`*textual-input-port*\`)\`
**procedure**: \`(textual-port-input-index \`*textual-input-port*\`)\`
**procedure**: \`(binary-port-input-buffer \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-size \`*binary-input-port*\`)\`
**procedure**: \`(binary-port-input-index \`*binary-input-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(textual-port-output-buffer ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(textual-port-output-count ",
        endParen: true,
        params: ["textual-output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s22"),
        description: `**procedure**: \`(port-output-count \`*output-port*\`)\`
**procedure**: \`(textual-port-output-count \`*textual-output-port*\`)\`
**procedure**: \`(binary-port-output-count \`*binary-output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return an exact integer representing the amount of space in characters or bytes available to be written in the port's output buffer, i.e., the difference between the buffer size and index.

The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart.
`
    },
    {
        name: "(textual-port-output-index ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(textual-port-output-size ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s20"),
        description: `**procedure**: \`(port-output-buffer \`*output-port*\`)\`
**procedure**: \`(port-output-size \`*output-port*\`)\`
**procedure**: \`(port-output-index \`*output-port*\`)\`
**procedure**: \`(textual-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(textual-port-output-size \`*output-port*\`)\`
**procedure**: \`(textual-port-output-index \`*output-port*\`)\`
**procedure**: \`(binary-port-output-buffer \`*output-port*\`)\`
**procedure**: \`(binary-port-output-size \`*output-port*\`)\`
**procedure**: \`(binary-port-output-index \`*output-port*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts.
`
    },
    {
        name: "(textual-port? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s45"),
        description: `**procedure**: \`(binary-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a binary port, \`#f\` otherwise
**procedure**: \`(textual-port? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a textual port, \`#f\` otherwise
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(thread-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s13"),
        description: `**procedure**: \`(thread-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition object, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(thread? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s3"),
        description: `**procedure**: \`(thread? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a thread object, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(threaded?)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s257"),
        description: `**procedure**: \`(threaded?)\`
**returns: **\`#t\` if called in a threaded version of the system, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(time ",
        endParen: true,
        params: ["expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s219"),
        description: `**syntax**: \`(time \`*expr*\`)\`
**returns: **the values of *expr*
**libraries: **\`(chezscheme)\`

\`time\` evaluates *expr* and, as a side-effect, prints (to the console-output port) the amount of cpu time, the amount of real time, the number of bytes allocated, and the amount of collection overhead associated with evaluating *expr*.

\`> (time (collect))\`
\` (time (collect))\`
\`     1 collection\`
\`     1 ms elapsed cpu time, including 1 ms collecting\`
\`     1 ms elapsed real time, including 1 ms collecting\`
\`     160 bytes allocated, including 8184 bytes reclaimed\`
`
    },
    {
        name: "(time-difference ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s209"),
        description: `**procedure**: \`(time-difference \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(time-difference! \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(add-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(add-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(subtract-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**procedure**: \`(subtract-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**libraries: **\`(chezscheme)\`

For \`time-difference\`, *time1* and *time2* must have the same time type, and the result is a time object with time type \`time-duration\`. For \`add-duration\`, \`add-duration!\`, \`subtract-duration\`, and \`subtract-duration!\`, *timed* must have time type \`time-duration\`, and the result is a time object with the same time type as *time*. \`time-difference!\`, \`add-duration!\`, and \`subtract-duration!\` are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object.

\`(let ([delay (make-time 'time-duration 0 1)])\`
\`   (let ([t1 (current-time 'time-monotonic)])\`
\`     (sleep delay)\`
\`     (let ([t2 (current-time 'time-monotonic)])\`
\`       (let ([t3 (time-difference t2 t1)])\`
\`         (and\`
\`           (eq? (time-type t3) 'time-duration)\`
\`           (time>=? t3 delay)\`
\`           (time=? (add-duration t1 t3) t2)\`
\`           (time=? (subtract-duration t2 t3) t1)))))) \`=>\` #t\`
`
    },
    {
        name: "(time-difference! ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s209"),
        description: `**procedure**: \`(time-difference \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(time-difference! \`*time1*\` \`*time2*\`)\`
**returns: **the result of subtracting *time2* from *time1*
**procedure**: \`(add-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(add-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of adding *timed* to \`time\`
**procedure**: \`(subtract-duration \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**procedure**: \`(subtract-duration! \`*time*\` \`*timed*\`)\`
**returns: **the result of subtracting *timed* from \`time\`
**libraries: **\`(chezscheme)\`

For \`time-difference\`, *time1* and *time2* must have the same time type, and the result is a time object with time type \`time-duration\`. For \`add-duration\`, \`add-duration!\`, \`subtract-duration\`, and \`subtract-duration!\`, *timed* must have time type \`time-duration\`, and the result is a time object with the same time type as *time*. \`time-difference!\`, \`add-duration!\`, and \`subtract-duration!\` are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object.

\`(let ([delay (make-time 'time-duration 0 1)])\`
\`   (let ([t1 (current-time 'time-monotonic)])\`
\`     (sleep delay)\`
\`     (let ([t2 (current-time 'time-monotonic)])\`
\`       (let ([t3 (time-difference t2 t1)])\`
\`         (and\`
\`           (eq? (time-type t3) 'time-duration)\`
\`           (time>=? t3 delay)\`
\`           (time=? (add-duration t1 t3) t2)\`
\`           (time=? (subtract-duration t2 t3) t1)))))) \`=>\` #t\`
`
    },
    {
        name: "(time-nanosecond ",
        endParen: true,
        params: ["time"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s205"),
        description: `**procedure**: \`(time-type \`*time*\`)\`
**returns: **the time type of *time*
**procedure**: \`(time-nanosecond \`*time*\`)\`
**returns: **the nanosecond of *time*
**procedure**: \`(time-second \`*time*\`)\`
**returns: **the second of *time*
**libraries: **\`(chezscheme)\`

*time* must be a time object.

\`(time-type (current-time)) \`=>\` time-utc\`
\` (time-type (current-time 'time-process)) \`=>\` time-process\`
\` (time-type (make-time 'time-duration 0 50)) \`=>\` time-duration\`
\` (time-second (current-time)) \`=>\` 1198816497\`
\` (time-nanosecond (current-time)) \`=>\` 2399000\`
\` (time-second (make-time 'time-duration 10 -5)) \`=>\` -5\`
\` (time-nanosecond (make-time 'time-duration 10 -5)) \`=>\` 10\`
`
    },
    {
        name: "(time-second ",
        endParen: true,
        params: ["time"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s205"),
        description: `**procedure**: \`(time-type \`*time*\`)\`
**returns: **the time type of *time*
**procedure**: \`(time-nanosecond \`*time*\`)\`
**returns: **the nanosecond of *time*
**procedure**: \`(time-second \`*time*\`)\`
**returns: **the second of *time*
**libraries: **\`(chezscheme)\`

*time* must be a time object.

\`(time-type (current-time)) \`=>\` time-utc\`
\` (time-type (current-time 'time-process)) \`=>\` time-process\`
\` (time-type (make-time 'time-duration 0 50)) \`=>\` time-duration\`
\` (time-second (current-time)) \`=>\` 1198816497\`
\` (time-nanosecond (current-time)) \`=>\` 2399000\`
\` (time-second (make-time 'time-duration 10 -5)) \`=>\` -5\`
\` (time-nanosecond (make-time 'time-duration 10 -5)) \`=>\` 10\`
`
    },
    {
        name: "(time-type ",
        endParen: true,
        params: ["time"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s205"),
        description: `**procedure**: \`(time-type \`*time*\`)\`
**returns: **the time type of *time*
**procedure**: \`(time-nanosecond \`*time*\`)\`
**returns: **the nanosecond of *time*
**procedure**: \`(time-second \`*time*\`)\`
**returns: **the second of *time*
**libraries: **\`(chezscheme)\`

*time* must be a time object.

\`(time-type (current-time)) \`=>\` time-utc\`
\` (time-type (current-time 'time-process)) \`=>\` time-process\`
\` (time-type (make-time 'time-duration 0 50)) \`=>\` time-duration\`
\` (time-second (current-time)) \`=>\` 1198816497\`
\` (time-nanosecond (current-time)) \`=>\` 2399000\`
\` (time-second (make-time 'time-duration 10 -5)) \`=>\` -5\`
\` (time-nanosecond (make-time 'time-duration 10 -5)) \`=>\` 10\`
`
    },
    {
        name: "(time-utc->date ",
        endParen: true,
        params: ["time"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s216"),
        description: `**procedure**: \`(time-utc->date \`*time*\`)\`
**procedure**: \`(time-utc->date \`*time*\` \`*offset*\`)\`
**returns: **a date object corresponding to *time*
**procedure**: \`(date->time-utc \`*date*\`)\`
**returns: **a time object corresponding to *date*
**libraries: **\`(chezscheme)\`

These procedures are used to convert between time and date objects. The *time* argument to \`time-utc->date\` must have time-type \`utc\`, and \`date->time-utc\` always returns a time object with time-type \`utc\`.

For \`time-utc->date\`, *offset* represents the time-zone offset in seconds east of UTC, as described at the beginning of this section. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero.

If *offset* is not provided to \`time-utc->date\`, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date->time-utc d) \`=>\` #<time-utc 1190552850.000000000>\`
\` (define t (make-time 'time-utc 0 1190552850))\`
\` (time-utc->date t) \`=>\` #<date Sun Sep 23 09:07:30 2007>\`
\` (time-utc->date t 0) \`=>\` #<date Sun Sep 23 13:07:30 2007>\`
`
    },
    {
        name: "(time-utc->date ",
        endParen: true,
        params: ["time", "offset"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s216"),
        description: `**procedure**: \`(time-utc->date \`*time*\`)\`
**procedure**: \`(time-utc->date \`*time*\` \`*offset*\`)\`
**returns: **a date object corresponding to *time*
**procedure**: \`(date->time-utc \`*date*\`)\`
**returns: **a time object corresponding to *date*
**libraries: **\`(chezscheme)\`

These procedures are used to convert between time and date objects. The *time* argument to \`time-utc->date\` must have time-type \`utc\`, and \`date->time-utc\` always returns a time object with time-type \`utc\`.

For \`time-utc->date\`, *offset* represents the time-zone offset in seconds east of UTC, as described at the beginning of this section. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero.

If *offset* is not provided to \`time-utc->date\`, then the current time zone's offset is used, and \`date-dst?\` and \`date-zone-name\` report information about the time zone. If *offset* is provided, then \`date-dst?\` and \`date-zone-name\` on the resulting date object produce \`#f\`.

\`(define d (make-date 0 30 7 9 23 9 2007 -14400))\`
\` (date->time-utc d) \`=>\` #<time-utc 1190552850.000000000>\`
\` (define t (make-time 'time-utc 0 1190552850))\`
\` (time-utc->date t) \`=>\` #<date Sun Sep 23 09:07:30 2007>\`
\` (time-utc->date t 0) \`=>\` #<date Sun Sep 23 13:07:30 2007>\`
`
    },
    {
        name: "(time<=? ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s207"),
        description: `**procedure**: \`(time=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>? \`*time1*\` \`*time2*\`)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*time1* and *time2* must be time objects and must have the same type.

\`(let ([t (current-time)])\`
\`   (time=? t t)) \`=>\` #t\`
\` (let ([t (current-time)])\`
\`   (let loop ()\`
\`     (when (time=? (current-time) t))\`
\`       (loop))\`
\`   (time>? (current-time) t)) \`=>\` #t\`
`
    },
    {
        name: "(time<? ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s207"),
        description: `**procedure**: \`(time=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>? \`*time1*\` \`*time2*\`)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*time1* and *time2* must be time objects and must have the same type.

\`(let ([t (current-time)])\`
\`   (time=? t t)) \`=>\` #t\`
\` (let ([t (current-time)])\`
\`   (let loop ()\`
\`     (when (time=? (current-time) t))\`
\`       (loop))\`
\`   (time>? (current-time) t)) \`=>\` #t\`
`
    },
    {
        name: "(time=? ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s207"),
        description: `**procedure**: \`(time=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>? \`*time1*\` \`*time2*\`)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*time1* and *time2* must be time objects and must have the same type.

\`(let ([t (current-time)])\`
\`   (time=? t t)) \`=>\` #t\`
\` (let ([t (current-time)])\`
\`   (let loop ()\`
\`     (when (time=? (current-time) t))\`
\`       (loop))\`
\`   (time>? (current-time) t)) \`=>\` #t\`
`
    },
    {
        name: "(time>=? ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s207"),
        description: `**procedure**: \`(time=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>? \`*time1*\` \`*time2*\`)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*time1* and *time2* must be time objects and must have the same type.

\`(let ([t (current-time)])\`
\`   (time=? t t)) \`=>\` #t\`
\` (let ([t (current-time)])\`
\`   (let loop ()\`
\`     (when (time=? (current-time) t))\`
\`       (loop))\`
\`   (time>? (current-time) t)) \`=>\` #t\`
`
    },
    {
        name: "(time>? ",
        endParen: true,
        params: ["time1", "time2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s207"),
        description: `**procedure**: \`(time=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time<=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>=? \`*time1*\` \`*time2*\`)\`
**procedure**: \`(time>? \`*time1*\` \`*time2*\`)\`
**returns: **\`#t\` if the relation holds, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*time1* and *time2* must be time objects and must have the same type.

\`(let ([t (current-time)])\`
\`   (time=? t t)) \`=>\` #t\`
\` (let ([t (current-time)])\`
\`   (let loop ()\`
\`     (when (time=? (current-time) t))\`
\`       (loop))\`
\`   (time>? (current-time) t)) \`=>\` #t\`
`
    },
    {
        name: "(time? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s204"),
        description: `**procedure**: \`(time? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a time object, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\` (time? (current-time)) \`=>\` #t\`
\` (time? (make-time 'time-utc 0 0)) \`=>\` #t\`
\` (time? "1400 hours") \`=>\` #f\`
`
    },
    {
        name: "timer-interrupt-handler",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s24"),
        description: `**thread parameter**: \`timer-interrupt-handler\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(top-level-bound? ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s30"),
        description: `**procedure**: \`(top-level-bound? \`*symbol*\`)\`
**procedure**: \`(top-level-bound? \`*symbol*\` \`*env*\`)\`
**returns: **\`#t\` if *symbol* is defined as a variable in *env*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

This predicate is useful in an interpreter to check for the existence of a top-level binding before requesting the value with \`top-level-value\`.

\`(top-level-bound? 'xyz) \`=>\` #f \`
\` \`
\` (begin\`
\`   (define-top-level-value 'xyz 3)\`
\`   (top-level-bound? 'xyz)) \`=>\` #t \`
\` \`
\` (define e (copy-environment (interaction-environment)))\`
\` (define-top-level-value 'pi 3.14 e)\`
\` (top-level-bound? 'pi) \`=>\` #f\`
\` (top-level-bound? 'pi e) \`=>\` #t\`
`
    },
    {
        name: "(top-level-bound? ",
        endParen: true,
        params: ["symbol", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s30"),
        description: `**procedure**: \`(top-level-bound? \`*symbol*\`)\`
**procedure**: \`(top-level-bound? \`*symbol*\` \`*env*\`)\`
**returns: **\`#t\` if *symbol* is defined as a variable in *env*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

This predicate is useful in an interpreter to check for the existence of a top-level binding before requesting the value with \`top-level-value\`.

\`(top-level-bound? 'xyz) \`=>\` #f \`
\` \`
\` (begin\`
\`   (define-top-level-value 'xyz 3)\`
\`   (top-level-bound? 'xyz)) \`=>\` #t \`
\` \`
\` (define e (copy-environment (interaction-environment)))\`
\` (define-top-level-value 'pi 3.14 e)\`
\` (top-level-bound? 'pi) \`=>\` #f\`
\` (top-level-bound? 'pi e) \`=>\` #t\`
`
    },
    {
        name: "(top-level-mutable? ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s31"),
        description: `**procedure**: \`(top-level-mutable? \`*symbol*\`)\`
**procedure**: \`(top-level-mutable? \`*symbol*\` \`*env*\`)\`
**returns: **\`#t\` if *symbol* is mutable in *env*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

This predicate is useful in an interpreter to check whether a variable can be assigned before assigning it with \`set-top-level-value!\`.

\`(define xyz 3)\`
\` (top-level-mutable? 'xyz) \`=>\` #t\`
\` (set-top-level-value! 'xyz 4)\`
\` (top-level-value 'xyz) \`=>\` 4 \`
\` \`
\` (define e (copy-environment (interaction-environment) #f))\`
\` (top-level-mutable? 'xyz e) \`=>\` #f\`
\` (set-top-level-value! 'xyz e) \`=>\` \`*exception: xyz is immutable*
`
    },
    {
        name: "(top-level-mutable? ",
        endParen: true,
        params: ["symbol", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s31"),
        description: `**procedure**: \`(top-level-mutable? \`*symbol*\`)\`
**procedure**: \`(top-level-mutable? \`*symbol*\` \`*env*\`)\`
**returns: **\`#t\` if *symbol* is mutable in *env*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

This predicate is useful in an interpreter to check whether a variable can be assigned before assigning it with \`set-top-level-value!\`.

\`(define xyz 3)\`
\` (top-level-mutable? 'xyz) \`=>\` #t\`
\` (set-top-level-value! 'xyz 4)\`
\` (top-level-value 'xyz) \`=>\` 4 \`
\` \`
\` (define e (copy-environment (interaction-environment) #f))\`
\` (top-level-mutable? 'xyz e) \`=>\` #f\`
\` (set-top-level-value! 'xyz e) \`=>\` \`*exception: xyz is immutable*
`
    },
    {
        name: "(top-level-program ",
        endParen: true,
        params: ["imports", "body"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:s14"),
        description: `**syntax**: \`(top-level-program \`*imports*\` \`*body*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(top-level-syntax ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s34"),
        description: `**procedure**: \`(top-level-syntax \`*symbol*\`)\`
**procedure**: \`(top-level-syntax \`*symbol*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`top-level-syntax\` is used to retrieve the transformer, compile-time value, or other compile-time binding to which the identifier named by *symbol* is bound in the environment *env*. If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ). All identifiers bound in an environment have compile-time bindings, including variables.

An exception is raised with condition type \`&assertion\` if the identifier named by *symbol* is not defined as a keyword in *env*.

\`(define-top-level-syntax 'also-let (top-level-syntax 'let))\`
\` (also-let ([x 3] [y 4]) (+ x y)) \`=>\` 7 \`
\` \`
\` (define foo 17)\`
\` (define-top-level-syntax 'also-foo (top-level-syntax 'foo))\`
\` also-foo \`=>\` 17\`
\` (set! also-foo 23)\`
\` also-foo \`=>\` 23\`
\` foo \`=>\` 23\`

The effect of the last example can be had more clearly with \`alias\`:

\`(define foo 17)\`
\` (alias also-foo foo)\`
\` also-foo \`=>\` 17\`
\` (set! also-foo 23)\`
\` also-foo \`=>\` 23\`
\` foo \`=>\` 23\`
`
    },
    {
        name: "(top-level-syntax ",
        endParen: true,
        params: ["symbol", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s34"),
        description: `**procedure**: \`(top-level-syntax \`*symbol*\`)\`
**procedure**: \`(top-level-syntax \`*symbol*\` \`*env*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`top-level-syntax\` is used to retrieve the transformer, compile-time value, or other compile-time binding to which the identifier named by *symbol* is bound in the environment *env*. If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ). All identifiers bound in an environment have compile-time bindings, including variables.

An exception is raised with condition type \`&assertion\` if the identifier named by *symbol* is not defined as a keyword in *env*.

\`(define-top-level-syntax 'also-let (top-level-syntax 'let))\`
\` (also-let ([x 3] [y 4]) (+ x y)) \`=>\` 7 \`
\` \`
\` (define foo 17)\`
\` (define-top-level-syntax 'also-foo (top-level-syntax 'foo))\`
\` also-foo \`=>\` 17\`
\` (set! also-foo 23)\`
\` also-foo \`=>\` 23\`
\` foo \`=>\` 23\`

The effect of the last example can be had more clearly with \`alias\`:

\`(define foo 17)\`
\` (alias also-foo foo)\`
\` also-foo \`=>\` 17\`
\` (set! also-foo 23)\`
\` also-foo \`=>\` 23\`
\` foo \`=>\` 23\`
`
    },
    {
        name: "(top-level-syntax? ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s35"),
        description: `**procedure**: \`(top-level-syntax? \`*symbol*\`)\`
**procedure**: \`(top-level-syntax? \`*symbol*\` \`*env*\`)\`
**returns: **\`#t\` if *symbol* is bound as a keyword in *env*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

All identifiers bound in an environment have compile-time bindings, including variables, so this predicate amounts to a bound check, but is more general than \`top-level-bound?\`, which returns true only for bound variables.

\`(define xyz 'hello)\`
\` (top-level-syntax? 'cons) \`=>\` #t\`
\` (top-level-syntax? 'lambda) \`=>\` #t\`
\` (top-level-syntax? 'hello) \`=>\` #t \`
\` \`
\` (top-level-syntax? 'cons (scheme-environment)) \`=>\` #t\`
\` (top-level-syntax? 'lambda (scheme-environment)) \`=>\` #t\`
\` (top-level-syntax? 'hello (scheme-environment)) \`=>\` #f\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(top-level-syntax? ",
        endParen: true,
        params: ["symbol", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s35"),
        description: `**procedure**: \`(top-level-syntax? \`*symbol*\`)\`
**procedure**: \`(top-level-syntax? \`*symbol*\` \`*env*\`)\`
**returns: **\`#t\` if *symbol* is bound as a keyword in *env*, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

All identifiers bound in an environment have compile-time bindings, including variables, so this predicate amounts to a bound check, but is more general than \`top-level-bound?\`, which returns true only for bound variables.

\`(define xyz 'hello)\`
\` (top-level-syntax? 'cons) \`=>\` #t\`
\` (top-level-syntax? 'lambda) \`=>\` #t\`
\` (top-level-syntax? 'hello) \`=>\` #t \`
\` \`
\` (top-level-syntax? 'cons (scheme-environment)) \`=>\` #t\`
\` (top-level-syntax? 'lambda (scheme-environment)) \`=>\` #t\`
\` (top-level-syntax? 'hello (scheme-environment)) \`=>\` #f\`

Copyright © 2022 Cisco Systems, Inc.
Licensed under the ().
Revised April 2022 for Chez Scheme Version 9.5.8
`
    },
    {
        name: "(top-level-value ",
        endParen: true,
        params: ["symbol"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s29"),
        description: `**procedure**: \`(top-level-value \`*symbol*\`)\`
**procedure**: \`(top-level-value \`*symbol*\` \`*env*\`)\`
**returns: **the top-level value of the variable named by *symbol* in *env*
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

An exception is raised with condition type \`&assertion\` if the identifier named by *symbol* is not defined as a variable in *env*.

\`top-level-value\` is similar to a top-level variable reference except that the variable to be referenced can be determined at run time, as can the environment.

\`(let ([cons +])\`
\`   (list (cons 3 4)\`
\`         ((top-level-value 'cons) 3 4))) \`=>\` (7 (3 . 4)) \`
\` \`
\` (define e (copy-environment (scheme-environment)))\`
\` (define-top-level-value 'pi 3.14 e)\`
\` (top-level-value 'pi e) \`=>\` 3.14\`
\` (set-top-level-value! 'pi 3.1416 e)\`
\` (top-level-value 'pi e) \`=>\` 3.1416\`
`
    },
    {
        name: "(top-level-value ",
        endParen: true,
        params: ["symbol", "env"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:s29"),
        description: `**procedure**: \`(top-level-value \`*symbol*\`)\`
**procedure**: \`(top-level-value \`*symbol*\` \`*env*\`)\`
**returns: **the top-level value of the variable named by *symbol* in *env*
**libraries: **\`(chezscheme)\`

If *env* is not provided, it defaults to the value of \`interaction-environment\`, i.e., the top-level evaluation environment (Section ).

An exception is raised with condition type \`&assertion\` if the identifier named by *symbol* is not defined as a variable in *env*.

\`top-level-value\` is similar to a top-level variable reference except that the variable to be referenced can be determined at run time, as can the environment.

\`(let ([cons +])\`
\`   (list (cons 3 4)\`
\`         ((top-level-value 'cons) 3 4))) \`=>\` (7 (3 . 4)) \`
\` \`
\` (define e (copy-environment (scheme-environment)))\`
\` (define-top-level-value 'pi 3.14 e)\`
\` (top-level-value 'pi e) \`=>\` 3.14\`
\` (set-top-level-value! 'pi 3.1416 e)\`
\` (top-level-value 'pi e) \`=>\` 3.1416\`
`
    },
    {
        name: "(trace ",
        endParen: true,
        params: ["var1", "var2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s9"),
        description: `**syntax**: \`(trace \`*var1*\` \`*var2*\` ...)\`
**returns: **a list of *var1*\` \`*var2*\` ...\`
**syntax**: \`(trace)\`
**returns: **a list of all currently traced top-level variables
**libraries: **\`(chezscheme)\`

In the first form, \`trace\` reassigns the top-level values of *var1*\` \`*var2*\` ...\`, whose values must be procedures, to equivalent procedures that display trace information in the manner of \`trace-lambda\`.

\`trace\` works by encapsulating the old value of each var in a traced procedure. It could be defined approximately as follows. (The actual version records and returns information about traced variables.)

\`(define-syntax trace\`
\`   (syntax-rules ()\`
\`     [(_ var ...)\`
\`      (begin\`
\`        (set-top-level-value! 'var\`
\`          (let ([p (top-level-value 'var)])\`
\`            (trace-lambda var args (apply p args))))\`
\`        ...)]))\`

Tracing for a procedure traced in this manner may be disabled via \`untrace\` (see below), an assignment of the corresponding variable to a different, untraced value, or a subsequent use of \`trace\` for the same variable. Because the value is traced and not the binding, however, a traced value obtained before tracing is disabled and retained after tracing is disabled will remain traced.

\`trace\` without subexpressions evaluates to a list of all currently traced variables. A variable is currently traced if it has been traced and not subsequently untraced or assigned to a different value.

The following transcript demonstrates the use of \`trace\` in an interactive session.

\`> (define half\`
\`     (lambda (x)\`
\`       (cond\`
\`         [(zero? x) 0]\`
\`         [(odd? x) (half (- x 1))]\`
\`         [(even? x) (+ (half (- x 1)) 1)])))\`
\` > (half 5)\`
\` 2\`
\` > (trace half)\`
\` (half)\`
\` > (half 5)\`
\` |(half 5)\`
\` |(half 4)\`
\` | (half 3)\`
\` | (half 2)\`
\` | |(half 1)\`
\` | |(half 0)\`
\` | |0\`
\` | 1\`
\` |2\`
\` 2\`
\` > (define traced-half half)\`
\` > (untrace half)\`
\` (half)\`
\` > (half 2)\`
\` 1\`
\` > (traced-half 2)\`
\` |(half 2)\`
\` |1\`
\` 1\`
`
    },
    {
        name: "(trace)",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s9"),
        description: `**syntax**: \`(trace \`*var1*\` \`*var2*\` ...)\`
**returns: **a list of *var1*\` \`*var2*\` ...\`
**syntax**: \`(trace)\`
**returns: **a list of all currently traced top-level variables
**libraries: **\`(chezscheme)\`

In the first form, \`trace\` reassigns the top-level values of *var1*\` \`*var2*\` ...\`, whose values must be procedures, to equivalent procedures that display trace information in the manner of \`trace-lambda\`.

\`trace\` works by encapsulating the old value of each var in a traced procedure. It could be defined approximately as follows. (The actual version records and returns information about traced variables.)

\`(define-syntax trace\`
\`   (syntax-rules ()\`
\`     [(_ var ...)\`
\`      (begin\`
\`        (set-top-level-value! 'var\`
\`          (let ([p (top-level-value 'var)])\`
\`            (trace-lambda var args (apply p args))))\`
\`        ...)]))\`

Tracing for a procedure traced in this manner may be disabled via \`untrace\` (see below), an assignment of the corresponding variable to a different, untraced value, or a subsequent use of \`trace\` for the same variable. Because the value is traced and not the binding, however, a traced value obtained before tracing is disabled and retained after tracing is disabled will remain traced.

\`trace\` without subexpressions evaluates to a list of all currently traced variables. A variable is currently traced if it has been traced and not subsequently untraced or assigned to a different value.

The following transcript demonstrates the use of \`trace\` in an interactive session.

\`> (define half\`
\`     (lambda (x)\`
\`       (cond\`
\`         [(zero? x) 0]\`
\`         [(odd? x) (half (- x 1))]\`
\`         [(even? x) (+ (half (- x 1)) 1)])))\`
\` > (half 5)\`
\` 2\`
\` > (trace half)\`
\` (half)\`
\` > (half 5)\`
\` |(half 5)\`
\` |(half 4)\`
\` | (half 3)\`
\` | (half 2)\`
\` | |(half 1)\`
\` | |(half 0)\`
\` | |0\`
\` | 1\`
\` |2\`
\` 2\`
\` > (define traced-half half)\`
\` > (untrace half)\`
\` (half)\`
\` > (half 2)\`
\` 1\`
\` > (traced-half 2)\`
\` |(half 2)\`
\` |1\`
\` 1\`
`
    },
    {
        name: "(trace-case-lambda ",
        endParen: true,
        params: ["name", "clause", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s3"),
        description: `**syntax**: \`(trace-case-lambda \`*name*\` \`*clause*\` ...)\`
**returns: **a traced procedure
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(trace-define ",
        endParen: true,
        params: ["var", "expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s14"),
        description: `**syntax**: \`(trace-define \`*var*\` \`*expr*\`)\`
**syntax**: \`(trace-define (\`*var*\` . \`*idspec*\`) \`*body1*\` \`*body2*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`trace-define\` is a convenient shorthand for defining variables bound to traced procedures of the same name. The first form is equivalent to

\`(define \`*var*
\`   (let ([x \`*expr*\`])\`
\`     (trace-lambda \`*var*\` args\`
\`       (apply x args))))\`

and the second is equivalent to

\`(define \`*var*
\`   (trace-lambda \`*var*\` \`*idspec*
\`     \`*body1*\` \`*body2*\` ...))\`

In the former case, *expr* must evaluate to a procedure.

\`> (let ()\`
\`     (trace-define plus\`
\`       (lambda (x y) \`
\`         (+ x y)))\`
\`     (list (plus 3 4) (+ 5 6)))\`
\` |(plus 3 4)\`
\` |7\`
\` (7 11)\`
`
    },
    {
        name: "(trace-define (",
        endParen: true,
        params: ["var", "idspec", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s14"),
        description: `**syntax**: \`(trace-define \`*var*\` \`*expr*\`)\`
**syntax**: \`(trace-define (\`*var*\` . \`*idspec*\`) \`*body1*\` \`*body2*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`trace-define\` is a convenient shorthand for defining variables bound to traced procedures of the same name. The first form is equivalent to

\`(define \`*var*
\`   (let ([x \`*expr*\`])\`
\`     (trace-lambda \`*var*\` args\`
\`       (apply x args))))\`

and the second is equivalent to

\`(define \`*var*
\`   (trace-lambda \`*var*\` \`*idspec*
\`     \`*body1*\` \`*body2*\` ...))\`

In the former case, *expr* must evaluate to a procedure.

\`> (let ()\`
\`     (trace-define plus\`
\`       (lambda (x y) \`
\`         (+ x y)))\`
\`     (list (plus 3 4) (+ 5 6)))\`
\` |(plus 3 4)\`
\` |7\`
\` (7 11)\`
`
    },
    {
        name: "(trace-define-syntax ",
        endParen: true,
        params: ["keyword", "expr"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s15"),
        description: `**syntax**: \`(trace-define-syntax \`*keyword*\` \`*expr*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`trace-define-syntax\` traces the input and output to the transformer value of *expr*, stripped of the contextual information used by the expander to maintain lexical scoping.

\`> (trace-define-syntax let*\`
\`     (syntax-rules ()\`
\`       [(_ () b1 b2 ...)\`
\`        (let () b1 b2 ...)]\`
\`       [(_ ((x e) m ...) b1 b2 ...)\`
\`        (let ((x e))\`
\`          (let* (m ...) b1 b2 ...))]))\`
\` > (let* ([x 3] [y (+ x x)]) (list x y))\`
\` |(let* (let* [(x 3) (y (+ x x))] [list x y]))\`
\` |(let ([x 3]) (let* ([y (+ x x)]) (list x y)))\`
\` |(let* (let* [(y (+ x x))] [list x y]))\`
\` |(let ([y (+ x x)]) (let* () (list x y)))\`
\` |(let* (let* () [list x y]))\`
\` |(let () (list x y))\`
\` (3 6)\`

Without contextual information, the displayed forms are more readable but less precise, since different identifiers with the same name are indistinguishable, as shown in the example below.

\`> (let ([x 0])\`
\`     (trace-define-syntax a\`
\`       (syntax-rules ()\`
\`         [(_ y) (eq? x y)]))\`
\`     (let ([x 1])\`
\`       (a x)))\`
\` |(a (a x))\`
\` |(eq? x x)\`
\` #f\`
`
    },
    {
        name: "(trace-do ((",
        endParen: true,
        params: ["var", "init", "update", "test", "result", "expr", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s7"),
        description: `**syntax**: \`(trace-do ((\`*var*\` \`*init*\` \`*update*\`) ...) (\`*test*\` \`*result*\` ...) \`*expr*\` ...)\`
**returns: **the values of the last *result* expression
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(trace-lambda ",
        endParen: true,
        params: ["name", "formals", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s0"),
        description: `**syntax**: \`(trace-lambda \`*name*\` \`*formals*\` \`*body1*\` \`*body2*\` ...)\`
**returns: **a traced procedure
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(trace-let ",
        endParen: true,
        params: ["name", "var", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s5"),
        description: `**syntax**: \`(trace-let \`*name*\` ((\`*var*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the body *body1*\` \`*body2*\` ...\`
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "trace-output-port",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s11"),
        description: `**thread parameter**: \`trace-output-port\`
**libraries: **\`(chezscheme)\`

\`trace-output-port\` is a parameter that determines the output port to which tracing information is sent. When called with no arguments, \`trace-output-port\` returns the current trace output port. When called with one argument, which must be a textual output port, \`trace-output-port\` changes the value of the current trace output port.
`
    },
    {
        name: "trace-print",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s12"),
        description: `**thread parameter**: \`trace-print\`
**libraries: **\`(chezscheme)\`

The value of \`trace-print\` must be a procedure of two arguments, an object and an output port. The trace package uses the value of \`trace-print\` to print the arguments and return values for each call to a traced procedure. \`trace-print\` is set to \`pretty-print\` by default.
`
    },
    {
        name: "(transcoded-port ",
        endParen: true,
        params: ["binary-port", "transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s47"),
        description: `**procedure**: \`(transcoded-port \`*binary-port*\` \`*transcoder*\`)\`
**returns: **a new textual port with the same byte stream as *binary-port*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`

This procedure returns a new textual port with transcoder *transcoder* and the same underlying byte stream as *binary-port*, positioned at the current position of *binary-port*.

As a side effect of creating the textual port, *binary-port* is closed to prevent read or write operations on *binary-port* from interfering with read and write operations on the new textual port. The underlying byte stream remains open, however, until the textual port is closed.
`
    },
    {
        name: "(transcoder-codec ",
        endParen: true,
        params: ["transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s20"),
        description: `**procedure**: \`(transcoder-codec \`*transcoder*\`)\`
**returns: **the codec encapsulated in *transcoder*
**procedure**: \`(transcoder-eol-style \`*transcoder*\`)\`
**returns: **the eol-style symbol encapsulated in *transcoder*
**procedure**: \`(transcoder-error-handling-mode \`*transcoder*\`)\`
**returns: **the error-handling-mode symbol encapsulated in *transcoder*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(transcoder-eol-style ",
        endParen: true,
        params: ["transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s20"),
        description: `**procedure**: \`(transcoder-codec \`*transcoder*\`)\`
**returns: **the codec encapsulated in *transcoder*
**procedure**: \`(transcoder-eol-style \`*transcoder*\`)\`
**returns: **the eol-style symbol encapsulated in *transcoder*
**procedure**: \`(transcoder-error-handling-mode \`*transcoder*\`)\`
**returns: **the error-handling-mode symbol encapsulated in *transcoder*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(transcoder-error-handling-mode ",
        endParen: true,
        params: ["transcoder"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s20"),
        description: `**procedure**: \`(transcoder-codec \`*transcoder*\`)\`
**returns: **the codec encapsulated in *transcoder*
**procedure**: \`(transcoder-eol-style \`*transcoder*\`)\`
**returns: **the eol-style symbol encapsulated in *transcoder*
**procedure**: \`(transcoder-error-handling-mode \`*transcoder*\`)\`
**returns: **the error-handling-mode symbol encapsulated in *transcoder*
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(transcoder? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s12"),
        description: `**procedure**: \`(transcoder? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a transcoder, \`#f\` otherwise
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(transcript-cafe ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s201"),
        description: `**procedure**: \`(transcript-cafe \`*path*\`)\`
**libraries: **\`(chezscheme)\`

*path* must be a string. \`transcript-cafe\` opens a transcript file as with \`transcript-on\` and enters a new café; exiting from this café (see \`exit\`) also ends transcription and closes the transcript file. Invoking \`transcript-off\` while in a transcript café ends transcription and closes the transcript file but does not cause an exit from the café.
`
    },
    {
        name: "(transcript-off)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s200"),
        description: `**procedure**: \`(transcript-off)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`transcript-off\` ends transcription and closes the transcript file.
`
    },
    {
        name: "(transcript-on ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s199"),
        description: `**procedure**: \`(transcript-on \`*path*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string.

\`transcript-on\` opens the file named by *path* for output, and it copies to this file all input from the current input port and all output to the current output port. An exception is raised with condition-type \`i/o-filename\` if the file cannot be opened for output.
`
    },
    {
        name: "(truncate ",
        endParen: true,
        params: ["real"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s101"),
        description: `**procedure**: \`(truncate \`*real*\`)\`
**returns: **the integer closest to *real* toward zero
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

If *real* is an infinity or NaN, \`truncate\` returns *real*.

\`(truncate 19) \`=>\` 19\`
\` (truncate 2/3) \`=>\` 0\`
\` (truncate -2/3) \`=>\` 0\`
\` (truncate 17.3) \`=>\` 17.0\`
\` (truncate -17/2) \`=>\` -8\`
`
    },
    {
        name: "(truncate-file ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s87"),
        description: `**procedure**: \`(truncate-port \`*output-port*\`)\`
**procedure**: \`(truncate-port \`*output-port*\` \`*pos*\`)\`
**procedure**: \`(truncate-file \`*output-port*\`)\`
**procedure**: \`(truncate-file \`*output-port*\` \`*pos*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`truncate-port\` and \`truncate-file\` are identical.

*pos* must be an exact nonnegative integer. It defaults to 0.

These procedures truncate the file or other object associated with *output-port* to *pos* and repositions the port to that position, i.e., it combines the functionality of \`set-port-length!\` and \`set-port-position!\` and can be called on a port only if \`port-has-set-port-length!?\` and \`port-has-set-port-position!?\` are both true of the port.
`
    },
    {
        name: "(truncate-file ",
        endParen: true,
        params: ["output-port", "pos"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s87"),
        description: `**procedure**: \`(truncate-port \`*output-port*\`)\`
**procedure**: \`(truncate-port \`*output-port*\` \`*pos*\`)\`
**procedure**: \`(truncate-file \`*output-port*\`)\`
**procedure**: \`(truncate-file \`*output-port*\` \`*pos*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`truncate-port\` and \`truncate-file\` are identical.

*pos* must be an exact nonnegative integer. It defaults to 0.

These procedures truncate the file or other object associated with *output-port* to *pos* and repositions the port to that position, i.e., it combines the functionality of \`set-port-length!\` and \`set-port-position!\` and can be called on a port only if \`port-has-set-port-length!?\` and \`port-has-set-port-position!?\` are both true of the port.
`
    },
    {
        name: "(truncate-port ",
        endParen: true,
        params: ["output-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s87"),
        description: `**procedure**: \`(truncate-port \`*output-port*\`)\`
**procedure**: \`(truncate-port \`*output-port*\` \`*pos*\`)\`
**procedure**: \`(truncate-file \`*output-port*\`)\`
**procedure**: \`(truncate-file \`*output-port*\` \`*pos*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`truncate-port\` and \`truncate-file\` are identical.

*pos* must be an exact nonnegative integer. It defaults to 0.

These procedures truncate the file or other object associated with *output-port* to *pos* and repositions the port to that position, i.e., it combines the functionality of \`set-port-length!\` and \`set-port-position!\` and can be called on a port only if \`port-has-set-port-length!?\` and \`port-has-set-port-position!?\` are both true of the port.
`
    },
    {
        name: "(truncate-port ",
        endParen: true,
        params: ["output-port", "pos"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s87"),
        description: `**procedure**: \`(truncate-port \`*output-port*\`)\`
**procedure**: \`(truncate-port \`*output-port*\` \`*pos*\`)\`
**procedure**: \`(truncate-file \`*output-port*\`)\`
**procedure**: \`(truncate-file \`*output-port*\` \`*pos*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`truncate-port\` and \`truncate-file\` are identical.

*pos* must be an exact nonnegative integer. It defaults to 0.

These procedures truncate the file or other object associated with *output-port* to *pos* and repositions the port to that position, i.e., it combines the functionality of \`set-port-length!\` and \`set-port-position!\` and can be called on a port only if \`port-has-set-port-length!?\` and \`port-has-set-port-position!?\` are both true of the port.
`
    },
    {
        name: "(type-descriptor ",
        endParen: true,
        params: ["name"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s180"),
        description: `**syntax**: \`(type-descriptor \`*name*\`)\`
**returns: **the record-type descriptor associated with *name*
**libraries: **\`(chezscheme)\`

*name* must name a record type defined by \`define-record\` or \`define-record-type\`.

This form is equivalent to the Revised Report \`record-type-descriptor\` form.

The record-type descriptor is useful for overriding the default read and write syntax using \`record-reader\` and \`record-writer\` and may also be used with the procedural interface routines described later in this section.

\`(define-record frob ())\`
\` (type-descriptor frob) \`=>\` #<record type frob>\`
`
    },
    {
        name: "(u8-list->bytevector ",
        endParen: true,
        params: ["list"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s253"),
        description: `**procedure**: \`(u8-list->bytevector \`*list*\`)\`
**returns: **a new bytevector of the elements of *list*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*list* must consist entirely of exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.

\`(u8-list->bytevector '()) \`=>\` #vu8()\`
\` (u8-list->bytevector '(1 127 128 255)) \`=>\` #vu8(1 127 128 255) \`
\` \`
\` (let ([v #vu8(1 2 3 4 5)])\`
\`   (let ([ls (bytevector->u8-list v)])\`
\`     (u8-list->bytevector (map * ls ls)))) \`=>\` #vu8(1 4 9 16 25)\`
`
    },
    {
        name: "(uint-list->bytevector ",
        endParen: true,
        params: ["list", "eness", "size"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s261"),
        description: `**procedure**: \`(uint-list->bytevector \`*list*\` \`*eness*\` \`*size*\`)\`
**procedure**: \`(sint-list->bytevector \`*list*\` \`*eness*\` \`*size*\`)\`
**returns: **a new bytevector of the elements of *list*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*eness* must be a valid endianness symbol naming the endianness. *size* must be an exact positive integer and specifies the number of bytes occupied by the value. For \`uint-list->bytevector\`, *list* must consist entirely of *size*-byte exact unsigned integers, i.e., values in the range 0 to 2 - 1 inclusive. For \`sint-list->bytevector\`, *list* must consist entirely of *size*-byte exact signed integers, i.e., values in the range -2 to 2 - 1 inclusive. Each value occupies *size* bytes in the resulting bytevector, whose length is thus *size* times the length of *list*.

\`(uint-list->bytevector '() 'big 25) \`=>\` #vu8()\`
\` (sint-list->bytevector '(0 -1) 'big 3) \`=>\` #vu8(0 0 0 #xff #xff #xff) \`
\` \`
\` (define (f size)\`
\`   (let ([ls (list (- (expt 2 (- (* 8 size) 1)))\`
\`                   (- (expt 2 (- (* 8 size) 1)) 1))])\`
\`     (sint-list->bytevector ls 'little size)))\`
\` (f 6) \`=>\` #vu8(#x00 #x00 #x00 #x00 #x00 #x80\`
\`       \`\`      #xff #xff #xff #xff #xff #x7f)\`
`
    },
    {
        name: "(unbox ",
        endParen: true,
        params: ["box"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s84"),
        description: `**procedure**: \`(unbox \`*box*\`)\`
**returns: **contents of *box*
**libraries: **\`(chezscheme)\`

\` (unbox #&a) \`=>\` a\`
\` (unbox #&#&(a b c)) \`=>\` #&(a b c) \`
\` \`
\` (let ([b (box "hi")])\`
\`   (unbox b)) \`=>\` "hi"\`
`
    },
    {
        name: "undefined-variable-warnings",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s123"),
        description: `**thread parameter**: \`undefined-variable-warnings\`
**libraries: **\`(chezscheme)\`

When \`undefined-variable-warnings\` is set to \`#t\`, the compiler issues a warning message whenever it cannot determine that a variable bound by \`letrec\`, \`letrec*\`, or an internal definition will not be referenced before it is defined. The default value is \`#f\`.

Regardless of the setting of this parameter, the compiler inserts code to check for the error, except at optimize level 3. The check is fairly inexpensive and does not typically inhibit inlining or other optimizations. In code that must be carefully tuned, however, it is sometimes useful to reorder bindings or make other changes to eliminate the checks. Enabling undefined-variable warnings can facilitate this process.

The checks are also visible in the output of \`expand/optimize\`.
`
    },
    {
        name: "(undefined-violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s31"),
        description: `**syntax**: \`&undefined\`
**procedure**: \`(make-undefined-violation)\`
**returns: **a condition of type \`&undefined\`
**procedure**: \`(undefined-violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&undefined\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

An undefined condition indicates an attempt to reference an unbound variable. This condition type might be defined as follows.

\`(define-condition-type &undefined &violation\`
\`   make-undefined-violation undefined-violation?)\`

The next several condition types describe conditions that occur when input or output operations fail in some manner.
`
    },
    {
        name: "(unget-char ",
        endParen: true,
        params: ["textual-input-port", "char"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s65"),
        description: `**procedure**: \`(unread-char \`*char*\`)\`
**procedure**: \`(unread-char \`*char*\` \`*textual-input-port*\`)\`
**procedure**: \`(unget-char \`*textual-input-port*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

For \`unread-char\`, if *textual-input-port* is not supplied, it defaults to the current input port. These procedures "unread" the last character read from \`textual-input-port\`. *char* may or may not be ignored, depending upon the implementation. In any case, *char* should be last character read from the port. A character should not be unread twice on the same port without an intervening call to \`read-char\` or \`get-char\`.

\`unread-char\` and \`unget-char\` are provided for applications requiring one character of lookahead and may be used in place of, or even in combination with, \`peek-char\` or \`lookahead-char\`. One character of lookahead is required in the procedure \`read-word\`, which is defined below in terms of \`unread-char\`. \`read-word\` returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since it does not know until it reads one character too many that it has read the entire word, \`read-word\` uses \`unread-char\` to return the character to the input port.

\`(define read-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ([c (read-char p)])\`
\`         (cond\`
\`           [(eof-object? c) '()]\`
\`           [(char-alphabetic? c)\`
\`            (cons c (f (read-char p)))]\`
\`           [else\`
\`            (unread-char c p)\`
\`            '()])))))\`

In the alternate version below, \`peek-char\` is used instead of \`unread-char\`.

\`(define read-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ([c (peek-char p)])\`
\`         (cond\`
\`           [(eof-object? c) '()]\`
\`           [(char-alphabetic? c)\`
\`            (read-char p)\`
\`            (cons c (f (peek-char p)))]\`
\`           [else '()])))))\`

The advantage of \`unread-char\` in this situation is that only one call to \`unread-char\` per word is required, whereas one call to \`peek-char\` is required for each character in the word plus the first character beyond. In many cases, \`unread-char\` and \`unget-char\` do not enjoy this advantage, and \`peek-char\` or \`lookahead-char\` should be used instead.
`
    },
    {
        name: "(unget-u8 ",
        endParen: true,
        params: ["binary-input-port", "octet"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s66"),
        description: `**procedure**: \`(unget-u8 \`*binary-input-port*\` \`*octet*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

This procedures "unreads" the last byte read from \`binary-input-port\`. *octet* may or may not be ignored, depending upon the implementation. In any case, *octet* should be last byte read from the port. A byte should not be unread twice on the same port without an intervening call to \`get-u8\`.
`
    },
    {
        name: "(unless ",
        endParen: true,
        params: ["test-expr", "expr1", "expr2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s17"),
        description: `**syntax**: \`(when \`*test-expr*\` \`*expr1*\` \`*expr2*\` ...)\`
**syntax**: \`(unless \`*test-expr*\` \`*expr1*\` \`*expr2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs control)\`, \`(rnrs)\`

For \`when\`, if *test-expr* evaluates to a true value, the expressions *expr1*\` \`*expr2*\` ...\` are evaluated in sequence, and the values of the last expression are returned. If *test-expr* evaluates to false, none of the other expressions are evaluated, and the value or values of \`when\` are unspecified.

For \`unless\`, if *test-expr* evaluates to false, the expressions *expr1*\` \`*expr2*\` ...\` are evaluated in sequence, and the values of the last expression are returned. If *test-expr* evaluates to a true value, none of the other expressions are evaluated, and the value or values of \`unless\` are unspecified.

A \`when\` or \`unless\` expression is usually clearer than the corresponding "one-armed" \`if\` expression.

\`(let ([x -4] [sign 'plus])\`
\`   (when (< x 0)\`
\`     (set! x (- 0 x))\`
\`     (set! sign 'minus))\`
\`   (list sign x)) \`=>\` (minus 4) \`
\` \`
\` (define check-pair\`
\`   (lambda (x)\`
\`     (unless (pair? x)\`
\`       (syntax-violation 'check-pair "invalid argument" x))\`
\`     x)) \`
\` \`
\` (check-pair '(a b c)) \`=>\` (a b c)\`

\`when\` may be defined as follows:

\`(define-syntax when\`
\`   (syntax-rules ()\`
\`     [(_ e0 e1 e2 ...)\`
\`      (if e0 (begin e1 e2 ...))]))\`

\`unless\` may be defined as follows:

\`(define-syntax unless\`
\`   (syntax-rules ()\`
\`     [(_ e0 e1 e2 ...)\`
\`      (if (not e0) (begin e1 e2 ...))]))\`

or in terms of \`when\` as follows:

\`(define-syntax unless\`
\`   (syntax-rules ()\`
\`     [(_ e0 e1 e2 ...)\`
\`      (when (not e0) e1 e2 ...)]))\`
`
    },
    {
        name: "(unlock-object ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s38"),
        description: `**procedure**: \`(unlock-object \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

An object may be locked more than once by successive calls to \`lock-object\`, \`Slock_object\`, or both, in which case it must be unlocked by an equal number of calls to \`unlock-object\` or \`Sunlock_object\` before it is truly unlocked.

An object contained within a locked object, such as an object in the car of a locked pair, need not also be locked unless a separate C pointer to the object exists. That is, if the inner object is accessed only via an indirection of the outer object, it should be left unlocked so that the collector is free to relocate it during collection.

Unlocking immediate values, such as fixnums, booleans, and characters, or objects that have been made static is unnecessary and ineffective but harmless.
`
    },
    {
        name: "(unquote ",
        endParen: true,
        params: ["obj", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s5"),
        description: `**syntax**: \`(quasiquote \`*obj*\` ...)\`
**syntax**: \`\`\`*obj*
**syntax**: \`(unquote \`*obj*\` ...)\`
**syntax**: \`,\`*obj*
**syntax**: \`(unquote-splicing \`*obj*\` ...)\`
**syntax**: \`,@\`*obj*
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`\`\`*obj* is equivalent to \`(quasiquote \`*obj*\`)\`, \`,\`*obj* is equivalent to \`(unquote \`*obj*\`)\`, and \`,@\`*obj* is equivalent to \`(unquote-splicing \`*obj*\`)\`. The abbreviated forms are converted into the longer forms by the Scheme reader (see \`read\`).

\`quasiquote\` is similar to \`quote\`, but it allows parts of the quoted text to be "unquoted." Within a \`quasiquote\` expression, \`unquote\` and \`unquote-splicing\` subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each \`unquote\` subform is inserted into the output in place of the \`unquote\` form, while the value of each \`unquote-splicing\` subform is spliced into the surrounding list or vector structure. \`unquote\` and \`unquote-splicing\` are valid only within \`quasiquote\` expressions.

\`quasiquote\` expressions may be nested, with each \`quasiquote\` introducing a new level of quotation and each \`unquote\` or \`unquote-splicing\` taking away a level of quotation. An expression nested within \`quasiquote\` expressions must be within \`unquote\` or \`unquote-splicing\` expressions to be evaluated.

\`\`(+ 2 3) \`=>\` (+ 2 3) \`
\` \`
\` \`(+ 2 ,(* 3 4)) \`=>\` (+ 2 12)\`
\` \`(a b (,(+ 2 3) c) d) \`=>\` (a b (5 c) d)\`
\` \`(a b ,(reverse '(c d e)) f g) \`=>\` (a b (e d c) f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a . ,b)) \`=>\` (1 . 2) \`
\` \`
\` \`(+ ,@(cdr '(* 2 3))) \`=>\` (+ 2 3)\`
\` \`(a b ,@(reverse '(c d e)) f g) \`=>\` (a b e d c f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a ,@b)) \`=>\` (1 . 2)\`
\` \`#(,@(list 1 2 3)) \`=>\` #(1 2 3) \`
\` \`
\` '\`,(cons 'a 'b) \`=>\` \`,(cons 'a 'b)\`
\` \`',(cons 'a 'b) \`=>\` '(a . b)\`

\`unquote\` and \`unquote-splicing\` forms with zero or more than one subform are valid only in splicing (list or vector) contexts. \`(unquote \`*obj*\` ...)\` is equivalent to \`(unquote \`*obj*\`) ...\`, and \`(unquote-splicing \`*obj*\` ...)\` is equivalent to \`(unquote-splicing \`*obj*\`) ...\`. These forms are primarily useful as intermediate forms in the output of the \`quasiquote\` expander. They support certain useful nested quasiquotation idioms [], such as \`,@,@\`, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated \`quasiquote\` expression.

\`\`(a (unquote) b) \`=>\` (a b)\`
\` \`(a (unquote (+ 3 3)) b) \`=>\` (a 6 b)\`
\` \`(a (unquote (+ 3 3) (* 3 3)) b) \`=>\` (a 6 9 b) \`
\` \`
\` (let ([x '(m n)]) \`\`(a ,@,@x f)) \`=>\` \`(a (unquote-splicing m n) f)\`
\` (let ([x '(m n)])\`
\`   (eval \`(let ([m '(b c)] [n '(d e)]) \`(a ,@,@x f))\`
\`         (environment '(rnrs)))) \`=>\` (a b c d e f)\`

\`unquote\` and \`unquote-splicing\` are auxiliary keywords for \`quasiquote\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(unquote-splicing ",
        endParen: true,
        params: ["obj", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s5"),
        description: `**syntax**: \`(quasiquote \`*obj*\` ...)\`
**syntax**: \`\`\`*obj*
**syntax**: \`(unquote \`*obj*\` ...)\`
**syntax**: \`,\`*obj*
**syntax**: \`(unquote-splicing \`*obj*\` ...)\`
**syntax**: \`,@\`*obj*
**returns: **see below
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`\`\`*obj* is equivalent to \`(quasiquote \`*obj*\`)\`, \`,\`*obj* is equivalent to \`(unquote \`*obj*\`)\`, and \`,@\`*obj* is equivalent to \`(unquote-splicing \`*obj*\`)\`. The abbreviated forms are converted into the longer forms by the Scheme reader (see \`read\`).

\`quasiquote\` is similar to \`quote\`, but it allows parts of the quoted text to be "unquoted." Within a \`quasiquote\` expression, \`unquote\` and \`unquote-splicing\` subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each \`unquote\` subform is inserted into the output in place of the \`unquote\` form, while the value of each \`unquote-splicing\` subform is spliced into the surrounding list or vector structure. \`unquote\` and \`unquote-splicing\` are valid only within \`quasiquote\` expressions.

\`quasiquote\` expressions may be nested, with each \`quasiquote\` introducing a new level of quotation and each \`unquote\` or \`unquote-splicing\` taking away a level of quotation. An expression nested within \`quasiquote\` expressions must be within \`unquote\` or \`unquote-splicing\` expressions to be evaluated.

\`\`(+ 2 3) \`=>\` (+ 2 3) \`
\` \`
\` \`(+ 2 ,(* 3 4)) \`=>\` (+ 2 12)\`
\` \`(a b (,(+ 2 3) c) d) \`=>\` (a b (5 c) d)\`
\` \`(a b ,(reverse '(c d e)) f g) \`=>\` (a b (e d c) f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a . ,b)) \`=>\` (1 . 2) \`
\` \`
\` \`(+ ,@(cdr '(* 2 3))) \`=>\` (+ 2 3)\`
\` \`(a b ,@(reverse '(c d e)) f g) \`=>\` (a b e d c f g)\`
\` (let ([a 1] [b 2])\`
\`   \`(,a ,@b)) \`=>\` (1 . 2)\`
\` \`#(,@(list 1 2 3)) \`=>\` #(1 2 3) \`
\` \`
\` '\`,(cons 'a 'b) \`=>\` \`,(cons 'a 'b)\`
\` \`',(cons 'a 'b) \`=>\` '(a . b)\`

\`unquote\` and \`unquote-splicing\` forms with zero or more than one subform are valid only in splicing (list or vector) contexts. \`(unquote \`*obj*\` ...)\` is equivalent to \`(unquote \`*obj*\`) ...\`, and \`(unquote-splicing \`*obj*\` ...)\` is equivalent to \`(unquote-splicing \`*obj*\`) ...\`. These forms are primarily useful as intermediate forms in the output of the \`quasiquote\` expander. They support certain useful nested quasiquotation idioms [], such as \`,@,@\`, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated \`quasiquote\` expression.

\`\`(a (unquote) b) \`=>\` (a b)\`
\` \`(a (unquote (+ 3 3)) b) \`=>\` (a 6 b)\`
\` \`(a (unquote (+ 3 3) (* 3 3)) b) \`=>\` (a 6 9 b) \`
\` \`
\` (let ([x '(m n)]) \`\`(a ,@,@x f)) \`=>\` \`(a (unquote-splicing m n) f)\`
\` (let ([x '(m n)])\`
\`   (eval \`(let ([m '(b c)] [n '(d e)]) \`(a ,@,@x f))\`
\`         (environment '(rnrs)))) \`=>\` (a b c d e f)\`

\`unquote\` and \`unquote-splicing\` are auxiliary keywords for \`quasiquote\`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.
`
    },
    {
        name: "(unread-char ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s65"),
        description: `**procedure**: \`(unread-char \`*char*\`)\`
**procedure**: \`(unread-char \`*char*\` \`*textual-input-port*\`)\`
**procedure**: \`(unget-char \`*textual-input-port*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

For \`unread-char\`, if *textual-input-port* is not supplied, it defaults to the current input port. These procedures "unread" the last character read from \`textual-input-port\`. *char* may or may not be ignored, depending upon the implementation. In any case, *char* should be last character read from the port. A character should not be unread twice on the same port without an intervening call to \`read-char\` or \`get-char\`.

\`unread-char\` and \`unget-char\` are provided for applications requiring one character of lookahead and may be used in place of, or even in combination with, \`peek-char\` or \`lookahead-char\`. One character of lookahead is required in the procedure \`read-word\`, which is defined below in terms of \`unread-char\`. \`read-word\` returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since it does not know until it reads one character too many that it has read the entire word, \`read-word\` uses \`unread-char\` to return the character to the input port.

\`(define read-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ([c (read-char p)])\`
\`         (cond\`
\`           [(eof-object? c) '()]\`
\`           [(char-alphabetic? c)\`
\`            (cons c (f (read-char p)))]\`
\`           [else\`
\`            (unread-char c p)\`
\`            '()])))))\`

In the alternate version below, \`peek-char\` is used instead of \`unread-char\`.

\`(define read-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ([c (peek-char p)])\`
\`         (cond\`
\`           [(eof-object? c) '()]\`
\`           [(char-alphabetic? c)\`
\`            (read-char p)\`
\`            (cons c (f (peek-char p)))]\`
\`           [else '()])))))\`

The advantage of \`unread-char\` in this situation is that only one call to \`unread-char\` per word is required, whereas one call to \`peek-char\` is required for each character in the word plus the first character beyond. In many cases, \`unread-char\` and \`unget-char\` do not enjoy this advantage, and \`peek-char\` or \`lookahead-char\` should be used instead.
`
    },
    {
        name: "(unread-char ",
        endParen: true,
        params: ["char", "textual-input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s65"),
        description: `**procedure**: \`(unread-char \`*char*\`)\`
**procedure**: \`(unread-char \`*char*\` \`*textual-input-port*\`)\`
**procedure**: \`(unget-char \`*textual-input-port*\` \`*char*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

For \`unread-char\`, if *textual-input-port* is not supplied, it defaults to the current input port. These procedures "unread" the last character read from \`textual-input-port\`. *char* may or may not be ignored, depending upon the implementation. In any case, *char* should be last character read from the port. A character should not be unread twice on the same port without an intervening call to \`read-char\` or \`get-char\`.

\`unread-char\` and \`unget-char\` are provided for applications requiring one character of lookahead and may be used in place of, or even in combination with, \`peek-char\` or \`lookahead-char\`. One character of lookahead is required in the procedure \`read-word\`, which is defined below in terms of \`unread-char\`. \`read-word\` returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since it does not know until it reads one character too many that it has read the entire word, \`read-word\` uses \`unread-char\` to return the character to the input port.

\`(define read-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ([c (read-char p)])\`
\`         (cond\`
\`           [(eof-object? c) '()]\`
\`           [(char-alphabetic? c)\`
\`            (cons c (f (read-char p)))]\`
\`           [else\`
\`            (unread-char c p)\`
\`            '()])))))\`

In the alternate version below, \`peek-char\` is used instead of \`unread-char\`.

\`(define read-word\`
\`   (lambda (p)\`
\`     (list->string\`
\`       (let f ([c (peek-char p)])\`
\`         (cond\`
\`           [(eof-object? c) '()]\`
\`           [(char-alphabetic? c)\`
\`            (read-char p)\`
\`            (cons c (f (peek-char p)))]\`
\`           [else '()])))))\`

The advantage of \`unread-char\` in this situation is that only one call to \`unread-char\` per word is required, whereas one call to \`peek-char\` is required for each character in the word plus the first character beyond. In many cases, \`unread-char\` and \`unget-char\` do not enjoy this advantage, and \`peek-char\` or \`lookahead-char\` should be used instead.
`
    },
    {
        name: "(unregister-guardian ",
        endParen: true,
        params: ["guardian"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s32"),
        description: `**procedure**: \`(unregister-guardian \`*guardian*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`unregister-guardian\` unregisters the as-yet unresurrected objects currently registered with the guardian, with one caveat.
`
    },
    {
        name: "(unsyntax ",
        endParen: true,
        params: ["template", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s40"),
        description: `**syntax**: \`(quasisyntax \`*template*\` ...)\`
**syntax**: \`#\`\`*template*
**syntax**: \`(unsyntax \`*template*\` ...)\`
**syntax**: \`#,\`*template*
**syntax**: \`(unsyntax-splicing \`*template*\` ...)\`
**syntax**: \`#,@\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#\`\`*template* is equivalent to \`(quasisyntax \`*template*\`)\`, while \`#,\`*template* is equivalent to \`(unsyntax \`*template*\`)\`, and \`#,@\`*template* to \`(unsyntax-splicing \`*template*\`)\`. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.

\`quasisyntax\` is similar to \`syntax\`, but it allows parts of the quoted text to be evaluated, in a manner similar to \`quasiquote\` (Section ).

Within a \`quasisyntax\` *template*, subforms of \`unsyntax\` and \`unsyntax-splicing\` forms are evaluated, and everything else is treated as ordinary template material, as with \`syntax\`. The value of each \`unsyntax\` subform is inserted into the output in place of the \`unsyntax\` form, while the value of each \`unsyntax-splicing\` subform is spliced into the surrounding list or vector structure. \`unsyntax\` and \`unsyntax-splicing\` are valid only within \`quasisyntax\` expressions.

\`quasisyntax\` expressions may be nested, with each \`quasisyntax\` introducing a new level of syntax quotation and each \`unsyntax\` or \`unsyntax-splicing\` taking away a level of quotation. An expression nested within \`quasisyntax\` expressions must be within \`unsyntax\` or \`unsyntax-splicing\` expressions to be evaluated.
`
    },
    {
        name: "(unsyntax-splicing ",
        endParen: true,
        params: ["template", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s40"),
        description: `**syntax**: \`(quasisyntax \`*template*\` ...)\`
**syntax**: \`#\`\`*template*
**syntax**: \`(unsyntax \`*template*\` ...)\`
**syntax**: \`#,\`*template*
**syntax**: \`(unsyntax-splicing \`*template*\` ...)\`
**syntax**: \`#,@\`*template*
**returns: **see below
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

\`#\`\`*template* is equivalent to \`(quasisyntax \`*template*\`)\`, while \`#,\`*template* is equivalent to \`(unsyntax \`*template*\`)\`, and \`#,@\`*template* to \`(unsyntax-splicing \`*template*\`)\`. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.

\`quasisyntax\` is similar to \`syntax\`, but it allows parts of the quoted text to be evaluated, in a manner similar to \`quasiquote\` (Section ).

Within a \`quasisyntax\` *template*, subforms of \`unsyntax\` and \`unsyntax-splicing\` forms are evaluated, and everything else is treated as ordinary template material, as with \`syntax\`. The value of each \`unsyntax\` subform is inserted into the output in place of the \`unsyntax\` form, while the value of each \`unsyntax-splicing\` subform is spliced into the surrounding list or vector structure. \`unsyntax\` and \`unsyntax-splicing\` are valid only within \`quasisyntax\` expressions.

\`quasisyntax\` expressions may be nested, with each \`quasisyntax\` introducing a new level of syntax quotation and each \`unsyntax\` or \`unsyntax-splicing\` taking away a level of quotation. An expression nested within \`quasisyntax\` expressions must be within \`unsyntax\` or \`unsyntax-splicing\` expressions to be evaluated.
`
    },
    {
        name: "(untrace ",
        endParen: true,
        params: ["var1", "var2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s10"),
        description: `**syntax**: \`(untrace \`*var1*\` \`*var2*\` ...)\`
**syntax**: \`(untrace)\`
**returns: **a list of untraced variables
**libraries: **\`(chezscheme)\`

\`untrace\` restores the original (pre-\`trace\`) top-level values of each currently traced variable in *var1*\` \`*var2*\` ...\`, effectively disabling the tracing of the values of these variables. Any variable in *var1*\` \`*var2*\` ...\` that is not currently traced is ignored. If \`untrace\` is called without arguments, the values of all currently traced variables are restored.

The following transcript demonstrates the use of \`trace\` and \`untrace\` in an interactive session to debug an incorrect procedure definition.

\`> (define square-minus-one\`
\`     (lambda (x)\`
\`       (- (* x x) 2)))\`
\` > (square-minus-one 3)\`
\` 7\`
\` > (trace square-minus-one * -)\`
\` (square-minus-one * -)\`
\` > (square-minus-one 3)\`
\` |(square-minus-one 3)\`
\` | (* 3 3)\`
\` | 9\`
\` |(- 9 2)\`
\` |7\`
\` 7\`
\` > (define square-minus-one\`
\`     (lambda (x)\`
\`       (- (* x x) 1))) ; change the 2 to 1\`
\` > (trace)\`
\` (- *)\`
\` > (square-minus-one 3)\`
\` |(* 3 3)\`
\` |9\`
\` |(- 9 1)\`
\` |8\`
\` 8\`
\` > (untrace square-minus-one)\`
\` ()\`
\` > (untrace * -)\`
\` (- *)\`
\` > (square-minus-one 3)\`
\` 8\`

The first call to \`square-minus-one\` indicates there is an error, the second (traced) call indicates the step at which the error occurs, the third call demonstrates that the fix works, and the fourth call demonstrates that \`untrace\` does not wipe out the fix.
`
    },
    {
        name: "(untrace)",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s10"),
        description: `**syntax**: \`(untrace \`*var1*\` \`*var2*\` ...)\`
**syntax**: \`(untrace)\`
**returns: **a list of untraced variables
**libraries: **\`(chezscheme)\`

\`untrace\` restores the original (pre-\`trace\`) top-level values of each currently traced variable in *var1*\` \`*var2*\` ...\`, effectively disabling the tracing of the values of these variables. Any variable in *var1*\` \`*var2*\` ...\` that is not currently traced is ignored. If \`untrace\` is called without arguments, the values of all currently traced variables are restored.

The following transcript demonstrates the use of \`trace\` and \`untrace\` in an interactive session to debug an incorrect procedure definition.

\`> (define square-minus-one\`
\`     (lambda (x)\`
\`       (- (* x x) 2)))\`
\` > (square-minus-one 3)\`
\` 7\`
\` > (trace square-minus-one * -)\`
\` (square-minus-one * -)\`
\` > (square-minus-one 3)\`
\` |(square-minus-one 3)\`
\` | (* 3 3)\`
\` | 9\`
\` |(- 9 2)\`
\` |7\`
\` 7\`
\` > (define square-minus-one\`
\`     (lambda (x)\`
\`       (- (* x x) 1))) ; change the 2 to 1\`
\` > (trace)\`
\` (- *)\`
\` > (square-minus-one 3)\`
\` |(* 3 3)\`
\` |9\`
\` |(- 9 1)\`
\` |8\`
\` 8\`
\` > (untrace square-minus-one)\`
\` ()\`
\` > (untrace * -)\`
\` (- *)\`
\` > (square-minus-one 3)\`
\` 8\`

The first call to \`square-minus-one\` indicates there is an error, the second (traced) call indicates the step at which the error occurs, the third call demonstrates that the fix works, and the fourth call demonstrates that \`untrace\` does not wipe out the fix.
`
    },
    {
        name: "(utf-16-codec)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s9"),
        description: `**procedure**: \`(utf-16-codec)\`
**procedure**: \`(utf-16-codec \`*endianness*\`)\`
**procedure**: \`(utf-16le-codec)\`
**procedure**: \`(utf-16be-codec)\`
**returns: **a codec
**libraries: **\`(chezscheme)\`

*endianness* must be the symbol \`big\` or the symbol \`little\`.

The codec returned by \`utf-16-codec\` can be used to create and process data written UTF-16 format. When called without the *endianness* argument or with *endianness* \`big\`, \`utf-16-codec\` returns a codec for standard UTF-16 data, i.e., one that defaults to big-endian format if no byte-order mark (BOM) is found.

When output is transcoded with a transcoder based on this codec, a BOM is emitted just before the first character written, and each character is written as a UTF-16 character in big-endian format. For input, a BOM is looked for at the start of the input and, if present, controls the byte order of the remaining UTF-16 characters. If no BOM is present, big-endian order is assumed. For input-output ports, the BOM is not emitted if the file is read before written, and a BOM is not looked for if the file is written before read.

For textual ports created via \`transcoded-port\`, a BOM written or read via the transcoder appears at the beginning of the underlying data stream or file only if the binary port passed to \`transcoded-port\` is positioned at the start of the data stream or file. When the transcoder can determine this is the case, it sets a flag that causes \`set-port-position!\` to position the port beyond the BOM if an attempt is made to reposition the port to the start of the data stream or file, so that the BOM is preserved.

When called with *endianness* \`little\`, \`utf-16-codec\` returns a codec that defaults to the little-endian format both for reading and for writing. For output-only streams or input/output streams that are written before read, the result is standard UTF-16, with a BOM that specifies little-endian format followed by characters in little-endian byte order. For input-only streams or input/output streams that are read before written, this codec allows programs to read from input streams that either begin with a BOM or are encoded in UTF-16LE format. This is particularly useful for handling files that might have been produced by older Windows applications that claim to produce UTF-16 files but actually produce UTF-16LE files.

The Revised Report version of \`utf-16-codec\` lacks the optional *endianness* argument.

The codecs returned by \`utf-16le-codec\` and \`utf-16be-codec\` are used to read and write data in the UTF-16LE and UTF-16BE formats, i.e., UTF-16 with little-endian or big-endian byte order and no BOM. For output, these codecs are useful for controlling whether and where the BOM is emitted, since no BOM is emitted implicitly and a BOM can be emitted explicitly as an ordinary character. For input, these codecs are useful for processing files known to be in little-endian or big-endian format with no BOM.
`
    },
    {
        name: "(utf-16-codec ",
        endParen: true,
        params: ["endianness"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s9"),
        description: `**procedure**: \`(utf-16-codec)\`
**procedure**: \`(utf-16-codec \`*endianness*\`)\`
**procedure**: \`(utf-16le-codec)\`
**procedure**: \`(utf-16be-codec)\`
**returns: **a codec
**libraries: **\`(chezscheme)\`

*endianness* must be the symbol \`big\` or the symbol \`little\`.

The codec returned by \`utf-16-codec\` can be used to create and process data written UTF-16 format. When called without the *endianness* argument or with *endianness* \`big\`, \`utf-16-codec\` returns a codec for standard UTF-16 data, i.e., one that defaults to big-endian format if no byte-order mark (BOM) is found.

When output is transcoded with a transcoder based on this codec, a BOM is emitted just before the first character written, and each character is written as a UTF-16 character in big-endian format. For input, a BOM is looked for at the start of the input and, if present, controls the byte order of the remaining UTF-16 characters. If no BOM is present, big-endian order is assumed. For input-output ports, the BOM is not emitted if the file is read before written, and a BOM is not looked for if the file is written before read.

For textual ports created via \`transcoded-port\`, a BOM written or read via the transcoder appears at the beginning of the underlying data stream or file only if the binary port passed to \`transcoded-port\` is positioned at the start of the data stream or file. When the transcoder can determine this is the case, it sets a flag that causes \`set-port-position!\` to position the port beyond the BOM if an attempt is made to reposition the port to the start of the data stream or file, so that the BOM is preserved.

When called with *endianness* \`little\`, \`utf-16-codec\` returns a codec that defaults to the little-endian format both for reading and for writing. For output-only streams or input/output streams that are written before read, the result is standard UTF-16, with a BOM that specifies little-endian format followed by characters in little-endian byte order. For input-only streams or input/output streams that are read before written, this codec allows programs to read from input streams that either begin with a BOM or are encoded in UTF-16LE format. This is particularly useful for handling files that might have been produced by older Windows applications that claim to produce UTF-16 files but actually produce UTF-16LE files.

The Revised Report version of \`utf-16-codec\` lacks the optional *endianness* argument.

The codecs returned by \`utf-16le-codec\` and \`utf-16be-codec\` are used to read and write data in the UTF-16LE and UTF-16BE formats, i.e., UTF-16 with little-endian or big-endian byte order and no BOM. For output, these codecs are useful for controlling whether and where the BOM is emitted, since no BOM is emitted implicitly and a BOM can be emitted explicitly as an ordinary character. For input, these codecs are useful for processing files known to be in little-endian or big-endian format with no BOM.
`
    },
    {
        name: "(utf-16-codec)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s22"),
        description: `**procedure**: \`(latin-1-codec)\`
**returns: **a codec for ISO 8859-1 (Latin 1) character encodings
**procedure**: \`(utf-8-codec)\`
**returns: **a codec for Unicode UTF-8 character encodings
**procedure**: \`(utf-16-codec)\`
**returns: **a codec for Unicode UTF-16 character encodings
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(utf-16be-codec)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s9"),
        description: `**procedure**: \`(utf-16-codec)\`
**procedure**: \`(utf-16-codec \`*endianness*\`)\`
**procedure**: \`(utf-16le-codec)\`
**procedure**: \`(utf-16be-codec)\`
**returns: **a codec
**libraries: **\`(chezscheme)\`

*endianness* must be the symbol \`big\` or the symbol \`little\`.

The codec returned by \`utf-16-codec\` can be used to create and process data written UTF-16 format. When called without the *endianness* argument or with *endianness* \`big\`, \`utf-16-codec\` returns a codec for standard UTF-16 data, i.e., one that defaults to big-endian format if no byte-order mark (BOM) is found.

When output is transcoded with a transcoder based on this codec, a BOM is emitted just before the first character written, and each character is written as a UTF-16 character in big-endian format. For input, a BOM is looked for at the start of the input and, if present, controls the byte order of the remaining UTF-16 characters. If no BOM is present, big-endian order is assumed. For input-output ports, the BOM is not emitted if the file is read before written, and a BOM is not looked for if the file is written before read.

For textual ports created via \`transcoded-port\`, a BOM written or read via the transcoder appears at the beginning of the underlying data stream or file only if the binary port passed to \`transcoded-port\` is positioned at the start of the data stream or file. When the transcoder can determine this is the case, it sets a flag that causes \`set-port-position!\` to position the port beyond the BOM if an attempt is made to reposition the port to the start of the data stream or file, so that the BOM is preserved.

When called with *endianness* \`little\`, \`utf-16-codec\` returns a codec that defaults to the little-endian format both for reading and for writing. For output-only streams or input/output streams that are written before read, the result is standard UTF-16, with a BOM that specifies little-endian format followed by characters in little-endian byte order. For input-only streams or input/output streams that are read before written, this codec allows programs to read from input streams that either begin with a BOM or are encoded in UTF-16LE format. This is particularly useful for handling files that might have been produced by older Windows applications that claim to produce UTF-16 files but actually produce UTF-16LE files.

The Revised Report version of \`utf-16-codec\` lacks the optional *endianness* argument.

The codecs returned by \`utf-16le-codec\` and \`utf-16be-codec\` are used to read and write data in the UTF-16LE and UTF-16BE formats, i.e., UTF-16 with little-endian or big-endian byte order and no BOM. For output, these codecs are useful for controlling whether and where the BOM is emitted, since no BOM is emitted implicitly and a BOM can be emitted explicitly as an ordinary character. For input, these codecs are useful for processing files known to be in little-endian or big-endian format with no BOM.
`
    },
    {
        name: "(utf-16le-codec)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s9"),
        description: `**procedure**: \`(utf-16-codec)\`
**procedure**: \`(utf-16-codec \`*endianness*\`)\`
**procedure**: \`(utf-16le-codec)\`
**procedure**: \`(utf-16be-codec)\`
**returns: **a codec
**libraries: **\`(chezscheme)\`

*endianness* must be the symbol \`big\` or the symbol \`little\`.

The codec returned by \`utf-16-codec\` can be used to create and process data written UTF-16 format. When called without the *endianness* argument or with *endianness* \`big\`, \`utf-16-codec\` returns a codec for standard UTF-16 data, i.e., one that defaults to big-endian format if no byte-order mark (BOM) is found.

When output is transcoded with a transcoder based on this codec, a BOM is emitted just before the first character written, and each character is written as a UTF-16 character in big-endian format. For input, a BOM is looked for at the start of the input and, if present, controls the byte order of the remaining UTF-16 characters. If no BOM is present, big-endian order is assumed. For input-output ports, the BOM is not emitted if the file is read before written, and a BOM is not looked for if the file is written before read.

For textual ports created via \`transcoded-port\`, a BOM written or read via the transcoder appears at the beginning of the underlying data stream or file only if the binary port passed to \`transcoded-port\` is positioned at the start of the data stream or file. When the transcoder can determine this is the case, it sets a flag that causes \`set-port-position!\` to position the port beyond the BOM if an attempt is made to reposition the port to the start of the data stream or file, so that the BOM is preserved.

When called with *endianness* \`little\`, \`utf-16-codec\` returns a codec that defaults to the little-endian format both for reading and for writing. For output-only streams or input/output streams that are written before read, the result is standard UTF-16, with a BOM that specifies little-endian format followed by characters in little-endian byte order. For input-only streams or input/output streams that are read before written, this codec allows programs to read from input streams that either begin with a BOM or are encoded in UTF-16LE format. This is particularly useful for handling files that might have been produced by older Windows applications that claim to produce UTF-16 files but actually produce UTF-16LE files.

The Revised Report version of \`utf-16-codec\` lacks the optional *endianness* argument.

The codecs returned by \`utf-16le-codec\` and \`utf-16be-codec\` are used to read and write data in the UTF-16LE and UTF-16BE formats, i.e., UTF-16 with little-endian or big-endian byte order and no BOM. For output, these codecs are useful for controlling whether and where the BOM is emitted, since no BOM is emitted implicitly and a BOM can be emitted explicitly as an ordinary character. For input, these codecs are useful for processing files known to be in little-endian or big-endian format with no BOM.
`
    },
    {
        name: "(utf-8-codec)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s22"),
        description: `**procedure**: \`(latin-1-codec)\`
**returns: **a codec for ISO 8859-1 (Latin 1) character encodings
**procedure**: \`(utf-8-codec)\`
**returns: **a codec for Unicode UTF-8 character encodings
**procedure**: \`(utf-16-codec)\`
**returns: **a codec for Unicode UTF-16 character encodings
**libraries: **\`(rnrs io ports)\`, \`(rnrs)\`
`
    },
    {
        name: "(utf16->string ",
        endParen: true,
        params: ["bytevector", "endianness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s96"),
        description: `**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**returns: **a string containing the specified decoding of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. These procedures return a UTF-16 or UTF-32 decoding of *bytevector*, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If *endianness-mandatory?* is not provided or is \`#f\`, the endianness is determined by a BOM at the front of *bytevector* or, if no BOM is present, by *endianness*. If *endianness-mandatory?* is \`#t\`, the endianness is determined by *endianness*, and, if a BOM appears at the front of *bytevector*, it is treated as a regular character encoding.

The UTF-16 BOM is the two-byte sequence \`#xFE\`, \`#xFF\` specifying "big" or the two-byte sequence \`#xFF\`, \`#xFE\` specifying "little." The UTF-32 BOM is the four-byte sequence \`#x00\`, \`#x00\`, \`#xFE\`, \`#xFF\` specifying "big" or the four-byte sequence \`#xFF\`, \`#xFE\`, \`#x00\`, \`#x00\` specifying "little."

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(utf16->string ",
        endParen: true,
        params: ["bytevector", "endianness", "endianness-mandatory?"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s96"),
        description: `**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**returns: **a string containing the specified decoding of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. These procedures return a UTF-16 or UTF-32 decoding of *bytevector*, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If *endianness-mandatory?* is not provided or is \`#f\`, the endianness is determined by a BOM at the front of *bytevector* or, if no BOM is present, by *endianness*. If *endianness-mandatory?* is \`#t\`, the endianness is determined by *endianness*, and, if a BOM appears at the front of *bytevector*, it is treated as a regular character encoding.

The UTF-16 BOM is the two-byte sequence \`#xFE\`, \`#xFF\` specifying "big" or the two-byte sequence \`#xFF\`, \`#xFE\` specifying "little." The UTF-32 BOM is the four-byte sequence \`#x00\`, \`#x00\`, \`#xFE\`, \`#xFF\` specifying "big" or the four-byte sequence \`#xFF\`, \`#xFE\`, \`#x00\`, \`#x00\` specifying "little."

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(utf32->string ",
        endParen: true,
        params: ["bytevector", "endianness"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s96"),
        description: `**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**returns: **a string containing the specified decoding of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. These procedures return a UTF-16 or UTF-32 decoding of *bytevector*, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If *endianness-mandatory?* is not provided or is \`#f\`, the endianness is determined by a BOM at the front of *bytevector* or, if no BOM is present, by *endianness*. If *endianness-mandatory?* is \`#t\`, the endianness is determined by *endianness*, and, if a BOM appears at the front of *bytevector*, it is treated as a regular character encoding.

The UTF-16 BOM is the two-byte sequence \`#xFE\`, \`#xFF\` specifying "big" or the two-byte sequence \`#xFF\`, \`#xFE\` specifying "little." The UTF-32 BOM is the four-byte sequence \`#x00\`, \`#x00\`, \`#xFE\`, \`#xFF\` specifying "big" or the four-byte sequence \`#xFF\`, \`#xFE\`, \`#x00\`, \`#x00\` specifying "little."

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(utf32->string ",
        endParen: true,
        params: ["bytevector", "endianness", "endianness-mandatory?"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s96"),
        description: `**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf16->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\`)\`
**procedure**: \`(utf32->string \`*bytevector*\` \`*endianness*\` \`*endianness-mandatory?*\`)\`
**returns: **a string containing the specified decoding of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`

*endianness* must be one of the symbols \`big\` or \`little\`. These procedures return a UTF-16 or UTF-32 decoding of *bytevector*, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If *endianness-mandatory?* is not provided or is \`#f\`, the endianness is determined by a BOM at the front of *bytevector* or, if no BOM is present, by *endianness*. If *endianness-mandatory?* is \`#t\`, the endianness is determined by *endianness*, and, if a BOM appears at the front of *bytevector*, it is treated as a regular character encoding.

The UTF-16 BOM is the two-byte sequence \`#xFE\`, \`#xFF\` specifying "big" or the two-byte sequence \`#xFF\`, \`#xFE\` specifying "little." The UTF-32 BOM is the four-byte sequence \`#x00\`, \`#x00\`, \`#xFE\`, \`#xFF\` specifying "big" or the four-byte sequence \`#xFF\`, \`#xFE\`, \`#x00\`, \`#x00\` specifying "little."

R. Kent Dybvig /
Copyright © 2009 . Electronically reproduced by permission.
Illustrations © 2009
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
/
`
    },
    {
        name: "(utf8->string ",
        endParen: true,
        params: ["bytevector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s95"),
        description: `**procedure**: \`(utf8->string \`*bytevector*\`)\`
**returns: **a string containing the UTF-8 decoding of *bytevector*
**libraries: **\`(rnrs bytevectors)\`, \`(rnrs)\`
`
    },
    {
        name: "(values ",
        endParen: true,
        params: ["obj", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s70"),
        description: `**procedure**: \`(values \`*obj*\` ...)\`
**returns: ***obj*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The procedure \`values\` accepts any number of arguments and simply passes (returns) the arguments to its continuation.

\`(values) \`=>
\` \`
\` (values 1) \`=>\` 1 \`
\` \`
\` (values 1 2 3) \`=>\` 1\`
\`                \`\` 2\`
\`                \`\` 3 \`
\` \`
\` (define head&tail\`
\`   (lambda (ls)\`
\`     (values (car ls) (cdr ls)))) \`
\` \`
\` (head&tail '(a b c)) \`=>\` a\`
\`                      \`\` (b c)\`
`
    },
    {
        name: "variable",
        endParen: false,
        params: [""],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/binding.html#./binding:s2"),
        description: `**syntax**: *variable*
**returns: **the value of *variable*

Any identifier appearing as an expression in a program is a variable if a visible variable binding for the identifier exists, e.g., the identifier appears within the scope of a binding created by \`define\`, \`lambda\`, \`let\`, or some other variable-binding construct.

\`list \`=>\` #<procedure>\`
\` (define x 'a)\`
\` (list x x) \`=>\` (a a)\`
\` (let ([x 'b])\`
\`   (list x x)) \`=>\` (b b)\`
\` (let ([let 'let]) let) \`=>\` let\`

It is a syntax violation for an identifier reference to appear within a \`library\` form or top-level program if it is not bound as a variable, keyword, record name, or other entity. Since the scope of the definitions in a \`library\`, top-level program, \`lambda\`, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed. So, for example, the reference to \`g\` within the definition of \`f\` below

\`(define f\`
\`   (lambda (x)\`
\`     (g x)))\`
\` (define g\`
\`   (lambda (x)\`
\`     (+ x x)))\`

is okay, but the reference to \`g\` in the definition of \`q\` below is not.

\`(define q (g 3))\`
\` (define g\`
\`   (lambda (x)\`
\`     (+ x x)))\`
`
    },
    {
        name: "(vector ",
        endParen: true,
        params: ["obj", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s231"),
        description: `**procedure**: \`(vector \`*obj*\` ...)\`
**returns: **a vector of the objects *obj*\` ...\`
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (vector) \`=>\` #()\`
\` (vector 'a 'b 'c) \`=>\` #(a b c)\`
`
    },
    {
        name: "(vector->immutable-vector ",
        endParen: true,
        params: ["vector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s35"),
        description: `**procedure**: \`(vector->immutable-vector \`*vector*\`)\`
**returns: **an immutable vector equal to *vector*
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(vector->list ",
        endParen: true,
        params: ["vector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s237"),
        description: `**procedure**: \`(vector->list \`*vector*\`)\`
**returns: **a list of the elements of *vector*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`vector->list\` provides a convenient method for applying list-processing operations to vectors. It may be defined without error checks as follows.

\`(define vector->list\`
\`   (lambda (s)\`
\`     (do ([i (- (vector-length s) 1) (- i 1)]\`
\`          [ls '() (cons (vector-ref s i) ls)])\`
\`         ((< i 0) ls)))) \`
\` \`
\` (vector->list (vector)) \`=>\` ()\`
\` (vector->list '#(a b c)) \`=>\` (a b c) \`
\` \`
\` (let ((v '#(1 2 3 4 5)))\`
\`   (apply * (vector->list v))) \`=>\` 120\`
`
    },
    {
        name: "(vector-cas! ",
        endParen: true,
        params: ["vector", "n", "old-obj", "new-obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s33"),
        description: `**procedure**: \`(vector-cas! \`*vector*\` \`*n*\` \`*old-obj*\` \`*new-obj*\`)\`
**returns: **\`#t\` if *vector* is changed, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

*vector* must be mutable. \`vector-cas!\` atomically changes the *n*th element of *vector* to *new-obj* if the replaced *n*th element is \`eq?\` to *old-obj*. If the *n*th element of *vector* that would be replaced is not \`eq?\` to *old-obj*, then *vector* is unchanged.

\`(define v (vector 'old0 'old1 'old2))\`
\` (vector-cas! v 1 'old1 'new1) \`=>\` #t\`
\` (vector-ref v 1) \`=>\` 'new1\`
\` (vector-cas! v 2 'old1 'new2) \`=>\` #f\`
\` (vector-ref v 2) \`=>\` 'old2\`
`
    },
    {
        name: "(vector-copy ",
        endParen: true,
        params: ["vector"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s31"),
        description: `**procedure**: \`(vector-copy \`*vector*\`)\`
**returns: **a copy of *vector*
**libraries: **\`(chezscheme)\`

\`vector-copy\` creates a new vector of the same length and contents as *vector*. The elements themselves are not copied.

\`(vector-copy '#(a b c)) \`=>\` #(a b c) \`
\` \`
\` (let ([v '#(a b c)])\`
\`   (eq? v (vector-copy v))) \`=>\` #f\`
`
    },
    {
        name: "(vector-fill! ",
        endParen: true,
        params: ["vector", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s236"),
        description: `**procedure**: \`(vector-fill! \`*vector*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`vector-fill!\` replaces each element of *vector* with *obj*. It may be defined without error checks as follows.

\`(define vector-fill!\`
\`   (lambda (v x)\`
\`     (let ([n (vector-length v)])\`
\`       (do ([i 0 (+ i 1)])\`
\`           ((= i n))\`
\`         (vector-set! v i x))))) \`
\` \`
\` (let ([v (vector 1 2 3)])\`
\`   (vector-fill! v 0)\`
\`   v) \`=>\` #(0 0 0)\`
`
    },
    {
        name: "(vector-for-each ",
        endParen: true,
        params: ["procedure", "vector1", "vector2", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s47"),
        description: `**procedure**: \`(vector-for-each \`*procedure*\` \`*vector1*\` \`*vector2*\` ...)\`
**returns: **unspecified
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(vector-length ",
        endParen: true,
        params: ["vector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s233"),
        description: `**procedure**: \`(vector-length \`*vector*\`)\`
**returns: **the number of elements in *vector*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

The length of a vector is always an exact nonnegative integer.

\`(vector-length '#()) \`=>\` 0\`
\` (vector-length '#(a b c)) \`=>\` 3\`
\` (vector-length (vector 1 '(2) 3 '#(4 5))) \`=>\` 4\`
\` (vector-length (make-vector 300)) \`=>\` 300\`
`
    },
    {
        name: "(vector-map ",
        endParen: true,
        params: ["procedure", "vector1", "vector1", "..."],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s44"),
        description: `**procedure**: \`(vector-map \`*procedure*\` \`*vector1*\` \`*vector1*\` ...)\`
**returns: **vector of results
**libraries: **\`(rnrs base)\`, \`(rnrs)\`
`
    },
    {
        name: "(vector-ref ",
        endParen: true,
        params: ["vector", "n"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s234"),
        description: `**procedure**: \`(vector-ref \`*vector*\` \`*n*\`)\`
**returns: **the *n*th element (zero-based) of *vector*
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *vector*.

\`(vector-ref '#(a b c) 0) \`=>\` a\`
\` (vector-ref '#(a b c) 1) \`=>\` b\`
\` (vector-ref '#(x y z w) 3) \`=>\` w\`
`
    },
    {
        name: "(vector-set! ",
        endParen: true,
        params: ["vector", "n", "obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s235"),
        description: `**procedure**: \`(vector-set! \`*vector*\` \`*n*\` \`*obj*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

*n* must be an exact nonnegative integer less than the length of *vector*. \`vector-set!\` changes the *n*th element of *vector* to *obj*.

\`(let ([v (vector 'a 'b 'c 'd 'e)])\`
\`   (vector-set! v 2 'x)\`
\`   v) \`=>\` #(a b x d e)\`
`
    },
    {
        name: "(vector-set-fixnum! ",
        endParen: true,
        params: ["vector", "n", "fixnum"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s32"),
        description: `**procedure**: \`(vector-set-fixnum! \`*vector*\` \`*n*\` \`*fixnum*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*vector* must be mutable. \`vector-set-fixnum!\` changes the *n*th element of *vector* to *fixnum*. *n* must be an exact nonnegative integer strictly less than the length of *vector*.

It is faster to store a fixnum than an arbitrary value, since for arbitrary values, the system has to record potential assignments from older to younger objects to support generational garbage collection. Care must be taken to ensure that the argument is indeed a fixnum, however; otherwise, the collector may not properly track the assignment. The primitive performs a fixnum check on the argument except at optimization level 3.

See also the description of fixnum-only vectors (fxvectors) below.

\`(let ([v (vector 1 2 3 4 5)])\`
\`   (vector-set-fixnum! v 2 73)\`
\`   v) \`=>\` #(1 2 73 4 5)\`
`
    },
    {
        name: "(vector-sort ",
        endParen: true,
        params: ["predicate", "vector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s239"),
        description: `**procedure**: \`(vector-sort \`*predicate*\` \`*vector*\`)\`
**returns: **a vector containing the elements of *vector*, sorted according to *predicate*
**procedure**: \`(vector-sort! \`*predicate*\` \`*vector*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs sorting)\`, \`(rnrs)\`

*predicate* should be a procedure that expects two arguments and returns \`#t\` if its first argument must precede its second in the sorted vector. That is, if *predicate* is applied to two elements *x* and *y*, where *x* appears after *y* in the input vector, the predicate should return true only if *x* should appear before *y* in the output vector. If this constraint is met, \`vector-sort\` performs a stable sort, i.e., two elements are reordered only when necessary according to *predicate*. \`vector-sort!\` performs the sort destructively and does not necessarily perform a stable sort. Duplicate elements are not removed. *predicate* should not have any side effects.

\`vector-sort\` may call *predicate* up to log times, where is the length of *vector*, while \`vector-sort!\` may call the predicate up to times. The looser bound for \`vector-sort!\` allows an implementation to use a quicksort algorithm, which may be faster in some cases than algorithms that have the tighter log bound.

\`(vector-sort < '#(3 4 2 1 2 5)) \`=>\` #(1 2 2 3 4 5)\`
\` (vector-sort > '#(0.5 1/2)) \`=>\` #(0.5 1/2)\`
\` (vector-sort > '#(1/2 0.5)) \`=>\` #(1/2 0.5) \`
\` \`
\` (let ([v (vector 3 4 2 1 2 5)])\`
\`   (vector-sort! < v)\`
\`   v) \`=>\` #(1 2 2 3 4 5)\`
`
    },
    {
        name: "(vector-sort! ",
        endParen: true,
        params: ["predicate", "vector"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s239"),
        description: `**procedure**: \`(vector-sort \`*predicate*\` \`*vector*\`)\`
**returns: **a vector containing the elements of *vector*, sorted according to *predicate*
**procedure**: \`(vector-sort! \`*predicate*\` \`*vector*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs sorting)\`, \`(rnrs)\`

*predicate* should be a procedure that expects two arguments and returns \`#t\` if its first argument must precede its second in the sorted vector. That is, if *predicate* is applied to two elements *x* and *y*, where *x* appears after *y* in the input vector, the predicate should return true only if *x* should appear before *y* in the output vector. If this constraint is met, \`vector-sort\` performs a stable sort, i.e., two elements are reordered only when necessary according to *predicate*. \`vector-sort!\` performs the sort destructively and does not necessarily perform a stable sort. Duplicate elements are not removed. *predicate* should not have any side effects.

\`vector-sort\` may call *predicate* up to log times, where is the length of *vector*, while \`vector-sort!\` may call the predicate up to times. The looser bound for \`vector-sort!\` allows an implementation to use a quicksort algorithm, which may be faster in some cases than algorithms that have the tighter log bound.

\`(vector-sort < '#(3 4 2 1 2 5)) \`=>\` #(1 2 2 3 4 5)\`
\` (vector-sort > '#(0.5 1/2)) \`=>\` #(0.5 1/2)\`
\` (vector-sort > '#(1/2 0.5)) \`=>\` #(1/2 0.5) \`
\` \`
\` (let ([v (vector 3 4 2 1 2 5)])\`
\`   (vector-sort! < v)\`
\`   v) \`=>\` #(1 2 2 3 4 5)\`
`
    },
    {
        name: "(vector? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s21"),
        description: `**procedure**: \`(vector? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a vector, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\` (vector? '#()) \`=>\` #t\`
\` (vector? '#(a b c)) \`=>\` #t\`
\` (vector? (vector 'a 'b 'c)) \`=>\` #t\`
\` (vector? '()) \`=>\` #f\`
\` (vector? '(a b c)) \`=>\` #f\`
\` (vector? "abc") \`=>\` #f\`
`
    },
    {
        name: "(verify-loadability ",
        endParen: true,
        params: ["situation", "input", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s50"),
        description: `**procedure**: \`(verify-loadability \`*situation*\` \`*input*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(violation? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s20"),
        description: `**syntax**: \`&violation\`
**procedure**: \`(make-violation)\`
**returns: **a condition of type \`&violation\`
**procedure**: \`(violation? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&violation\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type indicate that the program has violated some requirement, usually due to a bug in the program. This condition type might be defined as follows.

\`(define-condition-type &violation &serious\`
\`   make-violation violation?)\`
`
    },
    {
        name: "(virtual-register ",
        endParen: true,
        params: ["k"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s253"),
        description: `**procedure**: \`(virtual-register \`*k*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

\`virtual-register\` returns the value most recently stored in virtual register *k* (on the current thread, in threaded versions of the system).
`
    },
    {
        name: "(virtual-register-count)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s251"),
        description: `**procedure**: \`(virtual-register-count)\`
**returns: **the number of virtual registers
**libraries: **\`(chezscheme)\`

As of Version 9.0, the number of virtual registers is set at 16. It cannot be changed except by recompiling from source.
`
    },
    {
        name: "(visit ",
        endParen: true,
        params: ["path"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s59"),
        description: `**procedure**: \`(visit \`*path*\`)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

*path* must be a string. \`visit\` reads the named file, which must contain compiled object code compatible with the current machine type and version, and it runs those portions of the compiled object code that establish compile-time information or correspond to expressions identified as "visit" time by \`eval-when\` forms contained in the original source file.

For example, assume the file \`t1.ss\` contains the following forms:

\`(define-syntax a (identifier-syntax 3))\`
\` (module m (x) (define x 4))\`
\` (define y 5)\`

If \`t1.ss\` is compiled to \`t1.so\`, applying \`load\` to \`t1.so\` has the effect of defining all three identifiers. Applying \`visit\` to \`t1.so\`, however, has the effect of installing the transformer for \`a\`, installing the interface for \`m\` (for use by \`import\`), and recording \`y\` as a variable. \`visit\` is useful when separately compiling one file that depends on bindings defined in another without actually loading and evaluating the code in the supporting file.
`
    },
    {
        name: "(visit-compiled-from-port ",
        endParen: true,
        params: ["input-port"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s57"),
        description: `**procedure**: \`(visit-compiled-from-port \`*input-port*\`)\`
**returns: **result of the last compiled expression processed
**libraries: **\`(chezscheme)\`

\`visit-compiled-from-port\` reads and evaluates the object-code contents of *input-port* as previously created by functions like \`compile-file\`, \`compile-script\`, \`compile-library\`, and \`compile-to-port\`. In the process, it skips any revisit (run-time-only) code.

The return value is the value of the last expression whose last non-revisit compiled form is in *input-port*. If there are no such forms, then the result value is unspecified. The port is left at end-of-file but is not closed.
`
    },
    {
        name: "(void)",
        endParen: false,
        params: [""],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s113"),
        description: `**procedure**: \`(void)\`
**returns: **the void object
**libraries: **\`(chezscheme)\`

\`void\` is a procedure of no arguments that returns the void object. It can be used to force expressions that are used for effect or whose values are otherwise unspecified to evaluate to a consistent, trivial value. Since most operations that are used for effect return the void object, however, it is rarely necessary to explicitly invoke the \`void\` procedure.

Since the void object is used explicitly as an "unspecified" value, it is a bad idea to use it for any other purpose or to count on any given expression evaluating to the void object.

The default waiter printer suppresses the void object; that is, nothing is printed for expressions that evaluate to the void object.

\`(eq? (void) #f) \`=>\` #f\`
\` (eq? (void) #t) \`=>\` #f\`
\` (eq? (void) '()) \`=>\` #f\`
`
    },
    {
        name: "waiter-prompt-and-read",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s175"),
        description: `**thread parameter**: \`waiter-prompt-and-read\`
**libraries: **\`(chezscheme)\`

\`waiter-prompt-and-read\` must be set to a procedure. It is used by the waiter to print a prompt and read an expression. The value of \`waiter-prompt-and-read\` is called by the waiter with a positive integer that indicates the café nesting level. It should return an expression to be evaluated by the current evaluator (see \`new-cafe\` and \`current-eval\`).
`
    },
    {
        name: "waiter-prompt-string",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s174"),
        description: `**thread parameter**: \`waiter-prompt-string\`
**libraries: **\`(chezscheme)\`

The value of \`waiter-prompt-string\` must be a string. It is used by the default waiter prompter (see the parameter \`waiter-prompt-and-read\`) to print a prompt. Nested cafés are marked by repeating the prompt string once for each nesting level.

\`> (waiter-prompt-string)\`
\` ">"\`
\` > (waiter-prompt-string "%")\`
\` % (waiter-prompt-string)\`
\` "%"\`
\` % (new-cafe)\`
\` %% (waiter-prompt-string)\`
\` "%"\`
`
    },
    {
        name: "waiter-write",
        endParen: false,
        params: [""],
        type: "thread parameter",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s177"),
        description: `**thread parameter**: \`waiter-write\`
**libraries: **\`(chezscheme)\`

The value of \`waiter-write\` must be a procedure. The waiter uses the value of \`waiter-write\` to print the results of each expression read and evaluated by the waiter. The following example installs a procedure equivalent to the default \`waiter-write\`:

\`(waiter-write\`
\`   (lambda (x)\`
\`     (unless (eq? x (void))\`
\`       (pretty-print x (console-output-port)))\`
\`     (flush-output-port (console-output-port))))\`
`
    },
    {
        name: "(warning ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s1"),
        description: `**procedure**: \`(warning \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`

\`warning\` raises a continuable exception with condition type \`&warning\` and should be used to describe situations for which the \`&warning\` condition type is appropriate, typically a situation that should not prevent the program from continuing but might result in a more serious problem at some later point.

The continuation object with which the exception is raised also includes a \`&who\` condition whose who field is *who* if *who* is not \`#f\`, a \`&message\` condition whose message field is *msg*, and an \`&irritants\` condition whose irritants field is \`(\`*irritant*\` ...)\`.

*who* must be a string, a symbol, or \`#f\` identifying the procedure or syntactic form reporting the warning. It is usually best to identify a procedure the programmer has called rather than some other procedure the programmer may not be aware is involved in carrying out the operation. *msg* must be a string and should describe the exceptional situation. The irritants may be any Scheme objects and should include values that may have caused or been materially involved in the exceptional situation.
`
    },
    {
        name: "(warning? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s23"),
        description: `**syntax**: \`&warning\`
**procedure**: \`(make-warning)\`
**returns: **a condition of type \`&warning\`
**procedure**: \`(warning? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&warning\`, \`#f\` otherwise
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Warning conditions indicate situations that do not prevent the program from continuing its execution but, in some cases, might result in a more serious problem at some later point. For example, a compiler might use a condition of this type to indicate that it has processed a call to a standard procedure with the wrong number of arguments; this will not become a serious problem unless the call is actually evaluated at some later point. This condition type might be defined as follows.

\`(define-condition-type &warning &condition\`
\`   make-warning warning?)\`
`
    },
    {
        name: "(warningf ",
        endParen: true,
        params: ["who", "msg", "irritant", "..."],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s2"),
        description: `**procedure**: \`(assertion-violationf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **does not return
**procedure**: \`(errorf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **does not return
**procedure**: \`(warningf \`*who*\` \`*msg*\` \`*irritant*\` ...)\`
**returns: **unspecified
**libraries: **\`(chezscheme)\`
`
    },
    {
        name: "(weak-cons ",
        endParen: true,
        params: ["obj1", "obj2"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s24"),
        description: `**procedure**: \`(weak-cons \`*obj1*\` \`*obj2*\`)\`
**returns: **a new weak pair
**libraries: **\`(chezscheme)\`

*obj1* becomes the car and *obj2* becomes the cdr of the new pair. Weak pairs are indistinguishable from ordinary pairs in all but two ways:

The weak pointer in the car of a weak pair is just like a normal pointer as long as the object to which it points is accessible through a normal (nonweak) pointer somewhere in the system. If at some point the garbage collector recognizes that there are no nonweak pointers to the object, however, it replaces each weak pointer to the object with the "broken weak-pointer" object, \`#!bwp\`, and discards the object.

The cdr field of a weak pair is a weak pointer, so weak pairs may be used to form lists of weakly held objects. These lists may be manipulated using ordinary list-processing operations such as \`length\`, \`map\`, and \`assv\`. (Procedures like \`map\` that produce list structure always produce lists formed from nonweak pairs, however, even when their input lists are formed from weak pairs.) Weak pairs may be altered using \`set-car!\` and \`set-cdr!\`; after a \`set-car!\` the car field contains a weak pointer to the new object in place of the old object. Weak pairs are especially useful for building association pairs in association lists or hash tables.

Weak pairs are printed in the same manner as ordinary pairs; there is no reader syntax for weak pairs. As a result, weak pairs become normal pairs when they are written and then read.

\`(define x (cons 'a 'b))\`
\` (define p (weak-cons x '()))\`
\` (car p) \`=>\` (a . b) \`
\` \`
\` (define x (cons 'a 'b))\`
\` (define p (weak-cons x '()))\`
\` (set! x '*)\`
\` (collect)\`
\` (car p) \`=>\` #!bwp\`

The latter example above may in fact return \`(a . b)\` if a garbage collection promoting the pair into an older generation occurs prior to the assignment of \`x\` to \`*\`. It may be necessary to force an older generation collection to allow the object to be reclaimed. The storage management system guarantees only that the object will be reclaimed eventually once all nonweak pointers to it are dropped, but makes no guarantees about when this will occur.
`
    },
    {
        name: "(weak-pair? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s25"),
        description: `**procedure**: \`(weak-pair? \`*obj*\`)\`
**returns: **\`#t\` if obj is a weak pair, \`#f\` otherwise
**libraries: **\`(chezscheme)\`

\`(weak-pair? (weak-cons 'a 'b)) \`=>\` #t\`
\` (weak-pair? (cons 'a 'b)) \`=>\` #f\`
\` (weak-pair? "oops") \`=>\` #f\`
`
    },
    {
        name: "(when ",
        endParen: true,
        params: ["test-expr", "expr1", "expr2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/control.html#./control:s17"),
        description: `**syntax**: \`(when \`*test-expr*\` \`*expr1*\` \`*expr2*\` ...)\`
**syntax**: \`(unless \`*test-expr*\` \`*expr1*\` \`*expr2*\` ...)\`
**returns: **see below
**libraries: **\`(rnrs control)\`, \`(rnrs)\`

For \`when\`, if *test-expr* evaluates to a true value, the expressions *expr1*\` \`*expr2*\` ...\` are evaluated in sequence, and the values of the last expression are returned. If *test-expr* evaluates to false, none of the other expressions are evaluated, and the value or values of \`when\` are unspecified.

For \`unless\`, if *test-expr* evaluates to false, the expressions *expr1*\` \`*expr2*\` ...\` are evaluated in sequence, and the values of the last expression are returned. If *test-expr* evaluates to a true value, none of the other expressions are evaluated, and the value or values of \`unless\` are unspecified.

A \`when\` or \`unless\` expression is usually clearer than the corresponding "one-armed" \`if\` expression.

\`(let ([x -4] [sign 'plus])\`
\`   (when (< x 0)\`
\`     (set! x (- 0 x))\`
\`     (set! sign 'minus))\`
\`   (list sign x)) \`=>\` (minus 4) \`
\` \`
\` (define check-pair\`
\`   (lambda (x)\`
\`     (unless (pair? x)\`
\`       (syntax-violation 'check-pair "invalid argument" x))\`
\`     x)) \`
\` \`
\` (check-pair '(a b c)) \`=>\` (a b c)\`

\`when\` may be defined as follows:

\`(define-syntax when\`
\`   (syntax-rules ()\`
\`     [(_ e0 e1 e2 ...)\`
\`      (if e0 (begin e1 e2 ...))]))\`

\`unless\` may be defined as follows:

\`(define-syntax unless\`
\`   (syntax-rules ()\`
\`     [(_ e0 e1 e2 ...)\`
\`      (if (not e0) (begin e1 e2 ...))]))\`

or in terms of \`when\` as follows:

\`(define-syntax unless\`
\`   (syntax-rules ()\`
\`     [(_ e0 e1 e2 ...)\`
\`      (when (not e0) e1 e2 ...)]))\`
`
    },
    {
        name: "(who-condition? ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s26"),
        description: `**syntax**: \`&who\`
**procedure**: \`(make-who-condition \`*who*\`)\`
**returns: **a condition of type \`&who\`
**procedure**: \`(who-condition? \`*obj*\`)\`
**returns: **\`#t\` if *obj* is a condition of type \`&who\`, \`#f\` otherwise
**procedure**: \`(condition-who \`*condition*\`)\`
**returns: **the contents of *condition*'s \`who\` field
**libraries: **\`(rnrs conditions)\`, \`(rnrs)\`

Conditions of this type are often included with a \`&message\` condition to identify the syntactic form or procedure that detected the error. The *who* argument to the constructor should be a symbol or string. This condition type might be defined as follows.

\`(define-condition-type &who &condition\`
\`   make-who-condition who-condition?\`
\`   (who condition-who))\`
`
    },
    {
        name: "(with ((",
        endParen: true,
        params: ["pat", "expr", "template"],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/compat.html#./compat:s20"),
        description: `**syntax**: \`(with ((\`*pat*\` \`*expr*\`) ...) \`*template*\`)\`
**returns: **processed *template*

\`with\` is valid only within an template inside of \`extend-syntax\`. \`with\` patterns are the same as \`extend-syntax\` patterns, \`with\` expressions are the same as \`extend-syntax\` fenders, and \`with\` templates are the same as \`extend-syntax\` templates.

\`with\` can be used to introduce new pattern identifiers bound to expressions produced by arbitrary Scheme expressions within \`extend-syntax\` templates. That is, \`with\` allows an escape from the declarative style of \`extend-syntax\` into the procedural style of full Scheme.

One common use of \`with\` is the introduction of a temporary identifier or list of temporary identifiers into a template. \`with\` is also used to perform complex transformations that might be clumsy or inefficient if performed within the \`extend-syntax\` framework.

For example, \`or\` requires the use of a temporary identifier. We could define \`or\` as follows.

\`(extend-syntax (or)\`
\`   [(or) #f]\`
\`   [(or x) x]\`
\`   [(or x y ...)\`
\`    (let ([temp x])\`
\`      (if temp temp (or y ...)))])\`

This would work until we placed an \`or\` expression within the scope of an occurrence of \`temp\`, in which case strange things could happen, since \`extend-syntax\` does not respect lexical scoping. (This is one of the reasons that \`define-syntax\` is preferable to \`extend-syntax\`.)

\`(let ([temp #t])\`
\`   (or #f temp)) \`=>\` #f\`
`
    },
    {
        name: "(with-cost-center ",
        endParen: true,
        params: ["cost-center", "thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s243"),
        description: `**procedure**: \`(with-cost-center \`*cost-center*\` \`*thunk*\`)\`
**procedure**: \`(with-cost-center \`*timed?*\` \`*cost-center*\` \`*thunk*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure that accepts zero arguments. \`with-cost-center\` invokes *thunk* without arguments and returns its values. It also tracks, dynamically, the bytes allocated, instructions executed, and cpu time elapsed while evaluating the invocation of *thunk* and adds the tracked costs to the cost center's running record of these costs.

As described above, allocation counts are tracked only for code compiled with the parameter \`generate-allocation-counts\` set to true, and instruction counts are tracked only for code compiled with \`generate-instruction-counts\` set to true. Cpu time is tracked only if *timed?* is provided and not false and includes cpu time spent in instrumented, uninstrumented, and non-Scheme code.
`
    },
    {
        name: "(with-cost-center ",
        endParen: true,
        params: ["timed?", "cost-center", "thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s243"),
        description: `**procedure**: \`(with-cost-center \`*cost-center*\` \`*thunk*\`)\`
**procedure**: \`(with-cost-center \`*timed?*\` \`*cost-center*\` \`*thunk*\`)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure that accepts zero arguments. \`with-cost-center\` invokes *thunk* without arguments and returns its values. It also tracks, dynamically, the bytes allocated, instructions executed, and cpu time elapsed while evaluating the invocation of *thunk* and adds the tracked costs to the cost center's running record of these costs.

As described above, allocation counts are tracked only for code compiled with the parameter \`generate-allocation-counts\` set to true, and instruction counts are tracked only for code compiled with \`generate-instruction-counts\` set to true. Cpu time is tracked only if *timed?* is provided and not false and includes cpu time spent in instrumented, uninstrumented, and non-Scheme code.
`
    },
    {
        name: "(with-exception-handler ",
        endParen: true,
        params: ["procedure", "thunk"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/exceptions.html#./exceptions:s7"),
        description: `**procedure**: \`(with-exception-handler \`*procedure*\` \`*thunk*\`)\`
**returns: **see below
**libraries: **\`(rnrs exceptions)\`, \`(rnrs)\`

This procedure establishes *procedure*, which should accept one argument, as the current exception handler in place of the old current exception handler, *old-proc*, and invokes *thunk* without arguments. If the call to *thunk* returns, *old-proc* is reestablished as the current exception handler and the values returned by *thunk* are returned. If control leaves or subsequently reenters the call to *thunk* via the invocation of a continuation obtained via \`call/cc\`, the procedure that was the current exception handler when the continuation was captured is reinstated.

\`(define (try thunk)\`
\`   (call/cc\`
\`     (lambda (k)\`
\`       (with-exception-handler\`
\`         (lambda (x) (if (error? x) (k #f) (raise x)))\`
\`         thunk))))\`
\` (try (lambda () 17)) \`=>\` 17\`
\` (try (lambda () (raise (make-error)))) \`=>\` #f\`
\` (try (lambda () (raise (make-violation)))) \`=>\` \`*violation*
\` (with-exception-handler\`
\`   (lambda (x)\`
\`     (raise\`
\`       (apply condition\`
\`         (make-message-condition "oops")\`
\`         (simple-conditions x))))\`
\`   (lambda ()\`
\`     (try (lambda () (raise (make-violation)))))) \`=>\` \`*violation: oops*
`
    },
    {
        name: "(with-implicit (",
        endParen: true,
        params: ["id0", "id1", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:s11"),
        description: `**syntax**: \`(with-implicit (\`*id0*\` \`*id1*\` ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **see below
**libraries: **\`(chezscheme)\`

This form abstracts over the common usage of \`datum->syntax\` for creating implicit identifiers (see above). The form

\`(with-implicit (\`*id0*\` \`*id1*\` ...)\`
\`   \`*body1*\` \`*body2*\` ...)\`

is equivalent to

\`(with-syntax ([\`*id1*\` (datum->syntax #'\`*id0*\` '\`*id1*\`)] ...)\`
\`   \`*body1*\` \`*body2*\` ...)\`

\`with-implicit\` can be defined simply as follows.

\`(define-syntax with-implicit\`
\`   (syntax-rules ()\`
\`     [(_ (tid id ...) b1 b2 ...)\`
\`      (with-syntax ([id (datum->syntax #'tid 'id)] ...)\`
\`        b1 b2 ...)]))\`

We can use \`with-implicit\` to simplify the (correct version of) \`loop\` above.

\`(define-syntax loop\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(k e ...)\`
\`        (with-implicit (k break)\`
\`          #'(call-with-current-continuation\`
\`              (lambda (break)\`
\`                (let f () e ... (f)))))])))\`
`
    },
    {
        name: "(with-input-from-file ",
        endParen: true,
        params: ["path", "thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s59"),
        description: `**procedure**: \`(with-input-from-file \`*path*\` \`*thunk*\`)\`
**procedure**: \`(with-input-from-file \`*path*\` \`*thunk*\` \`*options*\`)\`
**returns: **the values returned by *thunk*
**libraries: **\`(chezscheme)\`

*path* must be a string. *thunk* must be a procedure and should accept zero arguments.

\`with-input-from-file\` temporarily changes the current input port to be the result of opening the file named by *path*, as if with \`open-input-file\`, during the application of *thunk*. If *thunk* returns, the port is closed and the current input port is restored to its old value.

The behavior of \`with-input-from-file\` is unspecified if a continuation created outside of *thunk* is invoked before *thunk* returns. An implementation may close the port and restore the current input port to its old value---but it may not.

See \`open-input-file\` above for a description of the optional *options* argument.

The Revised Report version of \`with-input-from-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(with-input-from-file ",
        endParen: true,
        params: ["path", "thunk", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s59"),
        description: `**procedure**: \`(with-input-from-file \`*path*\` \`*thunk*\`)\`
**procedure**: \`(with-input-from-file \`*path*\` \`*thunk*\` \`*options*\`)\`
**returns: **the values returned by *thunk*
**libraries: **\`(chezscheme)\`

*path* must be a string. *thunk* must be a procedure and should accept zero arguments.

\`with-input-from-file\` temporarily changes the current input port to be the result of opening the file named by *path*, as if with \`open-input-file\`, during the application of *thunk*. If *thunk* returns, the port is closed and the current input port is restored to its old value.

The behavior of \`with-input-from-file\` is unspecified if a continuation created outside of *thunk* is invoked before *thunk* returns. An implementation may close the port and restore the current input port to its old value---but it may not.

See \`open-input-file\` above for a description of the optional *options* argument.

The Revised Report version of \`with-input-from-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(with-input-from-file ",
        endParen: true,
        params: ["path", "thunk"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s79"),
        description: `**procedure**: \`(with-input-from-file \`*path*\` \`*thunk*\`)\`
**returns: **the values returned by *thunk*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. *thunk* must be a procedure and should accept zero arguments.

\`with-input-from-file\` temporarily changes the current input port to be the result of opening the file named by *path*, as if with \`open-input-file\`, during the application of *thunk*. If *thunk* returns, the port is closed and the current input port is restored to its old value.

The behavior of \`with-input-from-file\` is unspecified if a continuation created outside of *thunk* is invoked before *thunk* returns. An implementation may close the port and restore the current input port to its old value---but it may not.
`
    },
    {
        name: "(with-input-from-string ",
        endParen: true,
        params: ["string", "thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s46"),
        description: `**procedure**: \`(with-input-from-string \`*string*\` \`*thunk*\`)\`
**returns: **the values returned by *thunk*
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure and should accept zero arguments. \`with-input-from-string\` parameterizes the current input port to be the result of opening *string* for input during the application of *thunk*.

\`(with-input-from-string "(cons 3 4)"\`
\`   (lambda ()\`
\`     (eval (read)))) \`=>\` (3 . 4)\`
`
    },
    {
        name: "(with-interrupts-disabled ",
        endParen: true,
        params: ["body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s27"),
        description: `**syntax**: \`(with-interrupts-disabled \`*body1*\` \`*body2*\` ...)\`
**syntax**: \`(critical-section \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the body *body1*\` \`*body2*\` ...\`
**libraries: **\`(chezscheme)\`

\`with-interrupts-disabled\` evaluates the body *body1*\` \`*body2*\` ...\` with interrupts disabled. That is, upon entry, interrupts are disabled, and upon exit, interrupts are re-enabled. Thus, \`with-interrupts-disabled\` allows the implementation of indivisible operations in nonthreaded versions of or within a single thread in threaded versions of . \`critical-section\` is the same as \`with-interrupts-disabled\` and is provided for backward compatibility.

\`with-interrupts-disabled\` can be defined as follows.

\`(define-syntax with-interrupts-disabled\`
\`   (syntax-rules ()\`
\`     [(_ b1 b2 ...)\`
\`      (dynamic-wind\`
\`        disable-interrupts\`
\`        (lambda () b1 b2 ...)\`
\`        enable-interrupts)]))\`

The use of \`dynamic-wind\` ensures that interrupts are disabled whenever the body of the \`with-interrupts-disabled\` expression is active and re-enabled whenever it is not. Since calls to \`disable-interrupts\` are counted (see the discussion under \`disable-interrupts\` and \`enable-interrupts\` above), \`with-interrupts-disabled\` expressions may be nested with the desired effect.
`
    },
    {
        name: "(with-mutex ",
        endParen: true,
        params: ["mutex", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/threads.html#./threads:s10"),
        description: `**syntax**: \`(with-mutex \`*mutex*\` \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the body *body1*\` \`*body2*\` ...\`
**libraries: **\`(chezscheme)\`

\`with-mutex\` evaluates the expression *mutex*, which must evaluate to a mutex, acquires the mutex, evaluates the body *body1*\` \`*body2*\` ...\`, and releases the mutex. The mutex is released whether the body returns normally or via a control operation (that is, throw to a continuation, perhaps because of an error) that results in a nonlocal exit from the \`with-mutex\` form. If control subsequently returns to the body via a continuation invocation, the mutex is reacquired.

Using \`with-mutex\` is generally more convenient and safer than using \`mutex-acquire\` and \`mutex-release\` directly.
`
    },
    {
        name: "(with-output-to-file ",
        endParen: true,
        params: ["path", "thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s79"),
        description: `**procedure**: \`(with-output-to-file \`*path*\` \`*thunk*\`)\`
**procedure**: \`(with-output-to-file \`*path*\` \`*thunk*\` \`*options*\`)\`
**returns: **the value returned by *thunk*
**libraries: **\`(chezscheme)\`

*path* must be a string. *thunk* must be a procedure and should accept zero arguments.

\`with-output-to-file\` temporarily rebinds the current output port to be the result of opening the file named by *path*, as if with \`open-output-file\`, during the application of *thunk*. If *thunk* returns, the port is closed and the current output port is restored to its old value.

The behavior of \`with-output-to-file\` is unspecified if a continuation created outside of *thunk* is invoked before *thunk* returns. An implementation may close the port and restore the current output port to its old value---but it may not.

See \`open-output-file\` above for a description of the optional *options* argument.

The Revised Report version of \`with-output-to-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(with-output-to-file ",
        endParen: true,
        params: ["path", "thunk", "options"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s79"),
        description: `**procedure**: \`(with-output-to-file \`*path*\` \`*thunk*\`)\`
**procedure**: \`(with-output-to-file \`*path*\` \`*thunk*\` \`*options*\`)\`
**returns: **the value returned by *thunk*
**libraries: **\`(chezscheme)\`

*path* must be a string. *thunk* must be a procedure and should accept zero arguments.

\`with-output-to-file\` temporarily rebinds the current output port to be the result of opening the file named by *path*, as if with \`open-output-file\`, during the application of *thunk*. If *thunk* returns, the port is closed and the current output port is restored to its old value.

The behavior of \`with-output-to-file\` is unspecified if a continuation created outside of *thunk* is invoked before *thunk* returns. An implementation may close the port and restore the current output port to its old value---but it may not.

See \`open-output-file\` above for a description of the optional *options* argument.

The Revised Report version of \`with-output-to-file\` does not support the optional *options* argument.
`
    },
    {
        name: "(with-output-to-file ",
        endParen: true,
        params: ["path", "thunk"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s80"),
        description: `**procedure**: \`(with-output-to-file \`*path*\` \`*thunk*\`)\`
**returns: **the values returned by *thunk*
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

*path* must be a string or some other implementation-dependent value that names a file. *thunk* must be a procedure and should accept zero arguments.

\`with-output-to-file\` temporarily rebinds the current output port to be the result of opening the file named by *path*, as if with \`open-output-file\`, during the application of *thunk*. If *thunk* returns, the port is closed and the current output port is restored to its old value.

The behavior of \`with-output-to-file\` is unspecified if a continuation created outside of *thunk* is invoked before *thunk* returns. An implementation may close the port and restore the current output port to its old value---but it may not.
`
    },
    {
        name: "(with-output-to-string ",
        endParen: true,
        params: ["thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s50"),
        description: `**procedure**: \`(with-output-to-string \`*thunk*\`)\`
**returns: **a string containing the output
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure and should accept zero arguments. \`with-output-to-string\` parameterizes the current output port to a new string output port during the application of *thunk*. If *thunk* returns, the string associated with the new string output port is returned, as with \`get-output-string\`.

\`(with-output-to-string\`
\`   (lambda ()\`
\`     (display "Once upon a time ...")\`
\`     (newline))) \`=>\` "Once upon a time ...\\n"\`
`
    },
    {
        name: "(with-profile-tracker ",
        endParen: true,
        params: ["thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s150"),
        description: `**procedure**: \`(with-profile-tracker \`*thunk*\`)\`
**procedure**: \`(with-profile-tracker \`*preserve-existing?*\` \`*thunk*\`)\`
**returns: **a source table and the values returned by *thunk*
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure and should accept zero arguments. It may return any number of values.

\`with-profile-tracker\` invokes *thunk* without arguments. If *thunk* returns values *x1*\`, \`*x2*\`, ..., \`*xn*, \`with-profile-tracker\` returns + 1 values *st*\`, \`*x1*\`, \`*x2*\`, ..., \`*xn*, where *st* is a source table associating source objects with profile counts. If *preserve-existing?* is absent or \`#f\`, each count represents the number of times the source expression represented by the associated source object is evaluated during the invocation of *thunk*. Otherwise, each count represents the number of times the source expression represented by the associated source object is evaluated before or during the invocation of *thunk*.
`
    },
    {
        name: "(with-profile-tracker ",
        endParen: true,
        params: ["preserve-existing?", "thunk"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s150"),
        description: `**procedure**: \`(with-profile-tracker \`*thunk*\`)\`
**procedure**: \`(with-profile-tracker \`*preserve-existing?*\` \`*thunk*\`)\`
**returns: **a source table and the values returned by *thunk*
**libraries: **\`(chezscheme)\`

*thunk* must be a procedure and should accept zero arguments. It may return any number of values.

\`with-profile-tracker\` invokes *thunk* without arguments. If *thunk* returns values *x1*\`, \`*x2*\`, ..., \`*xn*, \`with-profile-tracker\` returns + 1 values *st*\`, \`*x1*\`, \`*x2*\`, ..., \`*xn*, where *st* is a source table associating source objects with profile counts. If *preserve-existing?* is absent or \`#f\`, each count represents the number of times the source expression represented by the associated source object is evaluated during the invocation of *thunk*. Otherwise, each count represents the number of times the source expression represented by the associated source object is evaluated before or during the invocation of *thunk*.
`
    },
    {
        name: "(with-source-path ",
        endParen: true,
        params: ["who", "name", "procedure"],
        type: "procedure",
        url: new URL("https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s103"),
        description: `**procedure**: \`(with-source-path \`*who*\` \`*name*\` \`*procedure*\`)\`
**libraries: **\`(chezscheme)\`

The procedure \`with-source-path\` searches through the current source-directories path, in order, for a file with the specified *name* and invokes *procedure* on the result. If no such file is found, an exception is raised with condition types \`&assertion\` and \`&who\` with *who* as who value.

If *name* is an absolute pathname or one beginning with \`./\` (or \`.\\\` under Windows) or \`../\` (or \`..\\\` under Windows), or if the list of source directories contains only \`"."\`, the default, or \`""\`, which is equivalent to \`"."\`, no searching is performed and *name* is returned.

*who* must be a symbol, *name* must be a string, and *procedure* should accept one argument.

The following examples assumes that the file "pie" exists in the directory "../spam" but not in "../ham" or the current directory.

\`(define find-file\`
\`   (lambda (fn)\`
\`     (with-source-path 'find-file fn values))) \`
\` \`
\` (find-file "pie") \`=>\` "pie" \`
\` \`
\` (source-directories '("." "../ham"))\`
\` (find-file "pie") \`=>\` \`*exception in find-file: pie not found*\` \`
\` \`
\` (source-directories '("." "../spam"))\`
\` (find-file "pie") \`=>\` "../spam/pie" \`
\` \`
\` (source-directories '("." "../ham"))\`
\` (find-file "/pie") \`=>\` "/pie" \`
\` \`
\` (source-directories '("." "../ham"))\`
\` (find-file "./pie") \`=>\` "./pie" \`
\` \`
\` (source-directories '("." "../spam"))\`
\` (find-file "../pie") \`=>\` "../ham/pie"\`
`
    },
    {
        name: "(with-syntax ((",
        endParen: true,
        params: ["pattern", "expr", "body1", "body2", "..."],
        type: "syntax",
        url: new URL("https://scheme.com/tspl4/syntax.html#./syntax:s38"),
        description: `**syntax**: \`(with-syntax ((\`*pattern*\` \`*expr*\`) ...) \`*body1*\` \`*body2*\` ...)\`
**returns: **the values of the final body expression
**libraries: **\`(rnrs syntax-case)\`, \`(rnrs)\`

It is sometimes useful to construct a transformer's output in separate pieces, then put the pieces together. \`with-syntax\` facilitates this by allowing the creation of local pattern bindings.

*pattern* is identical in form to a \`syntax-case\` pattern. The value of each *expr* is computed and destructured according to the corresponding *pattern*, and pattern variables within the *pattern* are bound as with \`syntax-case\` to appropriate portions of the value within the body *body1*\` \`*body2*\` ...\`, which is processed and evaluated like a \`lambda\` body.

\`with-syntax\` may be defined as a syntactic extension in terms of \`syntax-case\`.

\`(define-syntax with-syntax\`
\`   (lambda (x)\`
\`     (syntax-case x ()\`
\`       [(_ ((p e) ...) b1 b2 ...)\`
\`        #'(syntax-case (list e ...) ()\`
\`            [(p ...) (let () b1 b2 ...)])])))\`
`
    },
    {
        name: "(write ",
        endParen: true,
        params: ["obj"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s84"),
        description: `**procedure**: \`(write \`*obj*\`)\`
**procedure**: \`(write \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to \`put-datum\`, with the arguments reversed. See Section  for an implementation of \`put-datum\`, \`write\`, and \`display\`.
`
    },
    {
        name: "(write ",
        endParen: true,
        params: ["obj", "textual-output-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s84"),
        description: `**procedure**: \`(write \`*obj*\`)\`
**procedure**: \`(write \`*obj*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to \`put-datum\`, with the arguments reversed. See Section  for an implementation of \`put-datum\`, \`write\`, and \`display\`.
`
    },
    {
        name: "(write-char ",
        endParen: true,
        params: ["char"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s86"),
        description: `**procedure**: \`(write-char \`*char*\`)\`
**procedure**: \`(write-char \`*char*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to \`put-char\`, with the arguments reversed.
`
    },
    {
        name: "(write-char ",
        endParen: true,
        params: ["char", "textual-output-port"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/io.html#./io:s86"),
        description: `**procedure**: \`(write-char \`*char*\`)\`
**procedure**: \`(write-char \`*char*\` \`*textual-output-port*\`)\`
**returns: **unspecified
**libraries: **\`(rnrs io simple)\`, \`(rnrs)\`

If *textual-output-port* is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to \`put-char\`, with the arguments reversed.
`
    },
    {
        name: "(zero? ",
        endParen: true,
        params: ["num"],
        type: "procedure",
        url: new URL("https://scheme.com/tspl4/objects.html#./objects:s93"),
        description: `**procedure**: \`(zero? \`*num*\`)\`
**returns: **\`#t\` if *num* is zero, \`#f\` otherwise
**libraries: **\`(rnrs base)\`, \`(rnrs)\`

\`zero?\` is equivalent to \`(lambda (x) (= x 0))\`.

\`(zero? 0) \`=>\` #t\`
\` (zero? 1) \`=>\` #f\`
\` (zero? (- 3.0 3.0)) \`=>\` #t\`
\` (zero? (+ 1/2 1/2)) \`=>\` #f\`
\` (zero? 0+0i) \`=>\` #t\`
\` (zero? 0.0-0.0i) \`=>\` #t\`
`
    },
]
