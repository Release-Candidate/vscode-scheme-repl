/*
 * SPDX-FileCopyrightText:  Copyright 2023 Roland Csaszar
 * SPDX-License-Identifier: MIT
 *
 * Project:  vscode-scheme-repl
 * File:     generate_function_documentation.ts
 * Date:     19.May.2023
 *
 * ==============================================================================
 * Parse the HTML documentation from the Chez Scheme page and generate objects
 * holding the parsed data.
 * Run with `yarn --ignore-engines ts-node generate_function_documentation.ts`.
 */

/* eslint-disable operator-linebreak */
/* eslint-disable indent */

import * as https from "https";
import { createWriteStream, readFile, writeFile } from "fs";
import { JSDOM } from "jsdom";

/**
 * The type of a identifier.
 */
type IdentifierType =
    | "syntax"
    | "module"
    | "procedure"
    | "thread parameter"
    | "global parameter"
    | "Error: unknown";

/**
 * Return the string `s` converted to an `IdentifierType`.
 * Return `"Error: unknown"` if the string isn't recognized.
 * @param s The string to convert to an `IdentifierType`.
 * @returns The string `s` converted to an `IdentifierType`.
 * Return `"Error: unknown"` if the string isn't recognized.
 */
function stringToIType(s: string): IdentifierType {
    switch (s) {
        case "syntax":
            return "syntax";
        case "procedure":
            return "procedure";
        case "module":
            return "module";
        case "thread param":
            return "thread parameter";
        case "global param":
            return "global parameter";
    }

    return "Error: unknown";
}

/**
 * The object to save the data of a function documentation to.
 */
type FunctionDoc = {
    name: string;
    params: string[];
    endParen: boolean;
    type: IdentifierType;
    url: URL;
    description: string;
};

const baseURL = "https://cisco.github.io/ChezScheme/csug9.5/";

/**
 * The URL of the Chez Scheme documentation website.
 */
const docURL = baseURL + "summary.html";

/**
 * The path to save the downloaded HTML page to.
 */
const inFilename = "./summary_of_forms.html";

/**
 * The name of the file to save the parsed data to.
 */
const outFilename = "./src/functionDocumentation.ts";

/**
 * Main entry point.
 */
// eslint-disable-next-line max-statements
async function main(): Promise<void> {
    try {
        await download(new URL(docURL), inFilename);
    } catch (exp) {
        console.error(`Caught "${exp}" trying to download from ${docURL}`);
        process.exit(1);
    }
    const textProm = new Promise<string>((resolve, reject) => {
        readFile(inFilename, { encoding: "utf8" }, (r, d) => {
            resolve(d);
            reject(r);
        });
    });
    try {
        const htmlText = await textProm;
        const tsText = processHTML(htmlText);
        await writeFunctionDocumentation(tsText);
    } catch (error) {
        console.error(
            `Caught "${error}" trying to process the HTML and saving it.`
        );
        process.exit(1);
    }
}

/**
 * Return the data of the Chez function documentation as Typescript objects in a
 * text file.
 * @param text The HTML documentation file to parse.
 * @returns The data of the Chez function documentation as Typescript objects in a
 * text file.
 */
// eslint-disable-next-line max-lines-per-function
function processHTML(text: string): string {
    const htmlDoc = new JSDOM(text).window.document;
    const trs = Array.from(htmlDoc.querySelectorAll("tr")).filter(
        // eslint-disable-next-line no-magic-numbers
        (e) => e.childElementCount === 3 && e.children[0].nodeName !== "TH"
    );
    const ids: FunctionDoc[] = [];
    trs.forEach((tr) => parseTR(tr, ids));
    const today = new Date();
    const date = today.getDate();
    const month = today.getMonth() + 1;
    const year = today.getFullYear();

    return `/*
 * SPDX-FileCopyrightText:  Copyright 2023 Roland Csaszar
 * SPDX-License-Identifier: MIT
 *
 * Project:  vscode-scheme-repl
 * File:     functionDocumentation.ts
 * Date:     ${date}.${month}.${year}
 *
 * ==============================================================================
 * Autogenerated by the script \`../generate_function_documentation.ts\`,
 * DO NOT EDIT!
 */

/* eslint-disable max-lines */

/**
 * The type of a identifier.
 */
type IdentifierType =
    | "syntax"
    | "module"
    | "procedure"
    | "thread parameter"
    | "global parameter"
    | "Error: unknown";

/**
 * The object to save the data of a function documentation to.
 */
type FunctionDoc = {
    name: string;
    endParen: boolean;
    params: string[];
    type: IdentifierType;
    url: URL;
    description: string;
};

export const functionDocs: FunctionDoc[] = [
${ids
    .map(
        (id) =>
            `    {
        name: "${id.name}",
        endParen: ${id.endParen},
        params: ["${id.params.join('", "')}"],
        type: "${id.type}",
        url: new URL("${id.url}"),
        description: \`${id.description}\`
    },`
    )
    .join("\n")}
]
`;
}

/**
 * Parse the given `tr` element and add the date to `ids`.
 * @param tr The `tr` element to parse.
 * @param ids The list of identifiers to add the parsed data to.
 */
// eslint-disable-next-line max-statements
function parseTR(tr: HTMLTableRowElement, ids: FunctionDoc[]): void {
    const tds = Array.from(tr.childNodes) as HTMLTableCellElement[];
    const idType = stringToIType(tds[1].innerHTML);
    let name = "";
    let params: string[] = [];
    let endParen = false;
    let description = "";
    const nameElems = tds[0].childNodes[0].childNodes;
    if (idType === "global parameter" || idType === "thread parameter") {
        name = stringOrEmpty(nameElems[0].textContent);
    } else if (nameElems.length > 1) {
        name = stringOrEmpty(nameElems[0].textContent);

        // eslint-disable-next-line no-plusplus
        for (let nameIdx = 1; nameIdx < nameElems.length - 1; nameIdx++) {
            if (nameElems[nameIdx].nodeName === "I") {
                params.push(stringOrEmpty(nameElems[nameIdx].textContent));
            }
        }
        const end = stringOrEmpty(
            nameElems[nameElems.length - 1].textContent
        ).trim();
        if (end.endsWith(")")) {
            if (end !== ")") {
                params.push(end.slice(0, -1).trim());
            }
            endParen = true;
        }
    } else {
        name = stringOrEmpty(nameElems[0].textContent);
    }
    const url = new URL(
        // eslint-disable-next-line no-magic-numbers, dot-notation
        (tds[2].childNodes[0] as HTMLAnchorElement).href.startsWith("./")
            ? // eslint-disable-next-line no-magic-numbers
              baseURL + (tds[2].childNodes[0] as HTMLAnchorElement).href
            : // eslint-disable-next-line no-magic-numbers
              (tds[2].childNodes[0] as HTMLAnchorElement).href
    );
    ids.push({
        name,
        endParen,
        type: idType,
        params,
        url,
        description,
    });
}

/**
 * Return the string `s` if it isn't `undefined` or `null`, the empty string
 * `""` else.
 * @param s The `string` or `undefined` value to "convert".
 * @returns The string `s` if it isn't `undefined` or `null`, the empty string
 * `""` else.
 */
function stringOrEmpty(s: string | undefined | null): string {
    return s ? s : "";
}

/**
 * Download a file to the given path `fileName`.
 * @param url The URL to download.
 * @param fileName The path to save the downloaded file to.
 * @returns Nothing.
 */
async function download(url: URL, fileName: string): Promise<void> {
    const fileStream = createWriteStream(fileName);
    return new Promise<void>((resolve, reject) => {
        https.get(url, (res) => {
            res.pipe(fileStream);
            res.on("error", (e) => reject(e));
            fileStream.on("finish", () =>
                fileStream.close((err) => {
                    if (err) {
                        reject(err);
                    }
                    resolve();
                })
            );
        });
    });
}

/**
 * Write the parsed data to the file `outFilename`.
 * @param text The text to save.
 */
async function writeFunctionDocumentation(text: string): Promise<void> {
    const writeProm = new Promise<void>((_resolve, reject) => {
        writeFile(outFilename, text, { encoding: "utf8" }, (r) => {
            if (r) {
                reject(r);
            }
        });
    });

    await writeProm;
}

main();
